# BetterDiscordPlugins-All-In-One
{
	"blacklist": [],
	"settings": {
		"addClearButton": true,
		"confirmClear": false,
		"includeGuilds": true,
		"includeMuted": false,
		"includeDMs": false
	}
}
/**
 * @name ReadAllNotificationsButton
 * @author DevilBro
 * @authorId 278543574059057154
 * @version 1.6.7
 * @description Adds a Clear Button to the Server List and the Mentions Popout
 * @invite Jx3TjNS
 * @donate https://www.paypal.me/MircoWittrien
 * @patreon https://www.patreon.com/MircoWittrien
 * @website https://mwittrien.github.io/
 * @source https://github.com/mwittrien/BetterDiscordAddons/tree/master/Plugins/ReadAllNotificationsButton/
 * @updateUrl https://mwittrien.github.io/BetterDiscordAddons/Plugins/ReadAllNotificationsButton/ReadAllNotificationsButton.plugin.js
 */

module.exports = (_ => {
	const config = {
		"info": {
			"name": "ReadAllNotificationsButton",
			"author": "DevilBro",
			"version": "1.6.7",
			"description": "Adds a Clear Button to the Server List and the Mentions Popout"
		},
		"changeLog": {
			"improved": {
				"Canary Changes": "Preparing Plugins for the changes that are already done on Discord Canary"
			}
		}
	};

	return !window.BDFDB_Global || (!window.BDFDB_Global.loaded && !window.BDFDB_Global.started) ? class {
		getName () {return config.info.name;}
		getAuthor () {return config.info.author;}
		getVersion () {return config.info.version;}
		getDescription () {return `The Library Plugin needed for ${config.info.name} is missing. Open the Plugin Settings to download it. \n\n${config.info.description}`;}
		
		downloadLibrary () {
			require("request").get("https://mwittrien.github.io/BetterDiscordAddons/Library/0BDFDB.plugin.js", (e, r, b) => {
				if (!e && b && r.statusCode == 200) require("fs").writeFile(require("path").join(BdApi.Plugins.folder, "0BDFDB.plugin.js"), b, _ => BdApi.showToast("Finished downloading BDFDB Library", {type: "success"}));
				else BdApi.alert("Error", "Could not download BDFDB Library Plugin. Try again later or download it manually from GitHub: https://mwittrien.github.io/downloader/?library");
			});
		}
		
		load () {
			if (!window.BDFDB_Global || !Array.isArray(window.BDFDB_Global.pluginQueue)) window.BDFDB_Global = Object.assign({}, window.BDFDB_Global, {pluginQueue: []});
			if (!window.BDFDB_Global.downloadModal) {
				window.BDFDB_Global.downloadModal = true;
				BdApi.showConfirmationModal("Library Missing", `The Library Plugin needed for ${config.info.name} is missing. Please click "Download Now" to install it.`, {
					confirmText: "Download Now",
					cancelText: "Cancel",
					onCancel: _ => {delete window.BDFDB_Global.downloadModal;},
					onConfirm: _ => {
						delete window.BDFDB_Global.downloadModal;
						this.downloadLibrary();
					}
				});
			}
			if (!window.BDFDB_Global.pluginQueue.includes(config.info.name)) window.BDFDB_Global.pluginQueue.push(config.info.name);
		}
		start () {this.load();}
		stop () {}
		getSettingsPanel () {
			let template = document.createElement("template");
			template.innerHTML = `<div style="color: var(--header-primary); font-size: 16px; font-weight: 300; white-space: pre; line-height: 22px;">The Library Plugin needed for ${config.info.name} is missing.\nPlease click <a style="font-weight: 500;">Download Now</a> to install it.</div>`;
			template.content.firstElementChild.querySelector("a").addEventListener("click", this.downloadLibrary);
			return template.content.firstElementChild;
		}
	} : (([Plugin, BDFDB]) => {
		var _this;
		var blacklist, clearing;
		var settings = {};
		
		const ReadAllButtonComponent = class ReadAllButton extends BdApi.React.Component {
			clearClick() {
				if (settings.includeGuilds) this.clearGuilds(settings.includeMuted ? this.getGuilds() : this.getUnread());
				if (settings.includeDMs) BDFDB.DMUtils.markAsRead(this.getPingedDMs());
			}
			clearGuilds(guildIds) {
				BDFDB.GuildUtils.markAsRead(guildIds.filter(id => id && !blacklist.includes(id)));
			}
			getGuilds() {
				return BDFDB.LibraryModules.FolderStore.getFlattenedGuilds().map(g => g.id).filter(n => n);
			}
			getUnread() {
				return this.getGuilds().filter(id => BDFDB.LibraryModules.UnreadGuildUtils.hasUnread(id) || BDFDB.LibraryModules.UnreadGuildUtils.getMentionCount(id) > 0);
			}
			getPinged() {
				return this.getGuilds().filter(id => BDFDB.LibraryModules.UnreadGuildUtils.getMentionCount(id) > 0);
			}
			getMuted() {
				return this.getGuilds().filter(id => BDFDB.LibraryModules.MutedUtils.isGuildOrCategoryOrChannelMuted(id));
			}
			getPingedDMs() {
				return BDFDB.LibraryModules.ChannelStore.getSortedPrivateChannels().map(c => c.id).filter(id => id && BDFDB.LibraryModules.UnreadChannelUtils.getMentionCount(id) > 0);
			}
			render() {
				return BDFDB.ReactUtils.createElement("div", {
					className: BDFDB.disCNS.guildouter + BDFDB.disCN._readallnotificationsbuttonframe,
					children: BDFDB.ReactUtils.createElement("div", {
						className: BDFDB.disCNS.guildiconwrapper + BDFDB.disCN._readallnotificationsbuttoninner,
							children: BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.disCNS.guildiconchildwrapper + BDFDB.disCN._readallnotificationsbuttonbutton,
							children: "read all",
							onClick: _ => {
								if (!settings.confirmClear) this.clearClick();
								else BDFDB.ModalUtils.confirm(_this, _this.labels.modal_confirmnotifications, _ => this.clearClick());
							},
							onContextMenu: event => {
								BDFDB.ContextMenuUtils.open(_this, event, BDFDB.ContextMenuUtils.createItem(BDFDB.LibraryComponents.MenuItems.MenuGroup, {
									children: [
										BDFDB.ContextMenuUtils.createItem(BDFDB.LibraryComponents.MenuItems.MenuItem, {
											label: _this.labels.context_unreadguilds,
											id: BDFDB.ContextMenuUtils.createItemId(_this.name, "mark-unread-read"),
											action: _ => this.clearGuilds(this.getUnread())
										}),
										BDFDB.ContextMenuUtils.createItem(BDFDB.LibraryComponents.MenuItems.MenuItem, {
											label: _this.labels.context_pingedguilds,
											id: BDFDB.ContextMenuUtils.createItemId(_this.name, "mark-pinged-read"),
											action: _ => this.clearGuilds(this.getPinged())
										}),
										BDFDB.ContextMenuUtils.createItem(BDFDB.LibraryComponents.MenuItems.MenuItem, {
											label: _this.labels.context_mutedguilds,
											id: BDFDB.ContextMenuUtils.createItemId(_this.name, "mark-muted-read"),
											action: _ => this.clearGuilds(this.getMuted())
										}),
										BDFDB.ContextMenuUtils.createItem(BDFDB.LibraryComponents.MenuItems.MenuItem, {
											label: _this.labels.context_guilds,
											id: BDFDB.ContextMenuUtils.createItemId(_this.name, "mark-all-read"),
											action: _ => this.clearGuilds(this.getGuilds())
										}),
										BDFDB.ContextMenuUtils.createItem(BDFDB.LibraryComponents.MenuItems.MenuItem, {
											label: _this.labels.context_dms,
											id: BDFDB.ContextMenuUtils.createItemId(_this.name, "mark-dms-read"),
											action: _ => BDFDB.DMUtils.markAsRead(this.getPingedDMs())
										})
									]
								}));
							}
						})
					})
				});
			}
		};
	
		return class ReadAllNotificationsButton extends Plugin {
			onLoad () {
				_this = this;
				
				this.defaults = {
					settings: {
						addClearButton:	{value: true, 	inner: false,	description: "Add a 'Clear Mentions' button to the recent mentions popout"},
						confirmClear:	{value: false,	inner: false, 	description: "Ask for your confirmation before clearing reads"},
						includeGuilds:	{value: true, 	inner: true,	description: "unread Servers"},
						includeMuted:	{value: false, 	inner: true,	description: "muted unread Servers"},
						includeDMs:		{value: false, 	inner: true,	description: "unread DMs"}
					}
				};
				
				this.patchedModules = {
					after: {
						Guilds: "render",
						RecentMentions: "default",
						RecentsHeader: "default"
					}
				};
				
				this.css = `
					${BDFDB.dotCN.messagespopouttabbar} {
						flex: 1 0 auto;
					}
					${BDFDB.dotCN.messagespopouttabbar} ~ * {
						margin-left: 10px;
					}
					${BDFDB.dotCN._readallnotificationsbuttonframe} {
						height: 24px;
						margin-bottom: 10px;
					}
					${BDFDB.dotCN._readallnotificationsbuttonframe}:active {
						transform: translateY(1px);
					}
					${BDFDB.dotCN._readallnotificationsbuttoninner} {
						height: 24px;
					}
					${BDFDB.dotCN._readallnotificationsbuttonbutton} {
						border-radius: 4px;
						height: 24px;
						font-size: 12px;
						line-height: 1.3;
						white-space: nowrap;
						cursor: pointer;
					}
				`;
			}
			
			onStart () {
				let loadedBlacklist = BDFDB.DataUtils.load(this, "blacklist");
				this.saveBlacklist(!BDFDB.ArrayUtils.is(loadedBlacklist) ? [] : loadedBlacklist);

				this.forceUpdateAll();
			}
			
			onStop () {
				this.forceUpdateAll();
			}

			getSettingsPanel (collapseStates = {}) {
				let settingsPanel, settingsItems = [];
				
				settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.CollapseContainer, {
					title: "Settings",
					collapseStates: collapseStates,
					children: Object.keys(settings).filter(key => !this.defaults.settings[key].inner).map(key => BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsSaveItem, {
						type: "Switch",
						plugin: this,
						keys: ["settings", key],
						label: this.defaults.settings[key].description,
						value: settings[key]
					})).concat(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsPanelList, {
						title: "When left clicking the 'read all' button mark following Elements as read:",
						first: false,
						last: true,
						children: Object.keys(settings).filter(key => this.defaults.settings[key].inner).map(key => BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsSaveItem, {
							type: "Switch",
							plugin: this,
							keys: ["settings", key],
							label: this.defaults.settings[key].description,
							value: settings[key]
						}))
					}))
				}));
				
				settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.CollapseContainer, {
					title: "Server Black List",
					collapseStates: collapseStates,
					children: [
						BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsGuildList, {
							className: BDFDB.disCN.marginbottom20,
							disabled: BDFDB.DataUtils.load(this, "blacklist"),
							onClick: disabledGuilds => {
								this.saveBlacklist(disabledGuilds);
							}
						}),
						BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsItem, {
							type: "Button",
							color: BDFDB.LibraryComponents.Button.Colors.GREEN,
							label: "Enable for all Servers",
							onClick: _ => {
								this.batchSetGuilds(settingsPanel, collapseStates, true);
							},
							children: BDFDB.LanguageUtils.LanguageStrings.ENABLE
						}),
						BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsItem, {
							type: "Button",
							color: BDFDB.LibraryComponents.Button.Colors.PRIMARY,
							label: "Disable for all Servers",
							onClick: _ => {
								this.batchSetGuilds(settingsPanel, collapseStates, false);
							},
							children: BDFDB.LanguageUtils.LanguageStrings.DISABLE
						})
					]
				}));
				
				return settingsPanel = BDFDB.PluginUtils.createSettingsPanel(this, settingsItems);
			}

			onSettingsClosed () {
				if (this.SettingsUpdated) {
					delete this.SettingsUpdated;
					this.forceUpdateAll();
				}
			}
		
			forceUpdateAll () {
				settings = BDFDB.DataUtils.get(this, "settings");
				
				BDFDB.PatchUtils.forceAllUpdates(this);
			}
		
			processGuilds (e) {
				if (typeof e.returnvalue.props.children == "function") {
					let childrenRender = e.returnvalue.props.children;
					e.returnvalue.props.children = (...args) => {
						let children = childrenRender(...args);
						this.checkTree(children);
						return children;
					};
				}
				else this.checkTree(e.returnvalue);
			}
			
			checkTree (returnvalue) {
				let tree = BDFDB.ReactUtils.findChild(returnvalue, {filter: n => n && n.props && typeof n.props.children == "function"});
				if (tree) {
					let childrenRender = tree.props.children;
					tree.props.children = (...args) => {
						let children = childrenRender(...args);
						this.injectButton(children);
						return children;
					};
				}
				else this.injectButton(returnvalue);
			}
			
			injectButton (returnvalue) {
				let [children, index] = BDFDB.ReactUtils.findParent(returnvalue, {name: "ConnectedUnreadDMs"});
				if (index > -1) children.splice(index + 1, 0, BDFDB.ReactUtils.createElement(ReadAllButtonComponent, {}));
			}

			processRecentMentions (e) {
				if (e.instance.props.header && e.instance.props.header.props) e.instance.props.header.props.messages = e.returnvalue.props.messages;
			}

			processRecentsHeader (e) {
				if (settings.addClearButton && e.instance.props.tab == "Recent Mentions") e.returnvalue.props.children.push(BDFDB.ReactUtils.createElement("div", {
					children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TooltipContainer, {
						text: `${BDFDB.LanguageUtils.LanguageStrings.CLOSE} (${BDFDB.LanguageUtils.LanguageStrings.FORM_LABEL_ALL})`,
						children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Clickable, {
							className: BDFDB.disCNS.messagespopoutbutton + BDFDB.disCN.messagespopoutbuttonsecondary,
							children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SvgIcon, {
								nativeClass: true,
								name: BDFDB.LibraryComponents.SvgIcon.Names.CLOSE,
								width: 16,
								height: 16
							}),
							onClick: _ => {
								let clear = _ => {
									if (clearing) return BDFDB.NotificationUtils.toast(`${this.labels.toast_alreadyclearing} - ${BDFDB.LanguageUtils.LibraryStrings.please_wait}`, {type: "danger"});
									let messages = [].concat(e.instance.props.messages).filter(n => n);
									if (messages.length) {
										clearing = true;
										let toastInterval;
										let loadingString = `${this.labels.toast_clearing} - ${BDFDB.LanguageUtils.LibraryStrings.please_wait}`;
										let currentLoadingString = loadingString;
										let toast = BDFDB.NotificationUtils.toast(currentLoadingString, {
											timeout: 0,
											onClose: _ => {BDFDB.TimeUtils.clear(toastInterval);}
										});
										toastInterval = BDFDB.TimeUtils.interval(_ => {
											currentLoadingString = currentLoadingString.endsWith(".....") ? loadingString : currentLoadingString + ".";
											toast.update(currentLoadingString);
										}, 500);
										for (let i = 0; i < messages.length; i++) BDFDB.TimeUtils.timeout(_ => {
											BDFDB.LibraryModules.RecentMentionUtils.deleteRecentMention(messages[i].id);
											if (i == messages.length - 1) {
												clearing = false;
												toast.close();
												BDFDB.NotificationUtils.toast(this.labels.toastcleared, {type: "success"});
											}
										}, i * 1000);
									}
								};
								if (settings.confirmClear) BDFDB.ModalUtils.confirm(this, this.labels.modal_confirmmentions, clear);
								else clear();
							}
						})
					})
				}));
			}
			
			batchSetGuilds (settingsPanel, collapseStates, value) {
				if (!value) {
					for (let id of BDFDB.LibraryModules.FolderStore.getFlattenedGuildIds()) blacklist.push(id);
					this.saveBlacklist(BDFDB.ArrayUtils.removeCopies(blacklist));
				}
				else this.saveBlacklist([]);
				BDFDB.PluginUtils.refreshSettingsPanel(this, settingsPanel, collapseStates);
			}
			
			saveBlacklist (savedBlacklist) {
				blacklist = savedBlacklist;
				BDFDB.DataUtils.save(savedBlacklist, this, "blacklist");
			}

			setLabelsByLanguage () {
				switch (BDFDB.LanguageUtils.getLanguage().id) {
					case "bg":		// Bulgarian
						return {
							context_dms:						"Ð”Ð¸Ñ€ÐµÐºÑ‚Ð½Ð¾ ÑÑŠÐ¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ",
							context_guilds:						"Ð’ÑÐ¸Ñ‡ÐºÐ¸ ÑÑŠÑ€Ð²ÑŠÑ€Ð¸",
							context_mutedguilds:				"ÐŸÑ€Ð¸Ð³Ð»ÑƒÑˆÐµÐ½Ð¸ ÑÑŠÑ€Ð²ÑŠÑ€Ð¸",
							context_pingedguilds:				"Pinged ÑÑŠÑ€Ð²ÑŠÑ€Ð¸",
							context_unreadguilds:				"ÐÐµÐ¿Ñ€Ð¾Ñ‡ÐµÑ‚ÐµÐ½Ð¸ ÑÑŠÑ€Ð²ÑŠÑ€Ð¸",
							modal_confirmmentions:				"ÐÐ°Ð¸ÑÑ‚Ð¸Ð½Ð° Ð»Ð¸ Ð¸ÑÐºÐ°Ñ‚Ðµ Ð´Ð° Ð¸Ð·Ñ‚Ñ€Ð¸ÐµÑ‚Ðµ Ð²ÑÐ¸Ñ‡ÐºÐ¸ Ð½ÐµÐ¿Ñ€Ð¾Ñ‡ÐµÑ‚ÐµÐ½Ð¸ ÑÐ¿Ð¾Ð¼ÐµÐ½Ð°Ð²Ð°Ð½Ð¸Ñ?",
							modal_confirmnotifications:			"ÐÐ°Ð¸ÑÑ‚Ð¸Ð½Ð° Ð»Ð¸ Ð¸ÑÐºÐ°Ñ‚Ðµ Ð´Ð° Ð¸Ð·Ñ‚Ñ€Ð¸ÐµÑ‚Ðµ Ð²ÑÐ¸Ñ‡ÐºÐ¸ Ð½ÐµÐ¿Ñ€Ð¾Ñ‡ÐµÑ‚ÐµÐ½Ð¸ Ð¸Ð·Ð²ÐµÑÑ‚Ð¸Ñ?",
							toast_alreadyclearing:				"Ð˜Ð·Ñ‚Ñ€Ð¸Ð²Ð° Ð½ÑÐºÐ¾Ð¸ ÑÐ¿Ð¾Ð¼ÐµÐ½Ð°Ð²Ð°Ð½Ð¸Ñ Ð²ÐµÑ‡Ðµ",
							toast_cleared:						"Ð’ÑÐ¸Ñ‡ÐºÐ¸ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸ ÑÐ¿Ð¾Ð¼ÐµÐ½Ð°Ð²Ð°Ð½Ð¸Ñ Ð±ÑÑ…Ð° Ð¸Ð·Ñ‚Ñ€Ð¸Ñ‚Ð¸",
							toast_clearing:						"Ð˜Ð·Ñ‡Ð¸ÑÑ‚Ð²Ð° Ð²ÑÐ¸Ñ‡ÐºÐ¸ ÑÐºÐ¾Ñ€Ð¾ÑˆÐ½Ð¸ ÑÐ¿Ð¾Ð¼ÐµÐ½Ð°Ð²Ð°Ð½Ð¸Ñ"
						};
					case "da":		// Danish
						return {
							context_dms:						"Direkte beskeder",
							context_guilds:						"Alle servere",
							context_mutedguilds:				"DÃ¦mpede servere",
							context_pingedguilds:				"Pingede servere",
							context_unreadguilds:				"UlÃ¦ste servere",
							modal_confirmmentions:				"Er du sikker pÃ¥, at du vil slette alle ulÃ¦ste omtaler?",
							modal_confirmnotifications:			"Er du sikker pÃ¥, at du vil slette alle ulÃ¦ste meddelelser?",
							toast_alreadyclearing:				"Sletter allerede nogle omtaler",
							toast_cleared:						"Alle nylige omtaler er blevet slettet",
							toast_clearing:						"Rydder alle nylige omtaler"
						};
					case "de":		// German
						return {
							context_dms:						"Direktnachrichten",
							context_guilds:						"Alle Server",
							context_mutedguilds:				"Stummgeschaltete Server",
							context_pingedguilds:				"Gepingte Server",
							context_unreadguilds:				"Ungelesene Server",
							modal_confirmmentions:				"MÃ¶chten Sie wirklich alle ungelesenen ErwÃ¤hnungen lÃ¶schen?",
							modal_confirmnotifications:			"MÃ¶chten Sie wirklich alle ungelesenen Benachrichtigungen lÃ¶schen?",
							toast_alreadyclearing:				"LÃ¶scht bereits einige ErwÃ¤hnungen",
							toast_cleared:						"Alle kÃ¼rzlich ErwÃ¤hnungen wurden gelÃ¶scht",
							toast_clearing:						"LÃ¶scht alle letzten ErwÃ¤hnungen"
						};
					case "el":		// Greek
						return {
							context_dms:						"Î‘Î¼ÎµÏƒÎ± Î¼Î·Î½ÏÎ¼Î±Ï„Î±",
							context_guilds:						"ÎŒÎ»Î¿Î¹ Î¿Î¹ Î´Î¹Î±ÎºÎ¿Î¼Î¹ÏƒÏ„Î­Ï‚",
							context_mutedguilds:				"Î£Î¯Î³Î±ÏƒÎ· Î´Î¹Î±ÎºÎ¿Î¼Î¹ÏƒÏ„ÏŽÎ½",
							context_pingedguilds:				"Î”Î¹Î±ÎºÎ¿Î¼Î¹ÏƒÏ„Î­Ï‚ Ping",
							context_unreadguilds:				"ÎœÎ· Î±Î½Î±Î³Î½Ï‰ÏƒÎ¼Î­Î½Î¿Î¹ Î´Î¹Î±ÎºÎ¿Î¼Î¹ÏƒÏ„Î­Ï‚",
							modal_confirmmentions:				"Î•Î¯ÏƒÏ„Îµ Î²Î­Î²Î±Î¹Î¿Î¹ ÏŒÏ„Î¹ Î¸Î­Î»ÎµÏ„Îµ Î½Î± Î´Î¹Î±Î³ÏÎ¬ÏˆÎµÏ„Îµ ÏŒÎ»ÎµÏ‚ Ï„Î¹Ï‚ Î¼Î· Î±Î½Î±Î³Î½Ï‰ÏƒÎ¼Î­Î½ÎµÏ‚ Î±Î½Î±Ï†Î¿ÏÎ­Ï‚;",
							modal_confirmnotifications:			"Î•Î¯ÏƒÏ„Îµ Î²Î­Î²Î±Î¹Î¿Î¹ ÏŒÏ„Î¹ Î¸Î­Î»ÎµÏ„Îµ Î½Î± Î´Î¹Î±Î³ÏÎ¬ÏˆÎµÏ„Îµ ÏŒÎ»ÎµÏ‚ Ï„Î¹Ï‚ Î¼Î· Î±Î½Î±Î³Î½Ï‰ÏƒÎ¼Î­Î½ÎµÏ‚ ÎµÎ¹Î´Î¿Ï€Î¿Î¹Î®ÏƒÎµÎ¹Ï‚;",
							toast_alreadyclearing:				"Î”Î¹Î±Î³ÏÎ¬Ï†ÎµÎ¹ Î®Î´Î· ÎºÎ¬Ï€Î¿Î¹ÎµÏ‚ Î±Î½Î±Ï†Î¿ÏÎ­Ï‚",
							toast_cleared:						"ÎŒÎ»ÎµÏ‚ Î¿Î¹ Ï€ÏÏŒÏƒÏ†Î±Ï„ÎµÏ‚ Î±Î½Î±Ï†Î¿ÏÎ­Ï‚ Î­Ï‡Î¿Ï…Î½ Î´Î¹Î±Î³ÏÎ±Ï†ÎµÎ¯",
							toast_clearing:						"Î”Î¹Î±Î³ÏÎ¬Ï†ÎµÎ¹ ÏŒÎ»ÎµÏ‚ Ï„Î¹Ï‚ Ï€ÏÏŒÏƒÏ†Î±Ï„ÎµÏ‚ Î±Î½Î±Ï†Î¿ÏÎ­Ï‚"
						};
					case "es":		// Spanish
						return {
							context_dms:						"Mensajes directos",
							context_guilds:						"Todos los servidores",
							context_mutedguilds:				"Servidores silenciados",
							context_pingedguilds:				"Servidores con ping",
							context_unreadguilds:				"Servidores no leÃ­dos",
							modal_confirmmentions:				"Â¿EstÃ¡s seguro de que deseas eliminar todas las menciones no leÃ­das?",
							modal_confirmnotifications:			"Â¿EstÃ¡ seguro de que desea eliminar todas las notificaciones no leÃ­das?",
							toast_alreadyclearing:				"Elimina algunas menciones ya",
							toast_cleared:						"Se han eliminado todas las menciones recientes",
							toast_clearing:						"Borra todas las menciones recientes"
						};
					case "fi":		// Finnish
						return {
							context_dms:						"Suorat viestit",
							context_guilds:						"Kaikki palvelimet",
							context_mutedguilds:				"Mykistetyt palvelimet",
							context_pingedguilds:				"Pinged-palvelimet",
							context_unreadguilds:				"Lukemattomat palvelimet",
							modal_confirmmentions:				"Haluatko varmasti poistaa kaikki lukemattomat maininnat?",
							modal_confirmnotifications:			"Haluatko varmasti poistaa kaikki lukemattomat ilmoitukset?",
							toast_alreadyclearing:				"Poistaa jo joitain mainintoja",
							toast_cleared:						"Kaikki viimeisimmÃ¤t maininnat on poistettu",
							toast_clearing:						"TyhjentÃ¤Ã¤ kaikki viimeisimmÃ¤t maininnat"
						};
					case "fr":		// French
						return {
							context_dms:						"Messages directs",
							context_guilds:						"Tous les serveurs",
							context_mutedguilds:				"Serveurs muets",
							context_pingedguilds:				"Serveurs ping",
							context_unreadguilds:				"Serveurs non lus",
							modal_confirmmentions:				"Voulez-vous vraiment supprimer toutes les mentions non lues?",
							modal_confirmnotifications:			"Voulez-vous vraiment supprimer toutes les notifications non lues?",
							toast_alreadyclearing:				"Supprime dÃ©jÃ  certaines mentions",
							toast_cleared:						"Toutes les mentions rÃ©centes ont Ã©tÃ© supprimÃ©es",
							toast_clearing:						"Efface toutes les mentions rÃ©centes"
						};
					case "hr":		// Croatian
						return {
							context_dms:						"Direktna poruka",
							context_guilds:						"Svi posluÅ¾itelji",
							context_mutedguilds:				"PriguÅ¡eni posluÅ¾itelji",
							context_pingedguilds:				"Pingirani posluÅ¾itelji",
							context_unreadguilds:				"NeproÄitani posluÅ¾itelji",
							modal_confirmmentions:				"Jeste li sigurni da Å¾elite izbrisati sva neproÄitana spominjanja?",
							modal_confirmnotifications:			"Jeste li sigurni da Å¾elite izbrisati sve neproÄitane obavijesti?",
							toast_alreadyclearing:				"BriÅ¡e veÄ‡ spomenute",
							toast_cleared:						"Sva nedavna spominjanja su izbrisana",
							toast_clearing:						"BriÅ¡e sva nedavna spominjanja"
						};
					case "hu":		// Hungarian
						return {
							context_dms:						"KÃ¶zvetlen Ã¼zenet",
							context_guilds:						"Minden szerver",
							context_mutedguilds:				"NÃ©mÃ­tott szerverek",
							context_pingedguilds:				"Pingelt szerverek",
							context_unreadguilds:				"Olvasatlan szerverek",
							modal_confirmmentions:				"Biztosan tÃ¶rli az Ã¶sszes olvasatlan emlÃ­tÃ©st?",
							modal_confirmnotifications:			"Biztosan tÃ¶rli az Ã¶sszes olvasatlan Ã©rtesÃ­tÃ©st?",
							toast_alreadyclearing:				"NÃ©hÃ¡ny emlÃ­tÃ©st mÃ¡r tÃ¶rÃ¶l",
							toast_cleared:						"Az Ã¶sszes kÃ¶zelmÃºltbeli emlÃ­tÃ©st tÃ¶rÃ¶ltÃ©k",
							toast_clearing:						"TÃ¶rli az Ã¶sszes kÃ¶zelmÃºltbeli emlÃ­tÃ©st"
						};
					case "it":		// Italian
						return {
							context_dms:						"Messaggi diretti",
							context_guilds:						"Tutti i server",
							context_mutedguilds:				"Server disattivati",
							context_pingedguilds:				"Server sottoposti a ping",
							context_unreadguilds:				"Server non letti",
							modal_confirmmentions:				"Sei sicuro di voler eliminare tutte le menzioni non lette?",
							modal_confirmnotifications:			"Sei sicuro di voler eliminare tutte le notifiche non lette?",
							toast_alreadyclearing:				"Elimina giÃ  alcune menzioni",
							toast_cleared:						"Tutte le menzioni recenti sono state eliminate",
							toast_clearing:						"Cancella tutte le menzioni recenti"
						};
					case "ja":		// Japanese
						return {
							context_dms:						"ãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸",
							context_guilds:						"ã™ã¹ã¦ã®ã‚µãƒ¼ãƒãƒ¼",
							context_mutedguilds:				"ãƒŸãƒ¥ãƒ¼ãƒˆã•ã‚ŒãŸã‚µãƒ¼ãƒãƒ¼",
							context_pingedguilds:				"pingã•ã‚ŒãŸã‚µãƒ¼ãƒãƒ¼",
							context_unreadguilds:				"æœªèª­ã‚µãƒ¼ãƒãƒ¼",
							modal_confirmmentions:				"æœªèª­ã®ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã‚’ã™ã¹ã¦å‰Šé™¤ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ",
							modal_confirmnotifications:			"æœªèª­ã®é€šçŸ¥ã‚’ã™ã¹ã¦å‰Šé™¤ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ",
							toast_alreadyclearing:				"ã™ã§ã«ã„ãã¤ã‹ã®è¨€åŠã‚’å‰Šé™¤ã—ã¾ã™",
							toast_cleared:						"æœ€è¿‘ã®è¨€åŠã¯ã™ã¹ã¦å‰Šé™¤ã•ã‚Œã¾ã—ãŸ",
							toast_clearing:						"æœ€è¿‘ã®è¨€åŠã‚’ã™ã¹ã¦ã‚¯ãƒªã‚¢ã—ã¾ã™"
						};
					case "ko":		// Korean
						return {
							context_dms:						"ìª½ì§€",
							context_guilds:						"ëª¨ë“  ì„œë²„",
							context_mutedguilds:				"ìŒì†Œê±° ëœ ì„œë²„",
							context_pingedguilds:				"í•‘ëœ ì„œë²„",
							context_unreadguilds:				"ì½ì§€ ì•Šì€ ì„œë²„",
							modal_confirmmentions:				"ì½ì§€ ì•Šì€ ëª¨ë“  ë©˜ì…˜ì„ ì‚­ì œ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
							modal_confirmnotifications:			"ì½ì§€ ì•Šì€ ëª¨ë“  ì•Œë¦¼ì„ ì‚­ì œ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
							toast_alreadyclearing:				"ì´ë¯¸ ì¼ë¶€ ë©˜ì…˜ì„ ì‚­ì œí•©ë‹ˆë‹¤.",
							toast_cleared:						"ëª¨ë“  ìµœê·¼ ë©˜ì…˜ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.",
							toast_clearing:						"ìµœê·¼ ë©˜ì…˜ì„ ëª¨ë‘ ì§€ ì›ë‹ˆë‹¤."
						};
					case "lt":		// Lithuanian
						return {
							context_dms:						"Tiesioginiai praneÅ¡imai",
							context_guilds:						"Visi serveriai",
							context_mutedguilds:				"Nutildyti serveriai",
							context_pingedguilds:				"â€žPingedâ€œ serveriai",
							context_unreadguilds:				"Neskaityti serveriai",
							modal_confirmmentions:				"Ar tikrai norite iÅ¡trinti visus neperskaitytus paminÄ—jimus?",
							modal_confirmnotifications:			"Ar tikrai norite iÅ¡trinti visus neperskaitytus praneÅ¡imus?",
							toast_alreadyclearing:				"Kai kurie paminÄ—jimai jau iÅ¡trinami",
							toast_cleared:						"Visi naujausi paminÄ—jimai buvo iÅ¡trinti",
							toast_clearing:						"IÅ¡valo visus naujausius paminÄ—jimus"
						};
					case "nl":		// Dutch
						return {
							context_dms:						"Directe berichten",
							context_guilds:						"Alle servers",
							context_mutedguilds:				"Gedempte servers",
							context_pingedguilds:				"Gepingde servers",
							context_unreadguilds:				"Ongelezen servers",
							modal_confirmmentions:				"Weet u zeker dat u alle ongelezen vermeldingen wilt verwijderen?",
							modal_confirmnotifications:			"Weet u zeker dat u alle ongelezen meldingen wilt verwijderen?",
							toast_alreadyclearing:				"Verwijdert al enkele vermeldingen",
							toast_cleared:						"Alle recente vermeldingen zijn verwijderd",
							toast_clearing:						"Wist alle recente vermeldingen"
						};
					case "no":		// Norwegian
						return {
							context_dms:						"Direktemeldinger",
							context_guilds:						"Alle servere",
							context_mutedguilds:				"Dempede servere",
							context_pingedguilds:				"Pingede servere",
							context_unreadguilds:				"Uleste servere",
							modal_confirmmentions:				"Er du sikker pÃ¥ at du vil slette alle uleste omtaler?",
							modal_confirmnotifications:			"Er du sikker pÃ¥ at du vil slette alle uleste varsler?",
							toast_alreadyclearing:				"Sletter allerede noen omtaler",
							toast_cleared:						"Alle nylige omtaler er slettet",
							toast_clearing:						"Fjerner alle nylige omtaler"
						};
					case "pl":		// Polish
						return {
							context_dms:						"BezpoÅ›rednie wiadomoÅ›ci",
							context_guilds:						"Wszystkie serwery",
							context_mutedguilds:				"Wyciszone serwery",
							context_pingedguilds:				"Serwery pingowane",
							context_unreadguilds:				"Nieprzeczytane serwery",
							modal_confirmmentions:				"Czy na pewno chcesz usunÄ…Ä‡ wszystkie nieprzeczytane wzmianki?",
							modal_confirmnotifications:			"Czy na pewno chcesz usunÄ…Ä‡ wszystkie nieprzeczytane powiadomienia?",
							toast_alreadyclearing:				"Usuwa juÅ¼ niektÃ³re wzmianki",
							toast_cleared:						"Wszystkie ostatnie wzmianki zostaÅ‚y usuniÄ™te",
							toast_clearing:						"Usuwa wszystkie ostatnie wzmianki"
						};
					case "pt-BR":	// Portuguese (Brazil)
						return {
							context_dms:						"Mensagens diretas",
							context_guilds:						"Todos os servidores",
							context_mutedguilds:				"Servidores Silenciados",
							context_pingedguilds:				"Servidores com ping",
							context_unreadguilds:				"Servidores nÃ£o lidos",
							modal_confirmmentions:				"Tem certeza de que deseja excluir todas as menÃ§Ãµes nÃ£o lidas?",
							modal_confirmnotifications:			"Tem certeza de que deseja excluir todas as notificaÃ§Ãµes nÃ£o lidas?",
							toast_alreadyclearing:				"Exclui algumas menÃ§Ãµes jÃ¡",
							toast_cleared:						"Todas as menÃ§Ãµes recentes foram excluÃ­das",
							toast_clearing:						"Limpa todas as menÃ§Ãµes recentes"
						};
					case "ro":		// Romanian
						return {
							context_dms:						"Mesaje directe",
							context_guilds:						"Toate serverele",
							context_mutedguilds:				"Servere mutate",
							context_pingedguilds:				"Servere pinged",
							context_unreadguilds:				"Servere necitite",
							modal_confirmmentions:				"Sigur doriÈ›i sÄƒ È™tergeÈ›i toate menÈ›iunile necitite?",
							modal_confirmnotifications:			"Sigur doriÈ›i sÄƒ È™tergeÈ›i toate notificÄƒrile necitite?",
							toast_alreadyclearing:				"È˜terge deja cÃ¢teva menÈ›iuni",
							toast_cleared:						"Toate menÈ›iunile recente au fost È™terse",
							toast_clearing:						"È˜terge toate menÈ›iunile recente"
						};
					case "ru":		// Russian
						return {
							context_dms:						"ÐŸÑ€ÑÐ¼Ñ‹Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ",
							context_guilds:						"Ð’ÑÐµ ÑÐµÑ€Ð²ÐµÑ€Ñ‹",
							context_mutedguilds:				"ÐžÑ‚ÐºÐ»ÑŽÑ‡ÐµÐ½Ð½Ñ‹Ðµ ÑÐµÑ€Ð²ÐµÑ€Ñ‹",
							context_pingedguilds:				"ÐŸÑ€Ð¾Ð²ÐµÑ€ÐµÐ½Ð½Ñ‹Ðµ ÑÐµÑ€Ð²ÐµÑ€Ñ‹",
							context_unreadguilds:				"ÐÐµÐ¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ð½Ð½Ñ‹Ðµ ÑÐµÑ€Ð²ÐµÑ€Ñ‹",
							modal_confirmmentions:				"Ð’Ñ‹ ÑƒÐ²ÐµÑ€ÐµÐ½Ñ‹, Ñ‡Ñ‚Ð¾ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ ÑƒÐ´Ð°Ð»Ð¸Ñ‚ÑŒ Ð²ÑÐµ Ð½ÐµÐ¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ð½Ð½Ñ‹Ðµ ÑƒÐ¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ñ?",
							modal_confirmnotifications:			"Ð’Ñ‹ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ ÑƒÐ´Ð°Ð»Ð¸Ñ‚ÑŒ Ð²ÑÐµ Ð½ÐµÐ¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ð½Ð½Ñ‹Ðµ ÑƒÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ñ?",
							toast_alreadyclearing:				"Ð£Ð´Ð°Ð»ÑÐµÑ‚ ÑƒÐ¶Ðµ Ð½ÐµÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ ÑƒÐ¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ñ",
							toast_cleared:						"Ð’ÑÐµ Ð½ÐµÐ´Ð°Ð²Ð½Ð¸Ðµ ÑƒÐ¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ñ Ð±Ñ‹Ð»Ð¸ ÑƒÐ´Ð°Ð»ÐµÐ½Ñ‹",
							toast_clearing:						"Ð£Ð´Ð°Ð»ÑÐµÑ‚ Ð²ÑÐµ Ð½ÐµÐ´Ð°Ð²Ð½Ð¸Ðµ ÑƒÐ¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ñ"
						};
					case "sv":		// Swedish
						return {
							context_dms:						"Direktmeddelanden",
							context_guilds:						"Alla servrar",
							context_mutedguilds:				"DÃ¤mpade servrar",
							context_pingedguilds:				"Pingade servrar",
							context_unreadguilds:				"OlÃ¤sta servrar",
							modal_confirmmentions:				"Ã„r du sÃ¤ker pÃ¥ att du vill ta bort alla olÃ¤sta omnÃ¤mnanden?",
							modal_confirmnotifications:			"Ã„r du sÃ¤ker pÃ¥ att du vill ta bort alla olÃ¤sta aviseringar?",
							toast_alreadyclearing:				"Raderar nÃ¥gra omnÃ¤mnanden redan",
							toast_cleared:						"Alla nya omnÃ¤mnanden har tagits bort",
							toast_clearing:						"Rensar alla senaste omnÃ¤mnanden"
						};
					case "th":		// Thai
						return {
							context_dms:						"à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¹‚à¸”à¸¢à¸•à¸£à¸‡",
							context_guilds:						"à¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¹€à¸§à¸­à¸£à¹Œà¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”",
							context_mutedguilds:				"à¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¹€à¸§à¸­à¸£à¹Œà¸—à¸µà¹ˆà¸›à¸´à¸”à¹€à¸ªà¸µà¸¢à¸‡",
							context_pingedguilds:				"à¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¹€à¸§à¸­à¸£à¹Œ Pinged",
							context_unreadguilds:				"à¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¹€à¸§à¸­à¸£à¹Œà¸—à¸µà¹ˆà¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¹„à¸”à¹‰à¸­à¹ˆà¸²à¸™",
							modal_confirmmentions:				"à¹à¸™à¹ˆà¹ƒà¸ˆà¹„à¸«à¸¡à¸§à¹ˆà¸²à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸¥à¸šà¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸—à¸µà¹ˆà¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¹„à¸”à¹‰à¸­à¹ˆà¸²à¸™à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”",
							modal_confirmnotifications:			"à¹à¸™à¹ˆà¹ƒà¸ˆà¹„à¸«à¸¡à¸§à¹ˆà¸²à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸¥à¸šà¸à¸²à¸£à¹à¸ˆà¹‰à¸‡à¹€à¸•à¸·à¸­à¸™à¸—à¸µà¹ˆà¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¹„à¸”à¹‰à¸­à¹ˆà¸²à¸™à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”",
							toast_alreadyclearing:				"à¸¥à¸šà¸à¸²à¸£à¸à¸¥à¹ˆà¸²à¸§à¸–à¸¶à¸‡à¸šà¸²à¸‡à¸ªà¹ˆà¸§à¸™à¹à¸¥à¹‰à¸§",
							toast_cleared:						"à¸¥à¸šà¸à¸²à¸£à¸à¸¥à¹ˆà¸²à¸§à¸–à¸¶à¸‡à¸¥à¹ˆà¸²à¸ªà¸¸à¸”à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”à¹à¸¥à¹‰à¸§",
							toast_clearing:						"à¸¥à¹‰à¸²à¸‡à¸à¸²à¸£à¸žà¸¹à¸”à¸–à¸¶à¸‡à¸¥à¹ˆà¸²à¸ªà¸¸à¸”à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”"
						};
					case "tr":		// Turkish
						return {
							context_dms:						"Direkt Mesajlar",
							context_guilds:						"TÃ¼m Sunucular",
							context_mutedguilds:				"Sessiz Sunucular",
							context_pingedguilds:				"Ping GÃ¶nderilen Sunucular",
							context_unreadguilds:				"OkunmamÄ±ÅŸ Sunucular",
							modal_confirmmentions:				"OkunmamÄ±ÅŸ tÃ¼m bahisleri silmek istediÄŸinizden emin misiniz?",
							modal_confirmnotifications:			"OkunmamÄ±ÅŸ tÃ¼m bildirimleri silmek istediÄŸinizden emin misiniz?",
							toast_alreadyclearing:				"Zaten bazÄ± bahsetmeleri siler",
							toast_cleared:						"Son bahsedenlerin tÃ¼mÃ¼ silindi",
							toast_clearing:						"TÃ¼m son bahsedilenleri temizler"
						};
					case "uk":		// Ukrainian
						return {
							context_dms:						"ÐŸÑ€ÑÐ¼Ñ– Ð¿Ð¾Ð²Ñ–Ð´Ð¾Ð¼Ð»ÐµÐ½Ð½Ñ",
							context_guilds:						"Ð£ÑÑ– ÑÐµÑ€Ð²ÐµÑ€Ð¸",
							context_mutedguilds:				"ÐŸÑ€Ð¸Ð³Ð»ÑƒÑˆÐµÐ½Ñ– ÑÐµÑ€Ð²ÐµÑ€Ð¸",
							context_pingedguilds:				"Pinged ÑÐµÑ€Ð²ÐµÑ€Ð¸",
							context_unreadguilds:				"ÐÐµÐ¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ð½Ñ– ÑÐµÑ€Ð²ÐµÑ€Ð¸",
							modal_confirmmentions:				"Ð’Ð¸ Ð²Ð¿ÐµÐ²Ð½ÐµÐ½Ñ–, Ñ‰Ð¾ Ñ…Ð¾Ñ‡ÐµÑ‚Ðµ Ð²Ð¸Ð´Ð°Ð»Ð¸Ñ‚Ð¸ Ð²ÑÑ– Ð½ÐµÐ¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ð½Ñ– Ð·Ð³Ð°Ð´ÐºÐ¸?",
							modal_confirmnotifications:			"Ð’Ð¸ Ð²Ð¿ÐµÐ²Ð½ÐµÐ½Ñ–, Ñ‰Ð¾ Ñ…Ð¾Ñ‡ÐµÑ‚Ðµ Ð²Ð¸Ð´Ð°Ð»Ð¸Ñ‚Ð¸ Ð²ÑÑ– Ð½ÐµÐ¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ð½Ñ– ÑÐ¿Ð¾Ð²Ñ–Ñ‰ÐµÐ½Ð½Ñ?",
							toast_alreadyclearing:				"Ð’Ð¸Ð´Ð°Ð»ÑÑ” Ð´ÐµÑÐºÑ– Ð·Ð³Ð°Ð´ÐºÐ¸ Ð²Ð¶Ðµ",
							toast_cleared:						"Ð£ÑÑ– Ð¾ÑÑ‚Ð°Ð½Ð½Ñ– Ð·Ð³Ð°Ð´ÑƒÐ²Ð°Ð½Ð½Ñ Ð±ÑƒÐ»Ð¸ Ð²Ð¸Ð´Ð°Ð»ÐµÐ½Ñ–",
							toast_clearing:						"ÐžÑ‡Ð¸Ñ‰Ð°Ñ” Ð²ÑÑ– Ð¾ÑÑ‚Ð°Ð½Ð½Ñ– Ð·Ð³Ð°Ð´ÑƒÐ²Ð°Ð½Ð½Ñ"
						};
					case "vi":		// Vietnamese
						return {
							context_dms:						"Tin nháº¯n trá»±c tiáº¿p",
							context_guilds:						"Táº¥t cáº£ mÃ¡y chá»§",
							context_mutedguilds:				"MÃ¡y chá»§ bá»‹ táº¯t tiáº¿ng",
							context_pingedguilds:				"MÃ¡y chá»§ Pinged",
							context_unreadguilds:				"MÃ¡y chá»§ chÆ°a Ä‘á»c",
							modal_confirmmentions:				"Báº¡n cÃ³ cháº¯c cháº¯n muá»‘n xÃ³a táº¥t cáº£ cÃ¡c Ä‘á» cáº­p chÆ°a Ä‘á»c khÃ´ng?",
							modal_confirmnotifications:			"Báº¡n cÃ³ cháº¯c cháº¯n muá»‘n xÃ³a táº¥t cáº£ cÃ¡c thÃ´ng bÃ¡o chÆ°a Ä‘á»c khÃ´ng?",
							toast_alreadyclearing:				"ÄÃ£ xÃ³a má»™t sá»‘ Ä‘á» cáº­p",
							toast_cleared:						"Táº¥t cáº£ cÃ¡c Ä‘á» cáº­p gáº§n Ä‘Ã¢y Ä‘Ã£ bá»‹ xÃ³a",
							toast_clearing:						"XÃ³a táº¥t cáº£ cÃ¡c Ä‘á» cáº­p gáº§n Ä‘Ã¢y"
						};
					case "zh-CN":	// Chinese (China)
						return {
							context_dms:						"ç›´æŽ¥è®¯æ¯",
							context_guilds:						"æ‰€æœ‰æœåŠ¡å™¨",
							context_mutedguilds:				"é™éŸ³æœåŠ¡å™¨",
							context_pingedguilds:				"ç»‘å®šæœåŠ¡å™¨",
							context_unreadguilds:				"æœªè¯»æœåŠ¡å™¨",
							modal_confirmmentions:				"æ‚¨ç¡®å®šè¦åˆ é™¤æ‰€æœ‰æœªè¯»çš„æåŠå—ï¼Ÿ",
							modal_confirmnotifications:			"æ‚¨ç¡®å®šè¦åˆ é™¤æ‰€æœ‰æœªè¯»çš„é€šçŸ¥å—ï¼Ÿ",
							toast_alreadyclearing:				"å·²åˆ é™¤ä¸€äº›æåŠ",
							toast_cleared:						"æœ€è¿‘æ‰€æœ‰æåŠçš„å†…å®¹å‡å·²åˆ é™¤",
							toast_clearing:						"æ¸…é™¤æ‰€æœ‰æœ€è¿‘æåŠçš„å†…å®¹"
						};
					case "zh-TW":	// Chinese (Taiwan)
						return {
							context_dms:						"ç›´æŽ¥è¨Šæ¯",
							context_guilds:						"æ‰€æœ‰æœå‹™å™¨",
							context_mutedguilds:				"éœéŸ³æœå‹™å™¨",
							context_pingedguilds:				"ç¶å®šæœå‹™å™¨",
							context_unreadguilds:				"æœªè®€æœå‹™å™¨",
							modal_confirmmentions:				"æ‚¨ç¢ºå®šè¦åˆªé™¤æ‰€æœ‰æœªè®€çš„æåŠå—Žï¼Ÿ",
							modal_confirmnotifications:			"æ‚¨ç¢ºå®šè¦åˆªé™¤æ‰€æœ‰æœªè®€çš„é€šçŸ¥å—Žï¼Ÿ",
							toast_alreadyclearing:				"å·²åˆªé™¤ä¸€äº›æåŠ",
							toast_cleared:						"æœ€è¿‘æ‰€æœ‰æåŠçš„å…§å®¹å‡å·²åˆªé™¤",
							toast_clearing:						"æ¸…é™¤æ‰€æœ‰æœ€è¿‘æåŠçš„å…§å®¹"
						};
					default:		// English
						return {
							context_dms:						"Direct Messages",
							context_guilds:						"All Servers",
							context_mutedguilds:				"Muted Servers",
							context_pingedguilds:				"Pinged Servers",
							context_unreadguilds:				"Unread Servers",
							modal_confirmmentions:				"Are you sure you want to delete all unread Mentions?",
							modal_confirmnotifications:			"Are you sure you want to delete all unread Notifications?",
							toast_alreadyclearing:				"Already clearing some Mentions",
							toast_cleared:						"All recent Mentions have been cleared",
							toast_clearing:						"Clearing all recent Mentions"
						};
				}
			}
		};
	})(window.BDFDB_Global.PluginUtils.buildPlugin(config));
})();
/**
 * @name QuickMessages
 * @source https://github.com/QWERTxD/BetterDiscordPlugins/blob/main/QuickMessages/QuickMessages.plugin.js
 * @updateUrl https://raw.githubusercontent.com/QWERTxD/BetterDiscordPlugins/main/QuickMessages/QuickMessages.plugin.js
 * @website https://github.com/QWERTxD/BetterDiscordPlugins/tree/main/QuickMessages
 * @invite zMnHFAKsu3
 */

const request = require("request");
const fs = require("fs");
const path = require("path");

const config = {
    info: {
        name: "QuickMessages",
        authors: [
            {
                name: "QWERT",
                discord_id: "678556376640913408",
            }
        ],
        version: "1.2.0",
        description: "Save messages to quickly send them later, when you need.",
        github: "https://github.com/QWERTxD/BetterDiscordPlugins/tree/main/QuickMessages",
        github_raw: "https://raw.githubusercontent.com/QWERTxD/BetterDiscordPlugins/main/QuickMessages/QuickMessages.plugin.js",
    },
    changelog: [
        {
            title: "Added",
            type: "added",
            items: [
                "Added categories ðŸ¥³\nHover the \"Save as Quick Message\" button to use the categories.\nI still need ideas and suggestions, so if you have some, feel free to send them to me in the support server https://discord.gg/zMnHFAKsu3",
                "A Support Server!!"
            ],
        }
    ]
};

module.exports = !global.ZeresPluginLibrary ? class {
    constructor() {
        this._config = config;
    }

    getName() {
        return config.info.name;
    }

    getAuthor() {
        return config.info.authors.map(author => author.name).join(", ");
    }

    getDescription() {
        return config.info.description;
    }

    getVersion() {
        return config.info.version;
    }

    load() {
        BdApi.showConfirmationModal("Library plugin is needed",
            `The library plugin needed for ${config.info.name} is missing. Please click Download Now to install it.`, {
            confirmText: "Download",
            cancelText: "Cancel",
            onConfirm: () => {
                request.get("https://rauenzi.github.io/BDPluginLibrary/release/0PluginLibrary.plugin.js", (error, response, body) => {
                    if (error) {
                        return electron.shell.openExternal("https://betterdiscord.net/ghdl?url=https://raw.githubusercontent.com/rauenzi/BDPluginLibrary/master/release/0PluginLibrary.plugin.js");
                    }

                    fs.writeFileSync(path.join(BdApi.Plugins.folder, "0PluginLibrary.plugin.js"), body);
                });
            }
        });
    }

    start() { }

    stop() { }
} : (([Plugin, Library]) => {
    const { DiscordModules, WebpackModules, Patcher, DiscordContextMenu, Settings } = Library;
    const { SettingPanel, SettingGroup } = Settings;

    const { React } = DiscordModules;
    function configArrayPush(name, key, data) {
        const config = BdApi.getData(name, key) || [];
        if (config.includes(data)) return;
        config.push(data);
        BdApi.setData(name, key, config);
    }

    const configArrayRemove = function (name, key, value) {
        const data = BdApi.getData(name, key) || [];
        const config = data.filter(function (x) {
            return x != value;
        });
        BdApi.setData(name, key, config)
    }

    var messages = BdApi.getData('QuickMessages', 'messages') || [];

    function updateMessages() {
        messages = BdApi.getData('QuickMessages', 'messages') || [];
    }

    var categories = BdApi.getData('QuickMessages', 'categories') || [];

    function saveCategories() {
        BdApi.setData('QuickMessages', 'categories', categories);
    }
    class QuickMessages extends Plugin {
        constructor() {
            super();
        }

        buildSettingsPanel() {
            const that = this;
            const settingGroup = new SettingGroup("Clear Quick Messages", {
                shown: true,
                collapsible: false
            });
            const div = document.createElement("div");
            div.innerHTML = '<button class="button-38aScr lookFilled-1Gx00P colorRed-1TFJan sizeMedium-1AC_Sl grow-q77ONN">Delete All Quick Messages</button>'
            div.onclick = _ => {
                BdApi.showConfirmationModal('Are you sure?', 'This action is undonable. You will not be able to restore the deleted data.', {
                    confirmText: 'Delete',
                    danger: true,
                    onConfirm: function () {
                        BdApi.setData(that.getName(), 'messages', []);
                        that.forceUpdate();
                        BdApi.alert('QuickMessages', 'Successfully Removed All Quick Messages!');
                    }
                })
            }
            settingGroup.append(div);
            return new SettingPanel(this.saveSettings.bind(this), settingGroup);
        }

        getSettingsPanel() {
            return this.buildSettingsPanel().getElement();
        }

        onStart() {
            this.patchTextAreaContextMenus();
        }

        onStop() {
            Patcher.unpatchAll();
        }

        forceUpdate() {
            saveCategories();
            updateMessages();
            Patcher.unpatchAll();
            this.patchTextAreaContextMenus();
        }

        patchTextAreaContextMenus() {
            var shouldPaste = true;
            const SlateTextAreaContextMenu = WebpackModules.find(m => m.default?.displayName === "SlateTextAreaContextMenu");
            const CloseCircle = BdApi.findModuleByDisplayName('CloseCircle');
            const ComponentDispatch = BdApi.findModuleByProps("ComponentDispatch").ComponentDispatch;
            const ChannelTextAreaContainer = WebpackModules.find(m => m.type && m.type.render && m.type.render.displayName === "ChannelTextAreaContainer").type;
            const children = [];
            const saveToCategory = [];
            var text = "";

            categories.forEach(cat => {
                saveToCategory.push(
                    DiscordContextMenu.buildMenuItem({
                        label: cat.name,
                        action: _ => {
                            const category = categories.filter(e => e.name === cat.name)[0];
                            categories[categories.indexOf(category)].items.push(text);
                            this.forceUpdate();
                            BdApi.showToast(`Successfully created new Quick Message!`, { type: 'success' });
                        }
                    })
                )
                const catChildren = [];
                cat.items.forEach(e => {
                    catChildren.push(DiscordContextMenu.buildMenuItem({
                        label: e,
                        action: _ => {
                            if (!shouldPaste) return;
                            ComponentDispatch.dispatchToLastSubscribed("INSERT_TEXT", { content: e })
                        },
                        hint: React.createElement(CloseCircle, {
                            onClick: _ => {
                                shouldPaste = false;
                                const category = categories.filter(e => e.name === cat.name)[0];
                                categories[categories.indexOf(category)].items = Library.Utilities.removeFromArray(categories[categories.indexOf(category)].items, e);
                                this.forceUpdate();
                                BdApi.showToast(`Successfully removed Quick Message!`, { type: 'success' });
                            },
                            width: '15px',
                            height: '15px'
                        })
                    }))
                });
                catChildren.push(DiscordContextMenu.buildMenuItem({
                    label: "Delete Category", danger: true, action: _ => {
                        BdApi.showConfirmationModal(`Delete '${cat.name}'`, [
                            React.createElement(BdApi.findModuleByDisplayName("Card"), {
                                children: [
                                    React.createElement(BdApi.findModuleByDisplayName("Text"), {
                                        children: ["Are you sure you want to delete ", React.createElement("strong", {}, cat.name), "? This action cannot be undone."],
                                        size: "size16-1P40sf"
                                    })
                                ],
                                "type": "cardWarning",
                                "className": "card-3uOWw3 spacing-ApfUws marginBottom20-32qID7",
                            })
                        ], {
                            danger: true,
                            confirmText: "Delete",
                            onConfirm: _ => {
                                Library.Utilities.removeFromArray(categories, categories[categories.indexOf(cat)]);
                                this.forceUpdate();
                            }
                        })
                    }
                }))
                children.push(DiscordContextMenu.buildMenuItem({
                    label: cat.name,
                    children: catChildren
                }));
            })

            messages.forEach(message => {
                if (messages.indexOf(message) === 0) children.push(DiscordContextMenu.buildMenuItem({ type: 'separator' }))
                children.push(DiscordContextMenu.buildMenuItem({
                    label: message,
                    action: _ => {
                        if (!shouldPaste) return;
                        ComponentDispatch.dispatchToLastSubscribed("INSERT_TEXT", { content: message })
                    },
                    hint: React.createElement(CloseCircle, {
                        onClick: _ => {
                            shouldPaste = false;
                            configArrayRemove("QuickMessages", 'messages', message);
                            this.forceUpdate();
                            BdApi.showToast(`Successfully removed Quick Message!`, { type: 'success' });
                        },
                        width: '15px',
                        height: '15px'
                    })
                }));
            })


            const patch = (_, [props], ret) => {
                Patcher.after(ChannelTextAreaContainer, "render", (_, [{ textValue }], ret) => {
                    text = textValue;
                });

                ret.props.children.push(
                    DiscordContextMenu.buildMenuItem({
                        type: "separator"
                    }),
                    DiscordContextMenu.buildMenuItem({
                        label: "Save as Quick Message",
                        disabled: props.editor.containerRef.current.textContent.slice(0, -1) == props.editor.props.placeholder,
                        action: _ => {
                            configArrayPush("QuickMessages", "messages", text);
                            this.forceUpdate();
                            BdApi.showToast(`Successfully created new Quick Message!`, { type: 'success' });
                        },
                        children: [
                            saveToCategory,
                            DiscordContextMenu.buildMenuItem({ type: 'separator' }),
                            DiscordContextMenu.buildMenuItem({
                                label: 'Create a category...',
                                action: _ => {
                                    const FormItem = BdApi.findModuleByDisplayName("FormItem");
                                    const TextInput = BdApi.findModuleByDisplayName("TextInput");
                                    const Text = BdApi.findModuleByDisplayName("Text");
                                    let categoryName = "";

                                    Library.Modals.showModal("Create Category", [
                                        React.createElement(FormItem, {
                                            title: "Category Name",
                                            children: [
                                                React.createElement(TextInput, {
                                                    type: "text",
                                                    placeholder: "New Category",
                                                    onChange: e => {
                                                        categoryName = e;
                                                    }
                                                }),
                                                React.createElement(Text, {
                                                    children: ["This field is required"],
                                                    size: "size12-3cLvbJ",
                                                    color: "colorStatusRed-1YV2rj",
                                                    className: "error-chiOuv marginTop8-1DLZ1n",
                                                })
                                            ]
                                        })
                                    ], {
                                        danger: false,
                                        confirmText: "Create",
                                        onConfirm: _ => {
                                            const category = categories.filter(e => e.name === categoryName)[0];
                                            if (category) {
                                                categories[categories.indexOf(category)].items.push(text);
                                                this.forceUpdate();
                                            } else {
                                                categories.push({
                                                    name: categoryName,
                                                    items: [text]
                                                });
                                                this.forceUpdate();
                                            }
                                        }

                                    })
                                }
                            })
                        ]
                    }),
                    DiscordContextMenu.buildMenuItem({
                        label: "Quick Messages",
                        children: children.length > 0 ? children : DiscordContextMenu.buildMenuItem({ label: 'None' }),
                    }));
            };
            Patcher.after(SlateTextAreaContextMenu, "default", patch);

        }
    }

    return QuickMessages;
})(global.ZeresPluginLibrary.buildPlugin(config));
{
    "currentVersionInfo": {
        "version": "1.2.0",
        "hasShownChangelog": true
    }
}
{
	"general": {
		"pinIcon": true,
		"unreadAmount": true,
		"channelAmount": true
	},
	"preCategories": {
		"friends": {
			"enabled": false,
			"collapsed": false
		},
		"blocked": {
			"enabled": false,
			"collapsed": false
		},
		"groups": {
			"enabled": false,
			"collapsed": false
		}
	},
	"recentOrder": {
		"channelList": false,
		"guildList": false
	}
}
{
    "currentVersionInfo": {
        "version": "0.1.17",
        "hasShownChangelog": true
    }
}
{
    "currentVersionInfo": {
        "version": "0.0.8",
        "hasShownChangelog": true
    }
}
/**
 * @name OpenSpotifylinksInSpotify
 * @authorId 415849376598982656
 */
/*@cc_on
@if (@_jscript)
    
    // Offer to self-install for clueless users that try to run this directly.
    var shell = WScript.CreateObject("WScript.Shell");
    var fs = new ActiveXObject("Scripting.FileSystemObject");
    var pathPlugins = shell.ExpandEnvironmentStrings("%APPDATA%\BetterDiscord\plugins");
    var pathSelf = WScript.ScriptFullName;
    // Put the user at ease by addressing them in the first person
    shell.Popup("It looks like you've mistakenly tried to run me directly. \n(Don't do that!)", 0, "I'm a plugin for BetterDiscord", 0x30);
    if (fs.GetParentFolderName(pathSelf) === fs.GetAbsolutePathName(pathPlugins)) {
        shell.Popup("I'm in the correct folder already.", 0, "I'm already installed", 0x40);
    } else if (!fs.FolderExists(pathPlugins)) {
        shell.Popup("I can't find the BetterDiscord plugins folder.\nAre you sure it's even installed?", 0, "Can't install myself", 0x10);
    } else if (shell.Popup("Should I copy myself to BetterDiscord's plugins folder for you?", 0, "Do you need some help?", 0x34) === 6) {
        fs.CopyFile(pathSelf, fs.BuildPath(pathPlugins, fs.GetFileName(pathSelf)), true);
        // Show the user where to put plugins in the future
        shell.Exec("explorer " + pathPlugins);
        shell.Popup("I'm installed!", 0, "Successfully installed", 0x40);
    }
    WScript.Quit();

@else@*/

module.exports = (() => {
    const config = {
        info: {
            name: "Open Spotify Links in Spotify",
            authors: [
                {
                    name: "Strencher",
                    discord_id: "415849376598982656",
                    github_username: "Strencher",
                    twitter_username: "Strencher3"
                }
            ],
            version: "0.0.8",
            description: "Opens Spotify links in Spotify. requires Spotify Desktop App.",
            github: "https://github.com/Strencher/BetterDiscordStuff/blob/master/OpenSpotifylinksInSpotify/OpenSpotifylinksInSpotify.plugin.js",
            github_raw: "https://raw.githubusercontent.com/Strencher/BetterDiscordStuff/master/OpenSpotifylinksInSpotify/OpenSpotifylinksInSpotify.plugin.js"
        },
        changelog: [
            {
                title: "fix",
                type: "fixed",
                items: ["Fixed not working."]
            }
        ]
    };

    return !global.ZeresPluginLibrary ? class {
        constructor() { this._config = config; }
        getName() { return config.info.name; }
        getAuthor() { return config.info.authors.map(a => a.name).join(", "); }
        getDescription() { return config.info.description; }
        getVersion() { return config.info.version; }
        load() {
            BdApi.showConfirmationModal("Library plugin is needed", 
                [`The library plugin needed for ${config.info.name} is missing. Please click Download Now to install it.`], {
                    confirmText: "Download",
                    cancelText: "Cancel",
                    onConfirm: () => {
                        require("request").get("https://rauenzi.github.io/BDPluginLibrary/release/0PluginLibrary.plugin.js", async (error, response, body) => {
                        if (error) return require("electron").shell.openExternal("https://betterdiscord.net/ghdl?url=https://raw.githubusercontent.com/rauenzi/BDPluginLibrary/master/release/0PluginLibrary.plugin.js");
                        await new Promise(r => require("fs").writeFile(require("path").join(BdApi.Plugins.folder, "0PluginLibrary.plugin.js"), body, r));
                        });
                    }
                });
        }
        start() { }
        stop() { }
    } : (([Plugin, Api]) => {
        const plugin = (Plugin, Api) => {
            const { WebpackModules, PluginUtilities, DiscordModules, ReactComponents, Patcher, Toasts, Modals, DiscordModules: { React } } = Api;
            const { shell } = require('electron');
            return class OpenSpotifylinksInSpotify extends Plugin {
                constructor() {
                    super();
                }

                event(e) {
                    if (e.target.localName == "a" && e.target.href.includes("open.spotify.com")) {
                        e.preventDefault();
                        let url = e.target.href.split("/");
                        shell.openExternal(`spotify://${url[3]}/${url[url.length - 1]}`, { activate: true });
                    } else if(e.target.parentElement && e.target.parentElement.localName == "a" && e.target.parentElement.href.includes("open.spotify.com")) {
                        e.preventDefault();
                        let url = e.target.parentElement.href.split("/");
                        shell.openExternal(`spotify://${url[3]}/${url[url.length - 1]}`, { activate: true });
                    }
                }
                onStart() {
                    document.addEventListener("click", this.event);
                }
                onStop() {
                    document.removeEventListener("click", this.event);
                }

            }

        };
        return plugin(Plugin, Api);
    })(global.ZeresPluginLibrary.buildPlugin(config));
})();
/**
 * @name OnlineFriendCount
 * @author Zerthox
 * @version 1.4.1
 * @description Add the old online friend count back to guild list. Because nostalgia.
 * @authorLink https://github.com/Zerthox
 * @donate https://paypal.me/zerthox
 * @website https://github.com/Zerthox/BetterDiscord-Plugins
 * @source https://github.com/Zerthox/BetterDiscord-Plugins/tree/master/v1/onlinefriendcount.plugin.js
 * @updateUrl https://raw.githubusercontent.com/Zerthox/BetterDiscord-Plugins/master/v1/onlinefriendcount.plugin.js
 */

/* @cc_on
    @if (@_jscript)
        var name = WScript.ScriptName.split(".")[0];
        var shell = WScript.CreateObject("WScript.Shell");
        var fso = new ActiveXObject("Scripting.FileSystemObject");
        shell.Popup("Do NOT run random scripts from the internet with the Windows Script Host!\n\nYou are supposed to move this file to your BandagedBD/BetterDiscord plugins folder.", 0, name + ": Warning!", 0x1030);
        var pluginsPath = shell.expandEnvironmentStrings("%appdata%\\BetterDiscord\\plugins");
        if (!fso.FolderExists(pluginsPath)) {
            if (shell.Popup("Unable to find the BetterDiscord plugins folder on your computer.\nOpen the download page of BandagedBD/BetterDiscord?", 0, name + ": BetterDiscord installation not found", 0x14) === 6) {
                shell.Exec("explorer \"https://github.com/rauenzi/betterdiscordapp/releases\"");
            }
        } else if (WScript.ScriptFullName === pluginsPath + "\\" + WScript.ScriptName) {
            shell.Popup("This plugin is already in the correct folder.\nNavigate to the \"Plugins\" settings tab in Discord and enable it there.", 0, name, 0x40);
        } else {
            shell.Exec("explorer " + pluginsPath);
        }
        WScript.Quit();
    @else
@*/

const {React, ReactDOM} = BdApi;
const Flux = BdApi.findModuleByProps("connectStores");

function qReact(node, query) {
    let match = false;

    try {
        match = query(node);
    } catch (err) {
        console.debug("Suppressed error in qReact query:\n", err);
    }

    if (match) {
        return node;
    } else if (node && node.props && node.props.children) {
        for (const child of [node.props.children].flat()) {
            const result = qReact(child, query);

            if (result) {
                return result;
            }
        }
    }

    return null;
}

const Module = {
    Status: BdApi.findModuleByProps("getStatus", "getOnlineFriendCount")
};
const Component = {
    Link: BdApi.findModuleByProps("NavLink").Link
};
const Selector = {
    guilds: BdApi.findModuleByProps("guilds", "base"),
    list: BdApi.findModuleByProps("listItem"),
    friendsOnline: "friendsOnline-2JkivW"
};
const Styles = `/*! OnlineFriendCount v1.4.1 styles */
.friendsOnline-2JkivW {
    color: rgba(255, 255, 255, 0.3);
    text-align: center;
    text-transform: uppercase;
    font-size: 10px;
    font-weight: 500;
    line-height: 1.3;
    width: 70px;
    word-wrap: normal;
    white-space: nowrap;
    cursor: pointer;
}
.friendsOnline-2JkivW:hover {
    color: rgba(255, 255, 255, 0.5);
}`;

function OnlineCount({online}) {
    return React.createElement(
        "div",
        {
            className: Selector.list.listItem
        },
        React.createElement(
            Component.Link,
            {
                to: {
                    pathname: "/channels/@me"
                }
            },
            React.createElement(
                "div",
                {
                    className: Selector.friendsOnline
                },
                online,
                " Online"
            )
        )
    );
}

const OnlineCountContainer = Flux.connectStores([Module.Status], () => ({
    online: Module.Status.getOnlineFriendCount()
}))(OnlineCount);

class Plugin {
    start() {
        this.injectCSS(Styles);
        const guilds = this.findGuilds();

        const findChildFunc = (el) => {
            while (!(el.props.children instanceof Function)) {
                if (!el.props.children) {
                    this.log(`Unable to find children function for "${el.type.toString()}"`);
                    return null;
                }

                el = el.props.children;
            }

            return el;
        };

        this.createPatch(guilds.type.prototype, "render", {
            after: ({returnValue}) => {
                BdApi.monkeyPatch(findChildFunc(returnValue).props, "children", {
                    silent: true,
                    after: ({returnValue}) => {
                        BdApi.monkeyPatch(findChildFunc(returnValue).props, "children", {
                            silent: true,
                            after: ({returnValue}) => {
                                const scroller = qReact(returnValue, (e) =>
                                    e.props.children.find((e) => e.type.displayName === "ConnectedUnreadDMs")
                                );

                                if (!scroller) {
                                    this.error("Error during render: Cannot find guilds scroller Component");
                                    return;
                                }

                                const {children} = scroller.props;
                                const index = children.indexOf(
                                    qReact(scroller, (e) => e.type.displayName === "ConnectedUnreadDMs")
                                );
                                children.splice(
                                    index > -1 ? index : 1,
                                    0,
                                    React.createElement(OnlineCountContainer, null)
                                );
                            }
                        });
                    }
                });
            }
        });
        guilds.stateNode.forceUpdate();
    }

    stop() {
        this.findGuilds().stateNode.forceUpdate();
    }

    findGuilds() {
        let guilds = BdApi.getInternalInstance(document.getElementsByClassName(Selector.guilds.guilds)[0]);

        if (!guilds) {
            this.error("Cannot find Guilds element fiber");
            return;
        }

        while (!guilds.type || guilds.type.displayName !== "Guilds") {
            if (!guilds.return) {
                this.error("Cannot find Guilds Component");
                return;
            }

            guilds = guilds.return;
        }

        return guilds;
    }
}

module.exports = class Wrapper extends Plugin {
    getName() {
        return "OnlineFriendCount";
    }

    getVersion() {
        return "1.4.1";
    }

    getAuthor() {
        return "Zerthox";
    }

    getDescription() {
        return "Add the old online friend count back to guild list. Because nostalgia.";
    }

    log(...msgs) {
        console.log(
            `%c[${this.getName()}] %c(v${this.getVersion()})`,
            "color: #3a71c1; font-weight: 700;",
            "color: #666; font-size: .8em;",
            ...msgs
        );
    }

    warn(...msgs) {
        console.warn(
            `%c[${this.getName()}] %c(v${this.getVersion()})`,
            "color: #3a71c1; font-weight: 700;",
            "color: #666; font-size: .8em;",
            ...msgs
        );
    }

    error(...msgs) {
        console.error(
            `%c[${this.getName()}] %c(v${this.getVersion()})`,
            "color: #3a71c1; font-weight: 700;",
            "color: #666; font-size: .8em;",
            ...msgs
        );
    }

    constructor(...args) {
        super(...args);
        this._Patches = [];

        if (this.defaults) {
            this.settings = {...this.defaults, ...this.loadData("settings")};
        }
    }

    start() {
        this.log("Enabled");
        super.start();
    }

    stop() {
        while (this._Patches.length > 0) {
            this._Patches.pop()();
        }

        this.log("Unpatched all");

        if (document.getElementById(this.getName())) {
            BdApi.clearCSS(this.getName());
        }

        super.stop();
        this.log("Disabled");
    }

    saveData(id, value) {
        return BdApi.saveData(this.getName(), id, value);
    }

    loadData(id, fallback = null) {
        const data = BdApi.loadData(this.getName(), id);
        return data !== undefined && data !== null ? data : fallback;
    }

    injectCSS(css) {
        const el = document.getElementById(this.getName());

        if (!el) {
            BdApi.injectCSS(this.getName(), css);
        } else {
            el.innerHTML += "\n\n/* --- */\n\n" + css;
        }
    }

    createPatch(target, method, options) {
        options.silent = true;

        this._Patches.push(BdApi.monkeyPatch(target, method, options));

        const name =
            options.name ||
            target.displayName ||
            target.name ||
            target.constructor.displayName ||
            target.constructor.name ||
            "Unknown";
        this.log(
            `Patched ${method} of ${name} ${
                options.type === "component" || target instanceof React.Component ? "component" : "module"
            }`
        );
    }

    async forceUpdate(...classes) {
        this.forceUpdateElements(...classes.map((e) => Array.from(document.getElementsByClassName(e))).flat());
    }

    async forceUpdateElements(...elements) {
        for (const el of elements) {
            try {
                let fiber = BdApi.getInternalInstance(el);

                if (fiber) {
                    while (!fiber.stateNode || !fiber.stateNode.forceUpdate) {
                        fiber = fiber.return;
                    }

                    fiber.stateNode.forceUpdate();
                }
            } catch (e) {
                this.warn(
                    `Failed to force update "${
                        el.id ? `#${el.id}` : el.className ? `.${el.className}` : el.tagName
                    }" state node`
                );
                console.error(e);
            }
        }
    }
};

if (Plugin.prototype.getSettings) {
    const Flex = BdApi.findModuleByDisplayName("Flex");
    const Button = BdApi.findModuleByProps("Link", "Hovers");
    const Form = BdApi.findModuleByProps("FormItem", "FormSection", "FormDivider");
    const Margins = BdApi.findModuleByProps("marginLarge");

    class Settings extends React.Component {
        constructor(...args) {
            super(...args);
            this.state = this.props.current;
        }

        render() {
            const {name, defaults, children: Child} = this.props;
            return React.createElement(
                Form.FormSection,
                null,
                React.createElement(Child, {
                    update: (changed) => this.update({...this.state, ...changed}),
                    ...this.state
                }),
                React.createElement(Form.FormDivider, {
                    className: [Margins.marginTop20, Margins.marginBottom20].join(" ")
                }),
                React.createElement(
                    Flex,
                    {
                        justify: Flex.Justify.END
                    },
                    React.createElement(
                        Button,
                        {
                            size: Button.Sizes.SMALL,
                            onClick: () =>
                                BdApi.showConfirmationModal(name, "Reset all settings?", {
                                    onConfirm: () => this.update(defaults)
                                })
                        },
                        "Reset"
                    )
                )
            );
        }

        update(settings) {
            this.setState(settings);
            this.props.onChange(settings);
        }
    }

    module.exports.prototype.getSettingsPanel = function () {
        return React.createElement(
            Settings,
            {
                name: this.getName(),
                current: this.settings,
                defaults: this.defaults,
                onChange: (settings) => {
                    this.settings = settings;

                    if (this.update instanceof Function) {
                        this.update();
                    }

                    this.saveData("settings", settings);
                }
            },
            this.getSettings()
        );
    };
}

/* @end@*/
/**
 * @name NotificationSounds
 * @author DevilBro
 * @authorId 278543574059057154
 * @version 3.6.0
 * @description Allows you to replace the native Sounds with custom Sounds
 * @invite Jx3TjNS
 * @donate https://www.paypal.me/MircoWittrien
 * @patreon https://www.patreon.com/MircoWittrien
 * @website https://mwittrien.github.io/
 * @source https://github.com/mwittrien/BetterDiscordAddons/tree/master/Plugins/NotificationSounds/
 * @updateUrl https://mwittrien.github.io/BetterDiscordAddons/Plugins/NotificationSounds/NotificationSounds.plugin.js
 */

module.exports = (_ => {
	const config = {
		"info": {
			"name": "NotificationSounds",
			"author": "DevilBro",
			"version": "3.6.0",
			"description": "Allows you to replace the native Sounds with custom Sounds"
		}
	};

	return !window.BDFDB_Global || (!window.BDFDB_Global.loaded && !window.BDFDB_Global.started) ? class {
		getName () {return config.info.name;}
		getAuthor () {return config.info.author;}
		getVersion () {return config.info.version;}
		getDescription () {return `The Library Plugin needed for ${config.info.name} is missing. Open the Plugin Settings to download it. \n\n${config.info.description}`;}
		
		downloadLibrary () {
			require("request").get("https://mwittrien.github.io/BetterDiscordAddons/Library/0BDFDB.plugin.js", (e, r, b) => {
				if (!e && b && r.statusCode == 200) require("fs").writeFile(require("path").join(BdApi.Plugins.folder, "0BDFDB.plugin.js"), b, _ => BdApi.showToast("Finished downloading BDFDB Library", {type: "success"}));
				else BdApi.alert("Error", "Could not download BDFDB Library Plugin. Try again later or download it manually from GitHub: https://mwittrien.github.io/downloader/?library");
			});
		}
		
		load () {
			if (!window.BDFDB_Global || !Array.isArray(window.BDFDB_Global.pluginQueue)) window.BDFDB_Global = Object.assign({}, window.BDFDB_Global, {pluginQueue: []});
			if (!window.BDFDB_Global.downloadModal) {
				window.BDFDB_Global.downloadModal = true;
				BdApi.showConfirmationModal("Library Missing", `The Library Plugin needed for ${config.info.name} is missing. Please click "Download Now" to install it.`, {
					confirmText: "Download Now",
					cancelText: "Cancel",
					onCancel: _ => {delete window.BDFDB_Global.downloadModal;},
					onConfirm: _ => {
						delete window.BDFDB_Global.downloadModal;
						this.downloadLibrary();
					}
				});
			}
			if (!window.BDFDB_Global.pluginQueue.includes(config.info.name)) window.BDFDB_Global.pluginQueue.push(config.info.name);
		}
		start () {this.load();}
		stop () {}
		getSettingsPanel () {
			let template = document.createElement("template");
			template.innerHTML = `<div style="color: var(--header-primary); font-size: 16px; font-weight: 300; white-space: pre; line-height: 22px;">The Library Plugin needed for ${config.info.name} is missing.\nPlease click <a style="font-weight: 500;">Download Now</a> to install it.</div>`;
			template.content.firstElementChild.querySelector("a").addEventListener("click", this.downloadLibrary);
			return template.content.firstElementChild;
		}
	} : (([Plugin, BDFDB]) => {
		var audios, choices, firedEvents;
		var volumes = {};
		
		const removeAllKey = "REMOVE_ALL_BDFDB_DEVILBRO_DO_NOT_COPY";
		const defaultDevice = "default";
		
		var currentDevice = defaultDevice, createdAudios = {}, repatchIncoming;
		
		/* NEVER CHANGE THE SRC LINKS IN THE PLUGIN FILE, TO ADD NEW SOUNDS ADD THEM IN THE SETTINGS GUI IN THE PLUGINS PAGE */
		const types = {
			"message1":					{implemented: true,		name: "New Chat Message",			src: "/assets/dd920c06a01e5bb8b09678581e29d56f.mp3",	mute: true,		focus: null,	include: true},
			"dm":						{implemented: true,		name: "Direct Message",				src: "/assets/84c9fa3d07da865278bd77c97d952db4.mp3",	mute: true,		focus: true,	include: false},
			"mentioned":				{implemented: true,		name: "Mentioned",					src: "/assets/a5f42064e8120e381528b14fd3188b72.mp3",	mute: true,		focus: true,	include: false},
			"role":						{implemented: true,		name: "Mentioned (role)",			src: "/assets/a5f42064e8120e381528b14fd3188b72.mp3",	mute: true,		focus: true,	include: false},
			"everyone":					{implemented: true,		name: "Mentioned (@everyone)",		src: "/assets/a5f42064e8120e381528b14fd3188b72.mp3",	mute: true,		focus: true,	include: false},
			"here":						{implemented: true,		name: "Mentioned (@here)",			src: "/assets/a5f42064e8120e381528b14fd3188b72.mp3",	mute: true,		focus: true,	include: false},
			"deafen":					{implemented: true,		name: "Voicechat Deafen",			src: "/assets/e4d539271704b87764dc465b1a061abd.mp3",	mute: false,	focus: null,	include: true},
			"mute":						{implemented: true,		name: "Voicechat Mute",				src: "/assets/429d09ee3b86e81a75b5e06d3fb482be.mp3",	mute: false,	focus: null,	include: true},
			"disconnect":				{implemented: true,		name: "Voicechat Disconnect",		src: "/assets/7e125dc075ec6e5ae796e4c3ab83abb3.mp3",	mute: false,	focus: null,	include: true},
			"undeafen":					{implemented: true,		name: "Voicechat Undeafen",			src: "/assets/5a000a0d4dff083d12a1d4fc2c7cbf66.mp3",	mute: false,	focus: null,	include: true},
			"unmute":					{implemented: true,		name: "Voicechat Unmute",			src: "/assets/43805b9dd757ac4f6b9b58c1a8ee5f0d.mp3",	mute: false,	focus: null,	include: true},
			"user_join":				{implemented: true,		name: "Voicechat User Joined",		src: "/assets/5dd43c946894005258d85770f0d10cff.mp3",	mute: false,	focus: null,	include: true},
			"user_leave":				{implemented: true,		name: "Voicechat User Left",		src: "/assets/4fcfeb2cba26459c4750e60f626cebdc.mp3",	mute: false,	focus: null,	include: true},
			"user_moved":				{implemented: true,		name: "Voicechat User Moved",		src: "/assets/e81d11590762728c1b811eadfa5be766.mp3",	mute: false,	focus: null,	include: true},
			"reconnect":				{implemented: false,	name: "Voicechat Reconnect",		src: "/assets/471cfd0005b112ff857705e894bf41a6.mp3",	mute: true,		focus: null,	include: true},
			"ptt_start":				{implemented: true,		name: "Push2Talk Start",			src: "/assets/8b63833c8d252fedba6b9c4f2517c705.mp3",	mute: false,	focus: null,	include: true},
			"ptt_stop":					{implemented: true,		name: "Push2Talk Stop",				src: "/assets/74ab980d6890a0fa6aa0336182f9f620.mp3",	mute: false,	focus: null,	include: true},
			"call_calling":				{implemented: true,		name: "Outgoing Call",				src: "/assets/c6e92752668dde4eee5923d70441579f.mp3",	mute: null,		focus: null,	include: true},
			"call_ringing":				{implemented: true,		name: "Incoming Call",				src: "/assets/84a1b4e11d634dbfa1e5dd97a96de3ad.mp3",	mute: null,		focus: null,	include: true},
			"call_ringing_beat":		{implemented: false,	name: "Incoming Call Beat",			src: "/assets/b9411af07f154a6fef543e7e442e4da9.mp3",	mute: null,		focus: null,	include: true},
			"call_ringing_halloween":	{implemented: false,	name: "Incoming Call Halloween",	src: "/assets/bceeb2ba92c01584dcaafc957f769bae.mp3",	mute: null,		focus: null,	include: true},
			"stream_started":			{implemented: true,		name: "Stream Started",				src: "/assets/9ca817f41727edc1b2f1bc4f1911107c.mp3",	mute: false,	focus: null,	include: true},
			"stream_ended":				{implemented: true,		name: "Stream Ended",				src: "/assets/4e30f98aa537854f79f49a76af822bbc.mp3",	mute: false,	focus: null,	include: true},
			"stream_user_joined":		{implemented: true,		name: "Stream User Joined",			src: "/assets/5827bbf9a67c61cbb0e02ffbf434b654.mp3",	mute: false,	focus: null,	include: true},
			"stream_user_left":			{implemented: true,		name: "Stream User Left",			src: "/assets/7cdcdcbc426cc43583365a671c24b740.mp3",	mute: false,	focus: null,	include: true},
			"ddr-down":					{implemented: true,		name: "HotKeys Window Down",		src: "/assets/71f048f8aa7d4b24bf4268a87cbbb192.mp3",	mute: false,	focus: null,	include: true},
			"ddr-left":					{implemented: true,		name: "HotKeys Window Left",		src: "/assets/1de04408e62b5d52ae3ebbb91e9e1978.mp3",	mute: false,	focus: null,	include: true},
			"ddr-right":				{implemented: true,		name: "HotKeys Window Right",		src: "/assets/2c0433f93db8449e4a82b76dc520cb29.mp3",	mute: false,	focus: null,	include: true},
			"ddr-up":					{implemented: true,		name: "HotKeys Window Up",			src: "/assets/68472713f7a62c7c37e0a6a5d5a1faeb.mp3",	mute: false,	focus: null,	include: true},
			"mention1":					{implemented: false,	name: "Mention Ping",				src: "/assets/fa4d62c3cbc80733bf1f01b9c6f181de.mp3",	mute: true,		focus: null,	include: true},
			"mention2":					{implemented: false,	name: "Mention Ping 2",				src: "/assets/a5f42064e8120e381528b14fd3188b72.mp3",	mute: true,		focus: null,	include: true},
			"mention3":					{implemented: false,	name: "Mention Ping 3",				src: "/assets/84c9fa3d07da865278bd77c97d952db4.mp3",	mute: true,		focus: null,	include: true},	
			"message2":					{implemented: false,	name: "New Chatmessage 2",			src: "/assets/15fe810f6cfab609c7fcda61652b9b34.mp3",	mute: true,		focus: null,	include: true},
			"message3":					{implemented: false,	name: "New Chatmessage 3",			src: "/assets/53ce6a92d3c233e8b4ac529d34d374e4.mp3",	mute: true,		focus: null,	include: true},
			"human_man":				{implemented: false,	name: "Human Man Voice",			src: "/assets/a37dcd6272ae41cf49295d58c9806fe3.mp3",	mute: true,		focus: null,	include: true},
			"robot_man":				{implemented: false,	name: "Robot Man Voice",			src: "/assets/66598bea6e59eb8acdf32cf2d9d75ba9.mp3",	mute: true,		focus: null,	include: true},
			"discodo":					{implemented: false,	name: "Discodo Launch",				src: "/assets/ae7d16bb2eea76b9b9977db0fad66658.mp3",	mute: true,		focus: null,	include: true},
			"overlayunlock":			{implemented: false,	name: "Overlay Unlocked",			src: "/assets/ad322ffe0a88436296158a80d5d11baa.mp3",	mute: true,		focus: null,	include: true}
		};

		/* NEVER CHANGE THE SRC LINKS IN THE PLUGIN FILE, TO ADD NEW SOUNDS ADD THEM IN THE SETTINGS GUI IN THE PLUGINS PAGE */
		const defaultAudios = {
			"---": {
				"---":						null
			},
			"Discord": {}
		};
		
		for (let id in types) if (types[id].include) defaultAudios.Discord[types[id].name] = types[id].src;
		
		const WebAudioSound = class WebAudioSound {
			constructor (type) {
				this._name = type;
				this._src = audios[choices[type].category][choices[type].sound] || types[type].src;
				this._volume = choices[type].volume;
			}
			loop () {
				this._ensureAudio().then(audio => {
					audio.loop = true;
					audio.play();
				});
			}
			play () {
				this._ensureAudio().then(audio => {
					audio.loop = false;
					audio.play();
				});
			}
			pause () {
				this._audio.then(audio => {
					audio.pause();
				});
			}
			stop () {
				this._destroyAudio();
			}
			setTime (time) {
				this._audio.then(audio => {
					audio.currentTime = time;
				});
			}
			setLoop (loop) {
				this._audio.then(audio => {
					audio.loop = loop;
				});
			}
			_destroyAudio () {
				if (this._audio) {
					this._audio.then(audio => {
						audio.pause();
						audio.src = "";
					});
					this._audio = null;
				}
			}
			_ensureAudio () {
				return this._audio = this._audio || new Promise((callback, errorCallback) => {
					let audio = new Audio;
					audio.src = this._src && this._src.startsWith("data") ? this._src.replace(/ /g, "") : this._src;
					audio.onloadeddata = _ => {
						audio.volume = Math.min((BDFDB.LibraryModules.MediaDeviceUtils.getOutputVolume() / 100) * (this._volume / 100) * (volumes.globalVolume / 100), 1);
						BDFDB.LibraryModules.PlatformUtils.embedded && audio.setSinkId(currentDevice || defaultDevice);
						callback(audio);
					};
					audio.onerror = _ => {
						return errorCallback(new Error("could not play audio"))
					};
					audio.onended = _ => {
						return this._destroyAudio()
					};
					audio.load();
				}), this._audio;
			}
		};
	
		return class NotificationSounds extends Plugin {
			onLoad () {
				audios = {};
				choices = {};
				firedEvents = {};
				
				this.defaults = {
					volumes: {
						globalVolume:				{value: 100,				description: "Global Notification Sounds Volume"}
					}
				};
				
				this.patchPriority = 9;
			}
			
			onStart () {
				if (BDFDB.LibraryModules.PlatformUtils.embedded) {
					let change = _ => {
						if (window.navigator.mediaDevices && window.navigator.mediaDevices.enumerateDevices) {
							window.navigator.mediaDevices.enumerateDevices().then(enumeratedDevices => {
								let id = BDFDB.LibraryModules.MediaDeviceUtils.getOutputDeviceId();
								let allDevices = BDFDB.LibraryModules.MediaDeviceUtils.getOutputDevices();
								let filteredDevices = enumeratedDevices.filter(d => d.kind == "audiooutput" && d.deviceId != "communications");
								let deviceIndex = BDFDB.LibraryModules.ArrayUtils(allDevices).sortBy(d => d.index).findIndex(d => d.id == id);
								let deviceViaId = allDevices[id];
								let deviceViaIndex = filteredDevices[deviceIndex];
								if (deviceViaId && deviceViaIndex && deviceViaIndex.label != deviceViaId.name) deviceViaIndex = filteredDevices.find(d => d.label == deviceViaId.name);
								currentDevice = deviceViaIndex ? deviceViaIndex.deviceId : defaultDevice;
							}).catch(_ => {
								currentDevice = defaultDevice;
							});
						}
					};
					BDFDB.StoreChangeUtils.add(this, BDFDB.LibraryModules.MediaDeviceUtils, change);
					change();
				}
				
				BDFDB.PatchUtils.patch(this, BDFDB.LibraryModules.DispatchApiUtils, "dirtyDispatch", {before: e => {
					if (BDFDB.ObjectUtils.is(e.methodArguments[0]) && e.methodArguments[0].type == BDFDB.DiscordConstants.ActionTypes.MESSAGE_CREATE && e.methodArguments[0].message) {
						let message = e.methodArguments[0].message;
						let guildId = message.guild_id || null;
						if (!BDFDB.LibraryModules.MutedUtils.isGuildOrCategoryOrChannelMuted(guildId, message.channel_id) && message.author.id != BDFDB.UserUtils.me.id && !BDFDB.LibraryModules.RelationshipStore.isBlocked(message.author.id)) {
							if (!guildId && !(choices.dm.focus && document.hasFocus() && BDFDB.LibraryModules.LastChannelStore.getChannelId() == message.channel_id)) {
								this.fireEvent("dm");
								this.playAudio("dm");
								return;
							}
							else if (BDFDB.LibraryModules.MentionUtils.isRawMessageMentioned(message, BDFDB.UserUtils.me.id)) {
								if (message.mentions.length && !this.isSuppressMentionEnabled(guildId, message.channel_id) && !(choices.mentioned.focus && document.hasFocus() && BDFDB.LibraryModules.LastChannelStore.getChannelId() == message.channel_id)) for (let mention of message.mentions) if (mention.id == BDFDB.UserUtils.me.id) {
									this.fireEvent("mentioned");
									this.playAudio("mentioned");
									return;
								}
								if (guildId && message.mention_roles.length && !BDFDB.LibraryModules.MutedUtils.isSuppressRolesEnabled(guildId, message.channel_id) && !(choices.role.focus && document.hasFocus() && BDFDB.LibraryModules.LastChannelStore.getChannelId() == message.channel_id)) {
									let member = BDFDB.LibraryModules.MemberStore.getMember(guildId, BDFDB.UserUtils.me.id);
									if (member && member.roles.length) for (let roleId of message.mention_roles) if (member.roles.includes(roleId)) {
										this.fireEvent("role");
										this.playAudio("role");
										return;
									}
								}
								if (message.mention_everyone && !BDFDB.LibraryModules.MutedUtils.isSuppressEveryoneEnabled(guildId, message.channel_id)) {
									if (message.content.indexOf("@everyone") > -1 && !(choices.everyone.focus && document.hasFocus() && BDFDB.LibraryModules.LastChannelStore.getChannelId() == message.channel_id)) {
										this.fireEvent("everyone");
										this.playAudio("everyone");
										return;
									}
									if (message.content.indexOf("@here") > -1 && !(choices.here.focus && document.hasFocus() && BDFDB.LibraryModules.LastChannelStore.getChannelId() == message.channel_id)) {
										this.fireEvent("here");
										this.playAudio("here");
										return;
									}
								}
							}
						}
					}
				}});

				BDFDB.PatchUtils.patch(this, BDFDB.LibraryModules.SoundUtils, "playSound", {instead: e => {
					let type = e.methodArguments[0];
					if (!type) return;
					else if (choices[type]) {
						e.stopOriginalMethodCall();
						BDFDB.TimeUtils.timeout(_ => {
							if (type == "message1") {
								if (firedEvents["dm"]) firedEvents["dm"] = false;
								else if (firedEvents["mentioned"]) firedEvents["mentioned"] = false;
								else if (firedEvents["role"]) firedEvents["role"] = false;
								else if (firedEvents["everyone"]) firedEvents["everyone"] = false;
								else if (firedEvents["here"]) firedEvents["here"] = false;
								else this.playAudio(type);
							}
							else this.playAudio(type);
						});
					}
					else e.callOriginalMethodAfterwards();
				}});
				BDFDB.PatchUtils.patch(this, BDFDB.LibraryModules.SoundUtils, "createSound", {after: e => {
					if (choices[e.methodArguments[0]]) {
						let audio = new WebAudioSound(e.methodArguments[0]);
						createdAudios[e.methodArguments[0]] = audio;
						return audio;
					}
					else BDFDB.LogUtils.warn(`Could not create Sound for "${e.methodArguments[0]}".`, this);
				}});
				
				
				for (let key in defaultAudios) defaultAudios[key] = BDFDB.ObjectUtils.sort(defaultAudios[key]);

				this.loadAudios();
				this.loadChoices();
				
				let callListenerModule = BDFDB.ModuleUtils.findByProperties("handleRingUpdate");
				if (callListenerModule) {
					callListenerModule.terminate();
					BDFDB.PatchUtils.patch(this, callListenerModule, "handleRingUpdate", {instead: e => {
						if (BDFDB.LibraryModules.CallUtils.getCalls().filter(call => call.ringing.length > 0 && BDFDB.LibraryModules.VoiceUtils.getCurrentClientVoiceChannelId() === call.channelId).length > 0 && !BDFDB.LibraryModules.SoundStateUtils.isSoundDisabled("call_calling") && !BDFDB.LibraryModules.StreamerModeStore.disableSounds) {
							createdAudios["call_calling"].loop();
						}
						else createdAudios["call_calling"].stop();
					}});
					callListenerModule.initialize();
				}
				
				this.forceUpdateAll();
			}
			
			onStop () {
				for (let type in createdAudios) if (createdAudios[type]) createdAudios[type].stop();
			}

			getSettingsPanel (collapseStates = {}) {				
				let createSoundCard = type => {
					return [
						BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
							className: BDFDB.disCN.marginbottom8,
							align: BDFDB.LibraryComponents.Flex.Align.CENTER,
							direction: BDFDB.LibraryComponents.Flex.Direction.HORIZONTAL,
							children: [
								BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsLabel, {
									label: types[type].name
								}),
								types[type].focus != null ? BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsItem, {
									type: "Switch",
									mini: true,
									grow: 0,
									label: "Mute when Channel focused:",
									value: choices[type].focus,
									onChange: value => {
										choices[type].focus = value;
										this.saveChoice(type, false);
									}
								}) : null,
								types[type].mute !== null && BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsItem, {
									type: "Switch",
									mini: true,
									grow: 0,
									label: "Mute in DnD:",
									value: choices[type].mute,
									onChange: value => {
										choices[type].mute = value;
										this.saveChoice(type, false);
									}
								})
							].filter(n => n)
						}),
						BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
							className: BDFDB.disCN.marginbottom8,
							children: [
								BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex.Child, {
									grow: 0,
									shrink: 0,
									basis: "31%",
									children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.FormComponents.FormItem, {
										title: "Category",
										children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Select, {
											value: choices[type].category,
											options: Object.keys(audios).map(name => ({value: name, label: name})),
											searchable: true,
											onChange: value => {
												choices[type].category = value;
												choices[type].sound = Object.keys(audios[value] || {})[0];
												this.saveChoice(type, true);
												BDFDB.PluginUtils.refreshSettingsPanel(this, settingsPanel, collapseStates);
											}
										})
									})
								}),
								BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex.Child, {
									grow: 0,
									shrink: 0,
									basis: "31%",
									children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.FormComponents.FormItem, {
										title: "Sound",
										children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Select, {
											value: choices[type].sound,
											options: Object.keys(audios[choices[type].category] || {}).map(name => ({value: name, label: name})),
											searchable: true,
											onChange: value => {
												choices[type].sound = value;
												this.saveChoice(type, true);
												BDFDB.PluginUtils.refreshSettingsPanel(this, settingsPanel, collapseStates);
											}
										})
									})
								}),
								BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex.Child, {
									grow: 0,
									shrink: 0,
									basis: "31%",
									children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.FormComponents.FormItem, {
										title: "Volume",
										children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Slider, {
											defaultValue: choices[type].volume,
											digits: 1,
											onValueRender: value => {
												return value + "%";
											},
											onValueChange: value => {
												choices[type].volume = value;
												this.saveChoice(type, true);
											}
										})
									})
								})
							]
						}),
						BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.FormComponents.FormDivider, {
							className: BDFDB.disCN.marginbottom8
						})
					];
				};

				let successSavedAudio = data => {
					BDFDB.NotificationUtils.toast(`Sound ${data.sound} was added to category ${data.category}.`, {type: "success"});
					if (!audios[data.category]) audios[data.category] = {};
					audios[data.category][data.sound] = data.source;
					BDFDB.DataUtils.save(audios, this, "audios");
					BDFDB.PluginUtils.refreshSettingsPanel(this, settingsPanel, collapseStates);
					
				};
				
				let settingsPanel;
				return settingsPanel = BDFDB.PluginUtils.createSettingsPanel(this, {
					collapseStates: collapseStates,
					children: _ => {
						let settingsItems = [];
						
						settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.CollapseContainer, {
							title: "Settings",
							collapseStates: collapseStates,
							children: Object.keys(volumes).map(key => BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsSaveItem, {
								type: "Slider",
								plugin: this,
								keys: ["volumes", key],
								basis: "50%",
								label: this.defaults.volumes[key].description,
								value: volumes[key]
							}))
						}));
					
						settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.CollapseContainer, {
							title: "Add new Sound",
							collapseStates: collapseStates,
							children: [
								BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
									className: BDFDB.disCN.margintop4,
									children: [
										BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex.Child, {
											children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.FormComponents.FormItem, {
												title: "Categoryname",
												children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TextInput, {
													className: "input-newsound input-category",
													value: "",
													placeholder: "Categoryname"
												})
											})
										}),
										BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex.Child, {
											children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.FormComponents.FormItem, {
												title: "Soundname",
												children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TextInput, {
													className: "input-newsound input-sound",
													value: "",
													placeholder: "Soundname"
												})
											})
										})
									]
								}),
								BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
									className: BDFDB.disCN.margintop4,
									align: BDFDB.LibraryComponents.Flex.Align.END,
									children: [
										BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex.Child, {
											children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.FormComponents.FormItem, {
												title: "Source",
												children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TextInput, {
													className: "input-newsound input-source",
													type: "file",
													filter: ["audio", "video"],
													useFilePath: true,
													value: "",
													placeholder: "Source"
												})
											})
										}),
										BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Button, {
											style: {marginBottom: 1},
											onClick: _ => {
												for (let input of settingsPanel.props._node.querySelectorAll(".input-newsound " + BDFDB.dotCN.input)) if (!input.value || input.value.length == 0 || input.value.trim().length == 0) return BDFDB.NotificationUtils.toast("Fill out all fields to add a new sound", {type: "danger"});
												let category = settingsPanel.props._node.querySelector(".input-category " + BDFDB.dotCN.input).value.trim();
												let sound = settingsPanel.props._node.querySelector(".input-sound " + BDFDB.dotCN.input).value.trim();
												let source = settingsPanel.props._node.querySelector(".input-source " + BDFDB.dotCN.input).value.trim();
												if (source.indexOf("http") == 0) BDFDB.LibraryRequires.request(source, (error, response, result) => {
													if (response) {
														let type = response.headers["content-type"];
														if (type && (type.indexOf("octet-stream") > -1 || type.indexOf("audio") > -1 || type.indexOf("video") > -1)) return successSavedAudio({category, sound, source});
													}
													BDFDB.NotificationUtils.toast("Use a valid direct link to a video or audio source, they usually end on something like .mp3, .mp4 or .wav", {type: "danger"});
												});
												else BDFDB.LibraryRequires.fs.readFile(source, (error, response) => {
													if (error) BDFDB.NotificationUtils.toast("Could not fetch file. Please make sure the file exists", {type: "danger"});
													else return successSavedAudio({category, sound, source: `data:audio/mpeg;base64,${response.toString("base64")}`});
												});
											},
											children: BDFDB.LanguageUtils.LanguageStrings.SAVE
										})
									]
								})
							]
						}));
						
						settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.CollapseContainer, {
							title: "Sound Configuration",
							collapseStates: collapseStates,
							children: Object.keys(BDFDB.ObjectUtils.filter(types, typeData => typeData.implemented)).map(type => createSoundCard(type)).flat(10).filter(n => n)
						}));
						
						let removeableCategories = [{value: removeAllKey, label: BDFDB.LanguageUtils.LanguageStrings.FORM_LABEL_ALL}].concat(Object.keys(audios).filter(category => !(defaultAudios[category] && !Object.keys(audios[category] || {}).filter(sound => defaultAudios[category][sound] === undefined).length)).map(name => ({value: name, label: name})));
						let removeableSounds = {};
						for (let category of removeableCategories) removeableSounds[category.value] = [{value: removeAllKey, label: BDFDB.LanguageUtils.LanguageStrings.FORM_LABEL_ALL}].concat(Object.keys(audios[category.value] || {}).filter(sound => !(defaultAudios[category.value] && defaultAudios[category.value][sound] !== undefined)).map(name => ({value: name, label: name})));
						settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.CollapseContainer, {
							title: "Remove Sounds",
							collapseStates: collapseStates,
							children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
								className: BDFDB.disCN.margintop4,
								align: BDFDB.LibraryComponents.Flex.Align.END,
								children: [
									BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex.Child, {
										grow: 0,
										shrink: 0,
										basis: "35%",
										children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.FormComponents.FormItem, {
											title: "Category",
											children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Select, {
												key: "REMOVE_CATEGORY",
												value: removeAllKey,
												options: removeableCategories,
												searchable: true,
												onChange: (category, instance) => {
													let soundSelectIns = BDFDB.ReactUtils.findOwner(BDFDB.ReactUtils.findOwner(instance, {name: ["BDFDB_Modal", "BDFDB_SettingsPanel"], up: true}), {key: "REMOVE_SOUND"});
													if (soundSelectIns && removeableSounds[category.value]) {
														soundSelectIns.props.options = removeableSounds[category.value];
														soundSelectIns.props.value = removeAllKey;
														BDFDB.ReactUtils.forceUpdate(soundSelectIns);
													}
												}
											})
										})
									}),
									BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex.Child, {
										grow: 0,
										shrink: 0,
										basis: "35%",
										children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.FormComponents.FormItem, {
											title: "Sound",
											children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Select, {
												key: "REMOVE_SOUND",
												value: removeAllKey,
												options: removeableSounds[removeAllKey],
												searchable: true
											})
										})
									}),
									BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex.Child, {
										grow: 0,
										shrink: 1,
										basis: "25%",
										children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Button, {
											style: {marginBottom: 1},
											color: BDFDB.LibraryComponents.Button.Colors.RED,
											onClick: (event, instance) => {
												let wrapperIns = BDFDB.ReactUtils.findOwner(instance, {name: ["BDFDB_Modal", "BDFDB_SettingsPanel"], up: true});
												let categorySelectIns = BDFDB.ReactUtils.findOwner(wrapperIns, {key: "REMOVE_CATEGORY"});
												let soundSelectIns = BDFDB.ReactUtils.findOwner(wrapperIns, {key: "REMOVE_SOUND"});
												if (categorySelectIns && soundSelectIns) {
													let soundAmount = 0;
													let catAll = categorySelectIns.props.value == removeAllKey;
													let soundAll = soundSelectIns.props.value == removeAllKey;
													if (catAll) soundAmount = BDFDB.ArrayUtils.sum(Object.keys(audios).map(category => Object.keys(audios[category] || {}).filter(sound => !(defaultAudios[category] && defaultAudios[category][sound] !== undefined)).length));
													else if (soundAll) soundAmount = Object.keys(audios[categorySelectIns.props.value] || {}).filter(sound => !(defaultAudios[categorySelectIns.props.value] && defaultAudios[categorySelectIns.props.value][sound] !== undefined)).length;
													else if (audios[categorySelectIns.props.value][soundSelectIns.props.value]) soundAmount = 1;
													
													if (soundAmount) BDFDB.ModalUtils.confirm(this, `Are you sure you want to delete ${soundAmount} added Sound${soundAmount == 1 ? "" : "s"}?`, _ => {
														if (catAll) BDFDB.DataUtils.remove(this, "audios");
														else if (soundAll) BDFDB.DataUtils.remove(this, "audios", categorySelectIns.props.value);
														else {
															delete audios[categorySelectIns.props.value][soundSelectIns.props.value];
															if (BDFDB.ObjectUtils.isEmpty(audios[categorySelectIns.props.value])) delete audios[categorySelectIns.props.value];
															BDFDB.DataUtils.save(audios, this, "audios");
														}
														this.loadAudios();
														this.loadChoices();
														BDFDB.PluginUtils.refreshSettingsPanel(this, settingsPanel, collapseStates);
													});
													else BDFDB.NotificationUtils.toast("No Sounds to delete", {type: "danger"});
												}
											},
											children: BDFDB.LanguageUtils.LanguageStrings.DELETE
										})
									})
								]
							})
						}));
						
						return settingsItems;
					}
				});
			}

			onSettingsClosed () {
				if (this.SettingsUpdated) {
					delete this.SettingsUpdated;
					for (let type in createdAudios) if (createdAudios[type]) createdAudios[type].stop();
					createdAudios = {};
					this.forceUpdateAll();
				}
			}
		
			forceUpdateAll () {
				repatchIncoming = true;
				createdAudios["call_calling"] = BDFDB.LibraryModules.SoundUtils.createSound("call_calling");
				volumes = BDFDB.DataUtils.get(this, "volumes");
				BDFDB.PatchUtils.forceAllUpdates(this);
				BDFDB.DiscordUtils.rerenderAll();
			}
			
			loadAudios () {
				audios = Object.assign({}, BDFDB.DataUtils.load(this, "audios"), defaultAudios);
				BDFDB.DataUtils.save(BDFDB.ObjectUtils.exclude(audios, Object.keys(defaultAudios)), this, "audios");
			}

			loadChoices () {
				let loadedChoices = BDFDB.DataUtils.load(this, "choices");
				for (let type in types) {
					let choice = loadedChoices[type] || {}, soundFound = false;
					for (let category in audios) if (choice.category == category) for (let sound in audios[category]) if (choice.sound == sound) {
						soundFound = true;
						break;
					}
					if (!soundFound) choice = {
						category: "---",
						sound: "---",
						volume: 100,
						mute: types[type].mute,
						focus: types[type].focus
					};
					choices[type] = choice;
					this.saveChoice(type, false);
				}
			}

			saveChoice (type, play) {
				if (!choices[type]) return;
				BDFDB.DataUtils.save(choices[type], this, "choices", type);
				if (play) {
					this.SettingsUpdated = true;
					this.playAudio(type);
				}
			}

			playAudio (type) {
				if (this.dontPlayAudio(type) || BDFDB.LibraryModules.StreamerModeStore.disableSounds) return;
				if (createdAudios[type]) createdAudios[type].stop();
				createdAudios[type] = new WebAudioSound(type);
				createdAudios[type].play();
			}

			isSuppressMentionEnabled (guildId, channelId) {
				let channelSettings = BDFDB.LibraryModules.MutedUtils.getChannelMessageNotifications(guildId, channelId);
				return channelSettings && (channelSettings == BDFDB.DiscordConstants.UserNotificationSettings.NO_MESSAGES || channelSettings == BDFDB.DiscordConstants.UserNotificationSettings.NULL && BDFDB.LibraryModules.MutedUtils.getMessageNotifications(guildId) == BDFDB.DiscordConstants.UserNotificationSettings.NO_MESSAGES);
			}

			dontPlayAudio (type) {
				let status = BDFDB.UserUtils.getStatus();
				return choices[type].mute && (status == "dnd" || status == "streaming");
			}

			fireEvent (type) {
				firedEvents[type] = true;
				BDFDB.TimeUtils.timeout(_ => {firedEvents[type] = false;},3000);
			}
		};
	})(window.BDFDB_Global.PluginUtils.buildPlugin(config));
})();
{
	"choices": {
		"message1": {
			"category": "---",
			"focus": null,
			"mute": true,
			"sound": "---",
			"volume": 100
		},
		"dm": {
			"category": "---",
			"focus": true,
			"mute": true,
			"sound": "---",
			"volume": 100
		},
		"mentioned": {
			"category": "---",
			"focus": true,
			"mute": true,
			"sound": "---",
			"volume": 100
		},
		"role": {
			"category": "---",
			"focus": true,
			"mute": true,
			"sound": "---",
			"volume": 100
		},
		"everyone": {
			"category": "---",
			"focus": true,
			"mute": true,
			"sound": "---",
			"volume": 100
		},
		"here": {
			"category": "---",
			"focus": true,
			"mute": true,
			"sound": "---",
			"volume": 100
		},
		"deafen": {
			"category": "---",
			"focus": null,
			"mute": false,
			"sound": "---",
			"volume": 100
		},
		"mute": {
			"category": "---",
			"focus": null,
			"mute": false,
			"sound": "---",
			"volume": 100
		},
		"disconnect": {
			"category": "---",
			"focus": null,
			"mute": false,
			"sound": "---",
			"volume": 100
		},
		"undeafen": {
			"category": "---",
			"focus": null,
			"mute": false,
			"sound": "---",
			"volume": 100
		},
		"unmute": {
			"category": "---",
			"focus": null,
			"mute": false,
			"sound": "---",
			"volume": 100
		},
		"user_join": {
			"category": "---",
			"focus": null,
			"mute": false,
			"sound": "---",
			"volume": 100
		},
		"user_leave": {
			"category": "---",
			"focus": null,
			"mute": false,
			"sound": "---",
			"volume": 100
		},
		"user_moved": {
			"category": "---",
			"focus": null,
			"mute": false,
			"sound": "---",
			"volume": 100
		},
		"reconnect": {
			"category": "---",
			"focus": null,
			"mute": true,
			"sound": "---",
			"volume": 100
		},
		"ptt_start": {
			"category": "---",
			"focus": null,
			"mute": false,
			"sound": "---",
			"volume": 100
		},
		"ptt_stop": {
			"category": "---",
			"focus": null,
			"mute": false,
			"sound": "---",
			"volume": 100
		},
		"call_calling": {
			"category": "---",
			"focus": null,
			"mute": null,
			"sound": "---",
			"volume": 100
		},
		"call_ringing": {
			"category": "---",
			"focus": null,
			"mute": null,
			"sound": "---",
			"volume": 100
		},
		"call_ringing_beat": {
			"category": "---",
			"focus": null,
			"mute": null,
			"sound": "---",
			"volume": 100
		},
		"call_ringing_halloween": {
			"category": "---",
			"focus": null,
			"mute": null,
			"sound": "---",
			"volume": 100
		},
		"stream_started": {
			"category": "---",
			"focus": null,
			"mute": false,
			"sound": "---",
			"volume": 100
		},
		"stream_ended": {
			"category": "---",
			"focus": null,
			"mute": false,
			"sound": "---",
			"volume": 100
		},
		"stream_user_joined": {
			"category": "---",
			"focus": null,
			"mute": false,
			"sound": "---",
			"volume": 100
		},
		"stream_user_left": {
			"category": "---",
			"focus": null,
			"mute": false,
			"sound": "---",
			"volume": 100
		},
		"ddr-down": {
			"category": "---",
			"focus": null,
			"mute": false,
			"sound": "---",
			"volume": 100
		},
		"ddr-left": {
			"category": "---",
			"focus": null,
			"mute": false,
			"sound": "---",
			"volume": 100
		},
		"ddr-right": {
			"category": "---",
			"focus": null,
			"mute": false,
			"sound": "---",
			"volume": 100
		},
		"ddr-up": {
			"category": "---",
			"focus": null,
			"mute": false,
			"sound": "---",
			"volume": 100
		},
		"mention1": {
			"category": "---",
			"focus": null,
			"mute": true,
			"sound": "---",
			"volume": 100
		},
		"mention2": {
			"category": "---",
			"focus": null,
			"mute": true,
			"sound": "---",
			"volume": 100
		},
		"mention3": {
			"category": "---",
			"focus": null,
			"mute": true,
			"sound": "---",
			"volume": 100
		},
		"message2": {
			"category": "---",
			"focus": null,
			"mute": true,
			"sound": "---",
			"volume": 100
		},
		"message3": {
			"category": "---",
			"focus": null,
			"mute": true,
			"sound": "---",
			"volume": 100
		},
		"human_man": {
			"category": "---",
			"focus": null,
			"mute": true,
			"sound": "---",
			"volume": 100
		},
		"robot_man": {
			"category": "---",
			"focus": null,
			"mute": true,
			"sound": "---",
			"volume": 100
		},
		"discodo": {
			"category": "---",
			"focus": null,
			"mute": true,
			"sound": "---",
			"volume": 100
		},
		"overlayunlock": {
			"category": "---",
			"focus": null,
			"mute": true,
			"sound": "---",
			"volume": 100
		}
	},
	"volumes": {
		"globalVolume": 100
	}
}
/**
 * @name JoinedAtDate
 * @author DevilBro
 * @authorId 278543574059057154
 * @version 1.2.8
 * @description Displays the Joined At Date of a Member in the UserPopout and UserModal
 * @invite Jx3TjNS
 * @donate https://www.paypal.me/MircoWittrien
 * @patreon https://www.patreon.com/MircoWittrien
 * @website https://mwittrien.github.io/
 * @source https://github.com/mwittrien/BetterDiscordAddons/tree/master/Plugins/JoinedAtDate/
 * @updateUrl https://mwittrien.github.io/BetterDiscordAddons/Plugins/JoinedAtDate/JoinedAtDate.plugin.js
 */

module.exports = (_ => {
	const config = {
		"info": {
			"name": "JoinedAtDate",
			"author": "DevilBro",
			"version": "1.2.8",
			"description": "Displays the Joined At Date of a Member in the UserPopout and UserModal"
		},
		"changeLog": {
			"improved": {
				"New User Popout": "Fixed for the new User Popout, which will be released soon-ish"
			}
		}
	};

	return !window.BDFDB_Global || (!window.BDFDB_Global.loaded && !window.BDFDB_Global.started) ? class {
		getName () {return config.info.name;}
		getAuthor () {return config.info.author;}
		getVersion () {return config.info.version;}
		getDescription () {return `The Library Plugin needed for ${config.info.name} is missing. Open the Plugin Settings to download it. \n\n${config.info.description}`;}
		
		downloadLibrary () {
			require("request").get("https://mwittrien.github.io/BetterDiscordAddons/Library/0BDFDB.plugin.js", (e, r, b) => {
				if (!e && b && r.statusCode == 200) require("fs").writeFile(require("path").join(BdApi.Plugins.folder, "0BDFDB.plugin.js"), b, _ => BdApi.showToast("Finished downloading BDFDB Library", {type: "success"}));
				else BdApi.alert("Error", "Could not download BDFDB Library Plugin. Try again later or download it manually from GitHub: https://mwittrien.github.io/downloader/?library");
			});
		}
		
		load () {
			if (!window.BDFDB_Global || !Array.isArray(window.BDFDB_Global.pluginQueue)) window.BDFDB_Global = Object.assign({}, window.BDFDB_Global, {pluginQueue: []});
			if (!window.BDFDB_Global.downloadModal) {
				window.BDFDB_Global.downloadModal = true;
				BdApi.showConfirmationModal("Library Missing", `The Library Plugin needed for ${config.info.name} is missing. Please click "Download Now" to install it.`, {
					confirmText: "Download Now",
					cancelText: "Cancel",
					onCancel: _ => {delete window.BDFDB_Global.downloadModal;},
					onConfirm: _ => {
						delete window.BDFDB_Global.downloadModal;
						this.downloadLibrary();
					}
				});
			}
			if (!window.BDFDB_Global.pluginQueue.includes(config.info.name)) window.BDFDB_Global.pluginQueue.push(config.info.name);
		}
		start () {this.load();}
		stop () {}
		getSettingsPanel () {
			let template = document.createElement("template");
			template.innerHTML = `<div style="color: var(--header-primary); font-size: 16px; font-weight: 300; white-space: pre; line-height: 22px;">The Library Plugin needed for ${config.info.name} is missing.\nPlease click <a style="font-weight: 500;">Download Now</a> to install it.</div>`;
			template.content.firstElementChild.querySelector("a").addEventListener("click", this.downloadLibrary);
			return template.content.firstElementChild;
		}
	} : (([Plugin, BDFDB]) => {
		var loadedUsers, requestedUsers;
		var currentPopout;
		
		return class JoinedAtDate extends Plugin {
			onLoad () {
				loadedUsers = {};
				requestedUsers = {};

				this.defaults = {
					general: {
						displayText:			{value: true, 			description: "Display '{{presuffix}}' in the Date"}
					},
					places: {
						userPopout:				{value: true, 			description: "User Popouts"},
						userProfile:			{value: true, 			description: "User Profile Modal"}
					},
					dates: {
						joinedAtDate:			{value: {}, 			description: "Joined at Date"},
					}
				};
				
				this.patchedModules = {
					after: {
						UserPopout: "render",
						UserPopoutHeader: "default",
						AnalyticsContext: "render"
					}
				};
			}
			
			onStart () {
				BDFDB.PatchUtils.forceAllUpdates(this);
			}
			
			onStop () {
				BDFDB.PatchUtils.forceAllUpdates(this);
			}

			getSettingsPanel (collapseStates = {}) {
				let settingsPanel;
				return settingsPanel = BDFDB.PluginUtils.createSettingsPanel(this, {
					collapseStates: collapseStates,
					children: _ => {
						let settingsItems = [];
						
						settingsItems.push(Object.keys(this.defaults.general).map(key => BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsSaveItem, {
							type: "Switch",
							plugin: this,
							keys: ["general", key],
							label: key == "displayText" ? this.defaults.general[key].description.replace("{{presuffix}}", this.labels.joined_at.replace("{{time}}", "").trim()) : this.defaults.general[key].description,
							value: this.settings.general[key]
						})));
						
						settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.FormComponents.FormDivider, {
							className: BDFDB.disCN.marginbottom8
						}));
						
						settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsPanelList, {
							title: "Add Date in:",
							children: Object.keys(this.defaults.places).map(key => BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsSaveItem, {
								type: "Switch",
								plugin: this,
								keys: ["places", key],
								label: this.defaults.places[key].description,
								value: this.settings.places[key]
							}))
						}));
						
						settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.FormComponents.FormDivider, {
							className: BDFDB.disCN.marginbottom8
						}));
						
						settingsItems.push(Object.keys(this.defaults.dates).map(key => BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.DateInput, Object.assign({}, this.settings.dates[key], {
							label: this.defaults.dates[key].description,
							prefix: _ => (this.settings.general.displayText && this.labels.joined_at.split("{{time}}")[0] || "").trim(),
							suffix: _ => (this.settings.general.displayText && this.labels.joined_at.split("{{time}}")[1] || "").trim(),
							onChange: valueObj => {
								this.SettingsUpdated = true;
								this.settings.dates[key] = valueObj;
								BDFDB.DataUtils.save(this.settings.dates, this, "dates");
							}
						}))));
						
						return settingsItems.flat(10);
					}
				});
			}

			onSettingsClosed () {
				if (this.SettingsUpdated) {
					delete this.SettingsUpdated;
					BDFDB.PatchUtils.forceAllUpdates(this);
				}
			}

			processUserPopout (e) {
				currentPopout = e.instance;
			}

			processUserPopoutHeader (e) {
				if (e.instance.props.user && this.settings.places.userPopout) {
					let [children, index] = BDFDB.ReactUtils.findParent(e.returnvalue, {name: "CustomStatus"});
					if (index > -1) this.injectDate(currentPopout, children, 2, e.instance.props.user, e.instance.props.guildId);
				}
			}

			processAnalyticsContext (e) {
				if (typeof e.returnvalue.props.children == "function" && e.instance.props.section == BDFDB.DiscordConstants.AnalyticsSections.PROFILE_MODAL && this.settings.places.userProfile) {
					let renderChildren = e.returnvalue.props.children;
					e.returnvalue.props.children = (...args) => {
						let renderedChildren = renderChildren(...args);
						let [children, index] = BDFDB.ReactUtils.findParent(renderedChildren, {name: ["DiscordTag", "ColoredFluxTag"]});
						if (index > -1) this.injectDate(e.instance, children, 1, children[index].props.user, BDFDB.ReactUtils.findValue(e.instance, "guildId", {up: true}));
						return renderedChildren;
					};
				}
			}

			injectDate (instance, children, index, user, guildId) {
				if (!guildId) guildId = BDFDB.LibraryModules.LastGuildStore.getGuildId();
				if (!BDFDB.ArrayUtils.is(children) || !user || !guildId || user.discriminator == "0000" || !BDFDB.LibraryModules.MemberStore.getMember(guildId, user.id)) return;
				if (!loadedUsers[guildId]) loadedUsers[guildId] = {};
				if (!requestedUsers[guildId]) requestedUsers[guildId] = {};
				if (!BDFDB.ArrayUtils.is(requestedUsers[guildId][user.id])) {
					requestedUsers[guildId][user.id] = [instance];
					BDFDB.LibraryModules.APIUtils.get(BDFDB.DiscordConstants.Endpoints.GUILD_MEMBER(guildId, user.id)).then(result => {
						loadedUsers[guildId][user.id] = new Date(result.body.joined_at);
						for (let queuedInstance of requestedUsers[guildId][user.id]) BDFDB.ReactUtils.forceUpdate(queuedInstance);
					});
				}
				else if (!loadedUsers[guildId][user.id]) requestedUsers[guildId][user.id].push(instance);
				else {
					let timestamp = BDFDB.LibraryComponents.DateInput.format(this.settings.dates.joinedAtDate, loadedUsers[guildId][user.id]);
					children.splice(index, 0, BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TextScroller, {
						className: BDFDB.disCNS._joinedatdatedate + BDFDB.disCNS.userinfodate + BDFDB.disCN.textrow,
						children: this.settings.general.displayText ? this.labels.joined_at.replace("{{time}}", timestamp) : timestamp
					}));
				}
			}

			setLabelsByLanguage () {
				switch (BDFDB.LanguageUtils.getLanguage().id) {
					case "bg":		// Bulgarian
						return {
							joined_at:							"ÐŸÑ€Ð¸ÑÑŠÐµÐ´Ð¸Ð½Ð¸Ð» ÑÐµ Ð½Ð° {{time}}"
						};
					case "da":		// Danish
						return {
							joined_at:							"Deltog den {{time}}"
						};
					case "de":		// German
						return {
							joined_at:							"Beitritt am {{time}}"
						};
					case "el":		// Greek
						return {
							joined_at:							"ÎˆÎ³Î¹Î½Îµ Î¼Î­Î»Î¿Ï‚ ÏƒÏ„Î¹Ï‚ {{time}}"
						};
					case "es":		// Spanish
						return {
							joined_at:							"Se uniÃ³ el {{time}}"
						};
					case "fi":		// Finnish
						return {
							joined_at:							"Liittyi {{time}}"
						};
					case "fr":		// French
						return {
							joined_at:							"Rejoint le {{time}}"
						};
					case "hr":		// Croatian
						return {
							joined_at:							"PridruÅ¾io se {{time}}"
						};
					case "hu":		// Hungarian
						return {
							joined_at:							"Csatlakozott: {{time}}"
						};
					case "it":		// Italian
						return {
							joined_at:							"Iscritto il {{time}}"
						};
					case "ja":		// Japanese
						return {
							joined_at:							"{{time}}ã«å‚åŠ ã—ã¾ã—ãŸ"
						};
					case "ko":		// Korean
						return {
							joined_at:							"{{time}}ì— ê°€ìž…í–ˆìŠµë‹ˆë‹¤."
						};
					case "lt":		// Lithuanian
						return {
							joined_at:							"PrisijungÄ— {{time}}"
						};
					case "nl":		// Dutch
						return {
							joined_at:							"Aangesloten op {{time}}"
						};
					case "no":		// Norwegian
						return {
							joined_at:							"Ble med {{time}}"
						};
					case "pl":		// Polish
						return {
							joined_at:							"DoÅ‚Ä…czono {{time}}"
						};
					case "pt-BR":	// Portuguese (Brazil)
						return {
							joined_at:							"Entrou em {{time}}"
						};
					case "ro":		// Romanian
						return {
							joined_at:							"S-a Ã®nscris pe {{time}}"
						};
					case "ru":		// Russian
						return {
							joined_at:							"ÐŸÑ€Ð¸ÑÐ¾ÐµÐ´Ð¸Ð½Ð¸Ð»ÑÑ {{time}}"
						};
					case "sv":		// Swedish
						return {
							joined_at:							"Gick med den {{time}}"
						};
					case "th":		// Thai
						return {
							joined_at:							"à¹€à¸‚à¹‰à¸²à¸£à¹ˆà¸§à¸¡à¹€à¸¡à¸·à¹ˆà¸­ {{time}}"
						};
					case "tr":		// Turkish
						return {
							joined_at:							"{{time}} tarihinde katÄ±ldÄ±"
						};
					case "uk":		// Ukrainian
						return {
							joined_at:							"ÐŸÑ€Ð¸Ñ”Ð´Ð½Ð°Ð²ÑÑ {{time}}"
						};
					case "vi":		// Vietnamese
						return {
							joined_at:							"ÄÃ£ tham gia vÃ o {{time}}"
						};
					case "zh-CN":	// Chinese (China)
						return {
							joined_at:							"å·²äºŽ{{time}}åŠ å…¥"
						};
					case "zh-TW":	// Chinese (Taiwan)
						return {
							joined_at:							"å·²æ–¼{{time}}åŠ å…¥"
						};
					default:		// English
						return {
							joined_at:							"Joined on {{time}}"
						};
				}
			}
		};
	})(window.BDFDB_Global.PluginUtils.buildPlugin(config));
})();
{
	"dates": {
		"joinedAtDate": {}
	},
	"general": {
		"displayText": true
	},
	"places": {
		"userPopout": true,
		"userProfile": true
	}
}
/**
 * @name FriendNotifications
 * @author DevilBro
 * @authorId 278543574059057154
 * @version 1.7.2
 * @description Shows a Notification when a Friend or a User, you choose to observe, changes their Status
 * @invite Jx3TjNS
 * @donate https://www.paypal.me/MircoWittrien
 * @patreon https://www.patreon.com/MircoWittrien
 * @website https://mwittrien.github.io/
 * @source https://github.com/mwittrien/BetterDiscordAddons/tree/master/Plugins/FriendNotifications/
 * @updateUrl https://mwittrien.github.io/BetterDiscordAddons/Plugins/FriendNotifications/FriendNotifications.plugin.js
 */

module.exports = (_ => {
	const config = {
		"info": {
			"name": "FriendNotifications",
			"author": "DevilBro",
			"version": "1.7.2",
			"description": "Shows a Notification when a Friend or a User, you choose to observe, changes their Status"
		},
		"changeLog": {
			"improved": {
				"Added some extra Info": "New Info on how to control the Observer List better"
			}
		}
	};

	return !window.BDFDB_Global || (!window.BDFDB_Global.loaded && !window.BDFDB_Global.started) ? class {
		getName () {return config.info.name;}
		getAuthor () {return config.info.author;}
		getVersion () {return config.info.version;}
		getDescription () {return `The Library Plugin needed for ${config.info.name} is missing. Open the Plugin Settings to download it. \n\n${config.info.description}`;}
		
		downloadLibrary () {
			require("request").get("https://mwittrien.github.io/BetterDiscordAddons/Library/0BDFDB.plugin.js", (e, r, b) => {
				if (!e && b && r.statusCode == 200) require("fs").writeFile(require("path").join(BdApi.Plugins.folder, "0BDFDB.plugin.js"), b, _ => BdApi.showToast("Finished downloading BDFDB Library", {type: "success"}));
				else BdApi.alert("Error", "Could not download BDFDB Library Plugin. Try again later or download it manually from GitHub: https://mwittrien.github.io/downloader/?library");
			});
		}
		
		load () {
			if (!window.BDFDB_Global || !Array.isArray(window.BDFDB_Global.pluginQueue)) window.BDFDB_Global = Object.assign({}, window.BDFDB_Global, {pluginQueue: []});
			if (!window.BDFDB_Global.downloadModal) {
				window.BDFDB_Global.downloadModal = true;
				BdApi.showConfirmationModal("Library Missing", `The Library Plugin needed for ${config.info.name} is missing. Please click "Download Now" to install it.`, {
					confirmText: "Download Now",
					cancelText: "Cancel",
					onCancel: _ => {delete window.BDFDB_Global.downloadModal;},
					onConfirm: _ => {
						delete window.BDFDB_Global.downloadModal;
						this.downloadLibrary();
					}
				});
			}
			if (!window.BDFDB_Global.pluginQueue.includes(config.info.name)) window.BDFDB_Global.pluginQueue.push(config.info.name);
		}
		start () {this.load();}
		stop () {}
		getSettingsPanel () {
			let template = document.createElement("template");
			template.innerHTML = `<div style="color: var(--header-primary); font-size: 16px; font-weight: 300; white-space: pre; line-height: 22px;">The Library Plugin needed for ${config.info.name} is missing.\nPlease click <a style="font-weight: 500;">Download Now</a> to install it.</div>`;
			template.content.firstElementChild.querySelector("a").addEventListener("click", this.downloadLibrary);
			return template.content.firstElementChild;
		}
	} : (([Plugin, BDFDB]) => {
		var _this;
		var userStatusStore, timeLog, lastTimes, checkInterval;
		var friendCounter, timeLogList;
		var observedUsers = {};
		var paginationOffset = {};
		
		const statuses = {
			online: {
				value: true,
				name: "STATUS_ONLINE",
				sound: true
			},
			idle: {
				value: false,
				name: "STATUS_IDLE",
				sound: true
			},
			dnd: {
				value: false,
				name: "STATUS_DND",
				sound: true
			},
			playing: {
				value: false,
				checkActivity: true,
				sound: true
			},
			listening: {
				value: false,
				checkActivity: true,
				sound: true
			},
			streaming: {
				value: false,
				checkActivity: true,
				sound: true
			},
			offline: {
				value: true,
				name: "STATUS_OFFLINE",
				sound: true
			},
			mobile: {
				value: false
			},
			custom: {
				value: false
			}
		};
		
		const notificationTypes = {
			DISABLED: {
				button: null,
				value: 0,
				color: ""
			},
			TOAST: {
				button: 0,
				value: 1,
				color: "var(--bdfdb-blurple)"
			},
			DESKTOP: {
				button: 2,
				value: 2,
				color: "var(--bdfdb-green)"
			}
		};
		
		const FriendOnlineCounterComponent = class FriendOnlineCounter extends BdApi.React.Component {
			componentDidMount() {
				friendCounter = this;
			}
			render() {
				return BDFDB.ReactUtils.createElement("div", {
					className: BDFDB.disCNS.guildouter + BDFDB.disCN._friendnotificationsfriendsonlinewrap,
					children: BDFDB.ReactUtils.createElement("div", {
						className: BDFDB.disCNS.guildslabel + BDFDB.disCN._friendnotificationsfriendsonline,
						children: BDFDB.LanguageUtils.LanguageStringsFormat("FRIENDS_ONLINE_HEADER", this.props.amount),
						onClick: _ => _this.showTimeLog()
					})
				});
			}
		};
		
		const TimeLogComponent = class TimeLog extends BdApi.React.Component {
			componentDidMount() {
				timeLogList = this;
			}
			render() {
				return this.props.entries.length ? BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.PaginatedList, {
					items: this.props.entries,
					amount: 50,
					copyToBottom: true,
					renderItem: (log, i) => [
						i > 0 ? BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.FormComponents.FormDivider, {
						className: BDFDB.disCNS.margintop8 + BDFDB.disCN.marginbottom8
						}) : null,
						BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
							align: BDFDB.LibraryComponents.Flex.Align.CENTER,
							children: [
								BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TextElement, {
									className: BDFDB.disCN._friendnotificationslogtime,
									children: BDFDB.LibraryComponents.DateInput.format(_this.settings.dates.logDate, log.timestamp)
								}),
								BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.AvatarComponents.default, {
									className: BDFDB.disCN._friendnotificationslogavatar,
									src: log.avatar,
									size: BDFDB.LibraryComponents.AvatarComponents.Sizes.SIZE_40
								}),
								_this.createStatusDot(log.status, log.mobile, {marginRight: 6}),
								BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN._friendnotificationslogcontent,
									children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TextElement, {
										children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TextScroller, {
											speed: 1,
											children: BDFDB.ReactUtils.elementToReact(BDFDB.DOMUtils.create(log.string))
										})
									})
								})
							]
						})
					]
				}) : BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.MessagesPopoutComponents.EmptyStateBottom, {
					msg: BDFDB.LanguageUtils.LanguageStrings.AUTOCOMPLETE_NO_RESULTS_HEADER,
					image: BDFDB.DiscordUtils.getTheme() == BDFDB.disCN.themelight ? "/assets/9b0d90147f7fab54f00dd193fe7f85cd.svg" : "/assets/308e587f3a68412f137f7317206e92c2.svg"
				});
			}
		};
	
		return class FriendNotifications extends Plugin {
			onLoad () {
				_this = this;
				
				userStatusStore = {};
				timeLog = [];
				lastTimes = {};
				friendCounter = null;

				this.defaults = {
					general: {
						addOnlineCount:		{value: true, 	description: "Add an Online Friend Counter to the Server List (Click to open Time Log)"},
						showDiscriminator:	{value: false, 	description: "Add the User Discriminator"},
						disableForNew:		{value: false, 	description: "Disable Notifications for newly added Friends"},
						muteOnDND:			{value: false, 	description: "Do not notify me when I am in DnD Status"},
						openOnClick:		{value: false, 	description: "Open the DM when you click a Notification"}
					},
					notificationStrings: {
						online: 			{value: "$user changed status to '$status'"},
						idle: 				{value: "$user changed status to '$status'"},
						dnd: 				{value: "$user changed status to '$status'"},
						playing: 			{value: "$user started playing '$game'"},
						listening: 			{value: "$user started listening to '$song'"},
						streaming: 			{value: "$user started streaming '$game'"},
						offline: 			{value: "$user changed status to '$status'"},
						custom: 			{value: "$user changed status to '$custom'"}
					},
					notificationSounds: {},
					dates: {
						logDate:			{value: {}, 				description: "Log Timestamp"},
					},
					amounts: {
						toastTime:			{value: 5, 		min: 1,		description: "Amount of Seconds a Toast Notification stays on Screen: "},
						checkInterval:		{value: 10, 	min: 5,		description: "Check Users every X Seconds: "}
					}
				};
			
				this.patchedModules = {
					after: {
						Guilds: "render"
					}
				};
		
				this.css = `
					${BDFDB.dotCN._friendnotificationslogtime} {
						flex: 0 1 auto;
						min-width: 160px;
					}	
					${BDFDB.dotCN._friendnotificationslogavatar} {
						margin: 0 10px;
					}
					${BDFDB.dotCN._friendnotificationslogcontent} {
						max-width: 600px;
						overflow: hidden;
					}
					${BDFDB.dotCN._friendnotificationstypelabel} {
						border-radius: 3px;
						padding: 0 3px;
						margin: 0 6px;
					}
					${BDFDB.dotCN._friendnotificationsfriendsonline} {
						cursor: pointer;
					}
					${BDFDB.dotCNS._friendnotificationstimelogmodal + BDFDB.dotCN.messagespopoutemptyplaceholder} {
						position: absolute;
						bottom: 0;
						width: 100%;
					}
				`;
				
				for (let type in statuses) if (statuses[type].sound) {
					this.defaults.notificationSounds["toast" + type] = {value: {url: null, song: null, mute: false}};
					this.defaults.notificationSounds["desktop" + type] = {value: {url: null, song: null, mute: false}};
				}
			}
			
			onStart () {
				// REMOVE 24.04.2021
				let oldData = BDFDB.DataUtils.load(this);
				if (oldData.settings) {
					this.settings.general = oldData.settings;
					BDFDB.DataUtils.save(this.settings.general, this, "general");
					BDFDB.DataUtils.remove(this, "settings");
				}
				if (oldData.notificationstrings) {
					this.settings.notificationStrings = oldData.notificationstrings;
					BDFDB.DataUtils.save(this.settings.notificationStrings, this, "notificationStrings");
					BDFDB.DataUtils.remove(this, "notificationstrings");
				}
				if (oldData.notificationsounds) {
					this.settings.notificationSounds = oldData.notificationsounds;
					BDFDB.DataUtils.save(this.settings.notificationSounds, this, "notificationSounds");
					BDFDB.DataUtils.remove(this, "notificationsounds");
				}
				if (!BDFDB.DataUtils.load(this, "observed", BDFDB.UserUtils.me.id)) {
					let observed = {};
					let friendsObserved = BDFDB.DataUtils.load(this, "friends");
					let strangersObserved = BDFDB.DataUtils.load(this, "nonfriends");
					if (!BDFDB.ObjectUtils.isEmpty(friendsObserved)) observed.friends = friendsObserved;
					if (!BDFDB.ObjectUtils.isEmpty(strangersObserved)) observed.strangers = strangersObserved;
					if (observed.friends || observed.strangers) BDFDB.DataUtils.save(observed, this, "observed", BDFDB.UserUtils.me.id);
				}
				
				this.startInterval();

				BDFDB.PatchUtils.forceAllUpdates(this);
			}
			
			onStop () {
				BDFDB.TimeUtils.clear(checkInterval);
				
				BDFDB.PatchUtils.forceAllUpdates(this);
			}

			getSettingsPanel (collapseStates = {}) {
				let changeAllConfigs = (type, config, notificationType) => {
					let observed = this.getObservedData();
					let specificObserved = observed[type] || {};
					if (config == "all") {
						config = "disabled";
						for (let id in specificObserved) specificObserved[id][config] = notificationTypes[notificationType].button == 0 ? false : true;
					}
					else {
						let disabled = BDFDB.ObjectUtils.toArray(specificObserved).every(d => !d.disabled && d[config] == notificationTypes[notificationType].value);
						for (let id in specificObserved) specificObserved[id][config] = notificationTypes[disabled ? "DISABLED" : notificationType].value;
					}
					observed[type] = specificObserved
					BDFDB.DataUtils.save(observed, this, "observed", BDFDB.UserUtils.me.id);
					this.SettingsUpdated = true;
					BDFDB.PluginUtils.refreshSettingsPanel(this, settingsPanel, collapseStates);
				};
				let successSavedAudio = (type, parsedUrl, parsedData) => {
					if (parsedUrl && parsedData) BDFDB.NotificationUtils.toast(`Sound was saved successfully.`, {type: "success"});
					this.settings.notificationSounds[type].url = parsedUrl;
					this.settings.notificationSounds[type].song = parsedData;
					BDFDB.DataUtils.save(this.settings.notificationSounds, this, "notificationSounds");
					this.SettingsUpdated = true;
				};
				let createUserList = (users, type, title) => {
					let items = [];
					items.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
						className: BDFDB.disCNS.settingsrowtitle + BDFDB.disCNS.settingsrowtitledefault + BDFDB.disCN.cursordefault,
						children: [
							"Click on an Option to toggle",
							BDFDB.ReactUtils.createElement("span", {
								className: BDFDB.disCN._friendnotificationstypelabel,
								style: {backgroundColor: "var(--bdfdb-blurple)"},
								children: "Toast"
							}),
							"Notifications for that User"
						]
					}));
					if ("Notification" in window) items.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
						className: BDFDB.disCNS.settingsrowtitle + BDFDB.disCNS.settingsrowtitledefault + BDFDB.disCN.cursordefault,
						children: [
							"Right-Click on an Option to toggle",
							BDFDB.ReactUtils.createElement("span", {
								className: BDFDB.disCN._friendnotificationstypelabel,
								style: {backgroundColor: "var(--bdfdb-green)"},
								children: "Desktop"
							}),
							"Notifications for that User"
						]
					}));
					items.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
						className: BDFDB.disCNS.settingsrowtitle + BDFDB.disCNS.settingsrowtitledefault + BDFDB.disCN.cursordefault,
						style: {marginTop: 6},
						children: [
							"Click on an Option Header to toggle",
							BDFDB.ReactUtils.createElement("span", {
								className: BDFDB.disCN._friendnotificationstypelabel,
								style: {backgroundColor: "var(--bdfdb-blurple)"},
								children: "Toast"
							}),
							"Notifications for all Users"
						]
					}));
					if ("Notification" in window) items.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
						className: BDFDB.disCNS.settingsrowtitle + BDFDB.disCNS.settingsrowtitledefault + BDFDB.disCN.cursordefault,
						children: [
							"Right-Click on an Option Header to toggle",
							BDFDB.ReactUtils.createElement("span", {
								className: BDFDB.disCN._friendnotificationstypelabel,
								style: {backgroundColor: "var(--bdfdb-green)"},
								children: "Desktop"
							}),
							"Notifications for all Users"
						]
					}));
					items.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
						className: BDFDB.disCNS.settingsrowtitle + BDFDB.disCNS.settingsrowtitledefault + BDFDB.disCN.cursordefault,
						style: {marginTop: 6},
						children: "Click on an Avatar to toggle between enabled/disabled"
					}));
					if ("Notification" in window) items.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
						className: BDFDB.disCNS.settingsrowtitle + BDFDB.disCNS.settingsrowtitledefault + BDFDB.disCN.cursordefault,
						children: [
							"Right-Click on an Avatar to toggle all Options between",
							BDFDB.ReactUtils.createElement("span", {
								className: BDFDB.disCN._friendnotificationstypelabel,
								style: {backgroundColor: "var(--bdfdb-blurple)"},
								children: "Toast"
							}),
							"/",
							BDFDB.ReactUtils.createElement("span", {
								className: BDFDB.disCN._friendnotificationstypelabel,
								style: {backgroundColor: "var(--bdfdb-green)"},
								children: "Desktop"
							})
						]
					}));
					items.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsList, {
						className: BDFDB.disCN.margintop20,
						title: "all",
						settings: Object.keys(statuses),
						data: users,
						pagination: {
							alphabetKey: "username",
							amount: 50,
							offset: paginationOffset[title] || 0,
							onJump: offset => {paginationOffset[title] = offset;}
						},
						getCheckboxColor: value => {
							let color = (BDFDB.ObjectUtils.toArray(notificationTypes).find(n => n.value == value) || {}).color;
							return BDFDB.DiscordConstants.Colors[color] || color;
						},
						getCheckboxValue: (value, event) => {
							let eventValue = (BDFDB.ObjectUtils.toArray(notificationTypes).find(n => n.button == event.button) || {}).value;
							return eventValue == value ? 0 : eventValue;
						},
						renderLabel: cardData => [
							BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.AvatarComponents.default, {
								className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.listavatar, cardData.disabled && BDFDB.disCN.avatardisabled),
								src: BDFDB.UserUtils.getAvatar(cardData.id),
								status: BDFDB.UserUtils.getStatus(cardData.id),
								size: BDFDB.LibraryComponents.AvatarComponents.Sizes.SIZE_40,
								onClick: _ => {
									let observed = this.getObservedData();
									let data = observed[type][cardData.id] || this.createDefaultConfig();
									data.disabled = !data.disabled;
									observed[type][data.id] = data;
									BDFDB.DataUtils.save(observed, this, "observed", BDFDB.UserUtils.me.id);
									this.SettingsUpdated = true;
									BDFDB.PluginUtils.refreshSettingsPanel(this, settingsPanel, collapseStates);
								},
								onContextMenu: _ => {
									let observed = this.getObservedData();
									let data = observed[type][cardData.id] || this.createDefaultConfig();
									let batchType;
									for (let config in statuses) {
										if (data[config] == notificationTypes.TOAST.value) batchType = notificationTypes.DESKTOP.value;
										else if (data[config] == notificationTypes.DESKTOP.value) batchType = notificationTypes.TOAST.value;
										if (batchType != undefined) break;
									}
									for (let config in statuses) if (data[config] != notificationTypes.DISABLED.value) data[config] = batchType;
									observed[type][data.id] = data;
									BDFDB.DataUtils.save(observed, this, "observed", BDFDB.UserUtils.me.id);
									this.SettingsUpdated = true;
									BDFDB.PluginUtils.refreshSettingsPanel(this, settingsPanel, collapseStates);
								}
							}),
							BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TextScroller, {
								children: cardData.username
							})
						],
						onHeaderClick: config => {
							changeAllConfigs(type, config, "TOAST");
						},
						onHeaderContextMenu: config => {
							changeAllConfigs(type, config, "DESKTOP");
						},
						onCheckboxChange: (value, instance) => {
							let observed = this.getObservedData();
							let data = observed[type][instance.props.cardId] || this.createDefaultConfig();
							data[instance.props.settingId] = value;
							observed[type][instance.props.cardId] = data;
							BDFDB.DataUtils.save(observed, this, "observed", BDFDB.UserUtils.me.id);
							this.SettingsUpdated = true;
						},
						noRemove: type == "friends",
						onRemove: (e, instance) => {
							let observed = this.getObservedData();
							delete observed[type][instance.props.cardId];
							BDFDB.DataUtils.save(observed, this, "observed", BDFDB.UserUtils.me.id);
							BDFDB.PluginUtils.refreshSettingsPanel(this, settingsPanel, collapseStates);
							this.SettingsUpdated = true;
						}
					}));
					return BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.CollapseContainer, {
						title: title,
						collapseStates: collapseStates,
						dividerTop: true,
						children: items
					});
				};
				
				let settingsPanel;
				return settingsPanel = BDFDB.PluginUtils.createSettingsPanel(this, {
					collapseStates: collapseStates,
					children: _ => {
						let settingsItems = [];
						
						let observed = this.getObservedData();
						let friendIds = BDFDB.LibraryModules.RelationshipStore.getFriendIDs();
						
						settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.CollapseContainer, {
							title: "Settings",
							collapseStates: collapseStates,
							children: [
								Object.keys(this.defaults.general).map(key => BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsSaveItem, {
									type: "Switch",
									plugin: this,
									keys: ["general", key],
									label: this.defaults.general[key].description,
									value: this.settings.general[key]
								})),
								Object.keys(this.defaults.dates).map(key => BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.DateInput, {
									...(this.settings.dates[key] || {}),
									label: this.defaults.dates[key].description,
									onChange: valueObj => {
										this.SettingsUpdated = true;
										this.settings.dates[key] = valueObj;
										BDFDB.DataUtils.save(this.settings.dates, this, "dates");
									}
								})),
								Object.keys(this.defaults.amounts).map(key => (key.indexOf("desktop") == -1 || "Notification" in window) && BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsSaveItem, {
									type: "TextInput",
									childProps: {
										type: "number"
									},
									plugin: this,
									keys: ["amounts", key],
									label: this.defaults.amounts[key].description,
									basis: "20%",
									min: this.defaults.amounts[key].min,
									max: this.defaults.amounts[key].max,
									value: this.settings.amounts[key]
								}))
							]
						}));
						
						let friendCards = Object.keys(observed.friends).map(BDFDB.LibraryModules.UserStore.getUser).filter(n => n);
						let strangerCards = Object.keys(observed.strangers).map(BDFDB.LibraryModules.UserStore.getUser).filter(n => n);
						
						if (friendCards.length) settingsItems.push(createUserList(friendCards.map(user => Object.assign({}, user, observed.friends[user.id], {
							key: user.id,
							className: observed.friends[user.id].disabled ? BDFDB.disCN.hovercarddisabled : ""
						})), "friends", "Friend-List"));
						
						let strangerId = "";
						settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.CollapseContainer, {
							title: "Add new Stranger",
							collapseStates: collapseStates,
							children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
								className: BDFDB.disCN.margintop8,
								align: BDFDB.LibraryComponents.Flex.Align.CENTER,
								children: [
									BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex.Child, {
										children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TextInput, {
											className: `input-newstranger`,
											placeholder: "user (id or name#discriminator)",
											value: "",
											onChange: value => strangerId = value
										})
									}),
									BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Button, {
										onClick: _ => {
											let userId = strangerId.trim();
											if (userId == BDFDB.UserUtils.me.id) BDFDB.NotificationUtils.toast("Are you seriously trying to stalk yourself?", {type: "danger"});
											else if (friendIds.includes(userId)) BDFDB.NotificationUtils.toast("User is already a Friend of yours, please use the 'Friend-List' Area to configure them", {type: "danger"});
											else if (observed.strangers[userId]) BDFDB.NotificationUtils.toast("User is already being observed as a 'Stranger'", {type: "danger"});
											else {
												let user = /.+#[0-9]{4}/.test(userId) ? BDFDB.LibraryModules.UserStore.findByTag(userId.split("#").slice(0, -1).join("#"), userId.split("#").pop()) : BDFDB.LibraryModules.UserStore.getUser(userId);
												if (user) {
													observed.strangers[user.id || userId] = this.createDefaultConfig();
													BDFDB.DataUtils.save(observed, this, "observed", BDFDB.UserUtils.me.id);
													BDFDB.PluginUtils.refreshSettingsPanel(this, settingsPanel, collapseStates);
													this.SettingsUpdated = true;
												}
												else BDFDB.NotificationUtils.toast("Please enter a valid ID of a User that has been loaded in your Client", {type: "danger"});
											}
										},
										children: BDFDB.LanguageUtils.LanguageStrings.ADD
									})
								]
							})
						}));
						
						if (strangerCards.length) settingsItems.push(createUserList(strangerCards.map(user => Object.assign({}, user, observed.strangers[user.id], {
							key: user.id,
							className: observed.strangers[user.id].disabled ? BDFDB.disCN.hovercarddisabled : ""
						})), "strangers", "Stranger-List"));
						
						settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.CollapseContainer, {
							title: "Notification Messages",
							collapseStates: collapseStates,
							children: [BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
								className: BDFDB.disCN.marginbottom8,
								children: BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCNS.settingsrowtitle + BDFDB.disCNS.settingsrowtitle + BDFDB.disCNS.settingsrowtitledefault + BDFDB.disCN.cursordefault,
									children: [
										"Allows you to configure your own Message Strings for the different Statuses. ",
										BDFDB.ReactUtils.createElement("strong", {children: "$user"}),
										" is the Placeholder for the User Name, ",
										BDFDB.ReactUtils.createElement("strong", {children: "$status"}),
										" for the Status Name, ",
										BDFDB.ReactUtils.createElement("strong", {children: "$statusOld"}),
										" for the previous Status Name, ",
										BDFDB.ReactUtils.createElement("strong", {children: "$custom"}),
										" for the Custom Status, ",
										BDFDB.ReactUtils.createElement("strong", {children: "$game"}),
										" for the Game Name, ",
										BDFDB.ReactUtils.createElement("strong", {children: "$song"}),
										" for the Song Name and ",
										BDFDB.ReactUtils.createElement("strong", {children: "$artist"}),
										" for the Song Artist."
									]
								})
							})].concat(Object.keys(this.defaults.notificationStrings).map(key => BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsSaveItem, {
								type: "TextInput",
								plugin: this,
								keys: ["notificationStrings", key],
								placeholder: this.defaults.notificationStrings[key].value,
								label: BDFDB.LibraryModules.StringUtils.upperCaseFirstChar(key),
								basis: "80%",
								value: this.settings.notificationStrings[key]
							})))
						}));
						
						settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.CollapseContainer, {
							title: "Notification Sounds",
							collapseStates: collapseStates,
							children: Object.keys(this.defaults.notificationSounds).map((key, i) => (key.indexOf("desktop") == -1 || "Notification" in window) && [
								i != 0 && key.indexOf("toast") == 0 && BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.FormComponents.FormDivider, {
									className: BDFDB.disCN.marginbottom8
								}),
								BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
									className: BDFDB.disCN.marginbottom8,
									align: BDFDB.LibraryComponents.Flex.Align.CENTER,
									direction: BDFDB.LibraryComponents.Flex.Direction.HORIZONTAL,
									children: [
										BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsLabel, {
											label: `${key.split(/(desktop)|(toast)/).filter(n => n).map(n => BDFDB.LibraryModules.StringUtils.upperCaseFirstChar(n)).join("-")} Notification Sound`,
										}),
										BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsItem, {
											type: "Switch",
											mini: true,
											grow: 0,
											label: "Mute:",
											value: this.settings.notificationSounds[key].mute,
											onChange: value => {
												this.settings.notificationSounds[key].mute = value;
												BDFDB.DataUtils.save(this.settings.notificationSounds, this, "notificationSounds");
											}
										})
									].filter(n => n)
								}),
								BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
									className: BDFDB.disCN.marginbottom8,
									align: BDFDB.LibraryComponents.Flex.Align.CENTER,
									children: [
										BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex.Child, {
											children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TextInput, {
												className: `input-${key}src`,
												type: "file",
												filter: ["audio", "video"],
												useFilePath: true,
												placeholder: "Url or File Path",
												value: this.settings.notificationSounds[key].url
											})
										}),
										BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Button, {
											onClick: _ => {
												let source = settingsPanel.props._node.querySelector(`.input-${key}src ` + BDFDB.dotCN.input).value.trim();
												if (!source.length) {
													BDFDB.NotificationUtils.toast(`Sound File was removed.`, {type: "warning"});
													successSavedAudio(key, source, source);
												}
												else if (source.indexOf("http") == 0) BDFDB.LibraryRequires.request(source, (error, response, result) => {
													if (response) {
														let type = response.headers["content-type"];
														if (type && (type.indexOf("octet-stream") > -1 || type.indexOf("audio") > -1 || type.indexOf("video") > -1)) {
															successSavedAudio(key, source, source);
															return;
														}
													}
													BDFDB.NotificationUtils.toast("Use a valid direct Link to a Video or Audio Source, they usually end on something like .mp3, .mp4 or .wav", {type: "danger"});
												});
												else BDFDB.LibraryRequires.fs.readFile(source, (error, response) => {
													if (error) BDFDB.NotificationUtils.toast("Could not fetch File, please make sure the File exists", {type: "danger"});
													else successSavedAudio(key, source, `data:audio/mpeg;base64,${response.toString("base64")}`);
												});
											},
											children: BDFDB.LanguageUtils.LanguageStrings.SAVE
										})
									]
								})
							]).flat(10).filter(n => n)
						}));
						
						settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.CollapseContainer, {
							title: "LogIn/-Out Timelog",
							collapseStates: collapseStates,
							children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsItem, {
								type: "Button",
								label: "Overview of LogIns/-Outs of current Session",
								onClick: _ => {this.showTimeLog()},
								children: "Timelog"
							})
						}));
						
						return settingsItems;
					}
				});
			}

			onSettingsClosed () {
				if (this.SettingsUpdated) {
					delete this.SettingsUpdated;
					
					this.startInterval();
					BDFDB.PatchUtils.forceAllUpdates(this);
				}
			}
			
			processGuilds (e) {
				if (this.settings.general.addOnlineCount) {
					if (typeof e.returnvalue.props.children == "function") {
						let childrenRender = e.returnvalue.props.children;
						e.returnvalue.props.children = (...args) => {
							let children = childrenRender(...args);
							this.checkTree(children);
							return children;
						};
					}
					else this.checkTree(e.returnvalue);
				}
			}
			
			checkTree (returnvalue) {
				let tree = BDFDB.ReactUtils.findChild(returnvalue, {filter: n => n && n.props && typeof n.props.children == "function"});
				if (tree) {
					let childrenRender = tree.props.children;
					tree.props.children = (...args) => {
						let children = childrenRender(...args);
						this.injectCounter(children);
						return children;
					};
				}
				else this.injectCounter(returnvalue);
			}
			
			injectCounter (returnvalue) {
				let [children, index] = BDFDB.ReactUtils.findParent(returnvalue, {name: "ConnectedUnreadDMs"});
				if (index > -1) children.splice(index, 0, BDFDB.ReactUtils.createElement(FriendOnlineCounterComponent, {
					amount: BDFDB.LibraryModules.StatusMetaUtils.getOnlineFriendCount()
				}));
			}
			
			getObservedData () {
				let observed = Object.assign({friends: {}, strangers: {}}, BDFDB.DataUtils.load(this, "observed", BDFDB.UserUtils.me.id));
				let friendIds = BDFDB.LibraryModules.RelationshipStore.getFriendIDs();
				
				for (let id of friendIds) {
					let user = BDFDB.LibraryModules.UserStore.getUser(id);
					if (user) {
						observed.friends[id] = Object.assign({}, observed.friends[id] || observed.strangers[id] || this.createDefaultConfig());
						delete observed.strangers[id];
					}
				}
				for (let id in observed.friends) if (!friendIds.includes(id)) {
					observed.strangers[id] = Object.assign({}, observed.friends[id]);
					delete observed.friends[id];
				}
				
				delete observed.friends[BDFDB.UserUtils.me.id];
				delete observed.strangers[BDFDB.UserUtils.me.id];
				BDFDB.DataUtils.save(observed, this, "observed", BDFDB.UserUtils.me.id);
				
				return observed;
			}

			createDefaultConfig () {
				return Object.assign({
					disabled: this.settings.general.disableForNew
				}, BDFDB.ObjectUtils.map(statuses, init => notificationTypes[init ? "TOAST" : "DISABLED"].value));
			}

			getStatusWithMobileAndActivity (id, config, clientStatuses) {
				let status = {
					name: BDFDB.UserUtils.getStatus(id),
					activity: null,
					custom: false,
					mobile: clientStatuses && clientStatuses[id] && Object.keys(clientStatuses[id]).length == 1 && !!clientStatuses[id].mobile
				};
				let activity = BDFDB.UserUtils.getActivity(id) || BDFDB.UserUtils.getCustomStatus(id);
				if (activity && BDFDB.DiscordConstants.ActivityTypes[activity.type]) {
					let isCustom = activity.type == BDFDB.DiscordConstants.ActivityTypes.CUSTOM_STATUS;
					let activityName = isCustom ? "custom" : BDFDB.DiscordConstants.ActivityTypes[activity.type].toLowerCase();
					if (statuses[activityName] && config[activityName]) {
						Object.assign(status, {name: isCustom ? status.name : activityName, activity: Object.assign({}, activity), custom: isCustom});
						if (activity.type == BDFDB.DiscordConstants.ActivityTypes.STREAMING || activity.type == BDFDB.DiscordConstants.ActivityTypes.LISTENING) delete status.activity.name;
						else if (activity.type == BDFDB.DiscordConstants.ActivityTypes.PLAYING) {
							delete status.activity.details;
							delete status.activity.state;
						}
					}
				}
				return status;
			}
			
			getStatusName (id, status) {
				if (!status) return "";
				let statusName = (BDFDB.LanguageUtils.LanguageStringsCheck[statuses[status.name].name] && BDFDB.LanguageUtils.LanguageStrings[statuses[status.name].name] || this.labels["status_" + status.name] || statuses[status.name].name || "").toLowerCase();
				return statusName;
			}
			
			activityIsSame (id, status) {
				return BDFDB.equals(BDFDB.ObjectUtils.extract(userStatusStore[id].activity, "name", "details", "state", "emoji"), status && BDFDB.ObjectUtils.extract(status.activity, "name", "details", "state", "emoji"));
			}

			startInterval () {
				BDFDB.TimeUtils.clear(checkInterval);
				
				let data = this.getObservedData();
				observedUsers = Object.assign({}, data.strangers, data.friends);
				delete observedUsers[BDFDB.UserUtils.me.id];
				
				let clientStatuses = BDFDB.LibraryModules.StatusMetaUtils.getState().clientStatuses;
				for (let id in observedUsers) userStatusStore[id] = this.getStatusWithMobileAndActivity(id, observedUsers[id], clientStatuses);
				
				checkInterval = BDFDB.TimeUtils.interval(_ => {
					let amount = BDFDB.LibraryModules.StatusMetaUtils.getOnlineFriendCount();
					if (friendCounter && friendCounter.props.amount != amount) {
						friendCounter.props.amount = amount;
						BDFDB.ReactUtils.forceUpdate(friendCounter);
					}
					clientStatuses = BDFDB.LibraryModules.StatusMetaUtils.getState().clientStatuses;
					for (let id in observedUsers) if (!observedUsers[id].disabled) {
						let user = BDFDB.LibraryModules.UserStore.getUser(id);
						let status = this.getStatusWithMobileAndActivity(id, observedUsers[id], clientStatuses);
						let customChanged = false;
						if (user && observedUsers[id][status.name] && (
							observedUsers[id].custom && (
								userStatusStore[id].custom != status.custom && ((customChanged = status.custom) || true) ||
								(customChanged = status.custom && !this.activityIsSame(id, status))
							) ||
							observedUsers[id].mobile && userStatusStore[id].mobile != status.mobile ||
							statuses[status.name].checkActivity && !this.activityIsSame(id, status) ||
							userStatusStore[id].name != status.name
						)) {
							let EUdata = BDFDB.BDUtils.isPluginEnabled("EditUsers") && BDFDB.DataUtils.load("EditUsers", "users", user.id) || {};
							let name = EUdata.name || user.username;
							let avatar = EUdata.removeIcon ? "" : (EUdata.url || BDFDB.UserUtils.getAvatar(user.id));
							let timestamp = new Date().getTime();
							
							let statusName = this.getStatusName(id, status);
							let oldStatusName = this.getStatusName(id, userStatusStore[id]);
							
							let string = this.settings.notificationStrings[customChanged ? "custom" : status.name] || "'$user' changed status to '$status'";
							let toastString = BDFDB.StringUtils.htmlEscape(string).replace(/'{0,1}\$user'{0,1}/g, `<strong>${BDFDB.StringUtils.htmlEscape(name)}</strong>${this.settings.general.showDiscriminator ? ("#" + user.discriminator) : ""}`).replace(/'{0,1}\$statusOld'{0,1}/g, `<strong>${oldStatusName}</strong>`).replace(/'{0,1}\$status'{0,1}/g, `<strong>${statusName}</strong>`);
							if (status.activity) toastString = toastString.replace(/'{0,1}\$song'{0,1}|'{0,1}\$game'{0,1}/g, `<strong>${status.activity.name || status.activity.details || ""}</strong>`).replace(/'{0,1}\$artist'{0,1}|'{0,1}\$custom'{0,1}/g, `<strong>${[status.activity.emoji && status.activity.emoji.name, status.activity.state].filter(n => n).join(" ") || ""}</strong>`);
							
							let statusType = BDFDB.UserUtils.getStatus(user.id);
							timeLog.unshift({
								string: toastString,
								avatar: avatar,
								name: name,
								status: statusType,
								mobile: status.mobile,
								timestamp: timestamp
							});
							
							if (!(this.settings.general.muteOnDND && BDFDB.UserUtils.getStatus() == BDFDB.DiscordConstants.StatusTypes.DND) && (!lastTimes[user.id] || lastTimes[user.id] != timestamp)) {
								lastTimes[user.id] = timestamp;
								
								let openChannel = _ => {
									if (this.settings.general.openOnClick) {
										let DMid = BDFDB.LibraryModules.ChannelStore.getDMFromUserId(user.id)
										if (DMid) BDFDB.LibraryModules.ChannelUtils.selectPrivateChannel(DMid);
										else BDFDB.LibraryModules.DirectMessageUtils.openPrivateChannel(BDFDB.UserUtils.me.id, user.id);
										BDFDB.LibraryModules.WindowUtils.focus();
									}
								};
								if (observedUsers[id][status.name] == notificationTypes.DESKTOP.value) {
									let desktopString = string.replace(/\$user/g, `${name}${this.settings.general.showDiscriminator ? ("#" + user.discriminator) : ""}`).replace(/\$status/g, statusName).replace(/\$statusOld/g, oldStatusName);
									if (status.activity) desktopString = desktopString.replace(/\$song|\$game/g, status.activity.name || status.activity.details || "").replace(/\$artist|\$custom/g, [status.activity.emoji && status.activity.emoji.name, status.activity.state].filter(n => n).join(" ") || "");
									if (status.mobile) desktopString += " (mobile)";
									let notificationSound = this.settings.notificationSounds["desktop" + status.name] || {};
									BDFDB.NotificationUtils.desktop(desktopString, {
										icon: avatar,
										silent: notificationSound.mute,
										sound: notificationSound.song,
										onClick: openChannel
									});
								}
								else BDFDB.NotificationUtils.toast(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
									align: BDFDB.LibraryComponents.Flex.Align.CENTER,
									children: [
										BDFDB.ReactUtils.elementToReact(BDFDB.DOMUtils.create(toastString)),
										this.createStatusDot(statusType, status.mobile, {marginLeft: 6})
									]
								}), {
									timeout: this.settings.amounts.toastTime * 1000,
									avatar: avatar,
									barColor: BDFDB.UserUtils.getStatusColor(status.name, true),
									onClick: openChannel,
									onShow: _ => {
										let notificationSound = this.settings.notificationSounds["toast" + status.name] || {};
										if (!notificationSound.mute && notificationSound.song) {
											let audio = new Audio();
											audio.src = notificationSound.song;
											audio.play();
										}
									}
								});
							}
						}
						userStatusStore[id] = status;
					}
				}, this.settings.amounts.checkInterval * 1000);
			}
			
			createStatusDot (status, isMobile, style = {}) {
				return BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Status, {
					style: Object.assign({}, style),
					size: 12,
					color: isMobile ? BDFDB.UserUtils.getStatusColor(status, true) : null,
					isMobile: isMobile,
					status: isMobile ? BDFDB.DiscordConstants.StatusTypes.ONLINE : status
				});
			}

			showTimeLog () {
				let searchTimeout;
				BDFDB.ModalUtils.open(this, {
					size: "MEDIUM",
					header: "LogIn/-Out Timelog",
					subHeader: "",
					className: BDFDB.disCN._friendnotificationstimelogmodal,
					titleChildren: [
						BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Button, {
							color: BDFDB.LibraryComponents.Button.Colors.RED,
							size: BDFDB.LibraryComponents.Button.Sizes.TINY,
							look: BDFDB.LibraryComponents.Button.Looks.GHOST,
							style: {marginLeft: 6, marginRight: 12},
							children: BDFDB.LanguageUtils.LanguageStrings.BUILD_OVERRIDE_CLEAR,
							onClick: _ => BDFDB.ModalUtils.confirm(this, this.labels.clear_log, _ => {
								timeLog = [];
								timeLogList.props.entries = timeLog;
								BDFDB.ReactUtils.forceUpdate(timeLogList);
							})
						}),
						BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SearchBar, {
							autoFocus: true,
							query: "",
							onChange: (value, instance) => {
								BDFDB.TimeUtils.clear(searchTimeout);
								searchTimeout = BDFDB.TimeUtils.timeout(_ => {
									let searchString = value.toUpperCase();
									timeLogList.props.entries = timeLog.filter(n => n && n.name && n.name.toUpperCase().indexOf(searchString) > -1);
									BDFDB.ReactUtils.forceUpdate(timeLogList);
								}, 1000);
							},
							onClear: instance => {
								timeLogList.props.entries = timeLog;
								BDFDB.ReactUtils.forceUpdate(timeLogList);
							}
						})
					],
					children: BDFDB.ReactUtils.createElement(TimeLogComponent, {
						entries: timeLog
					})
				});
			}

			setLabelsByLanguage () {
				switch (BDFDB.LanguageUtils.getLanguage().id) {
					case "bg":		// Bulgarian
						return {
							clear_log:							"ÐÐ°Ð¸ÑÑ‚Ð¸Ð½Ð° Ð»Ð¸ Ð¸ÑÐºÐ°Ñ‚Ðµ Ð´Ð° Ð¸Ð·Ñ‡Ð¸ÑÑ‚Ð¸Ñ‚Ðµ Ð´Ð½ÐµÐ²Ð½Ð¸ÐºÐ° Ð½Ð° Ð²Ñ€ÐµÐ¼ÐµÑ‚Ð¾?",
							status_listening:					"Ð¡Ð»ÑƒÑˆÐ°Ð½Ðµ",
							status_playing:						"Ð˜Ð³Ñ€Ð°Ðµ"
						};
					case "da":		// Danish
						return {
							clear_log:							"Er du sikker pÃ¥, at du vil rydde tidsloggen?",
							status_listening:					"HÃ¸rer efter",
							status_playing:						"Spiller"
						};
					case "de":		// German
						return {
							clear_log:							"MÃ¶chtest du das Zeitprotokoll wirklich lÃ¶schen?",
							status_listening:					"HÃ¶ren",
							status_playing:						"Spielen"
						};
					case "el":		// Greek
						return {
							clear_log:							"Î•Î¯ÏƒÏ„Îµ Î²Î­Î²Î±Î¹Î¿Î¹ ÏŒÏ„Î¹ Î¸Î­Î»ÎµÏ„Îµ Î½Î± Î´Î¹Î±Î³ÏÎ¬ÏˆÎµÏ„Îµ Ï„Î¿ Î·Î¼ÎµÏÎ¿Î»ÏŒÎ³Î¹Î¿ ÏŽÏÎ±Ï‚;",
							status_listening:					"Î‘ÎºÎ¿ÏÎ³Î¿Î½Ï„Î±Ï‚",
							status_playing:						"Î Î±Î¹Ï‡Î½Î¯Î´Î¹"
						};
					case "es":		// Spanish
						return {
							clear_log:							"Â¿EstÃ¡ seguro de que desea borrar el registro de tiempo?",
							status_listening:					"Escuchando",
							status_playing:						"Jugando"
						};
					case "fi":		// Finnish
						return {
							clear_log:							"Haluatko varmasti tyhjentÃ¤Ã¤ aikalokin?",
							status_listening:					"Kuunteleminen",
							status_playing:						"Pelataan"
						};
					case "fr":		// French
						return {
							clear_log:							"Voulez-vous vraiment effacer le journal de temps?",
							status_listening:					"Ã‰coute",
							status_playing:						"En jouant"
						};
					case "hr":		// Croatian
						return {
							clear_log:							"Jeste li sigurni da Å¾elite oÄistiti vremenski zapisnik?",
							status_listening:					"SluÅ¡anje",
							status_playing:						"Sviranje"
						};
					case "hu":		// Hungarian
						return {
							clear_log:							"Biztosan tÃ¶rli az idÅ‘naplÃ³t?",
							status_listening:					"HallgatÃ¡s",
							status_playing:						"JÃ¡tÃ©k"
						};
					case "it":		// Italian
						return {
							clear_log:							"Sei sicuro di voler cancellare il registro del tempo?",
							status_listening:					"Ascoltando",
							status_playing:						"Giocando"
						};
					case "ja":		// Japanese
						return {
							clear_log:							"ã‚¿ã‚¤ãƒ ãƒ­ã‚°ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ",
							status_listening:					"èžã„ã¦ã„ã‚‹",
							status_playing:						"éŠã¶"
						};
					case "ko":		// Korean
						return {
							clear_log:							"ì‹œê°„ ë¡œê·¸ë¥¼ ì§€ìš°ì‹œê² ìŠµë‹ˆê¹Œ?",
							status_listening:					"ì²­ì·¨",
							status_playing:						"ë†€ì´"
						};
					case "lt":		// Lithuanian
						return {
							clear_log:							"Ar tikrai norite iÅ¡valyti laiko Å¾urnalÄ…?",
							status_listening:					"Klausymas",
							status_playing:						"Å½aidÅ¾ia"
						};
					case "nl":		// Dutch
						return {
							clear_log:							"Weet u zeker dat u het tijdlogboek wilt wissen?",
							status_listening:					"Luisteren",
							status_playing:						"Spelen"
						};
					case "no":		// Norwegian
						return {
							clear_log:							"Er du sikker pÃ¥ at du vil slette tidsloggen?",
							status_listening:					"Lytte",
							status_playing:						"Spiller"
						};
					case "pl":		// Polish
						return {
							clear_log:							"Czy na pewno chcesz wyczyÅ›ciÄ‡ dziennik czasu?",
							status_listening:					"SÅ‚uchajÄ…cy",
							status_playing:						"Gra"
						};
					case "pt-BR":	// Portuguese (Brazil)
						return {
							clear_log:							"Tem certeza de que deseja limpar o registro de horas?",
							status_listening:					"Ouvindo",
							status_playing:						"Jogando"
						};
					case "ro":		// Romanian
						return {
							clear_log:							"Sigur doriÈ›i sÄƒ È™tergeÈ›i jurnalul de timp?",
							status_listening:					"Ascultare",
							status_playing:						"Joc"
						};
					case "ru":		// Russian
						return {
							clear_log:							"Ð’Ñ‹ ÑƒÐ²ÐµÑ€ÐµÐ½Ñ‹, Ñ‡Ñ‚Ð¾ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ Ð¾Ñ‡Ð¸ÑÑ‚Ð¸Ñ‚ÑŒ Ð¶ÑƒÑ€Ð½Ð°Ð» Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸?",
							status_listening:					"ÐŸÑ€Ð¾ÑÐ»ÑƒÑˆÐ¸Ð²Ð°Ð½Ð¸Ðµ",
							status_playing:						"Ð˜Ð³Ñ€Ð°ÐµÑ‚"
						};
					case "sv":		// Swedish
						return {
							clear_log:							"Ã„r du sÃ¤ker pÃ¥ att du vill rensa tidsloggen?",
							status_listening:					"Lyssnande",
							status_playing:						"Spelar"
						};
					case "th":		// Thai
						return {
							clear_log:							"à¹à¸™à¹ˆà¹ƒà¸ˆà¹„à¸«à¸¡à¸§à¹ˆà¸²à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸¥à¹‰à¸²à¸‡à¸šà¸±à¸™à¸—à¸¶à¸à¹€à¸§à¸¥à¸²",
							status_listening:					"à¸à¸²à¸£à¸Ÿà¸±à¸‡",
							status_playing:						"à¸à¸³à¸¥à¸±à¸‡à¹€à¸¥à¹ˆà¸™"
						};
					case "tr":		// Turkish
						return {
							clear_log:							"Zaman kaydÄ±nÄ± temizlemek istediÄŸinizden emin misiniz?",
							status_listening:					"Dinleme",
							status_playing:						"Ã‡alma"
						};
					case "uk":		// Ukrainian
						return {
							clear_log:							"Ð’Ð¸ Ð²Ð¿ÐµÐ²Ð½ÐµÐ½Ñ–, Ñ‰Ð¾ Ñ…Ð¾Ñ‡ÐµÑ‚Ðµ Ð¾Ñ‡Ð¸ÑÑ‚Ð¸Ñ‚Ð¸ Ð¶ÑƒÑ€Ð½Ð°Ð» Ñ‡Ð°ÑÑƒ?",
							status_listening:					"Ð¡Ð»ÑƒÑ…Ð°Ð½Ð½Ñ",
							status_playing:						"Ð“Ñ€Ð°"
						};
					case "vi":		// Vietnamese
						return {
							clear_log:							"Báº¡n cÃ³ cháº¯c cháº¯n muá»‘n xÃ³a nháº­t kÃ½ thá»i gian khÃ´ng?",
							status_listening:					"Láº¯ng nghe",
							status_playing:						"Äang chÆ¡i"
						};
					case "zh-CN":	// Chinese (China)
						return {
							clear_log:							"æ‚¨ç¡®å®šè¦æ¸…é™¤æ—¶é—´è®°å½•å—ï¼Ÿ",
							status_listening:					"å€¾å¬",
							status_playing:						"çŽ©"
						};
					case "zh-TW":	// Chinese (Taiwan)
						return {
							clear_log:							"æ‚¨ç¢ºå®šè¦æ¸…é™¤æ™‚é–“è¨˜éŒ„å—Žï¼Ÿ",
							status_listening:					"å‚¾è½",
							status_playing:						"çŽ©"
						};
					default:		// English
						return {
							clear_log:							"Are you sure you want to clear the timelog?",
							status_listening:					"Listening",
							status_playing:						"Playing"
						};
				}
			}
		};
	})(window.BDFDB_Global.PluginUtils.buildPlugin(config));
})();
{
	"amounts": {
		"toastTime": 5,
		"checkInterval": 10
	},
	"dates": {
		"logDate": {}
	},
	"general": {
		"addOnlineCount": true,
		"showDiscriminator": false,
		"disableForNew": false,
		"muteOnDND": false,
		"openOnClick": false
	},
	"notificationSounds": {
		"toastonline": {
			"url": null,
			"song": null,
			"mute": false
		},
		"desktoponline": {
			"url": null,
			"song": null,
			"mute": false
		},
		"toastidle": {
			"url": null,
			"song": null,
			"mute": false
		},
		"desktopidle": {
			"url": null,
			"song": null,
			"mute": false
		},
		"toastdnd": {
			"url": null,
			"song": null,
			"mute": false
		},
		"desktopdnd": {
			"url": null,
			"song": null,
			"mute": false
		},
		"toastplaying": {
			"url": null,
			"song": null,
			"mute": false
		},
		"desktopplaying": {
			"url": null,
			"song": null,
			"mute": false
		},
		"toastlistening": {
			"url": null,
			"song": null,
			"mute": false
		},
		"desktoplistening": {
			"url": null,
			"song": null,
			"mute": false
		},
		"toaststreaming": {
			"url": null,
			"song": null,
			"mute": false
		},
		"desktopstreaming": {
			"url": null,
			"song": null,
			"mute": false
		},
		"toastoffline": {
			"url": null,
			"song": null,
			"mute": false
		},
		"desktopoffline": {
			"url": null,
			"song": null,
			"mute": false
		}
	},
	"notificationStrings": {
		"online": "$user changed status to '$status'",
		"idle": "$user changed status to '$status'",
		"dnd": "$user changed status to '$status'",
		"playing": "$user started playing '$game'",
		"listening": "$user started listening to '$song'",
		"streaming": "$user started streaming '$game'",
		"offline": "$user changed status to '$status'",
		"custom": "$user changed status to '$custom'"
	},
	"observed": {
		"836412217351602197": {
			"friends": {
				"320981925386911746": {
					"disabled": false,
					"online": 1,
					"idle": 1,
					"dnd": 1,
					"playing": 1,
					"listening": 1,
					"streaming": 1,
					"offline": 1,
					"mobile": 1,
					"custom": 1
				},
				"419068476066627584": {
					"disabled": false,
					"online": 1,
					"idle": 1,
					"dnd": 1,
					"playing": 1,
					"listening": 1,
					"streaming": 1,
					"offline": 1,
					"mobile": 1,
					"custom": 1
				},
				"585956278858416153": {
					"disabled": false,
					"online": 1,
					"idle": 1,
					"dnd": 1,
					"playing": 1,
					"listening": 1,
					"streaming": 1,
					"offline": 1,
					"mobile": 1,
					"custom": 1
				},
				"651498408967798786": {
					"disabled": false,
					"online": 1,
					"idle": 1,
					"dnd": 1,
					"playing": 1,
					"listening": 1,
					"streaming": 1,
					"offline": 1,
					"mobile": 1,
					"custom": 1
				},
				"651971106286207006": {
					"disabled": false,
					"online": 1,
					"idle": 1,
					"dnd": 1,
					"playing": 1,
					"listening": 1,
					"streaming": 1,
					"offline": 1,
					"mobile": 1,
					"custom": 1
				},
				"705640334037614654": {
					"disabled": false,
					"online": 1,
					"idle": 1,
					"dnd": 1,
					"playing": 1,
					"listening": 1,
					"streaming": 1,
					"offline": 1,
					"mobile": 1,
					"custom": 1
				},
				"707492675586097253": {
					"disabled": false,
					"online": 1,
					"idle": 1,
					"dnd": 1,
					"playing": 1,
					"listening": 1,
					"streaming": 1,
					"offline": 1,
					"mobile": 1,
					"custom": 1
				},
				"731247972431691930": {
					"disabled": false,
					"online": 1,
					"idle": 1,
					"dnd": 1,
					"playing": 1,
					"listening": 1,
					"streaming": 1,
					"offline": 1,
					"mobile": 1,
					"custom": 1
				},
				"743733713484906528": {
					"disabled": false,
					"online": 1,
					"idle": 1,
					"dnd": 1,
					"playing": 1,
					"listening": 1,
					"streaming": 1,
					"offline": 1,
					"mobile": 1,
					"custom": 1
				},
				"813927574186885131": {
					"disabled": false,
					"online": 1,
					"idle": 1,
					"dnd": 1,
					"playing": 1,
					"listening": 1,
					"streaming": 1,
					"offline": 1,
					"mobile": 1,
					"custom": 1
				},
				"813938797120192552": {
					"disabled": false,
					"online": 1,
					"idle": 1,
					"dnd": 1,
					"playing": 1,
					"listening": 1,
					"streaming": 1,
					"offline": 1,
					"mobile": 1,
					"custom": 1
				},
				"832401574373490729": {
					"disabled": false,
					"online": 1,
					"idle": 1,
					"dnd": 1,
					"playing": 1,
					"listening": 1,
					"streaming": 1,
					"offline": 1,
					"mobile": 1,
					"custom": 1
				},
				"836366185800269824": {
					"disabled": false,
					"online": 1,
					"idle": 1,
					"dnd": 1,
					"playing": 1,
					"listening": 1,
					"streaming": 1,
					"offline": 1,
					"mobile": 1,
					"custom": 1
				},
				"838183887490383923": {
					"disabled": false,
					"online": 1,
					"idle": 1,
					"dnd": 1,
					"playing": 1,
					"listening": 1,
					"streaming": 1,
					"offline": 1,
					"mobile": 1,
					"custom": 1
				},
				"833172032715096084": {
					"disabled": false,
					"online": 1,
					"idle": 1,
					"dnd": 1,
					"playing": 1,
					"listening": 1,
					"streaming": 1,
					"offline": 1,
					"mobile": 1,
					"custom": 1
				},
				"749422065781571685": {
					"disabled": false,
					"online": 1,
					"idle": 1,
					"dnd": 1,
					"playing": 1,
					"listening": 1,
					"streaming": 1,
					"offline": 1,
					"mobile": 1,
					"custom": 1
				},
				"700598104755273769": {
					"disabled": false,
					"online": 1,
					"idle": 1,
					"dnd": 1,
					"playing": 1,
					"listening": 1,
					"streaming": 1,
					"offline": 1,
					"mobile": 1,
					"custom": 1
				},
				"730676829245014026": {
					"disabled": false,
					"online": 1,
					"idle": 1,
					"dnd": 1,
					"playing": 1,
					"listening": 1,
					"streaming": 1,
					"offline": 1,
					"mobile": 1,
					"custom": 1
				}
			},
			"strangers": {
				"837117894591905873": {
					"disabled": false,
					"online": 1,
					"idle": 1,
					"dnd": 1,
					"playing": 1,
					"listening": 1,
					"streaming": 1,
					"offline": 1,
					"mobile": 1,
					"custom": 1
				}
			}
		}
	}
}
/**
 * @name EmojiUtilities
 * @version 0.0.9
 * @authorLink https://twitter.com/IAmZerebos
 * @donate https://paypal.me/ZackRauen
 * @patreon https://patreon.com/Zerebos
 * @website https://github.com/rauenzi/BetterDiscordAddons/tree/master/Plugins/EmojiUtilities
 * @source https://raw.githubusercontent.com/rauenzi/BetterDiscordAddons/master/Plugins/EmojiUtilities/EmojiUtilities.plugin.js
 * @updateUrl https://raw.githubusercontent.com/rauenzi/BetterDiscordAddons/master/Plugins/EmojiUtilities/EmojiUtilities.plugin.js
 */
/*@cc_on
@if (@_jscript)
    
    // Offer to self-install for clueless users that try to run this directly.
    var shell = WScript.CreateObject("WScript.Shell");
    var fs = new ActiveXObject("Scripting.FileSystemObject");
    var pathPlugins = shell.ExpandEnvironmentStrings("%APPDATA%\\BetterDiscord\\plugins");
    var pathSelf = WScript.ScriptFullName;
    // Put the user at ease by addressing them in the first person
    shell.Popup("It looks like you've mistakenly tried to run me directly. \n(Don't do that!)", 0, "I'm a plugin for BetterDiscord", 0x30);
    if (fs.GetParentFolderName(pathSelf) === fs.GetAbsolutePathName(pathPlugins)) {
        shell.Popup("I'm in the correct folder already.", 0, "I'm already installed", 0x40);
    } else if (!fs.FolderExists(pathPlugins)) {
        shell.Popup("I can't find the BetterDiscord plugins folder.\nAre you sure it's even installed?", 0, "Can't install myself", 0x10);
    } else if (shell.Popup("Should I copy myself to BetterDiscord's plugins folder for you?", 0, "Do you need some help?", 0x34) === 6) {
        fs.CopyFile(pathSelf, fs.BuildPath(pathPlugins, fs.GetFileName(pathSelf)), true);
        // Show the user where to put plugins in the future
        shell.Exec("explorer " + pathPlugins);
        shell.Popup("I'm installed!", 0, "Successfully installed", 0x40);
    }
    WScript.Quit();

@else@*/

module.exports = (() => {
    const config = {info:{name:"EmojiUtilities",authors:[{name:"Zerebos",discord_id:"249746236008169473",github_username:"rauenzi",twitter_username:"ZackRauen"}],version:"0.0.9",description:"Allows you to blacklist and favorite emojis.",github:"https://github.com/rauenzi/BetterDiscordAddons/tree/master/Plugins/EmojiUtilities",github_raw:"https://raw.githubusercontent.com/rauenzi/BetterDiscordAddons/master/Plugins/EmojiUtilities/EmojiUtilities.plugin.js"},changelog:[{title:"Plugin Status",type:"fixed",items:["Favorite emojis show up again as `Favorite Emojis`."]}],main:"index.js"};

    return !global.ZeresPluginLibrary ? class {
        constructor() {this._config = config;}
        getName() {return config.info.name;}
        getAuthor() {return config.info.authors.map(a => a.name).join(", ");}
        getDescription() {return config.info.description;}
        getVersion() {return config.info.version;}
        load() {
            BdApi.showConfirmationModal("Library Missing", `The library plugin needed for ${config.info.name} is missing. Please click Download Now to install it.`, {
                confirmText: "Download Now",
                cancelText: "Cancel",
                onConfirm: () => {
                    require("request").get("https://rauenzi.github.io/BDPluginLibrary/release/0PluginLibrary.plugin.js", async (error, response, body) => {
                        if (error) return require("electron").shell.openExternal("https://betterdiscord.net/ghdl?url=https://raw.githubusercontent.com/rauenzi/BDPluginLibrary/master/release/0PluginLibrary.plugin.js");
                        await new Promise(r => require("fs").writeFile(require("path").join(BdApi.Plugins.folder, "0PluginLibrary.plugin.js"), body, r));
                    });
                }
            });
        }
        start() {}
        stop() {}
    } : (([Plugin, Api]) => {
        const plugin = (Plugin, Api) => {

    const {Patcher, WebpackModules, PluginUtilities, DiscordModules, Utilities, ReactComponents, DCM} = Api;

    const FavoriteIcon = (({DiscordModules}) => {
    const ce = DiscordModules.React.createElement;
    return class FavoriteIcon extends DiscordModules.React.Component {
        render() {
            return ce("svg", {height: this.props.height || "24px", width: this.props.width || "24px", className: this.props.className, viewBox: "0 0 24 24"},
                ce("path", {d: "M0 0h24v24H0z", fill: "none"}),
                ce("path", {d: "M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z", fill: "currentColor"}),
            );
        }
    };
})(Api);
    const DisabledIcon = (({DiscordModules}) => {
    const ce = DiscordModules.React.createElement;
    return class BlacklistIcon extends DiscordModules.React.Component {
        render() {
            return ce("svg", {height: this.props.height || "24px", width: this.props.width || "24px", className: this.props.className, viewBox: "0 0 24 24"},
                ce("path", {d: "M0 0h24v24H0z", fill: "none"}),
                ce("path", {d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8 0-1.85.63-3.55 1.69-4.9L16.9 18.31C15.55 19.37 13.85 20 12 20zm6.31-3.1L7.1 5.69C8.45 4.63 10.15 4 12 4c4.42 0 8 3.58 8 8 0 1.85-.63 3.55-1.69 4.9z", fill: "currentColor"}),
            );
        }
    };
})(Api);

    const EmojiUtils = DiscordModules.EmojiUtils;
    const EmojiStore = DiscordModules.EmojiStore;

    const emojiIdRegex = new RegExp(`([0-9]{10,})`);

    return class EmojiUtilities extends Plugin {
        
        onStart() {
            this.disabledEmojis = PluginUtilities.loadData(this.getName(), "disabledEmojis", []);
            this.favoriteEmojis = PluginUtilities.loadData(this.getName(), "favoriteEmojis", []);
            this.disabledEmojis = this.disabledEmojis.filter(e => typeof(e) === "string");
            this.favoriteEmojis = this.favoriteEmojis.filter(e => typeof(e) === "string");


            this.addBlacklistFilter();
            this.addCategories();

            this.promises = {state: {cancelled: false}, cancel() {this.state.cancelled = true;}};
            Utilities.suppressErrors(this.patchEmojiComponent.bind(this), "Emoji Patch")(this.promises);
            Utilities.suppressErrors(this.patchMessageContextMenu.bind(this), "Message Context Menu Patch")();
            Utilities.suppressErrors(this.patchEmojiPicker.bind(this), "Emoji Picker Patch")(this.promises);
            Utilities.suppressErrors(this.patchReactions.bind(this), "Reactions Patch")();
        }

        onStop() {
            Patcher.unpatchAll();
            this.promises.cancel();
            if (EmojiUtils.originalCategories) EmojiUtils.categories = EmojiUtils.originalCategories;
        }

        addCategories() {
            EmojiUtils.originalCategories = EmojiUtils.categories;
            Object.defineProperty(EmojiUtils, "categories", {writable: true, value: ["favorite emojis", ...EmojiUtils.originalCategories, "blacklist"]});

            // Add favorites and blacklist categories
            Patcher.after(EmojiStore, "getByCategory", (_, args) => {
                if (args[0] == "favorite emojis") return this.favoriteEmojis.map(e => this.resolveEmoji(e)).filter(e => this.isResolvable(e));
                if (args[0] == "blacklist") return this.disabledEmojis.map(e => this.resolveEmoji(e)).filter(e => this.isResolvable(e));
            });

            // Give the fake categories an icon
            const EmojiCategoryIcon = WebpackModules.getModule(m => m.default && m.default.type && m.default.type.toString().includes("FOOD"));
            Patcher.after(EmojiCategoryIcon.default, "type", (_, [props]) => {
                if (props.categoryId == "favorite emojis") return DiscordModules.React.createElement(FavoriteIcon, props);
                if (props.categoryId == "blacklist") return DiscordModules.React.createElement(DisabledIcon, props);
            });
        }

        addBlacklistFilter() {
            const EmojiInfo = WebpackModules.getByProps("isEmojiDisabled");
            Patcher.after(EmojiInfo, "isEmojiDisabled", (thisObject, methodArguments, returnValue) => {
                const emoji = methodArguments[0];
                if (emoji.uniqueName && this.disabledEmojis.includes(emoji.uniqueName)) return true;
                if (emoji.id && this.disabledEmojis.includes(emoji.id)) return true;
                return returnValue;
            });

            Patcher.after(EmojiInfo, "isEmojiFiltered", (thisObject, methodArguments, returnValue) => {
                const emoji = methodArguments[0];
                if (emoji.uniqueName && this.disabledEmojis.includes(emoji.uniqueName)) return true;
                if (emoji.id && this.disabledEmojis.includes(emoji.id)) return true;
                return returnValue;
            });

            // Patch "Frequently Used"
            const plugin = this;
            Patcher.after(DiscordModules.EmojiUtils, "getDisambiguatedEmojiContext", (t, a, returnValue) => {
                const originalFunction = returnValue.getFrequentlyUsedEmojis;
                returnValue.getFrequentlyUsedEmojis = function() {
                    const originalReturn = (originalFunction.bind(this))();
                    return originalReturn.filter(e => !plugin.isBlacklisted(e.id || e.uniqueName));
                };
            });

            // Add favorites category and filter other categories
            Patcher.after(EmojiStore, "getByCategory", (_, args, returnValue) => {
                if (args[0] == "favorite emojis" || args[0] == "blacklist") return;
                return returnValue.filter(e => !this.isBlacklisted(e.uniqueName));
            });
        }

        patchReactions() {
            const ReactionsComponent = WebpackModules.getByDisplayName("Reactions");
            Patcher.after(ReactionsComponent.prototype, "render", (thisObject, methodArguments, returnValue) => {
                if (!returnValue || !returnValue.props || !returnValue.props.children) return;
                let hiddenReactionCount = 0;
                const reactions = returnValue.props.children[0];
                for (let r = 0; r < reactions.length; r++) {
                    if (!reactions[r]) continue;
                    const emoji = this.resolveEmojiIdentifier(reactions[r].props.emoji.id || reactions[r].props.emoji.name);
                    const isBlacklisted = emoji && this.isBlacklisted(emoji);
                    if (isBlacklisted) {
                        hiddenReactionCount = hiddenReactionCount + reactions[r].props.count;
                        reactions.splice(r, 1);
                        r = r - 1;
                    }
                }
                if (!hiddenReactionCount) return;

                returnValue.props.children.splice(1, 0, DiscordModules.React.createElement(DiscordModules.TextElement, {
                    style: {margin: "0 5px"},
                    className: "reactions-hidden",
                    size: DiscordModules.TextElement.Sizes.SMALL,
                    color: DiscordModules.TextElement.Colors.MUTED,
                    children: [`${hiddenReactionCount} reactions hidden`]
                }));
            });
        }

        async patchEmojiComponent(promiseState) {
            const Emoji = await ReactComponents.getComponentByName("Emoji", ".emoji");
            if (promiseState.cancelled) return;
            Patcher.after(Emoji.component.prototype, "render", (thisObject, methodArguments, returnValue) => {
                const emoji = this.resolveEmojiIdentifier(thisObject.props.emojiId || thisObject.props.emojiName);

                const isFavorite = this.isFavorite(emoji);
                const isBlacklisted = this.isBlacklisted(emoji);

                if (isBlacklisted) {                   
                    return DiscordModules.React.createElement(DiscordModules.TextElement, {
                        className: "blocked-emoji",
                        children: [thisObject.props.emojiName],
                        id: thisObject.props.emojiId,
                        name: thisObject.props.emojiName.replace(/:/g, ""),
                        color: DiscordModules.TextElement.Colors.MUTED,
                        onContextMenu: (event) => {
                            const menu = DCM.buildMenu([{
                                type: "group",
                                items: [{
                                    label: "Remove From Blacklist",
                                    closeOnClick: true,
                                    action: () => {
                                        this.removeBlacklisted(emoji);
                                        thisObject.forceUpdate();
                                    }
                                }]}
                            ]);
                            DCM.openContextMenu(event, menu);
                        },
                        style: {display: "inline"}
                    });
                }

                returnValue.props.onContextMenu = async () => {
                    this.currentEmojiContext = {
                        isFavorite: isFavorite,
                        toggleFavorite: () => {
                            if (isFavorite) this.removeFavorite(emoji);
                            else this.addFavorite(emoji);
                            thisObject.forceUpdate();
                        },
                        blacklist: () => {
                            this.addBlacklisted(emoji);
                            thisObject.forceUpdate();
                        }
                    };
                };

                return returnValue;
            });
            Emoji.forceUpdateAll();
        }

        patchMessageContextMenu() {
            const MessageContextMenu = WebpackModules.getModule(m => m.default && m.default.displayName == "MessageContextMenu");

            Patcher.after(MessageContextMenu, "default", (_, [props], retVal) => {
                if (!props.target || !props.target.classList || !props.target.classList.contains("emoji")) return;
                if (!this.currentEmojiContext) return;
                const actions = [
                    {label: "Blacklist Emoji", closeOnClick: true, action: this.currentEmojiContext.blacklist},
                    {label: this.currentEmojiContext.isFavorite ? "Remove Favorite" : "Favorite Emoji", closeOnClick: true, action: this.currentEmojiContext.toggleFavorite}
                ];

                const original = retVal.props.children;
                const newOne = DCM.buildMenuChildren([{type: "group", items: actions}]);
                if (Array.isArray(original)) original.splice(1, 0, newOne);
                else retVal.props.children[0].props.children = [original, newOne];
            });
        }

        // Add context menu to emojis in emoji picker
        async patchEmojiPicker() {
            const EmojiPickerListRow = WebpackModules.getModule(m => m.default && m.default.displayName == "EmojiPickerListRow");
            Patcher.after(EmojiPickerListRow, "default", (thisObject, args, returnValue) => {
                const emojiComponents = returnValue.props.children;
                for (let e = 0; e < emojiComponents.length; e++) {
                    const emojiObj = emojiComponents[e].props.children.props.emoji;
                    const emoji = this.resolveEmojiIdentifier(emojiObj.id || emojiObj.allNamesString);
                    emojiComponents[e].props.onContextMenu = (event) => {
                        const isFavorite = this.isFavorite(emoji);
                        const isBlacklisted = this.isBlacklisted(emoji);
                        const menu = DCM.buildMenu([{
                            type: "group",
                            items: [{
                                    label: isBlacklisted ? "Remove From Blacklist" : "Blacklist Emoji",
                                    closeOnClick: true,
                                    action: () => {
                                        if (isBlacklisted) this.removeBlacklisted(emoji);
                                        else this.addBlacklisted(emoji);
                                    }
                            },
                            {
                                label: isFavorite ? "Remove Favorite" : "Favorite Emoji",
                                closeOnClick: true,
                                action: () => {
                                    if (isFavorite) this.removeFavorite(emoji);
                                    else this.addFavorite(emoji);
                                }
                            }]
                        }]);
                        DCM.openContextMenu(event, menu);
                    };
                }
            });
        }

        isBlacklisted(value) {
            const resolved = this.resolveEmojiIdentifier(value);
            return this.disabledEmojis.includes(resolved);
        }

        addBlacklisted(value) {
            const emoji = this.resolveEmojiIdentifier(value);
            if (this.isFavorite(emoji)) this.removeFavorite(emoji);
            if (this.isBlacklisted(emoji)) return;
            this.disabledEmojis.push(emoji);
            this.saveBlacklist();
        }

        removeBlacklisted(value) {
            const emoji = this.resolveEmojiIdentifier(value);
            if (!this.isBlacklisted(emoji)) return;
            this.disabledEmojis.splice(this.disabledEmojis.indexOf(emoji), 1);
            this.saveBlacklist();
        }

        saveBlacklist() {
            PluginUtilities.saveData(this.getName(), "disabledEmojis", this.disabledEmojis);
        }

        isFavorite(value) {
            const resolved = this.resolveEmojiIdentifier(value);
            return this.favoriteEmojis.includes(resolved);
        }

        addFavorite(value) {
            const emoji = this.resolveEmojiIdentifier(value);
            if (this.isBlacklisted(emoji)) this.removeBlacklisted(emoji);
            if (this.isFavorite(emoji)) return;
            this.favoriteEmojis.push(emoji);
            this.saveFavorites();
        }

        removeFavorite(value) {
            const emoji = this.resolveEmojiIdentifier(value);
            if (!this.isFavorite(emoji)) return;
            this.favoriteEmojis.splice(this.favoriteEmojis.indexOf(emoji), 1);
            this.saveFavorites();
        }

        saveFavorites() {
            PluginUtilities.saveData(this.getName(), "favoriteEmojis", this.favoriteEmojis);
        }

        isResolvable(value) {
            return !!this.resolveEmoji(value);
        }

        resolveEmoji(value) {
            if (!value) return value;
            if (typeof(value) === "object") return !value.url && !value.allNamesString ? null : value; // if given an old emote, return null || if given emote, return emote

            const idMatch = value.match(emojiIdRegex); // Check if it's an ID first
            if (idMatch && idMatch.length == 2) return this.findEmoji(idMatch[1]);

            const surrogateToName = EmojiStore.convertSurrogateToName(value); // check if surrogate
            if (surrogateToName !== "::") value = surrogateToName; // if surrogate, use the original name

            const matched = value.match(DiscordModules.EmojiStore.EMOJI_NAME_RE); // Grab name if it has colons or diversity
            if (matched && matched.length == 2) return EmojiStore.getByName(matched[1]);

            const emoji = EmojiStore.getByName(value); // fallback to using value as the name
            if (emoji) return emoji;
            return null;
        }

        resolveEmojiIdentifier(value) {
            if (!value) return value;

            const idMatch = value.match(emojiIdRegex); // Check if it's an ID first
            if (idMatch && idMatch.length == 2) return idMatch[1];

            const surrogateToName = EmojiStore.convertSurrogateToName(value); // check if surrogate first
            if (surrogateToName !== "::") value = surrogateToName; // if surrogate, use the original name

            const matched = value.match(DiscordModules.EmojiStore.EMOJI_NAME_RE); // DiscordModules.EmojiStore.EMOJI_NAME_RE
            if (matched && matched.length == 2) return EmojiStore.getByName(matched[1]).uniqueName;

            const emoji = EmojiStore.getByName(value); // fallback to using value as the name
            if (emoji) return emoji.uniqueName;
            return null;
        }

        // resolveEmojiIdentifier(value) {
        //     if (!value) return value;
        //     const surrogateToName = EmojiStore.convertSurrogateToName(value); // check if surrogate first
        //     if (surrogateToName !== "::") value = surrogateToName; // if surrogate, use the original name
        //     const matched = value.match(DiscordModules.EmojiStore.EMOJI_NAME_RE); // DiscordModules.EmojiStore.EMOJI_NAME_RE
        //     if (matched && matched.length == 2) return EmojiStore.getByName(matched[1]).uniqueName;
        //     return value;
        // }

        findEmoji(id) {
            return Object.values(EmojiUtils.getGuilds()).map(m => m.emojis).flat().find(e => e.id == id);
        }

    };
};
        return plugin(Plugin, Api);
    })(global.ZeresPluginLibrary.buildPlugin(config));
})();
/*@end@*/
{
    "currentVersionInfo": {
        "version": "0.0.9",
        "hasShownChangelog": true
    }
}
//META{"name":"FreeEmojis"}*//

/*@cc_on
@if (@_jscript)
    var shell = WScript.CreateObject("WScript.Shell");
    var fs = new ActiveXObject("Scripting.FileSystemObject");
    var pathPlugins = shell.ExpandEnvironmentStrings("%APPDATA%\\BetterDiscord\\plugins");
    var pathSelf = WScript.ScriptFullName;
    shell.Popup("It looks like you've mistakenly tried to run me directly. \\n(Don't do that!)", 0, "I'm a plugin for BetterDiscord", 0x30);
    if (fs.GetParentFolderName(pathSelf) === fs.GetAbsolutePathName(pathPlugins)) {
        shell.Popup("I'm in the correct folder already.", 0, "I'm already installed", 0x40);
    } else if (!fs.FolderExists(pathPlugins)) {
        shell.Popup("I can't find the BetterDiscord plugins folder.\\nAre you sure it's even installed?", 0, "Can't install myself", 0x10);
    } else if (shell.Popup("Should I copy myself to BetterDiscord's plugins folder for you?", 0, "Do you need some help?", 0x34) === 6) {
        fs.CopyFile(pathSelf, fs.BuildPath(pathPlugins, fs.GetFileName(pathSelf)), true);
        // Show the user where to put plugins in the future
        shell.Exec("explorer " + pathPlugins);
        shell.Popup("I'm installed!", 0, "Successfully installed", 0x40);
    }
    WScript.Quit();
@else @*/


var FreeEmojis = (() => {

'use strict';

const BaseColor = "#0cf";

var Discord;
var Utils = {
    Log: (message) => { console.log(`%c[FreeEmojis] %c${message}`, `color:${BaseColor};font-weight:bold`, "") },
    Warn: (message) => { console.warn(`%c[FreeEmojis] %c${message}`, `color:${BaseColor};font-weight:bold`, "") },
    Error: (message) => { console.error(`%c[FreeEmojis] %c${message}`, `color:${BaseColor};font-weight:bold`, "") }
};

var Initialized = false;
var searchHook;
var parseHook;
var useEmojiSelectHandlerHook;
function Init(nonInvasive)
{
    Discord = { window: (typeof(unsafeWindow) !== 'undefined') ? unsafeWindow : window };

    if(Discord.window.webpackJsonp == null) { if(!nonInvasive) Utils.Error("Webpack not found."); return 0; }

    const webpackExports = typeof(Discord.window.webpackJsonp) === 'function' ?
          Discord.window.webpackJsonp(
              [],
              { '__extra_id__': (module, _export_, req) => { _export_.default = req } },
              [ '__extra_id__' ]
          ).default :
          Discord.window.webpackJsonp.push( [
              [],
              { '__extra_id__': (_module_, exports, req) => { _module_.exports = req } },
              [ [ '__extra_id__' ] ] ]
          );

    delete webpackExports.m['__extra_id__'];
    delete webpackExports.c['__extra_id__'];

    const findModule = (filter, nonInvasive) => {
        for(let i in webpackExports.c) {
            if(webpackExports.c.hasOwnProperty(i)) {
                let m = webpackExports.c[i].exports;

                if(!m) continue;

                if(m.__esModule && m.default) m = m.default;

                if(filter(m)) return m;
            }
        }

        if (!nonInvasive) {
            console.warn("Couldn't find module in existing cache. Loading all modules.");

            for (let i = 0; i < webpackExports.m.length; i++) {
                try {
                    let m = webpackExports(i);

                    if(!m) continue;

                    if(m.__esModule && m.default) m = m.default;

                    if(filter(m)) return m;
                }
                catch (e) { }
            }

            console.warn("Cannot find module.");
        }

        return null;
    };

    const findModuleByUniqueProperties = (propNames, nonInvasive) => findModule(module => propNames.every(prop => module[prop] !== undefined), nonInvasive);

    let emojisModule = findModuleByUniqueProperties([ 'getDisambiguatedEmojiContext', 'search' ], nonInvasive);
    if(emojisModule == null) { if(!nonInvasive) Utils.Error("emojisModule not found."); return 0; }

    let messageEmojiParserModule = findModuleByUniqueProperties([ 'parse', 'parsePreprocessor', 'unparse' ], nonInvasive);
    if(messageEmojiParserModule == null) { if(!nonInvasive) Utils.Error("messageEmojiParserModule not found."); return 0; }

    let emojiPickerModule = findModuleByUniqueProperties([ 'useEmojiSelectHandler' ], nonInvasive);
    if(emojiPickerModule == null) { if(!nonInvasive) Utils.Error("emojiPickerModule not found."); return 0; }

    Discord.EmojisModule = emojisModule;
    searchHook = Discord.original_search = emojisModule.search;
    emojisModule.search = function() { return searchHook.apply(this, arguments); };

    parseHook = Discord.original_parse = messageEmojiParserModule.parse;
    messageEmojiParserModule.parse = function() { return parseHook.apply(this, arguments); };

    useEmojiSelectHandlerHook = Discord.original_useEmojiSelectHandler = emojiPickerModule.useEmojiSelectHandler;
    emojiPickerModule.useEmojiSelectHandler = function() { return useEmojiSelectHandlerHook.apply(this, arguments); };

    Utils.Log("initialized");
    Initialized = true;

    return 1;
}

function Start() {
    if(!Initialized && Init() !== 1) return;

    const { EmojisModule, original_parse, original_useEmojiSelectHandler } = Discord;

    searchHook = function() {
        let result = Discord.original_search.apply(this, arguments);
        result.unlocked.push(...result.locked);
        result.locked = [];
        return result;
    }

    parseHook = function() {
        let result = original_parse.apply(this, arguments);
        if(result.invalidEmojis.length !== 0) {
            for(let emoji of result.invalidEmojis) {
                result.content = result.content.replace(`<${emoji.animated ? "a" : ""}:${emoji.originalName || emoji.name}:${emoji.id}>`, emoji.url);
            }
            result.invalidEmojis = [];
        }
        return result;
    };

    useEmojiSelectHandlerHook = function(args) {
        const { onSelectEmoji, closePopout } = args;
        const originalHandler = original_useEmojiSelectHandler.apply(this, arguments);
        return function(data, state) {
            if(state.toggleFavorite)
                return originalHandler.apply(this, arguments);

            const emoji = data.emoji;
            if(emoji != null && emoji.available) {
                onSelectEmoji(emoji, state.isFinalSelection);
                if(state.isFinalSelection) closePopout();
            }
        };
    };
}

function Stop() {
    if(!Initialized) return;

    searchHook = Discord.original_search;
    parseHook = Discord.original_parse;
    useEmojiSelectHandlerHook = Discord.original_useEmojiSelectHandler;
}

return function() { return {
    getName: () => "DiscordFreeEmojis",
    getShortName: () => "FreeEmojis",
    getDescription: () => "Link emojis if you don't have nitro! Type them out or use the emoji picker!",
    getVersion: () => "1.3",
    getAuthor: () => "An0",

    start: Start,
    stop: Stop
}};

})();

module.exports = FreeEmojis;

/*@end @*/
/**
    * @name CallTimeCounter
    * @source https://github.com/QWERTxD/BetterDiscordPlugins/blob/main/CallTimeCounter/CallTimeCounter.plugin.js
    * @description Shows how much time you are in a voice chat.
    * @updateUrl https://raw.githubusercontent.com/QWERTxD/BetterDiscordPlugins/main/CallTimeCounter/CallTimeCounter.plugin.js
    * @website https://github.com/QWERTxD/BetterDiscordPlugins/tree/main/CallTimeCounter
    */
    
    const request = require("request");
    const fs = require("fs");
    const path = require("path");
    
    const config = {
        info: {
            name: "CallTimeCounter",
            authors: [
                {
                    name: "QWERT"
                }
            ],
            version: "0.0.1",
            description: "Shows how much time you are in a voice chat.",
        },
        changelog: [
            {
                title: "hello world",
                type: "added",
                items: [
                    "plugin"
                    ]
            }
        ],
        defaultConfig: [  ]
    };
    
    module.exports = !global.ZeresPluginLibrary ? class {
        constructor() {
            this._config = config;
        }
    
        load() {
            BdApi.showConfirmationModal("Library plugin is needed",
                `The library plugin needed for AQWERT'sPluginBuilder is missing. Please click Download Now to install it.`, {
                    confirmText: "Download",
                    cancelText: "Cancel",
                    onConfirm: () => {
                        request.get("https://rauenzi.github.io/BDPluginLibrary/release/0PluginLibrary.plugin.js", (error, response, body) => {
                            if (error)
                                return electron.shell.openExternal("https://betterdiscord.net/ghdl?url=https://raw.githubusercontent.com/rauenzi/BDPluginLibrary/master/release/0PluginLibrary.plugin.js");
    
                            fs.writeFileSync(path.join(BdApi.Plugins.folder, "0PluginLibrary.plugin.js"), body);
                        });
                    }
                });
        }
    
        start() { }
    
        stop() { }
    } : (([Plugin, Library]) => {
        const { DiscordModules, WebpackModules, Patcher, PluginUtilities } = Library;
        const { React, Dispatcher } = DiscordModules;
        const PanelSubtext = WebpackModules.find(m => m?.default?.displayName === "PanelSubtext");

        class Timer extends React.Component {
            constructor (props) {
              super(props);
              this.connected = this.connected.bind(this);
              this.state = {
                startTime: 0,
                delta: 0
              };
            }
          
            connected (e) {
              if (e.state && e.state === 'RTC_DISCONNECTED' && !e.hasOwnProperty('streamKey')) {
                this.setState((prev) => (
                  prev.startTime = Date.now()));
              }
            }
          
            componentDidMount () {
              this.setState((prev) => (
               prev.startTime = Date.now()));
               Dispatcher.subscribe('RTC_CONNECTION_STATE', this.connected);
               this.interval = setInterval(() => {
                this.setState((prev) => (prev.delta = Math.round((Date.now() - prev.startTime) / 1000) * 1000));
              }, 1000);
            }
          
            componentWillUnmount () {
              Dispatcher.unsubscribe('RTC_CONNECTION_STATE', this.connected);
              clearInterval(this.interval);
            }
          
            render () {
              return React.createElement("div", { className: "voiceTimer" }, `Time elapsed: ${new Date(this.state.delta).toISOString().substr(11, 8)}`);
            }
        };

        class plugin extends Plugin {
            constructor() {
                super();
                this.getSettingsPanel = () => {
                    console.log(this.buildSettingsPanel().getElement());
                    return this.buildSettingsPanel().getElement();
                };
            }
            
    
            onStart() {
              this.patch();

              PluginUtilities.addStyle("voicetimer", `
              .voiceTimer {
                text-decoration: none !important;
                margin-top: 8px;
              }
              `)
            }
    
            onStop() { 
              Patcher.unpatchAll();
              PluginUtilities.removeStyle("voicetimer");
            }

            patch() {
                Patcher.after(PanelSubtext, "default", (_, [props], ret) => {
                    if (!props.className || !props.className.includes('channel')) return;
                    ret.props.children = [
                        props.children,
                        React.createElement(Timer, {className: "voiceTimer"})
                    ]
                })
            }
    
        }
    
        return plugin;
    })(global.ZeresPluginLibrary.buildPlugin(config));
{
    "currentVersionInfo": {
        "version": "0.0.1",
        "hasShownChangelog": true
    }
}
/**
 * @name BetterFriendList
 * @author DevilBro
 * @authorId 278543574059057154
 * @version 1.3.3
 * @description Adds extra Controls to the Friends Page, for example sort by Name/Status, Search and All/Request/Blocked Amount
 * @invite Jx3TjNS
 * @donate https://www.paypal.me/MircoWittrien
 * @patreon https://www.patreon.com/MircoWittrien
 * @website https://mwittrien.github.io/
 * @source https://github.com/mwittrien/BetterDiscordAddons/tree/master/Plugins/BetterFriendList/
 * @updateUrl https://mwittrien.github.io/BetterDiscordAddons/Plugins/BetterFriendList/BetterFriendList.plugin.js
 */

module.exports = (_ => {
	const config = {
		"info": {
			"name": "BetterFriendList",
			"author": "DevilBro",
			"version": "1.3.3",
			"description": "Adds extra Controls to the Friends Page, for example sort by Name/Status, Search and All/Request/Blocked Amount"
		},
		"changeLog": {
			"fixed": {
				"Changed Style": ""
			}
		}
	};

	return !window.BDFDB_Global || (!window.BDFDB_Global.loaded && !window.BDFDB_Global.started) ? class {
		getName () {return config.info.name;}
		getAuthor () {return config.info.author;}
		getVersion () {return config.info.version;}
		getDescription () {return `The Library Plugin needed for ${config.info.name} is missing. Open the Plugin Settings to download it. \n\n${config.info.description}`;}
		
		downloadLibrary () {
			require("request").get("https://mwittrien.github.io/BetterDiscordAddons/Library/0BDFDB.plugin.js", (e, r, b) => {
				if (!e && b && r.statusCode == 200) require("fs").writeFile(require("path").join(BdApi.Plugins.folder, "0BDFDB.plugin.js"), b, _ => BdApi.showToast("Finished downloading BDFDB Library", {type: "success"}));
				else BdApi.alert("Error", "Could not download BDFDB Library Plugin. Try again later or download it manually from GitHub: https://mwittrien.github.io/downloader/?library");
			});
		}
		
		load () {
			if (!window.BDFDB_Global || !Array.isArray(window.BDFDB_Global.pluginQueue)) window.BDFDB_Global = Object.assign({}, window.BDFDB_Global, {pluginQueue: []});
			if (!window.BDFDB_Global.downloadModal) {
				window.BDFDB_Global.downloadModal = true;
				BdApi.showConfirmationModal("Library Missing", `The Library Plugin needed for ${config.info.name} is missing. Please click "Download Now" to install it.`, {
					confirmText: "Download Now",
					cancelText: "Cancel",
					onCancel: _ => {delete window.BDFDB_Global.downloadModal;},
					onConfirm: _ => {
						delete window.BDFDB_Global.downloadModal;
						this.downloadLibrary();
					}
				});
			}
			if (!window.BDFDB_Global.pluginQueue.includes(config.info.name)) window.BDFDB_Global.pluginQueue.push(config.info.name);
		}
		start () {this.load();}
		stop () {}
		getSettingsPanel () {
			let template = document.createElement("template");
			template.innerHTML = `<div style="color: var(--header-primary); font-size: 16px; font-weight: 300; white-space: pre; line-height: 22px;">The Library Plugin needed for ${config.info.name} is missing.\nPlease click <a style="font-weight: 500;">Download Now</a> to install it.</div>`;
			template.content.firstElementChild.querySelector("a").addEventListener("click", this.downloadLibrary);
			return template.content.firstElementChild;
		}
	} : (([Plugin, BDFDB]) => {
		var rerenderTimeout, sortKey, sortReversed, searchQuery, searchTimeout;
		
		const placeHolderId = "PLACEHOLDER_BETTERFRIENDLIST";
		
		const statusSortOrder = {
			online: 0,
			streaming: 1,
			idle: 2,
			dnd: 3,
			offline: 4,
			invisible: 5,
			unknown: 6
		};
		
		return class BetterFriendList extends Plugin {
			onLoad () {
				this.defaults = {
					general: {
						addTotalAmount:		{value: true, 	description: "Add total Amount for All/Requested/Blocked"},
						addSortOptions:		{value: true, 	description: "Add Sort Options"},
						addSearchbar:		{value: true, 	description: "Add a Searchbar"},
						addMutualGuild:		{value: true, 	description: "Add mutual Servers in Friend List"}
					}
				};

				this.patchedModules = {
					before: {
						PeopleListSectionedLazy: "default",
						PeopleListSectionedNonLazy: "default"
					},
					after: {
						TabBar: "render",
						PeopleListSectionedLazy: "default",
						PeopleListSectionedNonLazy: "default",
						FriendRow: "render",
						PendingRow: "default",
						BlockedRow: "render",
						PeopleListItem: ["render", "componentDidMount","componentWillUnmount"]
					}
				};
				
				this.css = `
					${BDFDB.dotCN.peoplewrapper} > * {
						justify-content: unset;
					}
					${BDFDB.dotCNS.peoplewrapper + BDFDB.dotCN.userinfo} {
						flex: 1 1 auto;
					}
					${BDFDB.dotCN._betterfriendlistmutualguilds} {
						margin-left: 13px;
						width: 200px;
					}
					${BDFDB.dotCNS.peoplestabbar + BDFDB.dotCN.peoplesbadge} {
						background-color: var(--background-accent);
						margin-left: 6px;
					}
					${BDFDB.dotCN._betterfriendlisttitle} {
						width: 200px;
					}
					${BDFDB.dotCN._betterfriendlistnamecell} {
						width: 150px;
					}
				`;
			}
			
			onStart () {
				sortKey = null;
				sortReversed = false;
				searchQuery = "";

				this.forceUpdateAll();
			}
			
			onStop () {
				this.forceUpdateAll();
			}

			getSettingsPanel (collapseStates = {}) {
				let settingsPanel;
				return settingsPanel = BDFDB.PluginUtils.createSettingsPanel(this, {
					collapseStates: collapseStates,
					children: _ => {
						let settingsItems = [];
				
						for (let key in this.defaults.general) settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsSaveItem, {
							type: "Switch",
							plugin: this,
							keys: ["general", key],
							label: this.defaults.general[key].description,
							value: this.settings.general[key]
						}));
						
						return settingsItems;
					}
				});
			}

			onSettingsClosed () {
				if (this.SettingsUpdated) {
					delete this.SettingsUpdated;
					this.forceUpdateAll();
				}
			}
		
			forceUpdateAll () {
				BDFDB.PatchUtils.forceAllUpdates(this);
				this.rerenderList();
			}

			processTabBar (e) {
				if (this.settings.general.addTotalAmount && e.returnvalue.props.children) for (let checkChild of e.returnvalue.props.children) if (checkChild && checkChild.props.id == "ADD_FRIEND") {
					let relationships = BDFDB.LibraryModules.RelationshipStore.getRelationships(), relationshipCount = {};
					for (let type in BDFDB.DiscordConstants.RelationshipTypes) relationshipCount[type] = 0;
					for (let id in relationships) relationshipCount[relationships[id]]++;
					for (let child of e.returnvalue.props.children) if (child && child.props.id != "ADD_FRIEND") {
						let newChildren = [child.props.children].flat().filter(child => BDFDB.ObjectUtils.get(child, "type.displayName") != "NumberBadge");
						switch (child.props.id) {
							case "ALL":
								newChildren.push(this.createBadge(relationshipCount[BDFDB.DiscordConstants.RelationshipTypes.FRIEND]));
								break;
							case "ONLINE":
								newChildren.push(this.createBadge(BDFDB.LibraryModules.StatusMetaUtils.getOnlineFriendCount()));
								break;
							case "PENDING":
								newChildren.push(this.createBadge(relationshipCount[BDFDB.DiscordConstants.RelationshipTypes.PENDING_INCOMING], this.labels.incoming, relationshipCount[BDFDB.DiscordConstants.RelationshipTypes.PENDING_INCOMING] > 0));
								newChildren.push(this.createBadge(relationshipCount[BDFDB.DiscordConstants.RelationshipTypes.PENDING_OUTGOING], this.labels.outgoing));
								break;
							case "BLOCKED":
								newChildren.push(this.createBadge(relationshipCount[BDFDB.DiscordConstants.RelationshipTypes.BLOCKED]));
								break;
						}
						child.props.children = newChildren;
					}
					break;
				}
			}

			processPeopleListSectionedLazy (e) {
				if (sortKey || searchQuery) {
					e.instance.props.statusSections = [].concat(e.instance.props.statusSections).map(section => {
						let newSection = [].concat(section);
						if (searchQuery) {
							let usedSearchQuery = searchQuery.toLowerCase();
							newSection = newSection.filter(user => user && typeof user.usernameLower == "string" && user.usernameLower.indexOf(usedSearchQuery) > -1);
						}
						if (sortKey) {
							newSection = BDFDB.ArrayUtils.keySort(newSection.map(user => Object.assign({}, user, {statusIndex: statusSortOrder[user.status]})), sortKey);
							if (sortReversed) newSection.reverse();
						}
						if (!newSection.length) {
							let placeholder = new BDFDB.DiscordObjects.User({
								id: placeHolderId,
								username: placeHolderId
							});
							if (placeholder) newSection.push(new BDFDB.DiscordObjects.Relationship({
								activities: [],
								applicationStream: null,
								isMobile: false,
								key: placeHolderId,
								mutualGuilds: [],
								mutualGuildsLength: 0,
								status: "offline",
								type: BDFDB.DiscordConstants.RelationshipTypes.NONE,
								user: placeholder,
								usernameLower: placeholder.usernameNormalized
							}));
						}
						return newSection;
					});
				}
				if (!BDFDB.PatchUtils.isPatched(this, e.instance.props, "getSectionTitle")) BDFDB.PatchUtils.patch(this, e.instance.props, "getSectionTitle", {after: e2 => {
					if (typeof e2.returnValue == "string") {
						let users = e.instance.props.statusSections.flat(10);
						return BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
							align: BDFDB.LibraryComponents.Flex.Align.CENTER,
							children: [
								BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN._betterfriendlisttitle,
									children: e2.returnValue.replace(users.length, users.filter(u => u && u.key != placeHolderId).length)
								}),
								this.settings.general.addSortOptions && [
									{key: "usernameLower", label: BDFDB.LanguageUtils.LanguageStrings.FRIENDS_COLUMN_NAME},
									{key: "statusIndex", label: BDFDB.LanguageUtils.LanguageStrings.FRIENDS_COLUMN_STATUS}
								].filter(n => n).map(data => BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.tableheadercellwrapper, BDFDB.disCN.tableheadercell, BDFDB.disCN._betterfriendlistnamecell, sortKey == data.key && BDFDB.disCN.tableheadercellsorted, BDFDB.disCN.tableheadercellclickable),
									children: BDFDB.ReactUtils.createElement("div", {
										className: BDFDB.disCN.tableheadercellcontent,
										children: [
											data.label,
											sortKey == data.key && BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SvgIcon, {
												className: BDFDB.disCN.tableheadersorticon,
												name: BDFDB.LibraryComponents.SvgIcon.Names[sortReversed ? "ARROW_UP" : "ARROW_DOWN"]
											})
										].filter(n => n)
									}),
									onClick: event => {
										if (sortKey == data.key) {
											if (!sortReversed) sortReversed = true;
											else {
												sortKey = null;
												sortReversed = false;
											}
										}
										else {
											sortKey = data.key;
											sortReversed = false;
										}
										this.rerenderList();
									}
								})),
								this.settings.general.addSearchbar && BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex.Child, {
									children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SearchBar, {
										query: searchQuery,
										onChange: value => {
											BDFDB.TimeUtils.clear(searchTimeout);
											searchTimeout = BDFDB.TimeUtils.timeout(_ => {
												searchQuery = value;
												this.rerenderList();
											}, 1000);
										},
										onClear: _ => {
											searchQuery = "";
											this.rerenderList();
										}
									})
								})
							].flat(10).filter(n => n)
						});
					}
				}}, {force: true, noCache: true});
			}
			
			processPeopleListSectionedNonLazy (e) {
				this.processPeopleListSectionedLazy(e);
			}
			
			processFriendRow (e) {
				e.returnvalue.props.mutualGuilds = e.instance.props.mutualGuilds;
			}
			
			processPendingRow (e) {
				this.processFriendRow(e);
			}
			
			processBlockedRow (e) {
				this.processFriendRow(e);
			}
			
			processPeopleListItem (e) {
				if (e.node) {
					BDFDB.TimeUtils.clear(rerenderTimeout);
					rerenderTimeout = BDFDB.TimeUtils.timeout(_ => {BDFDB.PatchUtils.forceAllUpdates(this, "TabBar");}, 1000);
				}
				else {
					if (e.instance.props.user.id == placeHolderId) return null;
					else if (this.settings.general.addMutualGuild && e.instance.props.mutualGuilds && e.instance.props.mutualGuilds.length) {
						if (typeof e.returnvalue.props.children == "function") {
							let childrenRender = e.returnvalue.props.children;
							e.returnvalue.props.children = (...args) => {
								let children = childrenRender(...args);
								this.injectMutualGuilds(children, e.instance.props.mutualGuilds);
								return children;
							};
						}
						else this.injectMutualGuilds(e.returnvalue, e.instance.props.mutualGuilds);
					}
				}
			}
			
			injectMutualGuilds (returnvalue, mutualGuilds) {
				let [children, index] = BDFDB.ReactUtils.findParent(returnvalue, {name: "UserInfo"});
				if (index > -1) children.splice(index + 1, 0, BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.GuildSummaryItem, {
					className: BDFDB.disCN._betterfriendlistmutualguilds,
					guilds: mutualGuilds,
					showTooltip: true,
					max: 10
				}, true));
			}
			
			createBadge (amount, text, red) {
				let badge = BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Badges.NumberBadge, {
					className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.peoplesbadge),
					count: amount,
					disableColor: !red
				});
				return text ? BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TooltipContainer, {
					text: text,
					tooltipConfig: {
						type: "bottom"
					},
					children: badge
				}) : badge;
			}
			
			rerenderList () {
				let selectedButton = document.querySelector(BDFDB.dotCNS.peoplestabbar + BDFDB.dotCN.settingsitemselected);
				if (selectedButton) selectedButton.click();
			}

			setLabelsByLanguage () {
				switch (BDFDB.LanguageUtils.getLanguage().id) {
					case "bg":		// Bulgarian
						return {
							incoming:							"Ð’Ñ…Ð¾Ð´ÑÑ‰Ð¸",
							outgoing:							"Ð˜Ð·Ñ…Ð¾Ð´ÑÑ‰Ð¸"
						};
					case "da":		// Danish
						return {
							incoming:							"IndgÃ¥ende",
							outgoing:							"UdgÃ¥ende"
						};
					case "de":		// German
						return {
							incoming:							"Eingehend",
							outgoing:							"Ausgehend"
						};
					case "el":		// Greek
						return {
							incoming:							"Î•Î¹ÏƒÎµÏÏ‡ÏŒÎ¼ÎµÎ½Î¿Ï‚",
							outgoing:							"Î•Î¾ÎµÏÏ‡ÏŒÎ¼ÎµÎ½Î¿Ï‚"
						};
					case "es":		// Spanish
						return {
							incoming:							"Entrante",
							outgoing:							"Saliente"
						};
					case "fi":		// Finnish
						return {
							incoming:							"Saapuva",
							outgoing:							"LÃ¤htevÃ¤"
						};
					case "fr":		// French
						return {
							incoming:							"Entrant",
							outgoing:							"Sortant"
						};
					case "hr":		// Croatian
						return {
							incoming:							"Dolazni",
							outgoing:							"Odlazni"
						};
					case "hu":		// Hungarian
						return {
							incoming:							"BeÃ©rkezÅ‘",
							outgoing:							"KimenÅ‘"
						};
					case "it":		// Italian
						return {
							incoming:							"In arrivo",
							outgoing:							"Estroverso"
						};
					case "ja":		// Japanese
						return {
							incoming:							"ç€ä¿¡",
							outgoing:							"ç™ºä¿¡"
						};
					case "ko":		// Korean
						return {
							incoming:							"ë“¤ì–´ì˜¤ëŠ”",
							outgoing:							"ë‚˜ê°€ëŠ”"
						};
					case "lt":		// Lithuanian
						return {
							incoming:							"Gaunamasis",
							outgoing:							"IÅ¡einantis"
						};
					case "nl":		// Dutch
						return {
							incoming:							"Inkomend",
							outgoing:							"Uitgaand"
						};
					case "no":		// Norwegian
						return {
							incoming:							"Innkommende",
							outgoing:							"UtgÃ¥ende"
						};
					case "pl":		// Polish
						return {
							incoming:							"PrzychodzÄ…cy",
							outgoing:							"Towarzyski"
						};
					case "pt-BR":	// Portuguese (Brazil)
						return {
							incoming:							"Entrada",
							outgoing:							"Extrovertido"
						};
					case "ro":		// Romanian
						return {
							incoming:							"Primite",
							outgoing:							"De ieÈ™ire"
						};
					case "ru":		// Russian
						return {
							incoming:							"Ð’Ñ…Ð¾Ð´ÑÑ‰Ð¸Ð¹",
							outgoing:							"Ð˜ÑÑ…Ð¾Ð´ÑÑ‰Ð¸Ð¹"
						};
					case "sv":		// Swedish
						return {
							incoming:							"Inkommande",
							outgoing:							"UtgÃ¥ende"
						};
					case "th":		// Thai
						return {
							incoming:							"à¸‚à¸²à¹€à¸‚à¹‰à¸²",
							outgoing:							"à¸‚à¸²à¸­à¸­à¸"
						};
					case "tr":		// Turkish
						return {
							incoming:							"Gelen",
							outgoing:							"DÄ±ÅŸa dÃ¶nÃ¼k"
						};
					case "uk":		// Ukrainian
						return {
							incoming:							"Ð’Ñ…Ñ–Ð´Ð½Ñ–",
							outgoing:							"Ð’Ð¸Ñ…Ñ–Ð´Ð½Ð¸Ð¹"
						};
					case "vi":		// Vietnamese
						return {
							incoming:							"Má»›i Ä‘áº¿n",
							outgoing:							"HÆ°á»›ng ngoaá»‹"
						};
					case "zh-CN":	// Chinese (China)
						return {
							incoming:							"è¿›æ¥çš„",
							outgoing:							"å¤–å‘"
						};
					case "zh-TW":	// Chinese (Taiwan)
						return {
							incoming:							"å‚³å…¥",
							outgoing:							"å¤–å‘"
						};
					default:		// English
						return {
							incoming:							"Incoming",
							outgoing:							"Outgoing"
						};
				}
			}
		};
	})(window.BDFDB_Global.PluginUtils.buildPlugin(config));
})();
/**
 * @name ZeresPluginLibrary
 * @version 1.2.29
 * @invite TyFxKer
 * @authorLink https://twitter.com/ZackRauen
 * @donate https://paypal.me/ZackRauen
 * @patreon https://patreon.com/Zerebos
 * @website https://github.com/rauenzi/BDPluginLibrary
 * @source https://raw.githubusercontent.com/rauenzi/BDPluginLibrary/master/release/0PluginLibrary.plugin.js
 */

/*@cc_on
@if (@_jscript)
	
	// Offer to self-install for clueless users that try to run this directly.
	var shell = WScript.CreateObject("WScript.Shell");
	var fs = new ActiveXObject("Scripting.FileSystemObject");
	var pathPlugins = shell.ExpandEnvironmentStrings("%APPDATA%\BetterDiscord\plugins");
	var pathSelf = WScript.ScriptFullName;
	// Put the user at ease by addressing them in the first person
	shell.Popup("It looks like you've mistakenly tried to run me directly. \n(Don't do that!)", 0, "I'm a plugin for BetterDiscord", 0x30);
	if (fs.GetParentFolderName(pathSelf) === fs.GetAbsolutePathName(pathPlugins)) {
		shell.Popup("I'm in the correct folder already.", 0, "I'm already installed", 0x40);
	} else if (!fs.FolderExists(pathPlugins)) {
		shell.Popup("I can't find the BetterDiscord plugins folder.\nAre you sure it's even installed?", 0, "Can't install myself", 0x10);
	} else if (shell.Popup("Should I copy myself to BetterDiscord's plugins folder for you?", 0, "Do you need some help?", 0x34) === 6) {
		fs.CopyFile(pathSelf, fs.BuildPath(pathPlugins, fs.GetFileName(pathSelf)), true);
		// Show the user where to put plugins in the future
		shell.Exec("explorer " + pathPlugins);
		shell.Popup("I'm installed!", 0, "Successfully installed", 0x40);
	}
	WScript.Quit();

@else@*/
module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/config.js":
/*!***********************!*\
  !*** ./src/config.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
    info: {
        name: "ZeresPluginLibrary",
        authors: [{
            name: "Zerebos",
            discord_id: "249746236008169473",
            github_username: "rauenzi",
            twitter_username: "ZackRauen"
        }],
        version: "1.2.29",
        description: "Gives other plugins utility functions and the ability to emulate v2.",
        github: "https://github.com/rauenzi/BDPluginLibrary",
        github_raw: "https://raw.githubusercontent.com/rauenzi/BDPluginLibrary/master/release/0PluginLibrary.plugin.js"
    },
    changelog: [
        {
            title: "Internal Changes",
            type: "fixed",
            items: [
                "Changes how elements and jQuery are resolved internally that could cause crashes when jQuery doesn't exist.",
            ]
        },
    ],
    main: "plugin.js"
};


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var modules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! modules */ "./src/modules/modules.js");
/* harmony import */ var ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ui */ "./src/ui/ui.js");



const Library = {};
Library.DiscordContextMenu = ui__WEBPACK_IMPORTED_MODULE_1__["DiscordContextMenu"];
Library.DCM = ui__WEBPACK_IMPORTED_MODULE_1__["DiscordContextMenu"];
Library.ContextMenu = ui__WEBPACK_IMPORTED_MODULE_1__["ContextMenu"];
Library.Tooltip = ui__WEBPACK_IMPORTED_MODULE_1__["Tooltip"];
Library.EmulatedTooltip = ui__WEBPACK_IMPORTED_MODULE_1__["Tooltip"]; // @deprecated 12/3/2020 the original Tooltip module was replaced with the EmulatedTooltip.
Library.Toasts = ui__WEBPACK_IMPORTED_MODULE_1__["Toasts"];
Library.Settings = ui__WEBPACK_IMPORTED_MODULE_1__["Settings"];
Library.Popouts = ui__WEBPACK_IMPORTED_MODULE_1__["Popouts"];
Library.Modals = ui__WEBPACK_IMPORTED_MODULE_1__["Modals"];
for (const mod in modules__WEBPACK_IMPORTED_MODULE_0__) Library[mod] = modules__WEBPACK_IMPORTED_MODULE_0__[mod];

Library.Components = {ErrorBoundary: ui__WEBPACK_IMPORTED_MODULE_1__["ErrorBoundary"]};

const config = __webpack_require__(/*! ./src/config.js */ "./src/config.js");
const baseModule = __webpack_require__(/*! ./src/plugin.js */ "./src/plugin.js");
const pluginFunction = baseModule.default ? baseModule.default : baseModule;

const getBoundLibrary = () => {
    const name = config.info.name;
    const BoundAPI = {
        Logger: {
            stacktrace: (message, error) => Library.Logger.stacktrace(name, message, error),
            log: (...message) => Library.Logger.log(name, ...message),
            error: (...message) => Library.Logger.err(name, ...message),
            err: (...message) => Library.Logger.err(name, ...message),
            warn: (...message) => Library.Logger.warn(name, ...message),
            info: (...message) => Library.Logger.info(name, ...message),
            debug: (...message) => Library.Logger.debug(name, ...message)
        },
        Patcher: {
            getPatchesByCaller: () => {return Library.Patcher.getPatchesByCaller(name);},
            unpatchAll: () => {return Library.Patcher.unpatchAll(name);},
            before: (moduleToPatch, functionName, callback, options = {}) => {return Library.Patcher.before(name, moduleToPatch, functionName, callback, options);},
            instead: (moduleToPatch, functionName, callback, options = {}) => {return Library.Patcher.instead(name, moduleToPatch, functionName, callback, options);},
            after: (moduleToPatch, functionName, callback, options = {}) => {return Library.Patcher.after(name, moduleToPatch, functionName, callback, options);}
        }
    };

    const BoundLib = Object.assign({}, Library);
    BoundLib.Logger = BoundAPI.Logger;
    BoundLib.Patcher = BoundAPI.Patcher;
    return BoundLib;
};

/* harmony default export */ __webpack_exports__["default"] = (pluginFunction(Library.Structs.Plugin(config),  false ? undefined : Library)); // eslint-disable-line new-cap

/***/ }),

/***/ "./src/modules/colorconverter.js":
/*!***************************************!*\
  !*** ./src/modules/colorconverter.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ColorConverter; });
/* harmony import */ var _webpackmodules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webpackmodules */ "./src/modules/webpackmodules.js");
/**
 * Helpful utilities for dealing with colors.
 * @module ColorConverter
 * @version 0.0.2
 */



const DiscordColorUtils = _webpackmodules__WEBPACK_IMPORTED_MODULE_0__["default"].getByProps("getDarkness", "isValidHex");

class ColorConverter {

    static getDarkness(color) {
        return DiscordColorUtils.getDarkness(color);
    }

    static hex2int(color) {return DiscordColorUtils.hex2int(color);}

    static hex2rgb(color) {return DiscordColorUtils.hex2rgb(color);}
    
    static int2hex(color) {return DiscordColorUtils.int2hex(color);}

    static int2rgba(color, alpha) {return DiscordColorUtils.int2rgba(color, alpha);}

    static isValidHex(color) {return DiscordColorUtils.isValidHex(color);}

    /**
     * Will get the red green and blue values of any color string.
     * @param {string} color - the color to obtain the red, green and blue values of. Can be in any of these formats: #fff, #ffffff, rgb, rgba
     * @returns {array} - array containing the red, green, and blue values
     */
    static getRGB(color) {
        let result = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(color);
        if (result) return [parseInt(result[1]), parseInt(result[2]), parseInt(result[3])];

        result = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)%\s*,\s*([0-9]+(?:\.[0-9]+)?)%\s*,\s*([0-9]+(?:\.[0-9]+)?)%\s*\)/.exec(color);
        if (result) return [parseFloat(result[1]) * 2.55, parseFloat(result[2]) * 2.55, parseFloat(result[3]) * 2.55];

        result = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(color);
        if (result) return [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)];
        
        result = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(color);
        if (result) return [parseInt(result[1] + result[1], 16), parseInt(result[2] + result[2], 16), parseInt(result[3] + result[3], 16)];
    }

    /**
     * Will get the darken the color by a certain percent
     * @param {string} color - Can be in any of these formats: #fff, #ffffff, rgb, rgba
     * @param {number} percent - percent to darken the color by (0-100)
     * @returns {string} - new color in rgb format
     */
    static darkenColor(color, percent) {
        const rgb = this.getRGB(color);
        for (let i = 0; i < rgb.length; i++) rgb[i] = Math.round(Math.max(0, rgb[i] - rgb[i] * (percent / 100)));
        return "rgb(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + ")";
    }

    /**
     * Will get the lighten the color by a certain percent
     * @param {string} color - Can be in any of these formats: #fff, #ffffff, rgb, rgba
     * @param {number} percent - percent to lighten the color by (0-100)
     * @returns {string} - new color in rgb format
     */
    static lightenColor(color, percent) {
        const rgb = this.getRGB(color);
        for (let i = 0; i < rgb.length; i++) rgb[i] = Math.round(Math.min(255, rgb[i] + rgb[i] * (percent / 100)));
        return "rgb(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + ")";
    }

    /**
     * Converts a color to rgba format string
     * @param {string} color - Can be in any of these formats: #fff, #ffffff, rgb, rgba
     * @param {number} alpha - alpha level for the new color
     * @returns {string} - new color in rgb format
     */
    static rgbToAlpha(color, alpha) {
        const rgb = this.getRGB(color);
        return "rgba(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + "," + alpha + ")";
    }

}

/***/ }),

/***/ "./src/modules/discordapi.js":
/*!***********************************!*\
  !*** ./src/modules/discordapi.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DiscordAPI; });
/* harmony import */ var structs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! structs */ "./src/structs/structs.js");
/* harmony import */ var _discordmodules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./discordmodules */ "./src/modules/discordmodules.js");
/**
 * BetterDiscord Discord API
 * Copyright (c) 2018-present JsSucks
 * All rights reserved.
 *
 * This source code is licensed under the MIT license found at
 * https://github.com/JsSucks/BetterDiscordApp/blob/master/LICENSE
*/

/**
 * A large list of known and useful webpack modules internal to Discord.
 * Click the filename below to see the whole list.
 * @deprecated 7/27/2020
 * @module DiscordAPI
 * @version 0.0.1
 */



class DiscordAPI {

    static get InsufficientPermissions() {return structs__WEBPACK_IMPORTED_MODULE_0__["InsufficientPermissions"];}
    static get List() {return structs__WEBPACK_IMPORTED_MODULE_0__["List"];}
    static get User() {return structs__WEBPACK_IMPORTED_MODULE_0__["User"];}
    static get Channel() {return structs__WEBPACK_IMPORTED_MODULE_0__["Channel"];}
    static get Guild() {return structs__WEBPACK_IMPORTED_MODULE_0__["Guild"];}
    static get Message() {return structs__WEBPACK_IMPORTED_MODULE_0__["Message"];}
    static get UserSettings() {return structs__WEBPACK_IMPORTED_MODULE_0__["UserSettings"];}

    /**
     * A list of loaded guilds.
     */
    static get guilds() {
        const guilds = _discordmodules__WEBPACK_IMPORTED_MODULE_1__["default"].GuildStore.getGuilds();
        return structs__WEBPACK_IMPORTED_MODULE_0__["List"].from(Object.values(guilds), g => structs__WEBPACK_IMPORTED_MODULE_0__["Guild"].from(g));
    }

    /**
     * A list of loaded channels.
     */
    static get channels() {
        const channels = _discordmodules__WEBPACK_IMPORTED_MODULE_1__["default"].ChannelStore.getChannels();
        return structs__WEBPACK_IMPORTED_MODULE_0__["List"].from(Object.values(channels), c => structs__WEBPACK_IMPORTED_MODULE_0__["Channel"].from(c));
    }

    /**
     * A list of loaded users.
     */
    static get users() {
        const users = _discordmodules__WEBPACK_IMPORTED_MODULE_1__["default"].UserStore.getUsers();
        return structs__WEBPACK_IMPORTED_MODULE_0__["List"].from(Object.values(users), u => structs__WEBPACK_IMPORTED_MODULE_0__["User"].from(u));
    }

    /**
     * An object mapping guild IDs to their member counts.
     */
    static get memberCounts() {
        return _discordmodules__WEBPACK_IMPORTED_MODULE_1__["default"].MemberCountStore.getMemberCounts();
    }

    /**
     * A list of guilds in the order they appear in the server list.
     */
    static get sortedGuilds() {
        const guilds = _discordmodules__WEBPACK_IMPORTED_MODULE_1__["default"].SortedGuildStore.getSortedGuilds();
        return structs__WEBPACK_IMPORTED_MODULE_0__["List"].from(guilds, g => structs__WEBPACK_IMPORTED_MODULE_0__["Guild"].from(g));
    }

    /**
     * An array of guild IDs in the order they appear in the server list.
     */
    static get guildPositions() {
        return _discordmodules__WEBPACK_IMPORTED_MODULE_1__["default"].SortedGuildStore.guildPositions;
    }

    /**
     * The currently selected guild.
     */
    static get currentGuild() {
        const guild = _discordmodules__WEBPACK_IMPORTED_MODULE_1__["default"].GuildStore.getGuild(_discordmodules__WEBPACK_IMPORTED_MODULE_1__["default"].SelectedGuildStore.getGuildId());
        return guild ? structs__WEBPACK_IMPORTED_MODULE_0__["Guild"].from(guild) : null;
    }

    /**
     * The currently selected channel.
     */
    static get currentChannel() {
        const channel = _discordmodules__WEBPACK_IMPORTED_MODULE_1__["default"].ChannelStore.getChannel(_discordmodules__WEBPACK_IMPORTED_MODULE_1__["default"].SelectedChannelStore.getChannelId());
        return channel ? structs__WEBPACK_IMPORTED_MODULE_0__["Channel"].from(channel) : null;
    }

    /**
     * The current user.
     */
    static get currentUser() {
        const user = _discordmodules__WEBPACK_IMPORTED_MODULE_1__["default"].UserStore.getCurrentUser();
        return user ? structs__WEBPACK_IMPORTED_MODULE_0__["User"].from(user) : null;
    }

    /**
     * A list of the current user's friends.
     */
    static get friends() {
        const friends = _discordmodules__WEBPACK_IMPORTED_MODULE_1__["default"].RelationshipStore.getFriendIDs();
        return structs__WEBPACK_IMPORTED_MODULE_0__["List"].from(friends, id => structs__WEBPACK_IMPORTED_MODULE_0__["User"].fromId(id));
    }
}

/***/ }),

/***/ "./src/modules/discordclasses.js":
/*!***************************************!*\
  !*** ./src/modules/discordclasses.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _discordclassmodules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./discordclassmodules */ "./src/modules/discordclassmodules.js");
/* harmony import */ var _domtools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./domtools */ "./src/modules/domtools.js");



const getRaw = function(prop) {
    if (!this.hasOwnProperty(prop)) return "";
    return this[prop];
};

const getClass = function(prop) {
    if (!this.hasOwnProperty(prop)) return "";
    return this[prop].split(" ")[0];
};

/**
 * Proxy for all the class packages, allows us to safely attempt
 * to retrieve nested things without error. Also wraps the class in
 * {@link module:DOMTools.ClassName} which adds features but can still
 * be used in native function.
 * 
 * For a list of all available class namespaces check out {@link module:DiscordClassModules}.
 * 
 * @see module:DiscordClassModules
 * @module DiscordClasses
 * @version 0.1.0
 */
const DiscordModules = new Proxy(_discordclassmodules__WEBPACK_IMPORTED_MODULE_0__["default"], {
    get: function(list, item) {
        if (item == "getRaw" || item == "getClass") return (module, prop) => DiscordModules[module][item]([prop]);
        if (list[item] === undefined) return new Proxy({}, {get: function() {return "";}});
        return new Proxy(list[item], {
            get: function(obj, prop) {
                if (prop == "getRaw") return getRaw.bind(obj);
                if (prop == "getClass") return getClass.bind(obj);
                if (!obj.hasOwnProperty(prop)) return "";
                return new _domtools__WEBPACK_IMPORTED_MODULE_1__["default"].ClassName(obj[prop]);
            }
        });
    }
});
/* harmony default export */ __webpack_exports__["default"] = (DiscordModules);

/***/ }),

/***/ "./src/modules/discordclassmodules.js":
/*!********************************************!*\
  !*** ./src/modules/discordclassmodules.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ "./src/modules/utilities.js");
/* harmony import */ var _webpackmodules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webpackmodules */ "./src/modules/webpackmodules.js");



/**
 * A large list of known and labelled classes in discord.
 * Click the source link down below to view more info. Otherwise, if you
 * have the library installed or have a plugin using this library,
 * do `Object.keys(ZLibrary.DiscordClassModules)` in console for a list of modules.
 * 
 * You can use this directly, however the preferred way of doing this is to use {@link module:DiscordClasses} or {@link module:DiscordSelectors}
 * 
 * @see module:DiscordClasses
 * @see module:DiscordSelectors
 * @module DiscordClassModules
 * @version 0.0.2
 */
/* harmony default export */ __webpack_exports__["default"] = (_utilities__WEBPACK_IMPORTED_MODULE_0__["default"].memoizeObject({
    get ContextMenu() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("menu", "item");},
    get Scrollers() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("scrollerWrap", "scrollerThemed", "scrollerTrack");},
    get AccountDetails() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("container", "avatar", "hasBuildOverride");},
    get Typing() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("typing", "text");},
    get UserPopout() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("userPopout");},
    get PopoutRoles() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("roleCircle");},
    get UserModal() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("profileBadge");},
    get Textarea() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("channelTextArea", "textArea");},
    get Popouts() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("popouts", "popout");},
    get Titles() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("defaultMarginh5");},
    get Notices() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("notice", "colorInfo");},
    get Backdrop() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("backdrop");},
    get Modals() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getModule(m => m.modal && m.inner && !m.header);},
    get AuditLog() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("userHook");},
    get ChannelList() {return Object.assign({}, _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("containerDefault"), _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("name", "unread"), _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("sidebar", "hasNotice"));},
    get MemberList() {return Object.assign({}, _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("member", "memberInner"), _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("members", "membersWrap"));},
    get TitleWrap() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("titleWrapper");},
    get Titlebar() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("titleBar");},
    get Embeds() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("embed", "embedAuthor");},
    get Layers() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("layers", "layer");},
    get TooltipLayers() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("layerContainer", "layer");},
    get Margins() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getModule(m => !m.title && m.marginBottom40 && m.marginTop40);},
    get Dividers() {return Object.assign({}, _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("dividerDefault"), _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getModule(m => Object.keys(m).length == 1 && m.divider));},
    get Changelog() {return Object.assign({}, _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("container", "added"), _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("content", "modal", "size"));},
    get BasicInputs() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("inputDefault");},
    get Messages() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("message", "containerCozy");},
    get Guilds() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("guildsWrapper");},
    get EmojiPicker() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("emojiPicker", "emojiItem");},
    get Reactions() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("reaction", "reactionInner");},
    get Checkbox() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("checkbox", "checkboxInner");},
    get Tooltips() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("tooltip", "tooltipBlack");}
}));



/***/ }),

/***/ "./src/modules/discordmodules.js":
/*!***************************************!*\
  !*** ./src/modules/discordmodules.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ "./src/modules/utilities.js");
/* harmony import */ var _webpackmodules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webpackmodules */ "./src/modules/webpackmodules.js");
/**
 * A large list of known and useful webpack modules internal to Discord.
 * Click the source link down below to view more info. Otherwise, if you
 * have the library installed or have a plugin using this library,
 * do `Object.keys(ZLibrary.DiscordModules)` in console for a list of modules.
 * @module DiscordModules
 * @version 0.0.3
 */



/* harmony default export */ __webpack_exports__["default"] = (_utilities__WEBPACK_IMPORTED_MODULE_0__["default"].memoizeObject({
    get React() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("createElement", "cloneElement");},
    get ReactDOM() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("render", "findDOMNode");},
    get Events() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByPrototypes("setMaxListeners", "emit");},

    /* Guild Info, Stores, and Utilities */
    get GuildStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getGuild");},
    get SortedGuildStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getSortedGuilds");},
    get SelectedGuildStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getLastSelectedGuildId");},
    get GuildSync() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getSyncedGuilds");},
    get GuildInfo() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getAcronym");},
    get GuildChannelsStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getChannels", "getDefaultChannel");},
    get GuildMemberStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getMember");},
    get MemberCountStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getMemberCounts");},
    get GuildEmojiStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getEmojis");},
    get GuildActions() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("requestMembers");}, // apparently it's back
    get GuildPermissions() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getGuildPermissions");},

    /* Channel Store & Actions */
    get ChannelStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getChannel", "getDMFromUserId");},
    get SelectedChannelStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getLastSelectedChannelId");},
    get ChannelActions() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("selectChannel");},
    get PrivateChannelActions() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("openPrivateChannel");},
    // Absorbed into ChannelActions
    // get ChannelSelector() {return WebpackModules.getByProps("selectGuild", "selectChannel");},

    /* Current User Info, State and Settings */
    get UserInfoStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getSessionId");},
    get UserSettingsStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("guildPositions");},
    // Not really needed by plugins
    // get AccountManager() {return WebpackModules.getByProps("register", "login");},
    get UserSettingsUpdater() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("updateRemoteSettings");},
    get OnlineWatcher() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("isOnline");},
    get CurrentUserIdle() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("isIdle");},
    get RelationshipStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("isBlocked", "getFriendIDs");},
    get RelationshipManager() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("addRelationship");},
    get MentionStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getMentions");},

    /* User Stores and Utils */
    get UserStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getCurrentUser");},
    get UserStatusStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getStatus", "getState");},
    get UserTypingStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("isTyping");},
    get UserActivityStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getActivity");},
    get UserNameResolver() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getName");},
    get UserNoteStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getNote");},
    get UserNoteActions() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("updateNote");},

    /* Emoji Store and Utils */
    get EmojiInfo() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("isEmojiDisabled");},
    get EmojiUtils() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getGuildEmoji");},
    get EmojiStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getByCategory", "EMOJI_NAME_RE");},

    /* Invite Store and Utils */
    get InviteStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getInvites");},
    get InviteResolver() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("resolveInvite");},
    get InviteActions() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("acceptInvite");},

    /* Discord Objects & Utils */
    get DiscordConstants() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("Permissions", "ActivityTypes", "StatusTypes");},
    get DiscordPermissions() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("Permissions", "ActivityTypes", "StatusTypes").Permissions;},
    get Permissions() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("computePermissions");},
    get ColorConverter() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("hex2int");},
    get ColorShader() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("darken");},
    get TinyColor() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByPrototypes("toRgb");},
    get ClassResolver() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getClass");},
    get ButtonData() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("ButtonSizes");},
    // They removed this
    // get IconNames() {return WebpackModules.getByProps("IconNames");},
    get NavigationUtils() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("transitionTo", "replaceWith", "getHistory");},

    /* Discord Messages */
    get MessageStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getMessages");},
    get MessageActions() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("jumpToMessage", "_sendMessage");},
    get MessageQueue() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("enqueue");},
    get MessageParser() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getModule(m => Object.keys(m).length && Object.keys(m).every(k => k === "parse" || k === "unparse"));},

    /* In-Game Overlay */
    // Plugins don't need these
    // get OverlayUserPopoutSettings() {return WebpackModules.getByProps("openUserPopout");},
    // get OverlayUserPopoutInfo() {return WebpackModules.getByProps("getOpenedUserPopout");},

    /* Experiments */
    get ExperimentStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getExperimentOverrides");},
    get ExperimentsManager() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("isDeveloper");},
    get CurrentExperiment() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getExperimentId");},

    /* Streams */
    get StreamStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getAllActiveStreams", "getStreamForUser");},
    get StreamPreviewStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getIsPreviewLoading", "getPreviewURL");},

    /* Images, Avatars and Utils */
    get ImageResolver() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getUserAvatarURL", "getGuildIconURL");},
    get ImageUtils() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getSizedImageSrc");},
    get AvatarDefaults() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getUserAvatarURL", "DEFAULT_AVATARS");},

    /* Drag & Drop */
    // No longer a part of their DND arch
    // get DNDActions() {return WebpackModules.getByProps("beginDrag");},
    get DNDSources() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("addTarget");},
    get DNDObjects() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("DragSource");},

    /* Electron & Other Internals with Utils*/
    get ElectronModule() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("setBadge");},
    get Dispatcher() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("dirtyDispatch");},
    get PathUtils() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("hasBasename");},
    get NotificationModule() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("showNotification");},
    get RouterModule() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("Router");},
    get APIModule() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getAPIBaseURL");},
    get AnalyticEvents() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("AnalyticEventConfigs");},
    get KeyGenerator() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByRegex(/"binary"/);},
    get Buffers() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("Buffer", "kMaxLength");},
    get DeviceStore() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getDevices");},
    get SoftwareInfo() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("os");},
    // Absorbed into Sentry
    // get CurrentContext() {return WebpackModules.getByProps("setTagsContext");},

    /* Media Stuff (Audio/Video) */
    get MediaDeviceInfo() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("Codecs", "MediaEngineContextTypes");},
    get MediaInfo() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getOutputVolume");},
    get MediaEngineInfo() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("determineMediaEngine");},
    get VoiceInfo() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getEchoCancellation");},
    // DNE with restructure
    // get VideoStream() {return WebpackModules.getByProps("getVideoStream");},
    get SoundModule() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("playSound");},

    /* Window, DOM, HTML */
    get WindowInfo() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("isFocused", "windowSize");},
    // Was never needed anyway
    // get TagInfo() {return WebpackModules.getByProps("VALID_TAG_NAMES");},
    get DOMInfo() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("canUseDOM");},

    /* Locale/Location and Time */
    get LocaleManager() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("setLocale");},
    get Moment() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("parseZone");},
    get LocationManager() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("createLocation");},
    get Timestamps() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("fromTimestamp");},

    /* Strings and Utils */
    get Strings() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("Messages").Messages;},
    get StringFormats() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("a", "z");},
    get StringUtils() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("toASCII");},

    /* URLs and Utils */
    get URLParser() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("Url", "parse");},
    get ExtraURLs() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("getArticleURL");},

    /* Text Processing */
    get hljs() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("highlight", "highlightBlock");},
    get SimpleMarkdown() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("parseBlock", "parseInline", "defaultOutput");},

    /* DOM/React Components */
    /* ==================== */
    get LayerManager() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("popLayer", "pushLayer");},
    // Restructured away
    // get Tooltips() {return WebpackModules.find(m => m.hide && m.show && !m.search && !m.submit && !m.search && !m.activateRagingDemon && !m.dismiss);},
    get UserSettingsWindow() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("open", "updateAccount");},
    get ChannelSettingsWindow() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("open", "updateChannel");},
    get GuildSettingsWindow() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("open", "updateGuild");},

    /* Modals */
    get ModalActions() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("openModal", "updateModal");},
    get ModalStack() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("push", "update", "pop", "popWithKey");},
    get UserProfileModals() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("fetchMutualFriends", "setSection");},
    get AlertModal() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByPrototypes("handleCancel", "handleSubmit");},
    get ConfirmationModal() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].findByDisplayName("ConfirmModal");},
    // Grab with react components or open with UserProfileModals
    // get UserProfileModal() {
    //     return WebpackModules.find(m => {
    //         try {return m.modalConfig && m.prototype.render().type.displayName == "FluxContainer(Component)";}
    //         catch (err) {return false;}
    //     });
    // },
    get ChangeNicknameModal() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("open", "changeNickname");},
    get CreateChannelModal() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("open", "createChannel");},
    get PruneMembersModal() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("open", "prune");},
    get NotificationSettingsModal() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("open", "updateNotificationSettings");},
    get PrivacySettingsModal() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getModule(m => m.open && m.open.toString().includes("PRIVACY_SETTINGS_MODAL"));},
    // No longer available
    // get CreateInviteModal() {return WebpackModules.getByProps("open", "createInvite");},
    get Changelog() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getModule((m => m.defaultProps && m.defaultProps.selectable == false));},
    // Grab with react components
    // get Avatar() {
    //     return WebpackModules.find(m => {
    //         if (m.displayName != "FluxContainer(t)") return false;
    //         try {
    //             const temp = new m();
    //             return temp.state && temp.state.hasOwnProperty("isFocused");
    //         }
    //         catch (err) {return false;}
    //     });
    // },

    /* Popouts */
    get PopoutStack() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("open", "close", "closeAll");},
    get PopoutOpener() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("openPopout");},
    // Grab with react components
    // get EmojiPicker() {return WebpackModules.getByDisplayName("FluxContainer(EmojiPicker)");},
    get UserPopout() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByDisplayName("ConnectedUserPopout");},

    /* Context Menus */
    get ContextMenuActions() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("openContextMenu");},
    get ContextMenuItemsGroup() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByRegex(/itemGroup/);},
    get ContextMenuItem() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByRegex(/\.label\b.*\.hint\b.*\.action\b/);},

    /* Misc */
    get ExternalLink() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByRegex(/trusted/);},
    get TextElement() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByDisplayName("Text");},
    get FlexChild() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("Child");},
    get Titles() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("Tags", "default");},

    /* Settings */
    get SettingsWrapper() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByDisplayName("FormItem");},
    get SettingsNote() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByDisplayName("FormText");},
    get SettingsDivider() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getModule(m => !m.defaultProps && m.prototype && m.prototype.render && m.prototype.render.toString().includes("default.divider"));},

    get ColorPicker() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByDisplayName("ColorPicker");}, // Loaded by Discord on demand
    get Dropdown() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getModule(m => m.prototype && !m.prototype.handleClick && m.prototype.render && m.prototype.render.toString().includes("default.select"));},
    get Keybind() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByPrototypes("handleComboChange");},
    get RadioGroup() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByDisplayName("RadioGroup");},
    get Slider() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByPrototypes("renderMark");},
    get SwitchRow() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByDisplayName("SwitchItem");},
    get Textbox() {return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getModule(m => m.defaultProps && m.defaultProps.type == "text");},
}));


/***/ }),

/***/ "./src/modules/discordselectors.js":
/*!*****************************************!*\
  !*** ./src/modules/discordselectors.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _discordclassmodules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./discordclassmodules */ "./src/modules/discordclassmodules.js");
/* harmony import */ var _domtools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./domtools */ "./src/modules/domtools.js");



const getSelectorAll = function(prop) {
    if (!this.hasOwnProperty(prop)) return "";
    return `.${this[prop].split(" ").join(".")}`;
};

const getSelector = function(prop) {
    if (!this.hasOwnProperty(prop)) return "";
    return `.${this[prop].split(" ")[0]}`;
};

/**
 * Gives us a way to retrieve the internal classes as selectors without
 * needing to concatenate strings or use string templates. Wraps the
 * selector in {@link module:DOMTools.Selector} which adds features but can 
 * still be used in native function.
 * 
 * For a list of all available class namespaces check out {@link module:DiscordClassModules}.
 * 
 * @see module:DiscordClassModules
 * @module DiscordSelectors
 * @version 0.1.0
 */
const DiscordSelectors = new Proxy(_discordclassmodules__WEBPACK_IMPORTED_MODULE_0__["default"], {
    get: function(list, item) {
        if (item == "getSelectorAll" || item == "getSelector") return (module, prop) => DiscordSelectors[module][item]([prop]);
        if (list[item] === undefined) return new Proxy({}, {get: function() {return "";}});
        return new Proxy(list[item], {
            get: function(obj, prop) {
                if (prop == "getSelectorAll") return getSelectorAll.bind(obj);
                if (prop == "getSelector") return getSelector.bind(obj);
                if (!obj.hasOwnProperty(prop)) return "";
                return new _domtools__WEBPACK_IMPORTED_MODULE_1__["default"].Selector(obj[prop]);
            }
        });
    }
});

/* harmony default export */ __webpack_exports__["default"] = (DiscordSelectors);

/***/ }),

/***/ "./src/modules/domtools.js":
/*!*********************************!*\
  !*** ./src/modules/domtools.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DOMTools; });
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ "./src/modules/utilities.js");
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./logger */ "./src/modules/logger.js");
/* harmony import */ var structs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! structs */ "./src/structs/structs.js");
/**
 * Helpful utilities for dealing with DOM operations.
 * 
 * This module also extends `HTMLElement` to add a set of utility functions,
 * the same as the ones available in the module itself, but with the `element`
 * parameter bound to `this`.
 * @module DOMTools
 * @version 0.0.5
 */





/**
 * @interface
 * @name Offset
 * @property {number} top - Top offset of the target element.
 * @property {number} right - Right offset of the target element.
 * @property {number} bottom - Bottom offset of the target element.
 * @property {number} left - Left offset of the target element.
 * @property {number} height - Outer height of the target element.
 * @property {number} width - Outer width of the target element.
 */

 /**
 * Function that automatically removes added listener.
 * @callback module:DOMTools~CancelListener
 */
 
class DOMTools {

    static get Selector() {return structs__WEBPACK_IMPORTED_MODULE_2__["Selector"];}
    static get ClassName() {return structs__WEBPACK_IMPORTED_MODULE_2__["ClassName"];}
    static get DOMObserver() {return structs__WEBPACK_IMPORTED_MODULE_2__["DOMObserver"];}

    /**
     * Default DOMObserver for global usage.
     * 
     * @see DOMObserver
     */
    static get observer() {
        return this._observer || (this._observer = new structs__WEBPACK_IMPORTED_MODULE_2__["DOMObserver"]());
    }

    /**
     * This is my shit version of not having to use `$` from jQuery. Meaning
     * that you can pass a selector and it will automatically run {@link module:DOMTools.query}.
     * It also means that you can pass a string of html and it will perform and return `parseHTML`.
     * @see module:DOMTools.parseHTML
     * @see module:DOMTools.query
     * @param {string} selector - Selector to query or HTML to parse
     * @returns {(DocumentFragment|NodeList|HTMLElement)} - Either the result of `parseHTML` or `query`
     */
    static Q(selector) {
        const element = this.parseHTML(selector);
        const isHTML = element instanceof NodeList ? Array.from(element).some(n => n.nodeType === 1) : element.nodeType === 1;
        if (isHTML) return element;
        return this.query(selector);
    }

    /**
     * Essentially a shorthand for `document.querySelector`. If the `baseElement` is not provided
     * `document` is used by default.
     * @param {string} selector - Selector to query
     * @param {Element} [baseElement] - Element to base the query from
     * @returns {(Element|null)} - The found element or null if not found
     */
    static query(selector, baseElement) {
        if (!baseElement) baseElement = document;
        return baseElement.querySelector(selector);
    }

    /**
     * Essentially a shorthand for `document.querySelectorAll`. If the `baseElement` is not provided
     * `document` is used by default.
     * @param {string} selector - Selector to query
     * @param {Element} [baseElement] - Element to base the query from
     * @returns {Array<Element>} - Array of all found elements
     */
    static queryAll(selector, baseElement) {
        if (!baseElement) baseElement = document;
        return baseElement.querySelectorAll(selector);
    }

    /**
     * Parses a string of HTML and returns the results. If the second parameter is true,
     * the parsed HTML will be returned as a document fragment {@see https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment}.
     * This is extremely useful if you have a list of elements at the top level, they can then be appended all at once to another node.
     * 
     * If the second parameter is false, then the return value will be the list of parsed
     * nodes and there were multiple top level nodes, otherwise the single node is returned.
     * @param {string} html - HTML to be parsed
     * @param {boolean} [fragment=false] - Whether or not the return should be the raw `DocumentFragment`
     * @returns {(DocumentFragment|NodeList|HTMLElement)} - The result of HTML parsing
     */
    static parseHTML(html, fragment = false) {
        const template = document.createElement("template");
        template.innerHTML = html;
        const node = template.content.cloneNode(true);
        if (fragment) return node;
        return node.childNodes.length > 1 ? node.childNodes : node.childNodes[0];
    }

    /** Alternate name for {@link module:DOMTools.parseHTML} */
    static createElement(html, fragment = false) {return this.parseHTML(html, fragment);}
    
    /**
     * Takes a string of html and escapes it using the brower's own escaping mechanism.
     * @param {String} html - html to be escaped
     */
    static escapeHTML(html) {
        const textNode = document.createTextNode("");
        const spanElement = document.createElement("span");
        spanElement.append(textNode);
        textNode.nodeValue = html;
        return spanElement.innerHTML;
    }

    /**
     * Takes a string and escapes it for use as a DOM id.
     * @param {String} id - string to be escaped
     */
    static escapeID(id) {
        return id.replace(/^[^a-z]+|[^\w-]+/gi, "-");
    }

    /**
     * Adds a list of classes from the target element.
     * @param {Element} element - Element to edit classes of
     * @param {...string} classes - Names of classes to add
     * @returns {Element} - `element` to allow for chaining
     */
    static addClass(element, ...classes) {
        classes = classes.flat().filter(c => c);
        for (let c = 0; c < classes.length; c++) classes[c] = classes[c].toString().split(" ");
        classes = classes.flat().filter(c => c);
        element.classList.add(...classes);
        return element;
    }

    /**
     * Removes a list of classes from the target element.
     * @param {Element} element - Element to edit classes of
     * @param {...string} classes - Names of classes to remove
     * @returns {Element} - `element` to allow for chaining
     */
    static removeClass(element, ...classes) {
        for (let c = 0; c < classes.length; c++) classes[c] = classes[c].toString().split(" ");
        classes = classes.flat().filter(c => c);
        element.classList.remove(...classes);
        return element;
    }

    /**
     * When only one argument is present: Toggle class value;
     * i.e., if class exists then remove it and return false, if not, then add it and return true.
     * When a second argument is present:
     * If the second argument evaluates to true, add specified class value, and if it evaluates to false, remove it.
     * @param {Element} element - Element to edit classes of
     * @param {string} classname - Name of class to toggle
     * @param {boolean} [indicator] - Optional indicator for if the class should be toggled
     * @returns {Element} - `element` to allow for chaining
     */
    static toggleClass(element, classname, indicator) {
        classname = classname.toString().split(" ").filter(c => c);
        if (typeof(indicator) !== "undefined") classname.forEach(c => element.classList.toggle(c, indicator));
        else classname.forEach(c => element.classList.toggle(c));
        return element;
    }

    /**
     * Checks if an element has a specific class
     * @param {Element} element - Element to edit classes of
     * @param {string} classname - Name of class to check
     * @returns {boolean} - `true` if the element has the class, `false` otherwise.
     */
    static hasClass(element, classname) {
        return classname.toString().split(" ").filter(c => c).every(c => element.classList.contains(c));
    }

    /**
     * Replaces one class with another
     * @param {Element} element - Element to edit classes of
     * @param {string} oldName - Name of class to replace
     * @param {string} newName - New name for the class
     * @returns {Element} - `element` to allow for chaining
     */
    static replaceClass(element, oldName, newName) {
        element.classList.replace(oldName, newName);
        return element;
    }

    /**
     * Appends `thisNode` to `thatNode`
     * @param {Node} thisNode - Node to be appended to another node
     * @param {Node} thatNode - Node for `thisNode` to be appended to
     * @returns {Node} - `thisNode` to allow for chaining
     */
    static appendTo(thisNode, thatNode) {
        if (typeof(thatNode) == "string") thatNode = this.query(thatNode);
        if (!thatNode) return null;
        thatNode.append(thisNode);
        return thisNode;
    }

    /**
     * Prepends `thisNode` to `thatNode`
     * @param {Node} thisNode - Node to be prepended to another node
     * @param {Node} thatNode - Node for `thisNode` to be prepended to
     * @returns {Node} - `thisNode` to allow for chaining
     */
    static prependTo(thisNode, thatNode) {
        if (typeof(thatNode) == "string") thatNode = this.query(thatNode);
        if (!thatNode) return null;
        thatNode.prepend(thisNode);
        return thisNode;
    }

    /**
     * Insert after a specific element, similar to jQuery's `thisElement.insertAfter(otherElement)`.
     * @param {Node} thisNode - The node to insert
     * @param {Node} targetNode - Node to insert after in the tree
     * @returns {Node} - `thisNode` to allow for chaining
     */
    static insertAfter(thisNode, targetNode) {
        targetNode.parentNode.insertBefore(thisNode, targetNode.nextSibling);
        return thisNode;
    }

    /**
     * Insert after a specific element, similar to jQuery's `thisElement.after(newElement)`.
     * @param {Node} thisNode - The node to insert
     * @param {Node} newNode - Node to insert after in the tree
     * @returns {Node} - `thisNode` to allow for chaining
     */
    static after(thisNode, newNode) {
        thisNode.parentNode.insertBefore(newNode, thisNode.nextSibling);
        return thisNode;
    }

    /**
     * Gets the next sibling element that matches the selector.
     * @param {Element} element - Element to get the next sibling of
     * @param {string} [selector=""] - Optional selector
     * @returns {Element} - The sibling element
     */
    static next(element, selector = "") {
        return selector ? element.querySelector("+ " + selector) : element.nextElementSibling;
    }

    /**
     * Gets all subsequent siblings.
     * @param {Element} element - Element to get next siblings of
     * @returns {NodeList} - The list of siblings
     */
    static nextAll(element) {
        return element.querySelectorAll("~ *");
    }

    /**
     * Gets the subsequent siblings until an element matches the selector.
     * @param {Element} element - Element to get the following siblings of
     * @param {string} selector - Selector to stop at
     * @returns {Array<Element>} - The list of siblings
     */
    static nextUntil(element, selector) {
        const next = []; 
        while (element.nextElementSibling && !element.nextElementSibling.matches(selector)) next.push(element = element.nextElementSibling);
        return next;
    }

    /**
     * Gets the previous sibling element that matches the selector.
     * @param {Element} element - Element to get the previous sibling of
     * @param {string} [selector=""] - Optional selector
     * @returns {Element} - The sibling element
     */
    static previous(element, selector = "") {
        const previous = element.previousElementSibling;
        if (selector) return previous && previous.matches(selector) ? previous : null;
        return previous;
    }

    /**
     * Gets all preceeding siblings.
     * @param {Element} element - Element to get preceeding siblings of
     * @returns {NodeList} - The list of siblings
     */
    static previousAll(element) {
        const previous = [];
        while (element.previousElementSibling) previous.push(element = element.previousElementSibling);
        return previous;
    }

    /**
     * Gets the preceeding siblings until an element matches the selector.
     * @param {Element} element - Element to get the preceeding siblings of
     * @param {string} selector - Selector to stop at
     * @returns {Array<Element>} - The list of siblings
     */
    static previousUntil(element, selector) {
        const previous = []; 
        while (element.previousElementSibling && !element.previousElementSibling.matches(selector)) previous.push(element = element.previousElementSibling);
        return previous;
    }

    /**
     * Find which index in children a certain node is. Similar to jQuery's `$.index()`
     * @param {HTMLElement} node - The node to find its index in parent
     * @returns {number} Index of the node
     */
    static indexInParent(node) {
        const children = node.parentNode.childNodes;
        let num = 0;
        for (let i = 0; i < children.length; i++) {
            if (children[i] == node) return num;
            if (children[i].nodeType == 1) num++;
        }
        return -1;
    }

    /** Shorthand for {@link module:DOMTools.indexInParent} */
    static index(node) {return this.indexInParent(node);}

    /**
     * Gets the parent of the element if it matches the selector,
     * otherwise returns null.
     * @param {Element} element - Element to get parent of
     * @param {string} [selector=""] - Selector to match parent
     * @returns {(Element|null)} - The sibling element or null
     */
    static parent(element, selector = "") {
        return !selector || element.parentElement.matches(selector) ? element.parentElement : null;
    }

    /**
     * Gets all children of Element that match the selector if provided.
     * @param {Element} element - Element to get all children of
     * @param {string} selector - Selector to match the children to
     * @returns {Array<Element>} - The list of children
     */
    static findChild(element, selector) {
        return element.querySelector(":scope > " + selector);
    }

    /**
     * Gets all children of Element that match the selector if provided.
     * @param {Element} element - Element to get all children of
     * @param {string} selector - Selector to match the children to
     * @returns {Array<Element>} - The list of children
     */
    static findChildren(element, selector) {
        return element.querySelectorAll(":scope > " + selector);
    }

    /**
     * Gets all ancestors of Element that match the selector if provided.
     * @param {Element} element - Element to get all parents of
     * @param {string} [selector=""] - Selector to match the parents to
     * @returns {Array<Element>} - The list of parents
     */
    static parents(element, selector = "") {
        const parents = [];
        if (selector) while (element.parentElement && element.parentElement.closest(selector)) parents.push(element = element.parentElement.closest(selector));
        else while (element.parentElement) parents.push(element = element.parentElement);
        return parents;
    }

    /**
     * Gets the ancestors until an element matches the selector.
     * @param {Element} element - Element to get the ancestors of
     * @param {string} selector - Selector to stop at
     * @returns {Array<Element>} - The list of parents
     */
    static parentsUntil(element, selector) {
        const parents = [];
        while (element.parentElement && !element.parentElement.matches(selector)) parents.push(element = element.parentElement);
        return parents;
    }

    /**
     * Gets all siblings of the element that match the selector.
     * @param {Element} element - Element to get all siblings of
     * @param {string} [selector="*"] - Selector to match the siblings to
     * @returns {Array<Element>} - The list of siblings
     */
    static siblings(element, selector = "*") {
        return Array.from(element.parentElement.children).filter(e => e != element && e.matches(selector));
    }

    /**
     * Sets or gets css styles for a specific element. If `value` is provided
     * then it sets the style and returns the element to allow for chaining,
     * otherwise returns the style.  
     * @param {Element} element - Element to set the CSS of
     * @param {string} attribute - Attribute to get or set
     * @param {string} [value] - Value to set for attribute
     * @returns {Element|string} - When setting a value, element is returned for chaining, otherwise the value is returned.
     */
    static css(element, attribute, value) {
        if (typeof(value) == "undefined") return global.getComputedStyle(element)[attribute];
        element.style[attribute] = value;
        return element;
    }

    /**
     * Sets or gets the width for a specific element. If `value` is provided
     * then it sets the width and returns the element to allow for chaining,
     * otherwise returns the width.  
     * @param {Element} element - Element to set the CSS of
     * @param {string} [value] - Width to set
     * @returns {Element|string} - When setting a value, element is returned for chaining, otherwise the value is returned.
     */
    static width(element, value) {
        if (typeof(value) == "undefined") return parseInt(getComputedStyle(element).width);
        element.style.width = value;
        return element;
    }

    /**
     * Sets or gets the height for a specific element. If `value` is provided
     * then it sets the height and returns the element to allow for chaining,
     * otherwise returns the height.  
     * @param {Element} element - Element to set the CSS of
     * @param {string} [value] - Height to set
     * @returns {Element|string} - When setting a value, element is returned for chaining, otherwise the value is returned.
     */
    static height(element, value) {
        if (typeof(value) == "undefined") return parseInt(getComputedStyle(element).height);
        element.style.height = value;
        return element;
    }

    /**
     * Sets the inner text of an element if given a value, otherwise returns it.
     * @param {Element} element - Element to set the text of
     * @param {string} [text] - Content to set
     * @returns {string} - Either the string set by this call or the current text content of the node.
     */
    static text(element, text) {
        if (typeof(text) == "undefined") return element.textContent;
        return element.textContent = text;
    }

    /**
     * Returns the innerWidth of the element.
     * @param {Element} element - Element to retrieve inner width of
     * @return {number} - The inner width of the element.
     */
    static innerWidth(element) {
        return element.clientWidth;
    }

    /**
     * Returns the innerHeight of the element.
     * @param {Element} element - Element to retrieve inner height of
     * @return {number} - The inner height of the element.
     */
    static innerHeight(element) {
        return element.clientHeight;
    }

    /**
     * Returns the outerWidth of the element.
     * @param {Element} element - Element to retrieve outer width of
     * @return {number} - The outer width of the element.
     */
    static outerWidth(element) {
        return element.offsetWidth;
    }

    /**
     * Returns the outerHeight of the element.
     * @param {Element} element - Element to retrieve outer height of
     * @return {number} - The outer height of the element.
     */
    static outerHeight(element) {
        return element.offsetHeight;
    }

    /**
     * Gets the offset of the element in the page.
     * @param {Element} element - Element to get offset of
     * @return {Offset} - The offset of the element
     */
    static offset(element) {
        return element.getBoundingClientRect();
    }

    static get listeners() {return this._listeners || (this._listeners = {});}

    /**
     * This is similar to jQuery's `on` function and can *hopefully* be used in the same way.
     * 
     * Rather than attempt to explain, I'll show some example usages.
     * 
     * The following will add a click listener (in the `myPlugin` namespace) to `element`.
     * `DOMTools.on(element, "click.myPlugin", () => {console.log("clicked!");});`
     * 
     * The following will add a click listener (in the `myPlugin` namespace) to `element` that only fires when the target is a `.block` element.
     * `DOMTools.on(element, "click.myPlugin", ".block", () => {console.log("clicked!");});`
     * 
     * The following will add a click listener (without namespace) to `element`.
     * `DOMTools.on(element, "click", () => {console.log("clicked!");});`
     * 
     * The following will add a click listener (without namespace) to `element` that only fires once.
     * `const cancel = DOMTools.on(element, "click", () => {console.log("fired!"); cancel();});`
     * 
     * @param {Element} element - Element to add listener to
     * @param {string} event - Event to listen to with option namespace (e.g. "event.namespace")
     * @param {(string|callable)} delegate - Selector to run on element to listen to
     * @param {callable} [callback] - Function to fire on event
     * @returns {module:DOMTools~CancelListener} - A function that will undo the listener
     */
    static on(element, event, delegate, callback) {
        const [type, namespace] = event.split(".");
        const hasDelegate = delegate && callback;
        if (!callback) callback = delegate;
        const eventFunc = !hasDelegate ? callback : function(ev) {
            if (ev.target.matches(delegate)) {
                callback(ev);
            }
        };

        element.addEventListener(type, eventFunc);
        const cancel = () => {
            element.removeEventListener(type, eventFunc);
        };
        if (namespace) {
            if (!this.listeners[namespace]) this.listeners[namespace] = [];
            const newCancel = () => {
                cancel();
                this.listeners[namespace].splice(this.listeners[namespace].findIndex(l => l.event == type && l.element == element), 1);
            };
            this.listeners[namespace].push({
                event: type,
                element: element,
                cancel: newCancel
            });
            return newCancel;
        }
        return cancel;
    }

    /**
     * Functionality for this method matches {@link module:DOMTools.on} but automatically cancels itself
     * and removes the listener upon the first firing of the desired event.
     * 
     * @param {Element} element - Element to add listener to
     * @param {string} event - Event to listen to with option namespace (e.g. "event.namespace")
     * @param {(string|callable)} delegate - Selector to run on element to listen to
     * @param {callable} [callback] - Function to fire on event
     * @returns {module:DOMTools~CancelListener} - A function that will undo the listener
     */
    static once(element, event, delegate, callback) {
        const [type, namespace] = event.split(".");
        const hasDelegate = delegate && callback;
        if (!callback) callback = delegate;
        const eventFunc = !hasDelegate ? function(ev) {
            callback(ev);
            element.removeEventListener(type, eventFunc);
        } : function(ev) {
            if (!ev.target.matches(delegate)) return;
            callback(ev);
            element.removeEventListener(type, eventFunc);
        };

        element.addEventListener(type, eventFunc);
        const cancel = () => {
            element.removeEventListener(type, eventFunc);
        };
        if (namespace) {
            if (!this.listeners[namespace]) this.listeners[namespace] = [];
            const newCancel = () => {
                cancel();
                this.listeners[namespace].splice(this.listeners[namespace].findIndex(l => l.event == type && l.element == element), 1);
            };
            this.listeners[namespace].push({
                event: type,
                element: element,
                cancel: newCancel
            });
            return newCancel;
        }
        return cancel;
    }

    static __offAll(event, element) {
        const [type, namespace] = event.split(".");
        let matchFilter = listener => listener.event == type, defaultFilter = _ => _;
        if (element) {
            matchFilter = l => l.event == type && l.element == element;
            defaultFilter = l => l.element == element;
        }
        const listeners = this.listeners[namespace] || [];
        const list = type ? listeners.filter(matchFilter) : listeners.filter(defaultFilter);
        for (let c = 0; c < list.length; c++) list[c].cancel();
    }
    
    /**
     * This is similar to jQuery's `off` function and can *hopefully* be used in the same way.
     * 
     * Rather than attempt to explain, I'll show some example usages.
     * 
     * The following will remove a click listener called `onClick` (in the `myPlugin` namespace) from `element`.
     * `DOMTools.off(element, "click.myPlugin", onClick);`
     * 
     * The following will remove a click listener called `onClick` (in the `myPlugin` namespace) from `element` that only fired when the target is a `.block` element.
     * `DOMTools.off(element, "click.myPlugin", ".block", onClick);`
     * 
     * The following will remove a click listener (without namespace) from `element`.
     * `DOMTools.off(element, "click", onClick);`
     * 
     * The following will remove all listeners in namespace `myPlugin` from `element`.
     * `DOMTools.off(element, ".myPlugin");`
     * 
     * The following will remove all click listeners in namespace `myPlugin` from *all elements*.
     * `DOMTools.off("click.myPlugin");`
     * 
     * The following will remove all listeners in namespace `myPlugin` from *all elements*.
     * `DOMTools.off(".myPlugin");`
     * 
     * @param {(Element|string)} element - Element to remove listener from
     * @param {string} [event] - Event to listen to with option namespace (e.g. "event.namespace")
     * @param {(string|callable)} [delegate] - Selector to run on element to listen to
     * @param {callable} [callback] - Function to fire on event
     * @returns {Element} - The original element to allow for chaining
     */
    static off(element, event, delegate, callback) {
        if (typeof(element) == "string") return this.__offAll(element);
        const [type, namespace] = event.split(".");
        if (namespace) return this.__offAll(event, element);

        const hasDelegate = delegate && callback;
        if (!callback) callback = delegate;
        const eventFunc = !hasDelegate ? callback : function(ev) {
            if (ev.target.matches(delegate)) {
                callback(ev);
            }
        };

        element.removeEventListener(type, eventFunc);
        return element;
    }

    /**
     * Adds a listener for when the node is added/removed from the document body.
     * The listener is automatically removed upon firing.
     * @param {HTMLElement} node - node to wait for
     * @param {callable} callback - function to be performed on event
     * @param {boolean} onMount - determines if it should fire on Mount or on Unmount
     */
    static onMountChange(node, callback, onMount = true) {
        const wrappedCallback = () => {
            this.observer.unsubscribe(wrappedCallback);
            callback();
        };
        this.observer.subscribe(wrappedCallback, mutation => {
            const nodes = Array.from(onMount ? mutation.addedNodes : mutation.removedNodes);
            const directMatch = nodes.indexOf(node) > -1;
            const parentMatch = nodes.some(parent => parent.contains(node));
            return directMatch || parentMatch;
        });
        return node;
    }

    /** Shorthand for {@link module:DOMTools.onMountChange} with third parameter `true` */
    static onMount(node, callback) {return this.onMountChange(node, callback);}

    /** Shorthand for {@link module:DOMTools.onMountChange} with third parameter `false` */
    static onUnmount(node, callback) {return this.onMountChange(node, callback, false);}

    /** Alias for {@link module:DOMTools.onMount} */
    static onAdded(node, callback) {return this.onMount(node, callback);}

    /** Alias for {@link module:DOMTools.onUnmount} */
    static onRemoved(node, callback) {return this.onUnmount(node, callback, false);}

    /**
     * Helper function which combines multiple elements into one parent element
     * @param {Array<HTMLElement>} elements - array of elements to put into a single parent
     */
    static wrap(elements) {
        const domWrapper = this.parseHTML(`<div class="dom-wrapper"></div>`);
        for (let e = 0; e < elements.length; e++) domWrapper.appendChild(elements[e]);
        return domWrapper;
    }

    /**
     * Resolves the node to an HTMLElement. This is mainly used by library modules.
     * @param {(jQuery|Element)} node - node to resolve
     */
    static resolveElement(node) {
        try {
            if (!(node instanceof window.jQuery) && !(node instanceof Element)) return undefined;
            return node instanceof window.jQuery ? node[0] : node;
        }
        catch {
            return node;
        }
    }
}

const addToPrototype = function(MainObject, prop, func) {
    _utilities__WEBPACK_IMPORTED_MODULE_0__["default"].addToPrototype(HTMLElement, prop, function() {
        _logger__WEBPACK_IMPORTED_MODULE_1__["default"].warn("DOMTools", "These custom functions on HTMLElement will be removed.");
        return Reflect.apply(func, this, arguments);
    });
};

addToPrototype(HTMLElement, "addClass", function(...classes) {return DOMTools.addClass(this, ...classes);});
addToPrototype(HTMLElement, "removeClass", function(...classes) {return DOMTools.removeClass(this, ...classes);});
addToPrototype(HTMLElement, "toggleClass", function(className, indicator) {return DOMTools.toggleClass(this, className, indicator);});
addToPrototype(HTMLElement, "replaceClass", function(oldClass, newClass) {return DOMTools.replaceClass(this, oldClass, newClass);});
addToPrototype(HTMLElement, "hasClass", function(className) {return DOMTools.hasClass(this, className);});
addToPrototype(HTMLElement, "insertAfter", function(referenceNode) {return DOMTools.insertAfter(this, referenceNode);});
addToPrototype(HTMLElement, "after", function(newNode) {return DOMTools.after(this, newNode);});
addToPrototype(HTMLElement, "next", function(selector = "") {return DOMTools.next(this, selector);});
addToPrototype(HTMLElement, "nextAll", function() {return DOMTools.nextAll(this);});
addToPrototype(HTMLElement, "nextUntil", function(selector) {return DOMTools.nextUntil(this, selector);});
addToPrototype(HTMLElement, "previous", function(selector = "") {return DOMTools.previous(this, selector);});
addToPrototype(HTMLElement, "previousAll", function() {return DOMTools.previousAll(this);});
addToPrototype(HTMLElement, "previousUntil", function(selector) {return DOMTools.previousUntil(this, selector);});
addToPrototype(HTMLElement, "index", function() {return DOMTools.index(this);});
addToPrototype(HTMLElement, "findChild", function(selector) {return DOMTools.findChild(this, selector);});
addToPrototype(HTMLElement, "findChildren", function(selector) {return DOMTools.findChildren(this, selector);});
addToPrototype(HTMLElement, "parent", function(selector) {return DOMTools.parent(this, selector);});
addToPrototype(HTMLElement, "parents", function(selector = "") {return DOMTools.parents(this, selector);});
addToPrototype(HTMLElement, "parentsUntil", function(selector) {return DOMTools.parentsUntil(this, selector);});
addToPrototype(HTMLElement, "siblings", function(selector = "*") {return DOMTools.siblings(this, selector);});
addToPrototype(HTMLElement, "css", function(attribute, value) {return DOMTools.css(this, attribute, value);});
addToPrototype(HTMLElement, "width", function(value) {return DOMTools.width(this, value);});
addToPrototype(HTMLElement, "height", function(value) {return DOMTools.height(this, value);});
addToPrototype(HTMLElement, "innerWidth", function() {return DOMTools.innerWidth(this);});
addToPrototype(HTMLElement, "innerHeight", function() {return DOMTools.innerHeight(this);});
addToPrototype(HTMLElement, "outerWidth", function() {return DOMTools.outerWidth(this);});
addToPrototype(HTMLElement, "outerHeight", function() {return DOMTools.outerHeight(this);});
addToPrototype(HTMLElement, "offset", function() {return DOMTools.offset(this);});
addToPrototype(HTMLElement, "text", function(value) {return DOMTools.text(this, value);});
addToPrototype(HTMLElement, "on", function(event, delegate, callback) {return DOMTools.on(this, event, delegate, callback);});
addToPrototype(HTMLElement, "once", function(event, delegate, callback) {return DOMTools.once(this, event, delegate, callback);});
addToPrototype(HTMLElement, "off", function(event, delegate, callback) {return DOMTools.off(this, event, delegate, callback);});
addToPrototype(HTMLElement, "find", function(selector) {return DOMTools.query(selector, this);});
addToPrototype(HTMLElement, "findAll", function(selector) {return DOMTools.queryAll(selector, this);});
addToPrototype(HTMLElement, "appendTo", function(otherNode) {return DOMTools.appendTo(this, otherNode);});
addToPrototype(HTMLElement, "onAdded", function(callback) {return DOMTools.onAdded(this, callback);});
addToPrototype(HTMLElement, "onRemoved", function(callback) {return DOMTools.onRemoved(this, callback);});

/***/ }),

/***/ "./src/modules/logger.js":
/*!*******************************!*\
  !*** ./src/modules/logger.js ***!
  \*******************************/
/*! exports provided: LogTypes, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LogTypes", function() { return LogTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Logger; });
/** 
 * Simple logger for the lib and plugins.
 * 
 * @module Logger
 * @version 0.1.0
 */

/* eslint-disable no-console */

/**
 * List of logging types.
 */
const LogTypes = {
    /** Alias for error */
    err: "error",
    error: "error",
    /** Alias for debug */
    dbg: "debug",
    debug: "debug",
    log: "log",
    warn: "warn",
    info: "info"
};

class Logger {

    /**
     * Logs an error using a collapsed error group with stacktrace.
     * 
     * @param {string} module - Name of the calling module.
     * @param {string} message - Message or error to have logged.
     * @param {Error} error - Error object to log with the message.
     */
    static stacktrace(module, message, error) {
        console.error(`%c[${module}]%c ${message}\n\n%c`, "color: #3a71c1; font-weight: 700;", "color: red; font-weight: 700;", "color: red;", error);
    }

    /**
     * Logs using error formatting. For logging an actual error object consider {@link module:Logger.stacktrace}
     * 
     * @param {string} module - Name of the calling module.
     * @param {string} message - Messages to have logged.
     */
    static err(module, ...message) {Logger._log(module, message, "error");}

    /**
     * Logs a warning message.
     * 
     * @param {string} module - Name of the calling module.
     * @param {...any} message - Messages to have logged.
     */
    static warn(module, ...message) {Logger._log(module, message, "warn");}

    /**
     * Logs an informational message.
     * 
     * @param {string} module - Name of the calling module.
     * @param {...any} message - Messages to have logged.
     */
    static info(module, ...message) {Logger._log(module, message, "info");}

    /**
     * Logs used for debugging purposes.
     * 
     * @param {string} module - Name of the calling module.
     * @param {...any} message - Messages to have logged.
     */
    static debug(module, ...message) {Logger._log(module, message, "debug");}
    
    /**
     * Logs used for basic loggin.
     * 
     * @param {string} module - Name of the calling module.
     * @param {...any} message - Messages to have logged.
     */
    static log(module, ...message) {Logger._log(module, message);}

    /**
     * Logs strings using different console levels and a module label.
     * 
     * @param {string} module - Name of the calling module.
     * @param {any|Array<any>} message - Messages to have logged.
     * @param {module:Logger.LogTypes} type - Type of log to use in console.
     */
    static _log(module, message, type = "log") {
        type = Logger.parseType(type);
        if (!Array.isArray(message)) message = [message];
        console[type](`%c[${module}]%c`, "color: #3a71c1; font-weight: 700;", "", ...message);
    }

    static parseType(type) {
        return LogTypes.hasOwnProperty(type) ? LogTypes[type] : "log";
    }

}

/***/ }),

/***/ "./src/modules/modules.js":
/*!********************************!*\
  !*** ./src/modules/modules.js ***!
  \********************************/
/*! exports provided: Utilities, WebpackModules, Filters, DiscordModules, ColorConverter, DOMTools, DiscordClasses, DiscordSelectors, ReactTools, ReactComponents, DiscordAPI, Logger, Patcher, PluginUpdater, PluginUtilities, DiscordClassModules, Structs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utilities */ "./src/modules/utilities.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Utilities", function() { return _utilities__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _webpackmodules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webpackmodules */ "./src/modules/webpackmodules.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebpackModules", function() { return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Filters", function() { return _webpackmodules__WEBPACK_IMPORTED_MODULE_1__["Filters"]; });

/* harmony import */ var _discordmodules__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./discordmodules */ "./src/modules/discordmodules.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DiscordModules", function() { return _discordmodules__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _colorconverter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./colorconverter */ "./src/modules/colorconverter.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColorConverter", function() { return _colorconverter__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _domtools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./domtools */ "./src/modules/domtools.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DOMTools", function() { return _domtools__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _discordclasses__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./discordclasses */ "./src/modules/discordclasses.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DiscordClasses", function() { return _discordclasses__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _discordselectors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./discordselectors */ "./src/modules/discordselectors.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DiscordSelectors", function() { return _discordselectors__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _reacttools__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./reacttools */ "./src/modules/reacttools.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ReactTools", function() { return _reacttools__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _reactcomponents__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./reactcomponents */ "./src/modules/reactcomponents.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ReactComponents", function() { return _reactcomponents__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _discordapi__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./discordapi */ "./src/modules/discordapi.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DiscordAPI", function() { return _discordapi__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./logger */ "./src/modules/logger.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Logger", function() { return _logger__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _patcher__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./patcher */ "./src/modules/patcher.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Patcher", function() { return _patcher__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _pluginupdater__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./pluginupdater */ "./src/modules/pluginupdater.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PluginUpdater", function() { return _pluginupdater__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _pluginutilities__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./pluginutilities */ "./src/modules/pluginutilities.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PluginUtilities", function() { return _pluginutilities__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _discordclassmodules__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./discordclassmodules */ "./src/modules/discordclassmodules.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DiscordClassModules", function() { return _discordclassmodules__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var structs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! structs */ "./src/structs/structs.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "Structs", function() { return structs__WEBPACK_IMPORTED_MODULE_15__; });









// export {default as DiscordComponents} from "./discordcomponents";















/***/ }),

/***/ "./src/modules/patcher.js":
/*!********************************!*\
  !*** ./src/modules/patcher.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Patcher; });
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ "./src/modules/logger.js");
/* harmony import */ var _discordmodules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./discordmodules */ "./src/modules/discordmodules.js");
/* harmony import */ var _webpackmodules__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webpackmodules */ "./src/modules/webpackmodules.js");
/**
 * Patcher that can patch other functions allowing you to run code before, after or
 * instead of the original function. Can also alter arguments and return values.
 *
 * This is a modified version of what we have been working on in BDv2. {@link https://github.com/JsSucks/BetterDiscordApp/blob/master/client/src/modules/patcher.js}
 *
 * @module Patcher
 * @version 0.0.2
 */





class Patcher {

    // Use window._patches instead of local variables in case something tries to whack the lib
    static get patches() {return window._patches || (window._patches = []);}

    /**
     * Returns all the patches done by a specific caller
     * @param {string} name - Name of the patch caller
     * @method
     */
    static getPatchesByCaller(name) {
        if (!name) return [];
        const patches = [];
        for (const patch of this.patches) {
            for (const childPatch of patch.children) {
                if (childPatch.caller === name) patches.push(childPatch);
            }
        }
        return patches;
    }

    /**
     * Unpatches all patches passed, or when a string is passed unpatches all
     * patches done by that specific caller.
     * @param {Array|string} patches - Either an array of patches to unpatch or a caller name
     */
    static unpatchAll(patches) {
        if (typeof patches === "string") patches = this.getPatchesByCaller(patches);

        for (const patch of patches) {
            patch.unpatch();
        }
    }

    static resolveModule(module) {
        if (!module || typeof(module) === "function" || (typeof(module) === "object" && !Array.isArray(module))) return module;
        if (typeof module === "string") return _discordmodules__WEBPACK_IMPORTED_MODULE_1__["default"][module];
        if (Array.isArray(module)) return _webpackmodules__WEBPACK_IMPORTED_MODULE_2__["default"].findByUniqueProperties(module);
        return null;
    }

    static makeOverride(patch) {
        return function () {
            let returnValue;
            if (!patch.children || !patch.children.length) return patch.originalFunction.apply(this, arguments);
            for (const superPatch of patch.children.filter(c => c.type === "before")) {
                try {
                    superPatch.callback(this, arguments);
                }
                catch (err) {
                    _logger__WEBPACK_IMPORTED_MODULE_0__["default"].err("Patcher", `Could not fire before callback of ${patch.functionName} for ${superPatch.caller}`, err);
                }
            }

            const insteads = patch.children.filter(c => c.type === "instead");
            if (!insteads.length) {returnValue = patch.originalFunction.apply(this, arguments);}
            else {
                for (const insteadPatch of insteads) {
                    try {
                        const tempReturn = insteadPatch.callback(this, arguments, patch.originalFunction.bind(this));
                        if (typeof(tempReturn) !== "undefined") returnValue = tempReturn;
                    }
                    catch (err) {
                        _logger__WEBPACK_IMPORTED_MODULE_0__["default"].err("Patcher", `Could not fire instead callback of ${patch.functionName} for ${insteadPatch.caller}`, err);
                    }
                }
            }

            for (const slavePatch of patch.children.filter(c => c.type === "after")) {
                try {
                    const tempReturn = slavePatch.callback(this, arguments, returnValue);
                    if (typeof(tempReturn) !== "undefined") returnValue = tempReturn;
                }
                catch (err) {
                    _logger__WEBPACK_IMPORTED_MODULE_0__["default"].err("Patcher", `Could not fire after callback of ${patch.functionName} for ${slavePatch.caller}`, err);
                }
            }
            return returnValue;
        };
    }

    static rePatch(patch) {
        patch.proxyFunction = patch.module[patch.functionName] = this.makeOverride(patch);
    }

    static makePatch(module, functionName, name) {
        const patch = {
            name,
            module,
            functionName,
            originalFunction: module[functionName],
            proxyFunction: null,
            revert: () => { // Calling revert will destroy any patches added to the same module after this
                patch.module[patch.functionName] = patch.originalFunction;
                patch.proxyFunction = null;
                patch.children = [];
            },
            counter: 0,
            children: []
        };
        patch.proxyFunction = module[functionName] = this.makeOverride(patch);
        Object.assign(module[functionName], patch.originalFunction);
        module[functionName].__originalFunction = patch.originalFunction;
        module[functionName].toString = () => patch.originalFunction.toString();
        this.patches.push(patch);
        return patch;
    }

    /**
     * Function with no arguments and no return value that may be called to revert changes made by {@link module:Patcher}, restoring (unpatching) original method.
     * @callback module:Patcher~unpatch
     */

    /**
     * A callback that modifies method logic. This callback is called on each call of the original method and is provided all data about original call. Any of the data can be modified if necessary, but do so wisely.
     *
     * The third argument for the callback will be `undefined` for `before` patches. `originalFunction` for `instead` patches and `returnValue` for `after` patches.
     *
     * @callback module:Patcher~patchCallback
     * @param {object} thisObject - `this` in the context of the original function.
     * @param {arguments} arguments - The original arguments of the original function.
     * @param {(function|*)} extraValue - For `instead` patches, this is the original function from the module. For `after` patches, this is the return value of the function.
     * @return {*} Makes sense only when using an `instead` or `after` patch. If something other than `undefined` is returned, the returned value replaces the value of `returnValue`. If used for `before` the return value is ignored.
     */

    /**
     * This method patches onto another function, allowing your code to run beforehand.
     * Using this, you are also able to modify the incoming arguments before the original method is run.
     *
     * @param {string} caller - Name of the caller of the patch function. Using this you can undo all patches with the same name using {@link module:Patcher.unpatchAll}. Use `""` if you don't care.
     * @param {object} moduleToPatch - Object with the function to be patched. Can also patch an object's prototype.
     * @param {string} functionName - Name of the method to be patched
     * @param {module:Patcher~patchCallback} callback - Function to run before the original method
     * @param {object} options - Object used to pass additional options.
     * @param {string} [options.displayName] You can provide meaningful name for class/object provided in `what` param for logging purposes. By default, this function will try to determine name automatically.
     * @param {boolean} [options.forcePatch=true] Set to `true` to patch even if the function doesnt exist. (Adds noop function in place).
     * @return {module:Patcher~unpatch} Function with no arguments and no return value that should be called to cancel (unpatch) this patch. You should save and run it when your plugin is stopped.
     */
    static before(caller, moduleToPatch, functionName, callback, options = {}) {return this.pushChildPatch(caller, moduleToPatch, functionName, callback, Object.assign(options, {type: "before"}));}

    /**
     * This method patches onto another function, allowing your code to run after.
     * Using this, you are also able to modify the return value, using the return of your code instead.
     *
     * @param {string} caller - Name of the caller of the patch function. Using this you can undo all patches with the same name using {@link module:Patcher.unpatchAll}. Use `""` if you don't care.
     * @param {object} moduleToPatch - Object with the function to be patched. Can also patch an object's prototype.
     * @param {string} functionName - Name of the method to be patched
     * @param {module:Patcher~patchCallback} callback - Function to run instead of the original method
     * @param {object} options - Object used to pass additional options.
     * @param {string} [options.displayName] You can provide meaningful name for class/object provided in `what` param for logging purposes. By default, this function will try to determine name automatically.
     * @param {boolean} [options.forcePatch=true] Set to `true` to patch even if the function doesnt exist. (Adds noop function in place).
     * @return {module:Patcher~unpatch} Function with no arguments and no return value that should be called to cancel (unpatch) this patch. You should save and run it when your plugin is stopped.
     */
    static after(caller, moduleToPatch, functionName, callback, options = {}) {return this.pushChildPatch(caller, moduleToPatch, functionName, callback, Object.assign(options, {type: "after"}));}

    /**
     * This method patches onto another function, allowing your code to run instead.
     * Using this, you are also able to modify the return value, using the return of your code instead.
     *
     * @param {string} caller - Name of the caller of the patch function. Using this you can undo all patches with the same name using {@link module:Patcher.unpatchAll}. Use `""` if you don't care.
     * @param {object} moduleToPatch - Object with the function to be patched. Can also patch an object's prototype.
     * @param {string} functionName - Name of the method to be patched
     * @param {module:Patcher~patchCallback} callback - Function to run after the original method
     * @param {object} options - Object used to pass additional options.
     * @param {string} [options.displayName] You can provide meaningful name for class/object provided in `what` param for logging purposes. By default, this function will try to determine name automatically.
     * @param {boolean} [options.forcePatch=true] Set to `true` to patch even if the function doesnt exist. (Adds noop function in place).
     * @return {module:Patcher~unpatch} Function with no arguments and no return value that should be called to cancel (unpatch) this patch. You should save and run it when your plugin is stopped.
     */
    static instead(caller, moduleToPatch, functionName, callback, options = {}) {return this.pushChildPatch(caller, moduleToPatch, functionName, callback, Object.assign(options, {type: "instead"}));}

    /**
     * This method patches onto another function, allowing your code to run before, instead or after the original function.
     * Using this you are able to modify the incoming arguments before the original function is run as well as the return
     * value before the original function actually returns.
     *
     * @param {string} caller - Name of the caller of the patch function. Using this you can undo all patches with the same name using {@link module:Patcher.unpatchAll}. Use `""` if you don't care.
     * @param {object} moduleToPatch - Object with the function to be patched. Can also patch an object's prototype.
     * @param {string} functionName - Name of the method to be patched
     * @param {module:Patcher~patchCallback} callback - Function to run after the original method
     * @param {object} options - Object used to pass additional options.
     * @param {string} [options.type=after] - Determines whether to run the function `before`, `instead`, or `after` the original.
     * @param {string} [options.displayName] You can provide meaningful name for class/object provided in `what` param for logging purposes. By default, this function will try to determine name automatically.
     * @param {boolean} [options.forcePatch=true] Set to `true` to patch even if the function doesnt exist. (Adds noop function in place).
     * @return {module:Patcher~unpatch} Function with no arguments and no return value that should be called to cancel (unpatch) this patch. You should save and run it when your plugin is stopped.
     */
    static pushChildPatch(caller, moduleToPatch, functionName, callback, options = {}) {
        const {type = "after", forcePatch = true} = options;
        const module = this.resolveModule(moduleToPatch);
        if (!module) return null;
        if (!module[functionName] && forcePatch) module[functionName] = function() {};
        if (!(module[functionName] instanceof Function)) return null;

        if (typeof moduleToPatch === "string") options.displayName = moduleToPatch;
        const displayName = options.displayName || module.displayName || module.name || module.constructor.displayName || module.constructor.name;

        const patchId = `${displayName}.${functionName}`;
        const patch = this.patches.find(p => p.module == module && p.functionName == functionName) || this.makePatch(module, functionName, patchId);
        if (!patch.proxyFunction) this.rePatch(patch);
        const child = {
            caller,
            type,
            id: patch.counter,
            callback,
            unpatch: () => {
                patch.children.splice(patch.children.findIndex(cpatch => cpatch.id === child.id && cpatch.type === type), 1);
                if (patch.children.length <= 0) {
                    const patchNum = this.patches.findIndex(p => p.module == module && p.functionName == functionName);
                    if (patchNum < 0) return;
                    this.patches[patchNum].revert();
                    this.patches.splice(patchNum, 1);
                }
            }
        };
        patch.children.push(child);
        patch.counter++;
        return child.unpatch;
    }

}

/***/ }),

/***/ "./src/modules/pluginupdater.js":
/*!**************************************!*\
  !*** ./src/modules/pluginupdater.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PluginUpdater; });
/* harmony import */ var _pluginutilities__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pluginutilities */ "./src/modules/pluginutilities.js");
/* harmony import */ var _domtools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./domtools */ "./src/modules/domtools.js");
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logger */ "./src/modules/logger.js");
/* harmony import */ var _discordclasses__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./discordclasses */ "./src/modules/discordclasses.js");
/* harmony import */ var ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ui */ "./src/ui/ui.js");
/* harmony import */ var _styles_updates_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../styles/updates.css */ "./src/styles/updates.css");
/**
 * Functions that check for and update existing plugins.
 * @module PluginUpdater
 * @version 0.1.2
 */









/**
 * Function that gets the remote version from the file contents.
 * @param {string} fileContent - the content of the remote file
 * @returns {string} - remote version
 * @callback module:PluginUpdater~versioner
 */

/**
 * Comparator that takes the current version and the remote version,
 * then compares them returning `true` if there is an update and `false` otherwise.
 * @param {string} currentVersion - the current version of the plugin
 * @param {string} remoteVersion - the remote version of the plugin
 * @returns {boolean} - whether the plugin has an update or not
 * @callback module:PluginUpdater~comparator
 */

class PluginUpdater {

    static get CSS() {return _styles_updates_css__WEBPACK_IMPORTED_MODULE_5__["default"];}

    /**
     * Checks for updates for the specified plugin at the specified link. The final
     * parameter should link to the raw text of the plugin and will compare semantic
     * versions.
     * @param {string} pluginName - name of the plugin
     * @param {string} currentVersion - current version (semantic versioning only)
     * @param {string} updateURL - url to check for update
     * @param {module:PluginUpdater~versioner} [versioner] - versioner that finds the remote version. If not provided uses {@link module:PluginUpdater.defaultVersioner}.
     * @param {module:PluginUpdater~comparator} [comparator] - comparator that determines if there is an update. If not provided uses {@link module:PluginUpdater.defaultComparator}.
     */
    static checkForUpdate(pluginName, currentVersion, updateURL, versioner, comparator) {
        let updateLink = "https://raw.githubusercontent.com/rauenzi/BetterDiscordAddons/master/Plugins/" + pluginName + "/" + pluginName + ".plugin.js";
        if (updateURL) updateLink = updateURL;
        if (typeof(versioner) != "function") versioner = this.defaultVersioner;
        if (typeof(comparator) != "function") comparator = this.defaultComparator;

        if (typeof window.PluginUpdates === "undefined") {
            window.PluginUpdates = {
                plugins: {},
                checkAll: async function() {
                    for (const key in this.plugins) {
                        const plugin = this.plugins[key];
                        if (!plugin.versioner) plugin.versioner = PluginUpdater.defaultVersioner;
                        if (!plugin.comparator) plugin.comparator = PluginUpdater.defaultComparator;
                        await PluginUpdater.processUpdateCheck(plugin.name, plugin.raw);
                    }
                },
                interval: setInterval(() => {
                    window.PluginUpdates.checkAll();
                }, 7200000)
            };
            this.patchPluginList();
        }

        window.PluginUpdates.plugins[updateLink] = {name: pluginName, raw: updateLink, version: currentVersion, versioner: versioner, comparator: comparator};
        PluginUpdater.processUpdateCheck(pluginName, updateLink);
    }

    /**
     * Will check for updates and automatically show or remove the update notice
     * bar based on the internal result. Better not to call this directly and to
     * instead use {@link module:PluginUpdater.checkForUpdate}.
     * @param {string} pluginName - name of the plugin to check
     * @param {string} updateLink - link to the raw text version of the plugin
     */
    static async processUpdateCheck(pluginName, updateLink) {
        return new Promise(resolve => {
            const request = require("request");
            request(updateLink, (error, response, result) => {
                if (error || response.statusCode !== 200) return resolve();
                const remoteVersion = window.PluginUpdates.plugins[updateLink].versioner(result);
                const hasUpdate = window.PluginUpdates.plugins[updateLink].comparator(window.PluginUpdates.plugins[updateLink].version, remoteVersion);
                if (hasUpdate) resolve(this.showUpdateNotice(pluginName, updateLink));
                else resolve(this.removeUpdateNotice(pluginName));
            });
        });
    }

    /**
     * The default versioner used as {@link module:PluginUpdater~versioner} for {@link module:PluginUpdater.checkForUpdate}.
     * This works on basic semantic versioning e.g. "1.0.0". You do not need to provide this as a versioner if your plugin adheres
     * to this style as this will be used as default.
     * @param {string} currentVersion
     * @param {string} content
     */
    static defaultVersioner(content) {
        const remoteVersion = content.match(/['"][0-9]+\.[0-9]+\.[0-9]+['"]/i);
        if (!remoteVersion) return "0.0.0";
        return remoteVersion.toString().replace(/['"]/g, "");
    }

    /**
     * The default comparator used as {@link module:PluginUpdater~comparator} for {@link module:PluginUpdater.checkForUpdate}.
     * This works on basic semantic versioning e.g. "1.0.0". You do not need to provide this as a comparator if your plugin adheres
     * to this style as this will be used as default.
     * @param {string} currentVersion
     * @param {string} content
     */
    static defaultComparator(currentVersion, remoteVersion) {
        currentVersion = currentVersion.split(".").map((e) => {return parseInt(e);});
        remoteVersion = remoteVersion.split(".").map((e) => {return parseInt(e);});

        if (remoteVersion[0] > currentVersion[0]) return true;
        else if (remoteVersion[0] == currentVersion[0] && remoteVersion[1] > currentVersion[1]) return true;
        else if (remoteVersion[0] == currentVersion[0] && remoteVersion[1] == currentVersion[1] && remoteVersion[2] > currentVersion[2]) return true;
        return false;
    }

    static patchPluginList() {
        _domtools__WEBPACK_IMPORTED_MODULE_1__["default"].observer.subscribeToQuerySelector(mutation => {
            if (!mutation.addedNodes || !mutation.addedNodes.length) return;
            const button = document.getElementsByClassName("bd-pfbtn")[0];
            if (!button || !button.textContent.toLowerCase().includes("plugin") || button.nextElementSibling.classList.contains("bd-updatebtn")) return;
            button.after(PluginUpdater.createUpdateButton());
        }, "#bd-settingspane-container");
    }

    /**
     * Creates the update button found in the plugins page of BetterDiscord
     * settings. Returned button will already have listeners to create the tooltip.
     * @returns {HTMLElement} check for update button
     */
    static createUpdateButton() {
        const updateButton = _domtools__WEBPACK_IMPORTED_MODULE_1__["default"].parseHTML(`<button class="bd-pfbtn bd-updatebtn" style="left: 220px;">Check for Updates</button>`);
        updateButton.onclick = function () {
            ui__WEBPACK_IMPORTED_MODULE_4__["Toasts"].info("Plugin update check in progress.");
            window.PluginUpdates.checkAll().then(() => {ui__WEBPACK_IMPORTED_MODULE_4__["Toasts"].success("Plugin update check complete.");});
        };
        const tooltip = new ui__WEBPACK_IMPORTED_MODULE_4__["Tooltip"](updateButton, "Checks for updates of plugins that support this feature. Right-click for a list.");
        updateButton.oncontextmenu = function () {
            if (!window.PluginUpdates || !window.PluginUpdates.plugins) return;
            tooltip.label = Object.values(window.PluginUpdates.plugins).map(p => p.name).join(", ");
            tooltip.side = "bottom";
            tooltip.show();
            updateButton.onmouseout = function() {
                tooltip.label = "Checks for updates of plugins that support this feature. Right-click for a list.";
                tooltip.side = "top";
            };
        };
        return updateButton;
    }

    /**
     * Will download the latest version and replace the the old plugin version.
     * Will also update the button in the update bar depending on if the user
     * is using RestartNoMore plugin by square {@link https://github.com/Inve1951/BetterDiscordStuff/blob/master/plugins/restartNoMore.plugin.js}
     * @param {string} pluginName - name of the plugin to download
     * @param {string} updateLink - link to the raw text version of the plugin
     */
    static downloadPlugin(pluginName, updateLink) {
        const request = require("request");
        const fileSystem = require("fs");
        const path = require("path");
        request(updateLink, async (error, response, body) => {
            if (error) return _logger__WEBPACK_IMPORTED_MODULE_2__["default"].warn("PluginUpdates", "Unable to get update for " + pluginName);
            const remoteVersion = window.PluginUpdates.plugins[updateLink].versioner(body);
            let filename = updateLink.split("/");
            filename = filename[filename.length - 1];
            const file = path.join(_pluginutilities__WEBPACK_IMPORTED_MODULE_0__["default"].getPluginsFolder(), filename);
            await new Promise(r => fileSystem.writeFile(file, body, r));
            ui__WEBPACK_IMPORTED_MODULE_4__["Toasts"].success(`${pluginName} ${window.PluginUpdates.plugins[updateLink].version} has been replaced by ${pluginName} ${remoteVersion}`);
            this.removeUpdateNotice(pluginName);

            if (BdApi.isSettingEnabled("fork-ps-5")) return;
            if (!window.PluginUpdates.downloaded) {
                window.PluginUpdates.downloaded = [];
                const button = _domtools__WEBPACK_IMPORTED_MODULE_1__["default"].parseHTML(`<button class="btn btn-reload ${_discordclasses__WEBPACK_IMPORTED_MODULE_3__["default"].Notices.buttonMinor} ${_discordclasses__WEBPACK_IMPORTED_MODULE_3__["default"].Notices.button}">Reload</button>`);
                const tooltip = new ui__WEBPACK_IMPORTED_MODULE_4__["Tooltip"](button, window.PluginUpdates.downloaded.join(", "), {side: "top"});
                button.addEventListener("click", (e) => {
                    e.preventDefault();
                    window.location.reload(false);
                });
                button.addEventListener("mouseenter", () => {
                    tooltip.label = window.PluginUpdates.downloaded.join(", ");
                });
                document.getElementById("pluginNotice").append(button);
            }
            window.PluginUpdates.plugins[updateLink].version = remoteVersion;
            window.PluginUpdates.downloaded.push(pluginName);
        });
    }

    /**
     * Will show the update notice top bar seen in Discord. Better not to call
     * this directly and to instead use {@link module:PluginUpdater.checkForUpdate}.
     * @param {string} pluginName - name of the plugin
     * @param {string} updateLink - link to the raw text version of the plugin
     */
    static showUpdateNotice(pluginName, updateLink) {
        if (!document.getElementById("pluginNotice")) {
            const noticeElement = _domtools__WEBPACK_IMPORTED_MODULE_1__["default"].parseHTML(`<div class="${_discordclasses__WEBPACK_IMPORTED_MODULE_3__["default"].Notices.notice} ${_discordclasses__WEBPACK_IMPORTED_MODULE_3__["default"].Notices.colorInfo}" id="pluginNotice">
                                                        <div class="${_discordclasses__WEBPACK_IMPORTED_MODULE_3__["default"].Notices.closeButton}" id="pluginNoticeDismiss"></div>
                                                        <span class="notice-message">The following plugins have updates:</span>&nbsp;&nbsp;<strong id="outdatedPlugins"></strong>
                                                    </div>`);
            _domtools__WEBPACK_IMPORTED_MODULE_1__["default"].query("[class*='app-'] > [class*='app-']").prepend(noticeElement);
            noticeElement.querySelector("#pluginNoticeDismiss").addEventListener("click", async () => {
                noticeElement.classList.add("closing");
                await new Promise(resolve => setTimeout(resolve, 400));
                noticeElement.remove();
            });
        }
        const pluginNoticeID = pluginName + "-notice";
        if (document.getElementById(pluginNoticeID)) return;
        const pluginNoticeElement = _domtools__WEBPACK_IMPORTED_MODULE_1__["default"].parseHTML(`<span id="${pluginNoticeID}">${pluginName}</span>`);
        pluginNoticeElement.addEventListener("click", () => {
            this.downloadPlugin(pluginName, updateLink);
        });
        if (document.getElementById("outdatedPlugins").querySelectorAll("span").length) document.getElementById("outdatedPlugins").append(_domtools__WEBPACK_IMPORTED_MODULE_1__["default"].createElement("<span class='separator'>, </span>"));
        document.getElementById("outdatedPlugins").append(pluginNoticeElement);

        const tooltip = new ui__WEBPACK_IMPORTED_MODULE_4__["Tooltip"](pluginNoticeElement, "Click To Update!", {side: "bottom"});

        // If this is the first one added, show the tooltip immediately.
        if (document.getElementById("outdatedPlugins").querySelectorAll("span").length === 1) tooltip.show();
    }

    /**
     * Will remove the plugin from the update notice top bar seen in Discord.
     * Better not to call this directly and to instead use {@link module:PluginUpdater.checkForUpdate}.
     * @param {string} pluginName - name of the plugin
     */
    static removeUpdateNotice(pluginName) {
        if (!document.getElementById("outdatedPlugins")) return;
        const notice = document.getElementById(pluginName + "-notice");
        if (notice) {
            if (notice.nextElementSibling && notice.nextElementSibling.matches(".separator")) notice.nextElementSibling.remove();
            else if (notice.previousElementSibling && notice.previousElementSibling.matches(".separator")) notice.previousElementSibling.remove();
            notice.remove();
        }

        if (!document.getElementById("outdatedPlugins").querySelectorAll("span").length) {
            if (document.querySelector("#pluginNotice .btn-reload")) document.querySelector("#pluginNotice .notice-message").textContent = "To finish updating you need to reload.";
            else document.getElementById("pluginNoticeDismiss").click();
        }
    }
}


/***/ }),

/***/ "./src/modules/pluginutilities.js":
/*!****************************************!*\
  !*** ./src/modules/pluginutilities.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PluginUtilities; });
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ "./src/modules/logger.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utilities */ "./src/modules/utilities.js");
/* harmony import */ var _domtools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./domtools */ "./src/modules/domtools.js");
/* harmony import */ var _ui_discordcontextmenu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ui/discordcontextmenu */ "./src/ui/discordcontextmenu.js");






/**
 * A series of useful functions for BetterDiscord plugins.
 * @module PluginUtilities
 * @version 0.2.5
 */


 class PluginUtilities {

    /**
     * Loads data through BetterDiscord's API.
     * @param {string} name - name for the file (usually plugin name)
     * @param {string} key - which key the data is saved under
     * @param {object} defaultData - default data to populate the object with
     * @returns {object} the combined saved and default data
    */
    static loadData(name, key, defaultData) {
        const defaults = _utilities__WEBPACK_IMPORTED_MODULE_1__["default"].deepclone(defaultData);
        try {return _utilities__WEBPACK_IMPORTED_MODULE_1__["default"].extend(defaults ? defaults : {}, BdApi.getData(name, key));}
        catch (err) {_logger__WEBPACK_IMPORTED_MODULE_0__["default"].err(name, "Unable to load data: ", err);}
        return defaults;
    }

    /**
     * Saves data through BetterDiscord's API.
     * @param {string} name - name for the file (usually plugin name)
     * @param {string} key - which key the data should be saved under
     * @param {object} data - data to save
    */
    static saveData(name, key, data) {
        try {BdApi.setData(name, key, data);}
        catch (err) {_logger__WEBPACK_IMPORTED_MODULE_0__["default"].err(name, "Unable to save data: ", err);}
    }

    /**
     * Loads settings through BetterDiscord's API.
     * @param {string} name - name for the file (usually plugin name)
     * @param {object} defaultData - default data to populate the object with
     * @returns {object} the combined saved and default settings
    */
    static loadSettings(name, defaultSettings) {
        return this.loadData(name, "settings", defaultSettings);
    }

    /**
     * Saves settings through BetterDiscord's API.
     * @param {string} name - name for the file (usually plugin name)
     * @param {object} data - settings to save
    */
    static saveSettings(name, data) {
        this.saveData(name, "settings", data);
    }

    /**
     * Get the full path to the BetterDiscord folder.
     * @returns {string} full path to the BetterDiscord folder
     */
    static getBDFolder(subtarget = "") {
        const process = require("process");
        const path = require("path");
        if (process.env.injDir) return path.resolve(process.env.injDir, subtarget);
        switch (process.platform) {
            case "win32":
                return path.resolve(process.env.appdata, "BetterDiscord/", subtarget);
            case "darwin":
                return path.resolve(process.env.HOME, "Library/Preferences/", "BetterDiscord/", subtarget);
            default:
                return path.resolve(process.env.XDG_CONFIG_HOME ? process.env.XDG_CONFIG_HOME : process.env.HOME + "/.config", "BetterDiscord/", subtarget);
        }
    }

    /**
     * Get the full path to the plugins folder.
     * @returns {string} full path to the plugins folder
     */
    static getPluginsFolder() {
        return this.getBDFolder("plugins/");
    }

    /**
     * Get the full path to the themes folder.
     * @returns {string} full path to the themes folder
     */
    static getThemesFolder() {
        return this.getBDFolder("themes/");
    }

    /**
     * Adds a callback to a set of listeners for onSwitch.
     * @param {callable} callback - basic callback to happen on channel switch
     */
    static addOnSwitchListener(callback) {
        require("electron").remote.getCurrentWebContents().on("did-navigate-in-page", callback);
    }

    /**
     * Removes the listener added by {@link InternalUtilities.addOnSwitchListener}.
     * @param {callable} callback - callback to remove from the listener list
     */
    static removeOnSwitchListener(callback) {
        require("electron").remote.getCurrentWebContents().removeListener("did-navigate-in-page", callback);
    }

    /**
     * Adds a style to the document.
     * @param {string} id - identifier to use as the element id
     * @param {string} css - css to add to the document
     */
    static addStyle(id, css) {
        document.head.append(_domtools__WEBPACK_IMPORTED_MODULE_2__["default"].createElement(`<style id="${id}">${css}</style>`));
    }

    /**
     * Removes a style from the document.
     * @param {string} id - original identifier used
     */
    static removeStyle(id) {
        const element = document.getElementById(id);
        if (element) element.remove();
    }

    /**
     * Adds/requires a remote script to be loaded
     * @param {string} id - identifier to use for this script
     * @param {string} url - url from which to load the script
     * @returns {Promise} promise that resolves when the script is loaded
     */
    static addScript(id, url) {
        return new Promise(resolve => {
            const script = document.createElement("script");
            script.id = id;
            script.src = url;
            script.type = "text/javascript";
            script.onload = resolve;
            document.head.append(script);
        });
    }

    /**
     * Removes a remote script from the document.
     * @param {string} id - original identifier used
     */
    static removeScript(id) {
        const element = document.getElementById(id);
        if (element) element.remove();
    }

    static async getContextMenu(type) {
        return _ui_discordcontextmenu__WEBPACK_IMPORTED_MODULE_3__["default"].getDiscordMenu(type);
    }

    static forceUpdateContextMenus() {
        return _ui_discordcontextmenu__WEBPACK_IMPORTED_MODULE_3__["default"].forceUpdateMenus();
    }
}




/***/ }),

/***/ "./src/modules/reactcomponents.js":
/*!****************************************!*\
  !*** ./src/modules/reactcomponents.js ***!
  \****************************************/
/*! exports provided: ReactHelpers, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReactHelpers", function() { return Helpers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ReactComponents; });
/* harmony import */ var _patcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./patcher */ "./src/modules/patcher.js");
/* harmony import */ var _reflection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reflection */ "./src/modules/reflection.js");
/* harmony import */ var _discordmodules__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./discordmodules */ "./src/modules/discordmodules.js");
/* harmony import */ var _domtools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./domtools */ "./src/modules/domtools.js");
/* harmony import */ var _reacttools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./reacttools */ "./src/modules/reacttools.js");
/**
 * BetterDiscord React Component Manipulations
 * Original concept and some code by samogot - https://github.com/samogot / https://github.com/samogot/betterdiscord-plugins/tree/master/v2/1Lib%20Discord%20Internals
 *
 * Copyright (c) 2015-present JsSucks - https://github.com/JsSucks
 * All rights reserved.
 * https://github.com/JsSucks - https://betterdiscord.net
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
*/







class Helpers {
    static get plannedActions() {
        return this._plannedActions || (this._plannedActions = new Map());
    }

    static recursiveArray(parent, key, count = 1) {
        let index = 0;
        function* innerCall(parent, key) {
            const item = parent[key];
            if (Array.isArray(item)) {
                for (const subKey of item.keys()) {
                    yield* innerCall(item, subKey);
                }
                return;
            }
            yield {item, parent, key, index: index++, count};
        }

        return innerCall(parent, key);
    }

    static recursiveArrayCount(parent, key) {
        let count = 0;
        // eslint-disable-next-line no-empty-pattern
        for (let {} of this.recursiveArray(parent, key)) ++count;
        return this.recursiveArray(parent, key, count);
    }

    static get recursiveChildren() {
        return function* (parent, key, index = 0, count = 1) {
            const item = parent[key];
            yield {item, parent, key, index, count};
            if (item && item.props && item.props.children) {
                for (const {parent, key, index, count} of this.recursiveArrayCount(item.props, "children")) {
                    yield* this.recursiveChildren(parent, key, index, count);
                }
            }
        };
    }

    static returnFirst(iterator, process) {
        for (const child of iterator) {
            const retVal = process(child);
            if (retVal !== undefined) return retVal;
        }
    }

    static getFirstChild(rootParent, rootKey, selector) {
        const getDirectChild = (item, selector) => {
            if (item && item.props && item.props.children) {
                return this.returnFirst(this.recursiveArrayCount(item.props, "children"), checkFilter.bind(null, selector));
            }
        };
        const checkFilter = (selector, {item, parent, key, count, index}) => {
            let match = true;
            if (selector.type) match = item && selector.type === item.type;
            if (match && selector.tag) match = item && typeof item.type === "string" && selector.tag === item.type;
            if (match && selector.className) {
                match = item && item.props && typeof item.props.className === "string";
                if (match) {
                    const classes = item.props.className.split(" ");
                    if (selector.className === true) match = !!classes[0];
                    else if (typeof selector.className === "string") match = classes.includes(selector.className);
                    else if (selector.className instanceof RegExp) match = !!classes.find(cls => selector.className.test(cls));
                    else match = false;
                }
            }
            if (match && selector.text) {
                if (selector.text === true) match = typeof item === "string";
                else if (typeof selector.text === "string") match = item === selector.text;
                else if (selector.text instanceof RegExp) match = typeof item === "string" && selector.text.test(item);
                else match = false;
            }
            if (match && selector.nthChild) match = index === (selector.nthChild < 0 ? count + selector.nthChild : selector.nthChild);
            if (match && selector.hasChild) match = getDirectChild(item, selector.hasChild);
            if (match && selector.hasSuccessor) match = item && !!this.getFirstChild(parent, key, selector.hasSuccessor).item;
            if (match && selector.eq) {
                --selector.eq;
                return;
            }
            if (match) {
                if (selector.child) return getDirectChild(item, selector.child);
                else if (selector.successor) return this.getFirstChild(parent, key, selector.successor);
                return {item, parent, key};
            }
        };
        return this.returnFirst(this.recursiveChildren(rootParent, rootKey), checkFilter.bind(null, selector)) || {};
    }

    static parseSelector(selector) {
        if (selector.startsWith(".")) return {className: selector.substr(1)};
        if (selector.startsWith("#")) return {id: selector.substr(1)};
        return {};
    }

    static findByProp(obj, what, value) {
        if (obj.hasOwnProperty(what) && obj[what] === value) return obj;
        if (obj.props && !obj.children) return this.findByProp(obj.props, what, value);
        if (!obj.children) return null;
        if (!Array.isArray(obj.children)) return this.findByProp(obj.children, what, value);
        for (const child of obj.children) {
            if (!child) continue;
            const findInChild = this.findByProp(child, what, value);
            if (findInChild) return findInChild;
        }
        return null;
    }

    static findProp(obj, what) {
        if (obj.hasOwnProperty(what)) return obj[what];
        if (obj.props && !obj.children) return this.findProp(obj.props, what);
        if (!obj.children) return null;
        if (!Array.isArray(obj.children)) return this.findProp(obj.children, what);
        for (const child of obj.children) {
            if (!child) continue;
            const findInChild = this.findProp(child, what);
            if (findInChild) return findInChild;
        }
        return null;
    }

    static get React() {
        return _discordmodules__WEBPACK_IMPORTED_MODULE_2__["default"].React;
    }

    static get ReactDOM() {
        return _discordmodules__WEBPACK_IMPORTED_MODULE_2__["default"].ReactDOM;
    }
}



class ReactComponent {
    constructor(id, component, selector, filter) {
        this.id = id;
        this.component = component;
        // this.important = important;
        this.selector = selector;
        this.filter = filter;
    }

    forceUpdateAll() {
        if (!this.selector) return;
        for (const e of document.querySelectorAll(this.selector)) {
            Object(_reflection__WEBPACK_IMPORTED_MODULE_1__["default"])(e).forceUpdate(this); // eslint-disable-line new-cap
        }
    }
}

/**
 * Methods for obtaining and interacting with react components.
 * @module ReactComponents
 * @version 0.0.1
 */
class ReactComponents {
    static get components() {return this._components || (this._components = new Map());}
    static get unknownComponents() {return this._unknownComponents || (this._unknownComponents = new Set());}
    static get listeners() {return this._listeners || (this._listeners = new Map());}
    static get nameSetters() {return this._nameSetters || (this._nameSetters = new Set());}

    static get ReactComponent() {return ReactComponent;}
    static get Helpers() {return Helpers;}
    static get AutoPatcher() {return ReactAutoPatcher;}

    static push(component, selector, filter) {
        if (typeof(component) !== "function") return null;
        const {displayName} = component;
        if (!displayName) return this.processUnknown(component);

        const have = this.components.get(displayName);
        if (have) {
            if (!have.selector) have.selector = selector;
            if (!have.filter) have.filter = filter;
            return component;
        }

        const c = new ReactComponent(displayName, component, selector, filter);
        this.components.set(c.id, c);
        // if (!have) this.components.push(c);

        const listener = this.listeners.get(displayName);
        if (listener) {
            for (const l of listener.children) l(c);
            this.listeners.delete(listener);
        }

        // for (const listen of this.listeners) {
        //     if (!listen.filter) continue;
        // }

        return c;
    }

    /**
     * Finds a component from the components array or by waiting for it to be mounted.
     * @param {String} name The component's name
     * @param {Object} selector A selector to look for
     * @return {Promise<ReactComponent>}
     */
    static async getComponentByName(name, selector) {
        return this.getComponent(name, selector, m => m.displayName == name);
    }

    /**
     * Finds a component from the components array or by waiting for it to be mounted.
     * @param {String} name The component's name
     * @param {Object} selector A selector to look for
     * @param {Function} filter A function to filter components if a single element is rendered by multiple components
     * @return {Promise<ReactComponent>}
     */
    static async getComponent(name, selector, filter) {
        const have = this.components.get(name);
        if (have) {
            if (!have.selector) have.selector = selector;
            if (!have.filter) have.filter = filter;
            return have;
        }

        if (selector) {
            const callback = () => {
                if (this.components.get(name)) {
                    // Logger.info("ReactComponents", `Important component ${name} already found`);
                    _domtools__WEBPACK_IMPORTED_MODULE_3__["default"].observer.unsubscribe(observerSubscription);
                    return;
                }

                const elements = document.querySelectorAll(selector);
                if (!elements.length) return;

                let component, reflect;
                for (const element of elements) {
                    reflect = Object(_reflection__WEBPACK_IMPORTED_MODULE_1__["default"])(element); // eslint-disable-line new-cap
                    component = filter ? reflect.components.find(filter) : reflect.component;
                    if (component) break;
                }

                if (!component && filter) return;// Logger.log("ReactComponents", ["Found elements matching the query selector but no components passed the filter"]);

                _domtools__WEBPACK_IMPORTED_MODULE_3__["default"].observer.unsubscribe(observerSubscription);

                if (!component) return;// Logger.err("ReactComponents", [`FAILED TO GET IMPORTANT COMPONENT ${name} WITH REFLECTION FROM`, elements]);

                if (!component.displayName) component.displayName = name;
                // if (component.displayName && component.displayName != name) {
                //     let existing = this.listeners.find(l => l.id === component.displayName);
                //     let current = this.listeners.find(l => l.id === name);
                //     if (!existing) {current.id = component.displayName;}
                //     else {
                //         existing.listeners.push(current.listeners);
                //         Utilities.removeFromArray(this.listeners, current);
                //     }
                // }
                // Logger.info("ReactComponents", [`Found important component ${name} with reflection`, reflect]);

                this.push(component, selector, filter);
            };

            const observerSubscription = _domtools__WEBPACK_IMPORTED_MODULE_3__["default"].observer.subscribeToQuerySelector(callback, selector, null, true);
            setTimeout(callback, 0);
        }

        let listener = this.listeners.get(name);
        if (!listener) {
            listener = {
                id: name,
                children: [],
                filter
            };
            this.listeners.set(name, listener);
        }


        return new Promise(resolve => {
            listener.children.push(resolve);
        });
    }

    static setName(name, filter) {
        const have = this.components.get(name);
        if (have) return have;

        for (const component of this.unknownComponents.entries()) {
            if (!filter(component)) continue;
            component.displayName = name;
            this.unknownComponents.delete(component);
            return this.push(component);
        }
        return this.nameSetters.add({name, filter});
    }

    static processUnknown(component) {
        const have = this.unknownComponents.has(component);
        for (const setter of this.nameSetters.entries()) {
            if (setter.filter.filter(component)) {
                component.displayName = setter.name;
                this.nameSetters.delete(setter);
                return this.push(component);
            }
        }
        if (have) return have;
        this.unknownComponents.add(component);
        return component;
    }

    static *recursiveComponents(internalInstance = _reacttools__WEBPACK_IMPORTED_MODULE_4__["default"].rootInstance) {
        if (internalInstance.stateNode) yield internalInstance.stateNode;
        if (internalInstance.sibling) yield* this.recursiveComponents(internalInstance.sibling);
        if (internalInstance.child) yield* this.recursiveComponents(internalInstance.child);
    }
}

class ReactAutoPatcher {
    /**
     * Wait for React to be loaded and patch it's createElement to store all unknown components.
     * Also patches some known components.
     */
    static async autoPatch() {
        this.autoUnpatch();
        _patcher__WEBPACK_IMPORTED_MODULE_0__["default"].before("ReactComponents", _discordmodules__WEBPACK_IMPORTED_MODULE_2__["default"].React, "createElement", (react, [component]) => ReactComponents.push(component));
        _patcher__WEBPACK_IMPORTED_MODULE_0__["default"].instead("ReactComponents", _discordmodules__WEBPACK_IMPORTED_MODULE_2__["default"].React.Component.prototype, "UNSAFE_componentWillMount", (component) => ReactComponents.push(component));
        _patcher__WEBPACK_IMPORTED_MODULE_0__["default"].instead("ReactComponents", _discordmodules__WEBPACK_IMPORTED_MODULE_2__["default"].React.Component.prototype, "componentWillMount", (component) => ReactComponents.push(component));
        // this.patchComponents();
    }

    static async autoUnpatch() {
        _patcher__WEBPACK_IMPORTED_MODULE_0__["default"].unpatchAll("ReactComponents");
    }

    /**
     * Finds and processes all currently available react components.
     */
    static processAll() {
        for (const component of ReactComponents.recursiveComponents()) {
            ReactComponents.push(component.constructor);
        }
    }
}


/***/ }),

/***/ "./src/modules/reacttools.js":
/*!***********************************!*\
  !*** ./src/modules/reacttools.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ReactTools; });
/* harmony import */ var _domtools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./domtools */ "./src/modules/domtools.js");
/* harmony import */ var _discordmodules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./discordmodules */ "./src/modules/discordmodules.js");
/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utilities */ "./src/modules/utilities.js");
/* harmony import */ var _reflection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reflection */ "./src/modules/reflection.js");
/**
 * Helpful utilities for dealing with getting react information from DOM objects.
 * @module ReactTools
 * @version 0.0.5
 */






class ReactTools {

    /**
     * Performs reflection on a specific node.
     * @param {(HTMLElement|jQuery|Selector)} node - node or selector to reflect on.
     */
    static Reflect(node) {
        return Object(_reflection__WEBPACK_IMPORTED_MODULE_3__["default"])(node);
    }

    static get rootInstance() {return document.getElementById("app-mount")._reactRootContainer._internalRoot.current;}

    /**
     * Grabs the react internal instance of a specific node.
     * @param {(HTMLElement|jQuery)} node - node to obtain react instance of
     * @return {object} the internal react instance
     */
    static getReactInstance(node) {
        const domNode = _domtools__WEBPACK_IMPORTED_MODULE_0__["default"].resolveElement(node);
        if (!(domNode instanceof Element)) return undefined;
        return domNode[Object.keys(domNode).find((key) => key.startsWith("__reactInternalInstance") || key.startsWith("__reactFiber"))];
    }

    /**
     * Grabs a value from the react internal instance. Allows you to grab
     * long depth values safely without accessing no longer valid properties.
     * @param {(HTMLElement|jQuery)} node - node to obtain react instance of
     * @param {string} path - path to the requested value
     * @return {(*|undefined)} the value requested or undefined if not found.
     */
    static getReactProperty(node, path) {
        return _utilities__WEBPACK_IMPORTED_MODULE_2__["default"].getNestedProp(this.getReactInstance(node), path);
    }

    /**
     * Grabs a value from the react internal instance. Allows you to grab
     * long depth values safely without accessing no longer valid properties.
     * @param {(HTMLElement|jQuery)} node - node to obtain react instance of
     * @param {object} options - options for the search
     * @param {array} [options.include] - list of items to include from the search
     * @param {array} [options.exclude=["Popout", "Tooltip", "Scroller", "BackgroundFlash"]] - list of items to exclude from the search
     * @param {callable} [options.filter=_=>_] - filter to check the current instance with (should return a boolean)
     * @return {(*|null)} the owner instance or undefined if not found.
     */
    static getOwnerInstance(node, {include, exclude = ["Popout", "Tooltip", "Scroller", "BackgroundFlash"], filter = _ => _} = {}) {
        if (node === undefined) return undefined;
        const excluding = include === undefined;
        const nameFilter = excluding ? exclude : include;
        function getDisplayName(owner) {
            const type = owner.type;
            if (!type) return null;
            return type.displayName || type.name || null;
        }
        function classFilter(owner) {
            const name = getDisplayName(owner);
            return (name !== null && !!(nameFilter.includes(name) ^ excluding));
        }
        
        let curr = this.getReactInstance(node);
        for (curr = curr && curr.return; !_utilities__WEBPACK_IMPORTED_MODULE_2__["default"].isNil(curr); curr = curr.return) {
            if (_utilities__WEBPACK_IMPORTED_MODULE_2__["default"].isNil(curr)) continue;
            const owner = curr.stateNode;
            if (!_utilities__WEBPACK_IMPORTED_MODULE_2__["default"].isNil(owner) && !(owner instanceof HTMLElement) && classFilter(curr) && filter(owner)) return owner;
        }
        
        return null;
    }

    /**
     * Creates and renders a react element that wraps dom elements.
     * @param {(HTMLElement|Array<HTMLElement>)} element - element or array of elements to wrap into a react element
     * @returns {object} - rendered react element
     */
    static createWrappedElement(element) {
        if (Array.isArray(element)) element = _domtools__WEBPACK_IMPORTED_MODULE_0__["default"].wrap(element);
        return _discordmodules__WEBPACK_IMPORTED_MODULE_1__["default"].React.createElement(this.wrapElement(element));
    }

    /**
     * Creates an unrendered react component that wraps dom elements.
     * @param {(HTMLElement|Array<HTMLElement>)} element - element or array of elements to wrap into a react component
     * @returns {object} - unrendered react component
     */
    static wrapElement(element) {
        if (Array.isArray(element)) element = _domtools__WEBPACK_IMPORTED_MODULE_0__["default"].wrap(element);
        return class ReactWrapper extends _discordmodules__WEBPACK_IMPORTED_MODULE_1__["default"].React.Component {
            constructor(props) {
                super(props);
                this.element = element;
            }
    
            componentDidMount() {this.refs.element.appendChild(this.element);}
            render() {return _discordmodules__WEBPACK_IMPORTED_MODULE_1__["default"].React.createElement("div", {className: "react-wrapper", ref: "element"});}
        };
    }
}

/***/ }),

/***/ "./src/modules/reflection.js":
/*!***********************************!*\
  !*** ./src/modules/reflection.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ "./src/modules/logger.js");
/* harmony import */ var _domtools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./domtools */ "./src/modules/domtools.js");
/* harmony import */ var _webpackmodules__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webpackmodules */ "./src/modules/webpackmodules.js");
/* harmony import */ var _reactcomponents__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reactcomponents */ "./src/modules/reactcomponents.js");
/**
 * BetterDiscord Reflection Module
 * Copyright (c) 2015-present JsSucks - https://github.com/JsSucks
 * All rights reserved.
 * https://betterdiscord.net
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
*/






class Reflection {
    static reactInternalInstance(node) {
        if (!node) return null;
        if (!Object.keys(node) || !Object.keys(node).length) return null;
        const riiKey = Object.keys(node).find(k => k.startsWith("__reactInternalInstance") || k.startsWith("__reactFiber"));
        return riiKey ? node[riiKey] : null;
    }

    static findProp(node, prop) {
        const ii = this.reactInternalInstance(node);
        if (!ii) return null;
        const fir = this.findInReturn(ii, prop);
        if (fir) return fir;
        const fim = this.findInChildProps(ii, prop);
        if (fim) return fim;
        return null;
    }

    static findInReturn(internalInstance, prop) {
        const r = internalInstance.return;
        if (!r) return null;
        let find = this.findMemoizedProp(r, prop);
        if (find) return find;
        find = this.findMemoizedState(r, prop);
        if (find) return find;
        return this.findInReturn(r, prop);
    }

    static findMemoizedProp(obj, prop) {
        if (!obj.hasOwnProperty("memoizedProps")) return null;
        obj = obj.memoizedProps;
        return this.findPropIn(obj, prop);
    }

    static findMemoizedState(obj, prop) {
        if (!obj.hasOwnProperty("memoizedState")) return null;
        obj = obj.memoizedState;
        return this.findPropIn(obj, prop);
    }

    static findInChildProps(obj, prop) {
        try {
            const f = obj.children || obj.memoizedProps.children;
            if (!f.props) return null;
            if (!f.props.hasOwnProperty(prop)) return null;
            return f.props[prop];
        }
        catch (err) {
            return null;
        }
    }

    static findPropIn(obj, prop) {
        if (obj && !Array.isArray(obj) && obj instanceof Object && obj.hasOwnProperty(prop)) return obj[prop];
        if (obj && Array.isArray(obj)) {
            const found = obj.find(mp => {
                if (mp.props && mp.props.hasOwnProperty(prop)) return true;
            });
            if (found) return found;
        }
        return null;
    }

    static propIterator(obj, propNames) {
        if (obj === null || obj === undefined) return null;
        const curPropName = propNames.shift(1);
        if (!obj.hasOwnProperty(curPropName)) return null;
        const curProp = obj[curPropName];
        if (propNames.length === 0) {
            return curProp;
        }
        return this.propIterator(curProp, propNames);
    }

    static getState(node) {
        const stateNode = this.getStateNode(node);
        if (stateNode) return stateNode.state;
    }

    static getStateNode(node) {
        return this.getStateNodes(node)[0];
    }

    static getStateNodes(node) {
        const instance = this.reactInternalInstance(node);
        const stateNodes = [];
        let lastInstance = instance;

        while (lastInstance && lastInstance.return) {
            if (lastInstance.return.stateNode instanceof HTMLElement) break;
            if (lastInstance.return.stateNode) stateNodes.push(lastInstance.return.stateNode);
            lastInstance = lastInstance.return;
        }

        return stateNodes;
    }

    static getComponentStateNode(node, component) {
        if (component instanceof _reactcomponents__WEBPACK_IMPORTED_MODULE_3__["default"].ReactComponent) component = component.component;

        for (const stateNode of this.getStateNodes(node)) {
            if (stateNode instanceof component) return stateNode;
        }
    }

    static findStateNode(node, filter, first = true) {
        return this.getStateNodes(node)[first ? "find" : "filter"](filter);
    }

    static getComponent(node) {
        return this.getComponents(node)[0];
    }

    static getComponents(node) {
        const instance = this.reactInternalInstance(node);
        const components = [];
        let lastInstance = instance;

        while (lastInstance && lastInstance.return) {
            if (typeof lastInstance.return.type === "string") break;
            if (lastInstance.return.type) components.push(lastInstance.return.type);
            lastInstance = lastInstance.return;
        }

        return components;
    }

    static findComponent(node, filter, first = true) {
        return this.getComponents(node)[first ? "find" : "filter"](filter);
    }
}

const propsProxyHandler = {
    get(node, prop) {
        return Reflection.findProp(node, prop);
    }
};

/* harmony default export */ __webpack_exports__["default"] = (function(node) {
    return new class ReflectionInstance {
        constructor(ele) {
            if (typeof ele === "string") ele = document.querySelector(ele);
            this.node = _domtools__WEBPACK_IMPORTED_MODULE_1__["default"].resolveElement(ele);
        }

        get el() {return this.node;}
        get element() {return this.node;}

        get reactInternalInstance() {
            return Reflection.reactInternalInstance(this.node);
        }

        get props() {
            return new Proxy(this.node, propsProxyHandler);
        }
        get state() {
            return Reflection.getState(this.node);
        }

        get stateNode() {
            return Reflection.getStateNode(this.node);
        }
        get stateNodes() {
            return Reflection.getStateNodes(this.node);
        }
        getComponentStateNode(component) {
            return Reflection.getComponentStateNode(this.node, component);
        }
        findStateNode(filter) {
            if (typeof filter === "function") return Reflection.findStateNode(this.node, filter);
            if (filter) return Reflection.getComponentStateNode(this.node, filter);
            return Reflection.getStateNode(this.node);
        }

        get component() {
            return Reflection.getComponent(this.node);
        }
        get components() {
            return Reflection.getComponents(this.node);
        }
        getComponentByProps(props, selector) {
            return Reflection.findComponent(this.node, _webpackmodules__WEBPACK_IMPORTED_MODULE_2__["Filters"].byProperties(props, selector));
        }
        getComponentByPrototypes(props, selector) {
            return Reflection.findComponent(this.node, _webpackmodules__WEBPACK_IMPORTED_MODULE_2__["Filters"].byPrototypeFields(props, selector));
        }
        getComponentByRegex(regex, selector) {
            return Reflection.findComponent(this.node, _webpackmodules__WEBPACK_IMPORTED_MODULE_2__["Filters"].byCode(regex, selector));
        }
        getComponentByDisplayName(name) {
            return Reflection.findComponent(this.node, _webpackmodules__WEBPACK_IMPORTED_MODULE_2__["Filters"].byDisplayName(name));
        }

        forceUpdate(filter) {
            try {
                const stateNode = this.findStateNode(filter);
                if (!stateNode || !stateNode.forceUpdate) return;
                stateNode.forceUpdate();
            }
            catch (err) {
                _logger__WEBPACK_IMPORTED_MODULE_0__["default"].err("Reflection", err);
            }
        }

        prop(propName) {
            const split = propName.split(".");
            const first = Reflection.findProp(this.node, split[0]);
            if (split.length === 1) return first;
            return Reflection.propIterator(first, split.slice(1));
        }
    }(node);
});


/***/ }),

/***/ "./src/modules/utilities.js":
/*!**********************************!*\
  !*** ./src/modules/utilities.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Utilities; });
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ "./src/modules/logger.js");
/**
 * Random set of utilities that didn't fit elsewhere.
 * @module Utilities
 * @version 0.0.2
 */



class Utilities {

    /**
     * Stably sorts arrays since `.sort()` has issues.
     * @param {Array} list - array to sort
     * @param {function} comparator - comparator to sort by
     */
    static stableSort(list, comparator) {
        const entries = Array(list.length);

        // wrap values with initial indices
        for (let index = 0; index < list.length; index++) {
            entries[index] = [index, list[index]];
        }

        // sort with fallback based on initial indices
        entries.sort(function (a, b) {
            const comparison = Number(this(a[1], b[1]));
            return comparison || a[0] - b[0];
        }.bind(comparator));

        // re-map original array to stable sorted values
        for (let index = 0; index < list.length; index++) {
            list[index] = entries[index][1];
        }
    }

    /**
     * Generates an automatically memoizing version of an object.
     * @param {Object} object - object to memoize
     * @returns {Proxy} the proxy to the object that memoizes properties
     */
    static memoizeObject(object) {
        const proxy = new Proxy(object, {
            get: function(obj, mod) {
                if (!obj.hasOwnProperty(mod)) return undefined;
                if (Object.getOwnPropertyDescriptor(obj, mod).get) {
                    const value = obj[mod];
                    delete obj[mod];
                    obj[mod] = value;
                }
                return obj[mod];
            },
            set: function(obj, mod, value) {
                if (obj.hasOwnProperty(mod)) return _logger__WEBPACK_IMPORTED_MODULE_0__["default"].err("MemoizedObject", "Trying to overwrite existing property");
                obj[mod] = value;
                return obj[mod];
            }
        });

        Object.defineProperty(proxy, "hasOwnProperty", {value: function(prop) {
            return this[prop] !== undefined;
        }});

        return proxy;
    }

    /**
     * Wraps the method in a `try..catch` block.
     * @param {callable} method - method to wrap
     * @param {string} description - description of method
     * @returns {callable} wrapped version of method
     */
    static suppressErrors(method, description) {
        return (...params) => {
            try {return method(...params);}
            catch (e) {_logger__WEBPACK_IMPORTED_MODULE_0__["default"].err("Suppression", "Error occurred in " + description, e);}
        };
    }

    /**
     * This only exists because Samo relied on lodash being there... fuck lodash.
     * @param {*} anything - whatever you want
     */
    static isNil(anything) {
        return anything == null;
    }

    /**
     * Format template strings with placeholders (`${placeholder}`) into full strings.
     * Quick example: `PluginUtilities.formatString("Hello, ${user}", {user: "Zerebos"})`
     * would return "Hello, Zerebos".
     * @param {string} string - string to format
     * @param {object} values - object literal of placeholders to replacements
     * @returns {string} the properly formatted string
     */
    static formatTString(string, values) {
        for (const val in values) {
            let replacement = values[val];
            if (Array.isArray(replacement)) replacement = JSON.stringify(replacement);
            if (typeof(replacement) === "object" && replacement !== null) replacement = replacement.toString();
            string = string.replace(new RegExp(`\\$\\{${val}\\}`, "g"), replacement);
        }
        return string;
    }

    /**
     * Format strings with placeholders (`{{placeholder}}`) into full strings.
     * Quick example: `PluginUtilities.formatString("Hello, {{user}}", {user: "Zerebos"})`
     * would return "Hello, Zerebos".
     * @param {string} string - string to format
     * @param {object} values - object literal of placeholders to replacements
     * @returns {string} the properly formatted string
     */
    static formatString(string, values) {
        for (const val in values) {
            let replacement = values[val];
            if (Array.isArray(replacement)) replacement = JSON.stringify(replacement);
            if (typeof(replacement) === "object" && replacement !== null) replacement = replacement.toString();
            string = string.replace(new RegExp(`{{${val}}}`, "g"), replacement);
        }
        return string;
    }

    /**
     * Finds a value, subobject, or array from a tree that matches a specific filter. Great for patching render functions.
     * @param {object} tree React tree to look through. Can be a rendered object or an internal instance.
     * @param {callable} searchFilter Filter function to check subobjects against.
     */
    static findInReactTree(tree, searchFilter) {
        return this.findInTree(tree, searchFilter, {walkable: ["props", "children", "child", "sibling"]});
    }

    /**
     * Finds a value, subobject, or array from a tree that matches a specific filter.
     * @param {object} tree Tree that should be walked
     * @param {callable} searchFilter Filter to check against each object and subobject
     * @param {object} options Additional options to customize the search
     * @param {Array<string>|null} [options.walkable=null] Array of strings to use as keys that are allowed to be walked on. Null value indicates all keys are walkable
     * @param {Array<string>} [options.ignore=[]] Array of strings to use as keys to exclude from the search, most helpful when `walkable = null`.
     */
    static findInTree(tree, searchFilter, {walkable = null, ignore = []} = {}) {
        if (typeof searchFilter === "string") {
            if (tree.hasOwnProperty(searchFilter)) return tree[searchFilter];
        }
        else if (searchFilter(tree)) {
            return tree;
        }

        if (typeof tree !== "object" || tree == null) return undefined;

        let tempReturn;
        if (Array.isArray(tree)) {
            for (const value of tree) {
                tempReturn = this.findInTree(value, searchFilter, {walkable, ignore});
                if (typeof tempReturn != "undefined") return tempReturn;
            }
        }
        else {
            const toWalk = walkable == null ? Object.keys(tree) : walkable;
            for (const key of toWalk) {
                if (!tree.hasOwnProperty(key) || ignore.includes(key)) continue;
                tempReturn = this.findInTree(tree[key], searchFilter, {walkable, ignore});
                if (typeof tempReturn != "undefined") return tempReturn;
            }
        }
        return tempReturn;
    }

    /**
     * Gets a nested property (if it exists) safely. Path should be something like `prop.prop2.prop3`.
     * Numbers can be used for arrays as well like `prop.prop2.array.0.id`.
     * @param {Object} obj - object to get nested property of
     * @param {string} path - representation of the property to obtain
     */
    static getNestedProp(obj, path) {
        return path.split(".").reduce(function(ob, prop) {
            return ob && ob[prop];
        }, obj);
    }

    /**
     * Builds a classname string from any number of arguments. This includes arrays and objects.
     * When given an array all values from the array are added to the list.
     * When given an object they keys are added as the classnames if the value is truthy.
     * Copyright (c) 2018 Jed Watson https://github.com/JedWatson/classnames MIT License
     * @param {...Any} argument - anything that should be used to add classnames.
     */
    static className() {
        const classes = [];
        const hasOwn = {}.hasOwnProperty;

        for (let i = 0; i < arguments.length; i++) {
            const arg = arguments[i];
            if (!arg) continue;

            const argType = typeof arg;

            if (argType === "string" || argType === "number") {
                classes.push(arg);
            }
            else if (Array.isArray(arg) && arg.length) {
                const inner = this.classNames.apply(null, arg);
                if (inner) {
                    classes.push(inner);
                }
            }
            else if (argType === "object") {
                for (const key in arg) {
                    if (hasOwn.call(arg, key) && arg[key]) {
                        classes.push(key);
                    }
                }
            }
        }

        return classes.join(" ");
    }

    /**
     * Safely adds to the prototype of an existing object by checking if the
     * property exists on the prototype.
     * @param {object} object - Object whose prototype to extend
     * @param {string} prop - Name of the prototype property to add
     * @param {callable} func - Function to run
     */
    static addToPrototype(object, prop, func) {
        if (!object.prototype) return;
        if (object.prototype[prop]) return;
        return object.prototype[prop] = func;
    }

    /**
     * Deep extends an object with a set of other objects. Objects later in the list
     * of `extenders` have priority, that is to say if one sets a key to be a primitive,
     * it will be overwritten with the next one with the same key. If it is an object, 
     * and the keys match, the object is extended. This happens recursively.
     * @param {object} extendee - Object to be extended
     * @param {...object} extenders - Objects to extend with
     * @returns {object} - A reference to `extendee`
     */
    static extend(extendee, ...extenders) {
        for (let i = 0; i < extenders.length; i++) {
            for (const key in extenders[i]) {
                if (extenders[i].hasOwnProperty(key)) {
                    if (Array.isArray(extendee[key]) && Array.isArray(extenders[i][key])) this.extend(extendee[key], extenders[i][key]);
                    else if (typeof extendee[key] === "object" && typeof extenders[i][key] === "object") this.extend(extendee[key], extenders[i][key]);
                    else if (Array.isArray(extenders[i][key])) extendee[key] = [], this.extend(extendee[key], extenders[i][key]); // eslint-disable-line no-sequences
                    else if (typeof extenders[i][key] === "object") extendee[key] = {}, this.extend(extendee[key], extenders[i][key]); // eslint-disable-line no-sequences
                    else extendee[key] = extenders[i][key];
                }
            }
        }
        return extendee;
    }

    /* Code below comes from our work on BDv2:
     * https://github.com/JsSucks/BetterDiscordApp/blob/master/common/modules/utils.js
     */

    /**
     * Clones an object and all it's properties.
     * @param {Any} value The value to clone
     * @return {Any} The cloned value
     */
    static deepclone(value) {
        if (typeof value === "object") {
            if (Array.isArray(value)) return value.map(i => this.deepclone(i));

            const clone = Object.assign({}, value);

            for (const key in clone) {
                clone[key] = this.deepclone(clone[key]);
            }

            return clone;
        }

        return value;
    }

    /**
     * Freezes an object and all it's properties.
     * @param {Any} object The object to freeze
     * @param {Function} exclude A function to filter object that shouldn't be frozen
     */
    static deepfreeze(object, exclude) {
        if (exclude && exclude(object)) return;

        if (typeof object === "object" && object !== null) {
            const properties = Object.getOwnPropertyNames(object);

            for (const property of properties) {
                this.deepfreeze(object[property], exclude);
            }

            Object.freeze(object);
        }

        return object;
    }

    /**
     * Removes an item from an array. This differs from Array.prototype.filter as it mutates the original array instead of creating a new one.
     * @param {Array} array The array to filter
     * @param {Any} item The item to remove from the array
     * @return {Array}
     */
    static removeFromArray(array, item, filter) {
        let index;
        while ((index = filter ? array.findIndex(item) : array.indexOf(item)) > -1) array.splice(index, 1);
        return array;
    }

    /**
     * Returns a function, that, as long as it continues to be invoked, will not
     * be triggered. The function will be called after it stops being called for
     * N milliseconds.
     * 
     * Adapted from the version by David Walsh (https://davidwalsh.name/javascript-debounce-function)
     * 
     * @param {function} executor 
     * @param {number} delay 
     */
    static debounce(executor, delay) {
        let timeout;
        return function(...args) {
            const callback = () => {
                timeout = null;
                Reflect.apply(executor, null, args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(callback, delay);
        };
    }

    /**
     * Checks if a file exists and is a file.
     * @param {String} path The file's path
     * @return {Promise}
     * @deprecated 12/3/2020 Just use fs...
     */
    static async fileExists(path) {
        const fs = require("fs");
        return new Promise((resolve, reject) => {
            fs.stat(path, (err, stats) => {
                if (err) {
                    return reject({
                        message: `No such file or directory: ${err.path}`,
                        err
                    });
                }

                if (!stats.isFile()) {
                    return reject({
                        message: `Not a file: ${path}`,
                        stats
                    });
                }

                resolve();
            });
        });
    }

    /**
     * Returns the contents of a file.
     * @param {String} path The file's path
     * @return {Promise}
     * @deprecated 12/3/2020 Just use fs...
     */
    static async readFile(path) {
        await this.fileExists(path);
        
        const fs = require("fs");
        return new Promise((resolve, reject) => {
            fs.readFile(path, "utf-8", (err, data) => {
                if (err) {
                    return reject({
                        message: `Could not read file: ${path}`,
                        err
                    });
                }

                resolve(data);
            });
        });
    }

}

/***/ }),

/***/ "./src/modules/webpackmodules.js":
/*!***************************************!*\
  !*** ./src/modules/webpackmodules.js ***!
  \***************************************/
/*! exports provided: Filters, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Filters", function() { return Filters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WebpackModules; });
/* harmony import */ var _discordmodules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./discordmodules */ "./src/modules/discordmodules.js");
/**
 * Random set of utilities that didn't fit elsewhere.
 * @module WebpackModules
 * @version 0.0.2
 */


 /**
 * Checks if a given module matches a set of parameters.
 * @callback module:WebpackModules.Filters~filter
 * @param {*} module - module to check
 * @returns {boolean} - True if the module matches the filter, false otherwise
 */

/**
 * Filters for use with {@link module:WebpackModules} but may prove useful elsewhere.
 */
class Filters {
    /**
     * Generates a {@link module:WebpackModules.Filters~filter} that filters by a set of properties.
     * @param {Array<string>} props - Array of property names
     * @param {module:WebpackModules.Filters~filter} filter - Additional filter
     * @returns {module:WebpackModules.Filters~filter} - A filter that checks for a set of properties
     */
    static byProperties(props, filter = m => m) {
        return module => {
            const component = filter(module);
            if (!component) return false;
            for (let p = 0; p < props.length; p++) {
                if (module[props[p]] === undefined) return false;
            }
            return true;
        };
    }

    /**
     * Generates a {@link module:WebpackModules.Filters~filter} that filters by a set of properties on the object's prototype.
     * @param {Array<string>} fields - Array of property names
     * @param {module:WebpackModules.Filters~filter} filter - Additional filter
     * @returns {module:WebpackModules.Filters~filter} - A filter that checks for a set of properties on the object's prototype
     */
    static byPrototypeFields(fields, filter = m => m) {
        return module => {
            const component = filter(module);
            if (!component) return false;
            if (!component.prototype) return false;
            for (let f = 0; f < fields.length; f++) {
                if (module.prototype[fields[f]] === undefined) return false;
            }
            return true;
        };
    }

    /**
     * Generates a {@link module:WebpackModules.Filters~filter} that filters by a regex.
     * @param {RegExp} search - A RegExp to check on the module
     * @param {module:WebpackModules.Filters~filter} filter - Additional filter
     * @returns {module:WebpackModules.Filters~filter} - A filter that checks for a set of properties
     */
    static byCode(search, filter = m => m) {
        return module => {
            const method = filter(module);
            if (!method) return false;
            let methodString = "";
            try {methodString = method.toString([]);}
            catch (err) {methodString = method.toString();}
            return methodString.search(search) !== -1;
        };
    }

    /**
     * Generates a {@link module:WebpackModules.Filters~filter} that filters by strings.
     * @param {...String} search - A RegExp to check on the module
     * @returns {module:WebpackModules.Filters~filter} - A filter that checks for a set of strings
     */
    static byString(...strings) {
        return module => {
            let moduleString = "";
            try {moduleString = module.toString([]);}
            catch (err) {moduleString = module.toString();}
            for (const s of strings) {
                if (!moduleString.includes(s)) return false;
            }
            return true;
        };
    }

    /**
     * Generates a {@link module:WebpackModules.Filters~filter} that filters by a set of properties.
     * @param {string} name - Name the module should have
     * @param {module:WebpackModules.Filters~filter} filter - Additional filter
     * @returns {module:WebpackModules.Filters~filter} - A filter that checks for a set of properties
     */
    static byDisplayName(name) {
        return module => {
            return module && module.displayName === name;
        };
    }

    /**
     * Generates a combined {@link module:WebpackModules.Filters~filter} from a list of filters.
     * @param {...module:WebpackModules.Filters~filter} filters - A list of filters
     * @returns {module:WebpackModules.Filters~filter} - Combinatory filter of all arguments
     */
    static combine(...filters) {
        return module => {
            return filters.every(filter => filter(module));
        };
    }
}

class WebpackModules {

    static find(filter, first = true) {return this.getModule(filter, first);}
    static findAll(filter) {return this.getModule(filter, false);}
    static findByUniqueProperties(props, first = true) {return first ? this.getByProps(...props) : this.getAllByProps(...props);}
    static findByDisplayName(name) {return this.getByDisplayName(name);}

    /**
     * Finds a module using a filter function.
     * @param {Function} filter A function to use to filter modules
     * @param {Boolean} first Whether to return only the first matching module
     * @return {Any}
     */
    static getModule(filter, first = true) {
        const wrappedFilter = (m) => {
            try {return filter(m);}
            catch (err) {return false;}
        };
        const modules = this.getAllModules();
        const rm = [];
        for (const index in modules) {
            if (!modules.hasOwnProperty(index)) continue;
            const module = modules[index];
            const {exports} = module;
            let foundModule = null;

            if (!exports) continue;
            if (exports.__esModule && exports.default && wrappedFilter(exports.default)) foundModule = exports.default;
            if (wrappedFilter(exports)) foundModule = exports;
            if (!foundModule) continue;
            if (first) return foundModule;
            rm.push(foundModule);
        }
        return first || rm.length == 0 ? undefined : rm;
    }

    /**
     * Gets the index in the webpack require cache of a specific
     * module using a filter.
     * @param {Function} filter A function to use to filter modules
     * @return {Number|null}
     */
    static getIndex(filter) {
        const wrappedFilter = (m) => {
            try {return filter(m);}
            catch (err) {return false;}
        };
        const modules = this.getAllModules();
        for (const index in modules) {
            if (!modules.hasOwnProperty(index)) continue;
            const module = modules[index];
            const exports = module.exports;
            let foundModule = null;

            if (!exports) continue;
            if (exports.__esModule && exports.default && wrappedFilter(exports.default)) foundModule = exports.default;
            if (wrappedFilter(exports)) foundModule = exports;
            if (!foundModule) continue;
            return index;
        }
        return null;
    }

    /**
     * Gets the index in the webpack require cache of a specific
     * module that was already found.
     * @param {Any} module An already acquired module
     * @return {Number|null}
     */
    static getIndexByModule(module) {
        return this.getIndex(m => m == module);
    }

    /**
     * Finds all modules matching a filter function.
     * @param {Function} filter A function to use to filter modules
     */
    static getModules(filter) {return this.getModule(filter, false);}

    /**
     * Finds a module by its name.
     * @param {String} name The name of the module
     * @param {Function} fallback A function to use to filter modules if not finding a known module
     * @return {Any}
     */
    static getModuleByName(name, fallback) {
        if (_discordmodules__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProperty(name)) return _discordmodules__WEBPACK_IMPORTED_MODULE_0__["default"][name];
        if (!fallback) return undefined;
        const module = this.getModule(fallback, true);
        return module ? _discordmodules__WEBPACK_IMPORTED_MODULE_0__["default"][name] = module : undefined;
    }

    /**
     * Finds a module by its display name.
     * @param {String} name The display name of the module
     * @return {Any}
     */
    static getByDisplayName(name) {
        return this.getModule(Filters.byDisplayName(name), true);
    }

    /**
     * Finds a module using its code.
     * @param {RegEx} regex A regular expression to use to filter modules
     * @param {Boolean} first Whether to return the only the first matching module
     * @return {Any}
     */
    static getByRegex(regex, first = true) {
        return this.getModule(Filters.byCode(regex), first);
    }

    /**
     * Finds a single module using properties on its prototype.
     * @param {...string} prototypes Properties to use to filter modules
     * @return {Any}
     */
    static getByPrototypes(...prototypes) {
        return this.getModule(Filters.byPrototypeFields(prototypes), true);
    }

    /**
     * Finds all modules with a set of properties of its prototype.
     * @param {...string} prototypes Properties to use to filter modules
     * @return {Any}
     */
    static getAllByPrototypes(...prototypes) {
        return this.getModule(Filters.byPrototypeFields(prototypes), false);
    }

    /**
     * Finds a single module using its own properties.
     * @param {...string} props Properties to use to filter modules
     * @return {Any}
     */
    static getByProps(...props) {
        return this.getModule(Filters.byProperties(props), true);
    }

    /**
     * Finds all modules with a set of properties.
     * @param {...string} props Properties to use to filter modules
     * @return {Any}
     */
    static getAllByProps(...props) {
        return this.getModule(Filters.byProperties(props), false);
    }

    /**
     * Finds a single module using a set of strings.
     * @param {...String} props Strings to use to filter modules
     * @return {Any}
     */
    static getByString(...strings) {
        return this.getModule(Filters.byString(...strings), true);
    }

    /**
     * Finds all modules with a set of strings.
     * @param {...String} strings Strings to use to filter modules
     * @return {Any}
     */
    static getAllByString(...strings) {
        return this.getModule(Filters.byString(...strings), false);
    }

    /**
     * Gets a specific module by index of the webpack require cache.
     * Best used in combination with getIndex in order to patch a
     * specific function.
     *
     * Note: this gives the **raw** module, meaning the actual module
     * is in returnValue.exports. This is done in order to be able
     * to patch modules which export a single function directly.
     * @param {Number} index Index into the webpack require cache
     * @return {Any}
     */
    static getByIndex(index) {
        return WebpackModules.require.c[index].exports;
    }

    /**
     * Discord's __webpack_require__ function.
     */
    static get require() {
        if (this._require) return this._require;
        const id = "zl-webpackmodules";
        const __webpack_require__ = window.webpackJsonp.push([[], {
            [id]: (module, exports, req) => module.exports = req
        }, [[id]]]);
        delete __webpack_require__.m[id];
        delete __webpack_require__.c[id];
        return this._require = __webpack_require__;
    }

    /**
     * Returns all loaded modules.
     * @return {Array}
     */
    static getAllModules() {
        return this.require.c;
    }

}

/***/ }),

/***/ "./src/plugin.js":
/*!***********************!*\
  !*** ./src/plugin.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ((BasePlugin, Library) => {
    const {PluginUpdater, Patcher, Logger, Settings, Toasts, PluginUtilities, ReactComponents, DCM} = Library;
    const PluginLibrary = class PluginLibrary extends BasePlugin {
        get Library() {return Library;}
        
        load() {
            super.load();
            const wasLibLoaded = !!document.getElementById("ZLibraryCSS");
            const isBBDLoading = document.getElementsByClassName("bd-loaderv2").length;
            PluginUtilities.removeStyle("ZLibraryCSS");
            PluginUtilities.addStyle("ZLibraryCSS", Settings.CSS + Toasts.CSS + PluginUpdater.CSS);
            ReactComponents.AutoPatcher.processAll();
            ReactComponents.AutoPatcher.autoPatch();
            DCM.patchComponents();
            
            /**
             * Checking if this is the library first being loaded during init
             * This means that subsequent loads will cause dependents to reload
             * This also means first load when installing for the first time 
             * will automatically reload the dependent plugins. This is needed
             * for those plugins that prompt to download and install the lib.
             */

            if (!wasLibLoaded && isBBDLoading) return; // If the this is the lib's first load AND this is BD's initialization

            /**
             * Now we can go ahead and reload any dependent plugins by checking
             * for any with instance._config. Both plugins using buildPlugin()
             * and plugin skeletons that prompt for download should have this
             * instance property.
             */

            // development vs master
            const id = BdApi.version ? ["settings", "general", "showToasts"] : ["fork-ps-2"];
            const wasEnabled = BdApi.isSettingEnabled(...id);
            if (wasEnabled) BdApi.disableSetting(...id);
            this._reloadPlugins();
            if (wasEnabled) BdApi.enableSetting(...id);
        }

        _reloadPlugins() {
            const list = BdApi.Plugins.getAll().reduce((acc, val) => {
                if (!val._config) return acc;
                const name = val.getName();
                if (name === "ZeresPluginLibrary") return acc;
                acc.push(name);
                return acc;
            }, []);
            for (let p = 0; p < list.length; p++) BdApi.Plugins.reload(list[p]);
        }

        static buildPlugin(config) {
            const name = config.info.name;
            const BoundAPI = {
                Logger: {
                    stacktrace: (message, error) => Logger.stacktrace(name, message, error),
                    log: (...message) => Logger.log(name, ...message),
                    error: (...message) => Logger.err(name, ...message),
                    err: (...message) => Logger.err(name, ...message),
                    warn: (...message) => Logger.warn(name, ...message),
                    info: (...message) => Logger.info(name, ...message),
                    debug: (...message) => Logger.debug(name, ...message)
                },
                Patcher: {
                    getPatchesByCaller: () => {return Patcher.getPatchesByCaller(name);},
                    unpatchAll: () => {return Patcher.unpatchAll(name);},
                    before: (moduleToPatch, functionName, callback, options = {}) => {return Patcher.before(name, moduleToPatch, functionName, callback, options);},
                    instead: (moduleToPatch, functionName, callback, options = {}) => {return Patcher.instead(name, moduleToPatch, functionName, callback, options);},
                    after: (moduleToPatch, functionName, callback, options = {}) => {return Patcher.after(name, moduleToPatch, functionName, callback, options);}
                }
            };
            const BoundLib = Object.assign({}, Library);
            BoundLib.Logger = BoundAPI.Logger;
            BoundLib.Patcher = BoundAPI.Patcher;
            return [Library.Structs.Plugin(config), BoundLib]; // eslint-disable-line new-cap
        }
    };

    Object.assign(PluginLibrary, Library);
    Library.buildPlugin = PluginLibrary.buildPlugin;
    window.ZLibrary = Library;
    window.ZLibraryPromise = new Promise(r => setImmediate(r));
    window.ZeresPluginLibrary = PluginLibrary;
    return PluginLibrary;
});

/***/ }),

/***/ "./src/structs/discord/channel.js":
/*!****************************************!*\
  !*** ./src/structs/discord/channel.js ***!
  \****************************************/
/*! exports provided: Channel, PermissionOverwrite, RolePermissionOverwrite, MemberPermissionOverwrite, GuildChannel, GuildTextChannel, GuildVoiceChannel, ChannelCategory, PrivateChannel, DirectMessageChannel, GroupChannel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Channel", function() { return Channel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PermissionOverwrite", function() { return PermissionOverwrite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RolePermissionOverwrite", function() { return RolePermissionOverwrite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MemberPermissionOverwrite", function() { return MemberPermissionOverwrite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GuildChannel", function() { return GuildChannel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GuildTextChannel", function() { return GuildTextChannel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GuildVoiceChannel", function() { return GuildVoiceChannel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ChannelCategory", function() { return ChannelCategory; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PrivateChannel", function() { return PrivateChannel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectMessageChannel", function() { return DirectMessageChannel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GroupChannel", function() { return GroupChannel; });
/* harmony import */ var modules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! modules */ "./src/modules/modules.js");
/* harmony import */ var structs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! structs */ "./src/structs/structs.js");
/* harmony import */ var _guild__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./guild */ "./src/structs/discord/guild.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./message */ "./src/structs/discord/message.js");
/* harmony import */ var _user__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./user */ "./src/structs/discord/user.js");
/**
 * BetterDiscord Channel Struct
 * Copyright (c) 2018-present JsSucks
 * All rights reserved.
 *
 * This source code is licensed under the MIT license found at
 * https://github.com/JsSucks/BetterDiscordApp/blob/master/LICENSE
*/







const BotMessager = modules__WEBPACK_IMPORTED_MODULE_0__["WebpackModules"].getByProps("createBotMessage");

const cache = new WeakMap();

/**
 * @memberof module:DiscordAPI
 */
class Channel {

    constructor(data) {
        if (cache.has(data)) return cache.get(data);
        cache.set(data, this);

        this.discordObject = data;
    }

    static from(channel) {
        switch (channel.type) {
            default: return new Channel(channel);
            case 0: return new GuildTextChannel(channel);
            case 1: return new DirectMessageChannel(channel);
            case 2: return new GuildVoiceChannel(channel);
            case 3: return new GroupChannel(channel);
            case 4: return new ChannelCategory(channel);
        }
    }

    static fromId(id) {
        const channel = modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].ChannelStore.getChannel(id);
        if (channel) return Channel.from(channel);
    }

    static get GuildChannel() {return GuildChannel;}
    static get GuildTextChannel() {return GuildTextChannel;}
    static get GuildVoiceChannel() {return GuildVoiceChannel;}
    static get ChannelCategory() {return ChannelCategory;}
    static get PrivateChannel() {return PrivateChannel;}
    static get DirectMessageChannel() {return DirectMessageChannel;}
    static get GroupChannel() {return GroupChannel;}

    get id() {return this.discordObject.id;}
    get applicationId() {return this.discordObject.application_id;}
    get type() {return this.discordObject.type;}
    get name() {return this.discordObject.name;}

    /**
     * Send a message in this channel.
     * @param {String|object} content The new message's content
     * @param {Boolean} parse Whether to parse the message or send it as it is
     * @return {Promise<Message>}
     */
    async sendMessage(content, parse = false) {
        if (this.assertPermissions) this.assertPermissions("SEND_MESSAGES", modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordPermissions.VIEW_CHANNEL | modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordPermissions.SEND_MESSAGES);

        this.select();

        if (parse) content = modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].MessageParser.parse(this.discordObject, content);
        else if (typeof content == "string") content = {content, validNonShortcutEmojis: Array(0)};

        const response = await modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].MessageActions._sendMessage(this.id, content, {});
        return _message__WEBPACK_IMPORTED_MODULE_3__["Message"].from(modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].MessageStore.getMessage(this.id, response.body.id));
    }

    /**
     * Send a bot message in this channel that only the current user can see.
     * @param {String} content The new message's content
     * @return {Message}
     */
    sendBotMessage(content) {
        this.select();
        if (!BotMessager) return modules__WEBPACK_IMPORTED_MODULE_0__["Logger"].err("DiscordAPI", "Unable to create bot message");
        const message = BotMessager.createBotMessage(this.id, content);
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].MessageActions.receiveMessage(this.id, message);
        return _message__WEBPACK_IMPORTED_MODULE_3__["Message"].from(modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].MessageStore.getMessage(this.id, message.id));
    }

    /**
     * A list of messages in this channel.
     */
    get messages() {
        const messages = modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].MessageStore.getMessages(this.id).toArray();
        return structs__WEBPACK_IMPORTED_MODULE_1__["List"].from(messages, m => _message__WEBPACK_IMPORTED_MODULE_3__["Message"].from(m));
    }

    /**
     * Jumps to the latest message in this channel.
     */
    jumpToPresent() {
        if (this.assertPermissions) this.assertPermissions("VIEW_CHANNEL", modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordPermissions.VIEW_CHANNEL);
        if (this.hasMoreAfter) modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].MessageActions.jumpToPresent(this.id, modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordConstants.MAX_MESSAGES_PER_CHANNEL);
        else this.messages[this.messages.length - 1].jumpTo(false);
    }

    get hasMoreAfter() {
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].MessageStore.getMessages(this.id).hasMoreAfter;
    }

    /**
     * Sends an invite in this channel.
     * @param {String} code The invite code
     * @return {Promise<Message>}
     */
    async sendInvite(code) {
        if (this.assertPermissions) this.assertPermissions("SEND_MESSAGES", modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordPermissions.VIEW_CHANNEL | modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordPermissions.SEND_MESSAGES);
        const response = modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].MessageActions.sendInvite(this.id, code);
        return _message__WEBPACK_IMPORTED_MODULE_3__["Message"].from(modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].MessageStore.getMessage(this.id, response.body.id));
    }

    /**
     * Opens this channel in the UI.
     */
    select() {
        if (this.assertPermissions) this.assertPermissions("VIEW_CHANNEL", modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordPermissions.VIEW_CHANNEL);
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].NavigationUtils.transitionToGuild(this.guildId ? this.guildId : modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordConstants.ME, this.id);
    }

    /**
     * Whether this channel is currently selected.
     */
    get isSelected() {
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordAPI"].currentChannel === this;
    }

    /**
     * Updates this channel.
     * @return {Promise}
     */
    async updateChannel(body) {
        if (this.assertPermissions) this.assertPermissions("MANAGE_CHANNELS", modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordPermissions.MANAGE_CHANNELS);
        await modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].APIModule.patch({
            url: `${modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordConstants.Endpoints.CHANNELS}/${this.id}`,
            body
        });
        this.discordObject = modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].ChannelStore.getChannel(this.id);
        cache.set(this.discordObject, this);
    }

}



class PermissionOverwrite {
    constructor(data, channel_id) {
        this.discordObject = data;
        this.channelId = channel_id;
    }

    static from(data, channel_id) {
        switch (data.type) {
            default: return new PermissionOverwrite(data, channel_id);
            case "role": return new RolePermissionOverwrite(data, channel_id);
            case "member": return new MemberPermissionOverwrite(data, channel_id);
        }
    }

    static get RolePermissionOverwrite() {return RolePermissionOverwrite;}
    static get MemberPermissionOverwrite() {return MemberPermissionOverwrite;}

    get type() {return this.discordObject.type;}
    get allow() {return this.discordObject.allow;}
    get deny() {return this.discordObject.deny;}

    get channel() {
        return Channel.fromId(this.channelId);
    }

    get guild() {
        if (this.channel) return this.channel.guild;
        return null;
    }
}

class RolePermissionOverwrite extends PermissionOverwrite {
    get roleId() {return this.discordObject.id;}

    get role() {
        if (this.guild) return this.guild.roles.find(r => r.id === this.roleId);
        return null;
    }
}

class MemberPermissionOverwrite extends PermissionOverwrite {
    get memberId() {return this.discordObject.id;}

    get member() {
        return _user__WEBPACK_IMPORTED_MODULE_4__["GuildMember"].fromId(this.memberId);
    }
}

class GuildChannel extends Channel {
    static get PermissionOverwrite() {return PermissionOverwrite;}

    get guildId() {return this.discordObject.guild_id;}
    get parentId() {return this.discordObject.parent_id;} // Channel category
    get position() {return this.discordObject.position;}
    get nicks() {return this.discordObject.nicks;}

    checkPermissions(perms) {
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].Permissions.can({data: BigInt(perms)}, modules__WEBPACK_IMPORTED_MODULE_0__["DiscordAPI"].currentUser, this.discordObject);
    }

    assertPermissions(name, perms) {
        if (!this.checkPermissions(perms)) throw new structs__WEBPACK_IMPORTED_MODULE_1__["InsufficientPermissions"](name);
    }

    get category() {
        return Channel.fromId(this.parentId);
    }

    /**
     * The current user's permissions on this channel.
     */
    get permissions() {
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildPermissions.getChannelPermissions(this.id);
    }

    get permissionOverwrites() {
        return structs__WEBPACK_IMPORTED_MODULE_1__["List"].from(Object.values(this.discordObject.permissionOverwrites), p => PermissionOverwrite.from(p, this.id));
    }

    get guild() {
        return _guild__WEBPACK_IMPORTED_MODULE_2__["Guild"].fromId(this.guildId);
    }

    /**
     * Whether this channel is the guild's default channel.
     */
    get isDefaultChannel() {
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildChannelsStore.getDefaultChannel(this.guildId).id === this.id;
    }

    /**
     * Opens this channel's settings window.
     * @param {String} section The section to open (see DiscordConstants.ChannelSettingsSections)
     */
    openSettings(section = "OVERVIEW") {
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].ChannelSettingsWindow.setSection(section);
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].ChannelSettingsWindow.open(this.id);
    }

    /**
     * Updates this channel's name.
     * @param {String} name The channel's new name
     * @return {Promise}
     */
    updateName(name) {
        return this.updateChannel({name});
    }

    /**
     * Changes the channel's position.
     * @param {Number} position The channel's new position
     * @return {Promise}
     */
    changeSortLocation(position = 0) {
        if (position instanceof GuildChannel) position = position.position;
        return this.updateChannel({position});
    }

    /**
     * Updates this channel's permission overwrites.
     * @param {Array} permission_overwrites An array of permission overwrites
     * @return {Promise}
     */
    updatePermissionOverwrites(permission_overwrites) {
        return this.updateChannel({permission_overwrites});
    }

    /**
     * Updates this channel's category.
     * @param {ChannelCategory} category The new channel category
     * @return {Promise}
     */
    updateCategory(category) {
        return this.updateChannel({parent_id: category.id || category});
    }
}

// Type 0 - GUILD_TEXT
class GuildTextChannel extends GuildChannel {
    get type() {return "GUILD_TEXT";}
    get topic() {return this.discordObject.topic;}
    get nsfw() {return this.discordObject.nsfw;}

    /**
     * Updates this channel's topic.
     * @param {String} topic The new channel topic
     * @return {Promise}
     */
    updateTopic(topic) {
        return this.updateChannel({topic});
    }

    /**
     * Updates this channel's NSFW flag.
     * @param {Boolean} nsfw Whether the channel should be marked as NSFW
     * @return {Promise}
     */
    setNsfw(nsfw = true) {
        return this.updateChannel({nsfw});
    }

    setNotNsfw() {
        return this.setNswf(false);
    }
}

// Type 2 - GUILD_VOICE
class GuildVoiceChannel extends GuildChannel {
    get type() {return "GUILD_VOICE";}
    get userLimit() {return this.discordObject.userLimit;}
    get bitrate() {return this.discordObject.bitrate;}

    sendMessage() {throw new Error("Cannot send messages in a voice channel.");}
    get messages() {return new structs__WEBPACK_IMPORTED_MODULE_1__["List"]();}
    jumpToPresent() {throw new Error("Cannot select a voice channel.");}
    get hasMoreAfter() {return false;}
    sendInvite() {throw new Error("Cannot invite someone to a voice channel.");}
    select() {throw new Error("Cannot select a voice channel.");}

    /**
     * Updates this channel's bitrate.
     * @param {Number} bitrate The new bitrate
     * @return {Promise}
     */
    updateBitrate(bitrate) {
        return this.updateChannel({bitrate});
    }

    /**
     * Updates this channel's user limit.
     * @param {Number} user_limit The new user limit
     * @return {Promise}
     */
    updateUserLimit(user_limit) {
        return this.updateChannel({user_limit});
    }
}

// Type 4 - GUILD_CATEGORY
class ChannelCategory extends GuildChannel {
    get type() {return "GUILD_CATEGORY";}
    get parentId() {return undefined;}
    get category() {return undefined;}

    sendMessage() {throw new Error("Cannot send messages in a channel category.");}
    get messages() {return new structs__WEBPACK_IMPORTED_MODULE_1__["List"]();}
    jumpToPresent() {throw new Error("Cannot select a channel category.");}
    get hasMoreAfter() {return false;}
    sendInvite() {throw new Error("Cannot invite someone to a channel category.");}
    select() {throw new Error("Cannot select a channel category.");}
    updateCategory() {throw new Error("Cannot set a channel category on another channel category.");}

    /**
     * A list of channels in this category.
     */
    get channels() {
        return structs__WEBPACK_IMPORTED_MODULE_1__["List"].from(this.guild.channels, c => c.parentId === this.id);
    }

    /**
     * Opens the create channel modal for this guild.
     * @param {Number} type The type of channel to create - either 0 (text), 2 (voice) or 4 (category)
     * @param {GuildChannel} clone A channel to clone permissions of
     */
    openCreateChannelModal(type, category, clone) {
        this.guild.openCreateChannelModal(type, this.id, this, clone);
    }

    /**
     * Creates a channel in this category.
     * @param {Number} type The type of channel to create - either 0 (text) or 2 (voice)
     * @param {String} name A name for the new channel
     * @param {Array} permission_overwrites An array of PermissionOverwrite-like objects - leave to use the permissions of the category
     * @return {Promise<GuildChannel>}
     */
    createChannel(type, name, permission_overwrites) {
        return this.guild.createChannel(type, name, this, permission_overwrites);
    }
}

class PrivateChannel extends Channel {
    get userLimit() {return this.discordObject.userLimit;}
    get bitrate() {return this.discordObject.bitrate;}
}

// Type 1 - DM
class DirectMessageChannel extends PrivateChannel {
    get type() {return "DM";}
    get recipientId() {return this.discordObject.recipients[0];}

    /**
     * The other user of this direct message channel.
     */
    get recipient() {
        return _user__WEBPACK_IMPORTED_MODULE_4__["User"].fromId(this.recipientId);
    }
}

// Type 3 - GROUP_DM
class GroupChannel extends PrivateChannel {
    get ownerId() {return this.discordObject.ownerId;}
    get type() {return "GROUP_DM";}
    get name() {return this.discordObject.name;}
    get icon() {return this.discordObject.icon;}

    /**
     * A list of the other members of this group direct message channel.
     */
    get members() {
        return structs__WEBPACK_IMPORTED_MODULE_1__["List"].from(this.discordObject.recipients, id => _user__WEBPACK_IMPORTED_MODULE_4__["User"].fromId(id));
    }

    /**
     * The owner of this group direct message channel. This is usually the person who created it.
     */
    get owner() {
        return _user__WEBPACK_IMPORTED_MODULE_4__["User"].fromId(this.ownerId);
    }

    /**
     * Updates this channel's name.
     * @param {String} name The channel's new name
     * @return {Promise}
     */
    updateName(name) {
        return this.updateChannel({name});
    }
}


// export {Channel, GuildChannel, ChannelCategory, GuildTextChannel, GuildVoiceChannel, PrivateChannel, DirectMessageChannel, GroupChannel};
// export {PermissionOverwrite, RolePermissionOverwrite, MemberPermissionOverwrite};


/***/ }),

/***/ "./src/structs/discord/guild.js":
/*!**************************************!*\
  !*** ./src/structs/discord/guild.js ***!
  \**************************************/
/*! exports provided: Role, Emoji, Guild */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Role", function() { return Role; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Emoji", function() { return Emoji; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Guild", function() { return Guild; });
/* harmony import */ var modules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! modules */ "./src/modules/modules.js");
/* harmony import */ var structs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! structs */ "./src/structs/structs.js");
/* harmony import */ var _channel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./channel */ "./src/structs/discord/channel.js");
/* harmony import */ var _user__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./user */ "./src/structs/discord/user.js");
/**
 * BetterDiscord Guild Struct
 * Copyright (c) 2018-present JsSucks
 * All rights reserved.
 *
 * This source code is licensed under the MIT license found at
 * https://github.com/JsSucks/BetterDiscordApp/blob/master/LICENSE
*/






const roles = new WeakMap();

class Role {
    constructor(data, guild_id) {
        if (roles.has(data)) return roles.get(data);
        roles.set(data, this);

        this.discordObject = data;
        this.guildId = guild_id;
    }

    get id() {return this.discordObject.id;}
    get name() {return this.discordObject.name;}
    get position() {return this.discordObject.position;}
    get originalPosition() {return this.discordObject.originalPosition;}
    get permissions() {return this.discordObject.permissions;}
    get managed() {return this.discordObject.managed;}
    get mentionable() {return this.discordObject.mentionable;}
    get hoist() {return this.discordObject.hoist;}
    get colour() {return this.discordObject.color;}
    get colourString() {return this.discordObject.colorString;}

    get guild() {
        return Guild.fromId(this.guildId);
    }

    get members() {
        return this.guild.members.filter(m => m.roles.includes(this));
    }
}

const emojis = new WeakMap();

class Emoji {
    constructor(data) {
        if (emojis.has(data)) return emojis.get(data);
        emojis.set(data, this);

        this.discordObject = data;
    }

    get id() {return this.discordObject.id;}
    get guildId() {return this.discordObject.guild_id;}
    get name() {return this.discordObject.name;}
    get managed() {return this.discordObject.managed;}
    get animated() {return this.discordObject.animated;}
    get allNamesString() {return this.discordObject.allNamesString;}
    get requireColons() {return this.discordObject.require_colons;}
    get url() {return this.discordObject.url;}
    get roles() {return this.discordObject.roles;}

    get guild() {
        return Guild.fromId(this.guildId);
    }
}

const guilds = new WeakMap();

/**
 * @memberof module:DiscordAPI
 */
class Guild {

    constructor(data) {
        if (guilds.has(data)) return guilds.get(data);
        guilds.set(data, this);

        this.discordObject = data;
    }

    static from(data) {
        return new Guild(data);
    }

    static fromId(id) {
        const guild = modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildStore.getGuild(id);
        if (guild) return Guild.from(guild);
    }

    static get Role() {return Role;}
    static get Emoji() {return Emoji;}

    get id() {return this.discordObject.id;}
    get ownerId() {return this.discordObject.ownerId;}
    get applicationId() {return this.discordObject.application_id;}
    get systemChannelId() {return this.discordObject.systemChannelId;}
    get name() {return this.discordObject.name;}
    get acronym() {return this.discordObject.acronym;}
    get icon() {return this.discordObject.icon;}
    get joinedAt() {return this.discordObject.joinedAt;}
    get verificationLevel() {return this.discordObject.verificationLevel;}
    get mfaLevel() {return this.discordObject.mfaLevel;}
    get large() {return this.discordObject.large;}
    get lazy() {return this.discordObject.lazy;}
    get voiceRegion() {return this.discordObject.region;}
    get afkChannelId() {return this.discordObject.afkChannelId;}
    get afkTimeout() {return this.discordObject.afkTimeout;}
    get explicitContentFilter() {return this.discordObject.explicitContentFilter;}
    get defaultMessageNotifications() {return this.discordObject.defaultMessageNotifications;}
    get splash() {return this.discordObject.splash;}
    get features() {return this.discordObject.features;}

    get owner() {
        return this.members.find(m => m.userId === this.ownerId);
    }

    get roles() {
        return structs__WEBPACK_IMPORTED_MODULE_1__["List"].from(Object.values(this.discordObject.roles), r => new Role(r, this.id))
            .sort((r1, r2) => r1.position === r2.position ? 0 : r1.position > r2.position ? 1 : -1);
    }

    get channels() {
        const channels = modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildChannelsStore.getChannels(this.id);
        const returnChannels = new structs__WEBPACK_IMPORTED_MODULE_1__["List"]();
        for (const category in channels) {
            if (channels.hasOwnProperty(category)) {
                if (!Array.isArray(channels[category])) continue;
                const channelList = channels[category];
                for (const channel of channelList) {
                    // For some reason Discord adds a new category with the ID "null" and name "Uncategorized"
                    if (channel.channel.id === "null") continue;
                    returnChannels.push(_channel__WEBPACK_IMPORTED_MODULE_2__["Channel"].from(channel.channel));
                }
            }
        }
        return returnChannels;
    }

    /**
     * Channels that don't have a parent. (Channel categories and any text/voice channel not in one.)
     */
    get mainChannels() {
        return this.channels.filter(c => !c.parentId);
    }

    /**
     * The guild's default channel. (Usually the first in the list.)
     */
    get defaultChannel() {
        return _channel__WEBPACK_IMPORTED_MODULE_2__["Channel"].from(modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildChannelsStore.getDefaultChannel(this.id));
    }

    /**
     * The guild's AFK channel.
     */
    get afkChannel() {
        if (this.afkChannelId) return _channel__WEBPACK_IMPORTED_MODULE_2__["Channel"].fromId(this.afkChannelId);
        return null;
    }

    /**
     * The channel system messages are sent to.
     */
    get systemChannel() {
        if (this.systemChannelId) return _channel__WEBPACK_IMPORTED_MODULE_2__["Channel"].fromId(this.systemChannelId);
        return null;
    }

    /**
     * A list of GuildMember objects.
     */
    get members() {
        const members = modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildMemberStore.getMembers(this.id);
        return structs__WEBPACK_IMPORTED_MODULE_1__["List"].from(members, m => new _user__WEBPACK_IMPORTED_MODULE_3__["GuildMember"](m, this.id));
    }

    /**
     * The current user as a GuildMember of this guild.
     */
    get currentUser() {
        return this.members.find(m => m.user === modules__WEBPACK_IMPORTED_MODULE_0__["DiscordAPI"].currentUser);
    }

    /**
     * The total number of members in the guild.
     */
    get memberCount() {
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].MemberCountStore.getMemberCount(this.id);
    }

    /**
     * An array of the guild's custom emojis.
     */
    get emojis() {
        return structs__WEBPACK_IMPORTED_MODULE_1__["List"].from(modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].EmojiUtils.getGuildEmoji(this.id), e => new Emoji(e));
    }

    checkPermissions(perms) {
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].Permissions.can(perms, modules__WEBPACK_IMPORTED_MODULE_0__["DiscordAPI"].currentUser, this.discordObject);
    }

    assertPermissions(name, perms) {
        if (!this.checkPermissions(perms)) throw new structs__WEBPACK_IMPORTED_MODULE_1__["InsufficientPermissions"](name);
    }

    /**
     * The current user's permissions on this guild.
     */
    get permissions() {
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildPermissions.getGuildPermissions(this.id);
    }

    getMember(id) {
        const member = modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildMemberStore.getMember(this.id, id);
        if (member) return new _user__WEBPACK_IMPORTED_MODULE_3__["GuildMember"](member, this.id);
    }

    isMember(id) {
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildMemberStore.isMember(this.id, id);
    }

    /**
     * Whether the user has not restricted direct messages from members of this guild.
     */
    get allowPrivateMessages() {
        return !modules__WEBPACK_IMPORTED_MODULE_0__["DiscordAPI"].UserSettings.restrictedGuildIds.includes(this.id);
    }

    /**
     * Marks all messages in the guild as read.
     */
    markAsRead() {
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildActions.markGuildAsRead(this.id);
    }

    /**
     * Selects the guild in the UI.
     */
    select() {
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildActions.selectGuild(this.id);
    }

    /**
     * Whether this guild is currently selected.
     */
    get isSelected() {
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordAPI"].currentGuild === this;
    }

    /**
     * Opens this guild's settings window.
     * @param {String} section The section to open (see DiscordConstants.GuildSettingsSections)
     */
    openSettings(section = "OVERVIEW") {
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildSettingsWindow.setSection(section);
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildSettingsWindow.open(this.id);
    }

    /**
     * Kicks members who don't have any roles and haven't been seen in the number of days passed.
     * @param {Number} days
     */
    pruneMembers(days) {
        this.assertPermissions("KICK_MEMBERS", modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordPermissions.KICK_MEMBERS);
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].PruneMembersModal.prune(this.id, days);
    }

    openPruneMumbersModal() {
        this.assertPermissions("KICK_MEMBERS", modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordPermissions.KICK_MEMBERS);
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].PruneMembersModal.open(this.id);
    }

    /**
     * Opens the create channel modal for this guild.
     * @param {Number} type The type of channel to create - either 0 (text), 2 (voice) or 4 (category)
     * @param {ChannelCategory} category The category to create the channel in
     * @param {GuildChannel} clone A channel to clone permissions, topic, bitrate and user limit of
     */
    openCreateChannelModal(type, category, clone) {
        this.assertPermissions("MANAGE_CHANNELS", modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordPermissions.MANAGE_CHANNELS);
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].CreateChannelModal.open(type, this.id, category ? category.id : undefined, clone ? clone.id : undefined);
    }

    /**
     * Creates a channel in this guild.
     * @param {Number} type The type of channel to create - either 0 (text), 2 (voice) or 4 (category)
     * @param {String} name A name for the new channel
     * @param {ChannelCategory} category The category to create the channel in
     * @param {Array} permission_overwrites An array of PermissionOverwrite-like objects - leave to use the permissions of the category
     * @return {Promise<GuildChannel>}
     */
    async createChannel(type, name, category, permission_overwrites) {
        this.assertPermissions("MANAGE_CHANNELS", modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordPermissions.MANAGE_CHANNELS);
        const response = await modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].APIModule.post({
            url: modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordConstants.Endpoints.GUILD_CHANNELS(this.id), // eslint-disable-line new-cap
            body: {
                type,
                name,
                parent_id: category ? category.id : undefined,
                permission_overwrites: permission_overwrites ? permission_overwrites.map(p => ({
                    type: p.type,
                    id: (p.type === "user" ? p.userId : p.roleId) || p.id,
                    allow: p.allow,
                    deny: p.deny
                })) : undefined
            }
        });

        return _channel__WEBPACK_IMPORTED_MODULE_2__["Channel"].fromId(response.body.id);
    }

    openNotificationSettingsModal() {
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].NotificationSettingsModal.open(this.id);
    }

    openPrivacySettingsModal() {
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].PrivacySettingsModal.open(this.id);
    }

    nsfwAgree() {
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildActions.nsfwAgree(this.id);
    }

    nsfwDisagree() {
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildActions.nsfwDisagree(this.id);
    }

    /**
     * Changes the guild's position in the list.
     * @param {Number} index The new position
     */
    changeSortLocation(index) {
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildActions.move(modules__WEBPACK_IMPORTED_MODULE_0__["DiscordAPI"].guildPositions.indexOf(this.id), index);
    }

    /**
     * Updates this guild.
     * @return {Promise}
     */
    async updateGuild(body) {
        this.assertPermissions("MANAGE_GUILD", modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordPermissions.MANAGE_GUILD);
        await modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildSettingsWindow.saveGuild(this.id, body);
        this.discordObject = modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildStore.getGuild(this.id);
        guilds.set(this.discordObject, this);
    }

    /**
     * Updates this guild's name.
     * @param {String} name The new name
     * @return {Promise}
     */
    updateName(name) {
        return this.updateGuild({name});
    }

    /**
     * Updates this guild's voice region.
     * @param {String} region The ID of the new voice region (obtainable via the API - see https://discordapp.com/developers/docs/resources/voice#list-voice-regions)
     * @return {Promise}
     */
    updateVoiceRegion(region) {
        return this.updateGuild({region});
    }

    /**
     * Updates this guild's verification level.
     * @param {Number} verificationLevel The new verification level (see https://discordapp.com/developers/docs/resources/guild#guild-object-verification-level)
     * @return {Promise}
     */
    updateVerificationLevel(verification_level) {
        return this.updateGuild({verification_level});
    }

    /**
     * Updates this guild's default message notification level.
     * @param {Number} defaultMessageNotifications The new default notification level (0: all messages, 1: only mentions)
     * @return {Promise}
     */
    updateDefaultMessageNotifications(default_message_notifications) {
        return this.updateGuild({default_message_notifications});
    }

    /**
     * Updates this guild's explicit content filter level.
     * @param {Number} explicitContentFilter The new explicit content filter level (0: disabled, 1: members without roles, 2: everyone)
     * @return {Promise}
     */
    updateExplicitContentFilter(explicit_content_filter) {
        return this.updateGuild({explicit_content_filter});
    }

    /**
     * Updates this guild's AFK channel.
     * @param {GuildVoiceChannel} afkChannel The new AFK channel
     * @return {Promise}
     */
    updateAfkChannel(afk_channel) {
        return this.updateGuild({afk_channel_id: afk_channel.id || afk_channel});
    }

    /**
     * Updates this guild's AFK timeout.
     * @param {Number} afkTimeout The new AFK timeout
     * @return {Promise}
     */
    updateAfkTimeout(afk_timeout) {
        return this.updateGuild({afk_timeout});
    }

    /**
     * Updates this guild's icon.
     * @param {Buffer|String} icon A buffer/base 64 encoded 128x128 JPEG image
     * @return {Promise}
     */
    updateIcon(icon) {
        return this.updateGuild({icon: typeof icon === "string" ? icon : icon.toString("base64")});
    }

    /**
     * Updates this guild's icon using a local file.
     * TODO
     * @param {String} icon_path The path to the new icon
     * @return {Promise}
     */
    async updateIconFromFile(icon_path) {
        const buffer = await modules__WEBPACK_IMPORTED_MODULE_0__["Utilities"].readFileBuffer(icon_path);
        return this.updateIcon(buffer);
    }

    /**
     * Updates this guild's owner. (Should plugins really ever need to do this?)
     * @param {User|GuildMember} owner The user/guild member to transfer ownership to
     * @return {Promise}
     */
    updateOwner(owner) {
        return this.updateGuild({owner_id: owner.user ? owner.user.id : owner.id || owner});
    }

    /**
     * Updates this guild's splash image.
     * (I don't know what this is actually used for. The API documentation says it's VIP-only.)
     * @param {Buffer|String} icon A buffer/base 64 encoded 128x128 JPEG image
     * @return {Promise}
     */
    updateSplash(splash) {
        return this.updateGuild({splash: typeof splash === "string" ? splash : splash.toString("base64")});
    }

    /**
     * Updates this guild's splash image using a local file.
     * TODO
     * @param {String} splash_path The path to the new splash
     * @return {Promise}
     */
    async updateSplashFromFile(splash_path) {
        const buffer = await modules__WEBPACK_IMPORTED_MODULE_0__["Utilities"].readFileBuffer(splash_path);
        return this.updateSplash(buffer);
    }

    /**
     * Updates this guild's system channel.
     * @param {GuildTextChannel} systemChannel The new system channel
     * @return {Promise}
     */
    updateSystemChannel(system_channel) {
        return this.updateGuild({system_channel_id: system_channel.id || system_channel});
    }

}



/***/ }),

/***/ "./src/structs/discord/message.js":
/*!****************************************!*\
  !*** ./src/structs/discord/message.js ***!
  \****************************************/
/*! exports provided: Reaction, Embed, Message, DefaultMessage, RecipientAddMessage, RecipientRemoveMessage, CallMessage, GroupChannelNameChangeMessage, GroupChannelIconChangeMessage, MessagePinnedMessage, GuildMemberJoinMessage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Reaction", function() { return Reaction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Embed", function() { return Embed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Message", function() { return Message; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultMessage", function() { return DefaultMessage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RecipientAddMessage", function() { return RecipientAddMessage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RecipientRemoveMessage", function() { return RecipientRemoveMessage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CallMessage", function() { return CallMessage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GroupChannelNameChangeMessage", function() { return GroupChannelNameChangeMessage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GroupChannelIconChangeMessage", function() { return GroupChannelIconChangeMessage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MessagePinnedMessage", function() { return MessagePinnedMessage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GuildMemberJoinMessage", function() { return GuildMemberJoinMessage; });
/* harmony import */ var modules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! modules */ "./src/modules/modules.js");
/* harmony import */ var structs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! structs */ "./src/structs/structs.js");
/* harmony import */ var _channel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./channel */ "./src/structs/discord/channel.js");
/* harmony import */ var _user__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./user */ "./src/structs/discord/user.js");
/**
 * BetterDiscord Message Struct
 * Copyright (c) 2018-present JsSucks
 * All rights reserved.
 *
 * This source code is licensed under the MIT license found at
 * https://github.com/JsSucks/BetterDiscordApp/blob/master/LICENSE
*/






const reactions = new WeakMap();

class Reaction {
    constructor(data, message_id, channel_id) {
        if (reactions.has(data)) return reactions.get(data);
        reactions.set(data, this);

        this.discordObject = data;
        this.messageId = message_id;
        this.channelId = channel_id;
    }

    get emoji() {
        const id = this.discordObject.emoji.id;
        if (!id || !this.guild) return this.discordObject.emoji;
        return this.guild.emojis.find(e => e.id === id);
    }

    get count() {return this.discordObject.count;}
    get me() {return this.discordObject.me;}

    get channel() {
        return _channel__WEBPACK_IMPORTED_MODULE_2__["Channel"].fromId(this.channel_id);
    }

    get message() {
        if (this.channel) return this.channel.messages.find(m => m.id === this.messageId);
        return null;
    }

    get guild() {
        if (this.channel) return this.channel.guild;
        return null;
    }
}

const embeds = new WeakMap();

class Embed {
    constructor(data, message_id, channel_id) {
        if (embeds.has(data)) return embeds.get(data);
        embeds.set(data, this);

        this.discordObject = data;
        this.messageId = message_id;
        this.channelId = channel_id;
    }

    get title() {return this.discordObject.title;}
    get type() {return this.discordObject.type;}
    get description() {return this.discordObject.description;}
    get url() {return this.discordObject.url;}
    get timestamp() {return this.discordObject.timestamp;}
    get colour() {return this.discordObject.color;}
    get footer() {return this.discordObject.footer;}
    get image() {return this.discordObject.image;}
    get thumbnail() {return this.discordObject.thumbnail;}
    get video() {return this.discordObject.video;}
    get provider() {return this.discordObject.provider;}
    get author() {return this.discordObject.author;}
    get fields() {return this.discordObject.fields;}

    get channel() {
        return _channel__WEBPACK_IMPORTED_MODULE_2__["Channel"].fromId(this.channelId);
    }

    get message() {
        if (this.channel) return this.channel.messages.find(m => m.id === this.messageId);
        return null;
    }

    get guild() {
        if (this.channel) return this.channel.guild;
        return null;
    }
}

const messages = new WeakMap();

/**
 * @memberof module:DiscordAPI
 */
class Message {

    constructor(data) {
        if (messages.has(data)) return messages.get(data);
        messages.set(data, this);

        this.discordObject = data;
    }

    static from(data) {
        switch (data.type) {
            default: return new Message(data);
            case 0: return new DefaultMessage(data);
            case 1: return new RecipientAddMessage(data);
            case 2: return new RecipientRemoveMessage(data);
            case 3: return new CallMessage(data);
            case 4: return new GroupChannelNameChangeMessage(data);
            case 5: return new GroupChannelIconChangeMessage(data);
            case 6: return new MessagePinnedMessage(data);
            case 7: return new GuildMemberJoinMessage(data);
        }
    }

    static get DefaultMessage() {return DefaultMessage;}
    static get RecipientAddMessage() {return RecipientAddMessage;}
    static get RecipientRemoveMessage() {return RecipientRemoveMessage;}
    static get CallMessage() {return CallMessage;}
    static get GroupChannelNameChangeMessage() {return GroupChannelNameChangeMessage;}
    static get GroupChannelIconChangeMessage() {return GroupChannelIconChangeMessage;}
    static get MessagePinnedMessage() {return MessagePinnedMessage;}
    static get GuildMemberJoinMessage() {return GuildMemberJoinMessage;}

    static get Reaction() {return Reaction;}
    static get Embed() {return Embed;}

    get id() {return this.discordObject.id;}
    get channelId() {return this.discordObject.channel_id;}
    get nonce() {return this.discordObject.nonce;}
    get type() {return this.discordObject.type;}
    get timestamp() {return this.discordObject.timestamp;}
    get state() {return this.discordObject.state;}
    get nick() {return this.discordObject.nick;}
    get colourString() {return this.discordObject.colorString;}

    get author() {
        if (this.discordObject.author && !this.webhookId) return _user__WEBPACK_IMPORTED_MODULE_3__["User"].from(this.discordObject.author);
        return null;
    }

    get channel() {
        return _channel__WEBPACK_IMPORTED_MODULE_2__["Channel"].fromId(this.channelId);
    }

    get guild() {
        if (this.channel) return this.channel.guild;
        return null;
    }

    /**
     * Deletes the message.
     * @return {Promise}
     */
    delete() {
        if (!this.isDeletable) throw new Error(`Message type ${this.type} is not deletable.`);
        if (this.author !== modules__WEBPACK_IMPORTED_MODULE_0__["DiscordAPI"].currentUser) {
            if (this.channel.assertPermissions) this.channel.assertPermissions("MANAGE_MESSAGES", modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordPermissions.MANAGE_MESSAGES);
            else if (!this.channel.owner === modules__WEBPACK_IMPORTED_MODULE_0__["DiscordAPI"].currentUser) throw new structs__WEBPACK_IMPORTED_MODULE_1__["InsufficientPermissions"]("MANAGE_MESSAGES");
        }

        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].APIModule.delete(`${modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordConstants.Endpoints.MESSAGES(this.channelId)}/${this.id}`); // eslint-disable-line new-cap
    }

    get isDeletable() {
        return this.type === "DEFAULT" || this.type === "CHANNEL_PINNED_MESSAGE" || this.type === "GUILD_MEMBER_JOIN";
    }

    /**
     * Jumps to the message.
     */
    jumpTo(flash = true) {
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].MessageActions.jumpToMessage(this.channelId, this.id, flash);
    }

}



class DefaultMessage extends Message {
    get webhookId() {return this.discordObject.webhookId;}
    get type() {return "DEFAULT";}
    get content() {return this.discordObject.content;}
    get contentParsed() {return this.discordObject.contentParsed;}
    get inviteCodes() {return this.discordObject.invites;}
    get attachments() {return this.discordObject.attachments;}
    get mentionIds() {return this.discordObject.mentions;}
    get mentionRoleIds() {return this.discordObject.mentionRoles;}
    get mentionEveryone() {return this.discordObject.mentionEveryone;}
    get editedTimestamp() {return this.discordObject.editedTimestamp;}
    get tts() {return this.discordObject.tts;}
    get mentioned() {return this.discordObject.mentioned;}
    get bot() {return this.discordObject.bot;}
    get blocked() {return this.discordObject.blocked;}
    get pinned() {return this.discordObject.pinned;}
    get activity() {return this.discordObject.activity;}
    get application() {return this.discordObject.application;}

    get webhook() {
        if (this.webhookId) return this.discordObject.author;
        return null;
    }

    get mentions() {
        return structs__WEBPACK_IMPORTED_MODULE_1__["List"].from(this.mentionIds, id => _user__WEBPACK_IMPORTED_MODULE_3__["User"].fromId(id));
    }

    get mention_roles() {
        return structs__WEBPACK_IMPORTED_MODULE_1__["List"].from(this.mentionRoleIds, id => this.guild.roles.find(r => r.id === id));
    }

    get embeds() {
        return structs__WEBPACK_IMPORTED_MODULE_1__["List"].from(this.discordObject.embeds, r => new Embed(r, this.id, this.channelId));
    }

    get reactions() {
        return structs__WEBPACK_IMPORTED_MODULE_1__["List"].from(this.discordObject.reactions, r => new Reaction(r, this.id, this.channelId));
    }

    get edited() {
        return !!this.editedTimestamp;
    }

    /**
     * Programmatically update the message's content.
     * @param {String} content The message's new content
     * @param {Boolean} parse Whether to parse the message or update it as it is
     * @return {Promise}
     */
    async edit(content, parse = false) {
        if (this.author !== modules__WEBPACK_IMPORTED_MODULE_0__["DiscordAPI"].currentUser) throw new Error("Cannot edit messages sent by other users.");
        if (parse) content = modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].MessageParser.parse(this.discordObject, content);
        else content = {content};

        const response = await modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].APIModule.patch({
            url: `${modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordConstants.Endpoints.MESSAGES(this.channelId)}/${this.id}`, // eslint-disable-line new-cap
            body: content
        });

        this.discordObject = modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].MessageStore.getMessage(this.id, response.body.id);
        messages.set(this.discordObject, this);
    }

    /**
     * Start the edit mode of the UI.
     * @param {String} content A string to show in the message text area - if empty the message's current content will be used
     */
    startEdit(content) {
        if (this.author !== modules__WEBPACK_IMPORTED_MODULE_0__["DiscordAPI"].currentUser) throw new Error("Cannot edit messages sent by other users.");
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].MessageActions.startEditMessage(this.channelId, this.id, content || this.content);
    }

    /**
     * Exit the edit mode of the UI.
     */
    endEdit() {
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].MessageActions.endEditMessage();
    }
}

class RecipientAddMessage extends Message {
    get type() {return "RECIPIENT_ADD";}
    get addedUserId() {return this.discordObject.mentions[0];}

    get addedUser() {
        return _user__WEBPACK_IMPORTED_MODULE_3__["User"].fromId(this.addedUserId);
    }
}

class RecipientRemoveMessage extends Message {
    get type() {return "RECIPIENT_REMOVE";}
    get removedUserId() {return this.discordObject.mentions[0];}

    get removedUser() {
        return _user__WEBPACK_IMPORTED_MODULE_3__["User"].fromId(this.removedUserId);
    }

    get userLeft() {
        return this.author === this.removedUser;
    }
}

class CallMessage extends Message {
    get type() {return "CALL";}
    get mentionIds() {return this.discordObject.mentions;}
    get call() {return this.discordObject.call;}

    get endedTimestamp() {return this.call.endedTimestamp;}

    get mentions() {
        return structs__WEBPACK_IMPORTED_MODULE_1__["List"].from(this.mentionIds, id => _user__WEBPACK_IMPORTED_MODULE_3__["User"].fromId(id));
    }

    get participants() {
        return structs__WEBPACK_IMPORTED_MODULE_1__["List"].from(this.call.participants, id => _user__WEBPACK_IMPORTED_MODULE_3__["User"].fromId(id));
    }
}

class GroupChannelNameChangeMessage extends Message {
    get type() {return "CHANNEL_NAME_CHANGE";}
    get newName() {return this.discordObject.content;}
}

class GroupChannelIconChangeMessage extends Message {
    get type() {return "CHANNEL_ICON_CHANGE";}
}

class MessagePinnedMessage extends Message {
    get type() {return "CHANNEL_PINNED_MESSAGE";}
}

class GuildMemberJoinMessage extends Message {
    get type() {return "GUILD_MEMBER_JOIN";}
}


/***/ }),

/***/ "./src/structs/discord/user.js":
/*!*************************************!*\
  !*** ./src/structs/discord/user.js ***!
  \*************************************/
/*! exports provided: User, GuildMember */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "User", function() { return User; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GuildMember", function() { return GuildMember; });
/* harmony import */ var modules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! modules */ "./src/modules/modules.js");
/* harmony import */ var structs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! structs */ "./src/structs/structs.js");
/* harmony import */ var _guild__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./guild */ "./src/structs/discord/guild.js");
/* harmony import */ var _channel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./channel */ "./src/structs/discord/channel.js");
/**
 * BetterDiscord User Struct
 * Copyright (c) 2018-present JsSucks
 * All rights reserved.
 *
 * This source code is licensed under the MIT license found at
 * https://github.com/JsSucks/BetterDiscordApp/blob/master/LICENSE
*/






const users = new WeakMap();

/**
 * @memberof module:DiscordAPI
 */
class User {

    constructor(data) {
        if (users.has(data)) return users.get(data);
        users.set(data, this);

        this.discordObject = data;
    }

    static from(data) {
        return new User(data);
    }

    static fromId(id) {
        const user = modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserStore.getUser(id);
        if (user) return User.from(user);
    }

    get id() {return this.discordObject.id;}
    get username() {return this.discordObject.username;}
    get usernameLowerCase() {return this.discordObject.usernameLowerCase;}
    get discriminator() {return this.discordObject.discriminator;}
    get avatar() {return this.discordObject.avatar;}
    get email() {return undefined;}
    get phone() {return undefined;}
    get flags() {return this.discordObject.flags;}
    get isBot() {return this.discordObject.bot;}
    get premium() {return this.discordObject.premium;}
    get verified() {return this.discordObject.verified;}
    get mfaEnabled() {return this.discordObject.mfaEnabled;}
    get mobile() {return this.discordObject.mobile;}

    get tag() {return this.discordObject.tag;}
    get avatarUrl() {return this.discordObject.avatarURL;}
    get createdAt() {return this.discordObject.createdAt;}

    get isClamied() {return this.discordObject.isClaimed();}
    get isLocalBot() {return this.discordObject.isLocalBot();}
    get isPhoneVerified() {return this.discordObject.isPhoneVerified();}

    get guilds() {
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordAPI"].guilds.filter(g => g.members.find(m => m.user === this));
    }

    get status() {
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserStatusStore.getStatus(this.id);
    }

    get activity() {
        // type can be either 0 (normal/rich presence game), 1 (streaming) or 2 (listening to Spotify)
        // (3 appears as watching but is undocumented)
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserStatusStore.getActivity(this.id);
    }

    get note() {
        const note = modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserNoteStore.getNote(this.id);
        if (note) return note;
        return null;
    }

    /**
     * Updates the note for this user.
     * @param {String} note The new note
     * @return {Promise}
     */
    updateNote(note) {
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].APIModule.put({
            url: `${modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordConstants.Endpoints.NOTES}/${this.id}`,
            body: {note}
        });
    }

    get privateChannel() {
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordAPI"].channels.find(c => c.type === "DM" && c.recipientId === this.id);
    }

    async ensurePrivateChannel() {
        if (modules__WEBPACK_IMPORTED_MODULE_0__["DiscordAPI"].currentUser === this) throw new Error("Cannot create a direct message channel to the current user.");
        return _channel__WEBPACK_IMPORTED_MODULE_3__["Channel"].fromId(await modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].PrivateChannelActions.ensurePrivateChannel(modules__WEBPACK_IMPORTED_MODULE_0__["DiscordAPI"].currentUser.id, this.id));
    }

    async sendMessage(content, parse = true) {
        const channel = await this.ensurePrivateChannel();
        return channel.sendMessage(content, parse);
    }

    get isFriend() {
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].RelationshipStore.isFriend(this.id);
    }

    get isBlocked() {
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].RelationshipStore.isBlocked(this.id);
    }

    addFriend() {
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].RelationshipManager.addRelationship(this.id, {location: "Context Menu"});
    }

    removeFriend() {
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].RelationshipManager.removeRelationship(this.id, {location: "Context Menu"});
    }

    block() {
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].RelationshipManager.addRelationship(this.id, {location: "Context Menu"}, modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordConstants.RelationshipTypes.BLOCKED);
    }

    unblock() {
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].RelationshipManager.removeRelationship(this.id, {location: "Context Menu"});
    }

    /**
     * Opens the profile modal for this user.
     * @param {String} section The section to open (see DiscordConstants.UserProfileSections)
     */
    openUserProfileModal(section = "USER_INFO") {
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserProfileModal.open(this.id);
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserProfileModal.setSection(section);
    }
}



const guild_members = new WeakMap();

class GuildMember {
    constructor(data, guild_id) {
        if (guild_members.has(data)) return guild_members.get(data);
        guild_members.set(data, this);

        this.discordObject = data;
        this.guildId = guild_id;
    }

    get userId() {return this.discordObject.userId;}
    get nickname() {return this.discordObject.nick;}
    get colourString() {return this.discordObject.colorString;}
    get hoistRoleId() {return this.discordObject.hoistRoleId;}
    get roleIds() {return this.discordObject.roles;}

    get user() {
        return User.fromId(this.userId);
    }

    get name() {
        return this.nickname || this.user.username;
    }

    get guild() {
        return _guild__WEBPACK_IMPORTED_MODULE_2__["Guild"].fromId(this.guildId);
    }

    get roles() {
        return structs__WEBPACK_IMPORTED_MODULE_1__["List"].from(this.roleIds, id => this.guild.roles.find(r => r.id === id))
            .sort((r1, r2) => r1.position === r2.position ? 0 : r1.position > r2.position ? 1 : -1);
    }

    get hoistRole() {
        return this.guild.roles.find(r => r.id === this.hoistRoleId);
    }

    checkPermissions(perms) {
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].Permissions.can(perms, modules__WEBPACK_IMPORTED_MODULE_0__["DiscordAPI"].currentUser.discordObject, this.guild.discordObject);
    }

    assertPermissions(name, perms) {
        if (!this.checkPermissions(perms)) throw new structs__WEBPACK_IMPORTED_MODULE_1__["InsufficientPermissions"](name);
    }

    /**
     * Opens the modal to change this user's nickname.
     */
    openChangeNicknameModal() {
        if (modules__WEBPACK_IMPORTED_MODULE_0__["DiscordAPI"].currentUser === this.user) this.assertPermissions("CHANGE_NICKNAME", modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordPermissions.CHANGE_NICKNAME);
        else this.assertPermissions("MANAGE_NICKNAMES", modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordPermissions.MANAGE_NICKNAMES);

        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].ChangeNicknameModal.open(this.guildId, this.userId);
    }

    /**
     * Changes the user's nickname on this guild.
     * @param {String} nickname The user's new nickname
     * @return {Promise}
     */
    changeNickname(nick) {
        if (modules__WEBPACK_IMPORTED_MODULE_0__["DiscordAPI"].currentUser === this.user) this.assertPermissions("CHANGE_NICKNAME", modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordPermissions.CHANGE_NICKNAME);
        else this.assertPermissions("MANAGE_NICKNAMES", modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordPermissions.MANAGE_NICKNAMES);

        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].APIModule.patch({
            url: `${modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordConstants.Endpoints.GUILD_MEMBERS(this.guild_id)}/${modules__WEBPACK_IMPORTED_MODULE_0__["DiscordAPI"].currentUser === this.user ? "@me/nick" : this.userId}`, // eslint-disable-line new-cap
            body: {nick}
        });
    }

    /**
     * Kicks this user from the guild.
     * @param {String} reason A reason to attach to the audit log entry
     * @return {Promise}
     */
    kick(reason = "") {
        this.assertPermissions("KICK_MEMBERS", modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordPermissions.KICK_MEMBERS);
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildActions.kickUser(this.guildId, this.userId, reason);
    }

    /**
     * Bans this user from the guild.
     * @param {Number} daysToDelete The number of days of the user's recent message history to delete
     * @param {String} reason A reason to attach to the audit log entry
     * @return {Promise}
     */
    ban(daysToDelete = 1, reason = "") {
        this.assertPermissions("BAN_MEMBERS", modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordPermissions.BAN_MEMBERS);
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildActions.banUser(this.guildId, this.userId, daysToDelete, reason);
    }

    /**
     * Removes the ban for this user.
     * @return {Promise}
     */
    unban() {
        this.assertPermissions("BAN_MEMBERS", modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordPermissions.BAN_MEMBERS);
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildActions.unbanUser(this.guildId, this.userId);
    }

    /**
     * Moves this user to another voice channel.
     * @param {GuildVoiceChannel} channel The channel to move this user to
     */
    move(channel) {
        this.assertPermissions("MOVE_MEMBERS", modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordPermissions.MOVE_MEMBERS);
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildActions.setChannel(this.guildId, this.userId, channel.id);
    }

    /**
     * Mutes this user for everyone in the guild.
     */
    mute(active = true) {
        this.assertPermissions("MUTE_MEMBERS", modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordPermissions.MUTE_MEMBERS);
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildActions.setServerMute(this.guildId, this.userId, active);
    }

    /**
     * Unmutes this user.
     */
    unmute() {
        this.mute(false);
    }

    /**
     * Deafens this user.
     */
    deafen(active = true) {
        this.assertPermissions("DEAFEN_MEMBERS", modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordPermissions.DEAFEN_MEMBERS);
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].GuildActions.setServerDeaf(this.guildId, this.userId, active);
    }

    /**
     * Undeafens this user.
     */
    undeafen() {
        this.deafen(false);
    }

    /**
     * Gives this user a role.
     * @param {Role} role The role to add
     * @return {Promise}
     */
    addRole(...roles) {
        const newRoles = this.roleIds.concat([]);
        let changed = false;
        for (const role of roles) {
            if (newRoles.includes(role.id || role)) continue;
            newRoles.push(role.id || role);
            changed = true;
        }
        if (!changed) return;
        return this.updateRoles(newRoles);
    }

    /**
     * Removes a role from this user.
     * @param {Role} role The role to remove
     * @return {Promise}
     */
    removeRole(...roles) {
        const newRoles = this.roleIds.concat([]);
        let changed = false;
        for (const role of roles) {
            if (!newRoles.includes(role.id || role)) continue;
            modules__WEBPACK_IMPORTED_MODULE_0__["Utilities"].removeFromArray(newRoles, role.id || role);
            changed = true;
        }
        if (!changed) return;
        return this.updateRoles(newRoles);
    }

    /**
     * Updates this user's roles.
     * @param {Array} roles An array of Role objects or role IDs
     * @return {Promise}
     */
    updateRoles(roles) {
        roles = roles.map(r => r.id || r);
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].APIModule.patch({
            url: `${modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].DiscordConstants.Endpoints.GUILD_MEMBERS(this.guildId)}/${this.userId}`, // eslint-disable-line new-cap
            body: {roles}
        });
    }
}


/***/ }),

/***/ "./src/structs/discord/usersettings.js":
/*!*********************************************!*\
  !*** ./src/structs/discord/usersettings.js ***!
  \*********************************************/
/*! exports provided: UserSettings */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UserSettings", function() { return UserSettings; });
/* harmony import */ var modules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! modules */ "./src/modules/modules.js");
/* harmony import */ var structs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! structs */ "./src/structs/structs.js");
/* harmony import */ var _guild__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./guild */ "./src/structs/discord/guild.js");
/**
 * BetterDiscord Channel Struct
 * Copyright (c) 2018-present JsSucks
 * All rights reserved.
 *
 * This source code is licensed under the MIT license found at
 * https://github.com/JsSucks/BetterDiscordApp/blob/master/LICENSE
*/







/**
 * @memberof module:DiscordAPI
 */
class UserSettings {
    /**
     * Opens Discord's settings UI.
     */
    static open(section = "ACCOUNT") {
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserSettingsWindow.setSection(section);
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserSettingsWindow.open();
    }

    /**
     * The user's current status. Either "online", "idle", "dnd" or "invisible".
     */
    static get status() {return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserSettingsStore.status;}

    /**
     * The user's selected explicit content filter level.
     * 0 == off, 1 == everyone except friends, 2 == everyone
     * Configurable in the privacy and safety panel.
     */
    static get explicitContentFilter() {return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserSettingsStore.explicitContentFilter;}

    /**
     * Whether to disallow direct messages from server members by default.
     */
    static get defaultGuildsRestricted() {return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserSettingsStore.defaultGuildsRestricted;}

    /**
     * An array of guilds to disallow direct messages from their members.
     * This is bypassed if the member is has another mutual guild with this disabled, or the member is friends with the current user.
     * Configurable in each server's privacy settings.
     */
    static get restrictedGuildIds() {return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserSettingsStore.restrictedGuilds;}

    static get restrictedGuilds() {
        return structs__WEBPACK_IMPORTED_MODULE_1__["List"].from(this.restrictedGuildIds, id => _guild__WEBPACK_IMPORTED_MODULE_2__["Guild"].fromId(id) || id);
    }

    /**
     * An array of flags specifying who should be allowed to add the current user as a friend.
     * If everyone is checked, this will only have one item, "all". Otherwise it has either "mutual_friends", "mutual_guilds", both or neither.
     * Configurable in the privacy and safety panel.
     */
    static get friendSourceFlags() {return Object.keys(modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserSettingsStore.friendSourceFlags);}
    static get friendSourceEveryone() {return this.friend_source_flags.include("all");}
    static get friendSourceMutual_friends() {return this.friend_source_flags.include("all") || this.friend_source_flags.include("mutual_friends");}
    static get friendSourceMutual_guilds() {return this.friend_source_flags.include("all") || this.friend_source_flags.include("mutual_guilds");}
    static get friendSourceAnyone() {return this.friend_source_flags.length > 0;}

    /**
     * Whether to automatically add accounts from other platforms running on the user's computer.
     * Configurable in the connections panel.
     */
    static get detectPlatformAccounts() {return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserSettingsStore.detectPlatformAccounts;}

    /**
     * The number of seconds Discord will wait for activity before sending mobile push notifications.
     * Configurable in the notifications panel.
     */
    static get afkTimeout() {return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserSettingsStore.afkTimeout;}

    /**
     * Whether to display the currently running game as a status message.
     * Configurable in the games panel.
     */
    static get showCurrentGame() {return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserSettingsStore.showCurrentGame;}

    /**
     * Whether to show images uploaded directly to Discord.
     * Configurable in the text and images panel.
     */
    static get inlineAttachmentMedia() {return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserSettingsStore.inlineAttachmentMedia;}

    /**
     * Whether to show images linked in Discord.
     * Configurable in the text and images panel.
     */
    static get inlineEmbedMedia() {return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserSettingsStore.inlineEmbedMedia;}

    /**
     * Whether to automatically play GIFs when the Discord window is active without having to hover the mouse over the image.
     * Configurable in the text and images panel.
     */
    static get autoplayGifs() {return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserSettingsStore.gifAutoPlay;}

    /**
     * Whether to show content from HTTP[s] links as embeds.
     * Configurable in the text and images panel.
     */
    static get showEmbeds() {return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserSettingsStore.renderEmbeds;}

    /**
     * Whether to show a message's reactions.
     * Configurable in the text and images panel.
     */
    static get showReactions() {return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserSettingsStore.renderReactions;}

    /**
     * Whether to play animated emoji.
     * Configurable in the text and images panel.
     */
    static get animateEmoji() {return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserSettingsStore.animateEmoji;}

    /**
     * Whether to convert ASCII emoticons to emoji.
     * Configurable in the text and images panel.
     */
    static get convertEmoticons() {return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserSettingsStore.convertEmoticons;}

    /**
     * Whether to allow playing text-to-speech messages.
     * Configurable in the text and images panel.
     */
    static get allowTts() {return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserSettingsStore.enableTTSCommand;}

    /**
     * The user's selected theme. Either "dark" or "light".
     * Configurable in the appearance panel.
     */
    static get theme() {return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserSettingsStore.theme;}

    /**
     * Whether the user has enabled compact mode.
     * `true` if compact mode is enabled, `false` if cozy mode is enabled.
     * Configurable in the appearance panel.
     */
    static get displayCompact() {return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserSettingsStore.messageDisplayCompact;}

    /**
     * Whether the user has enabled developer mode.
     * Currently only adds a "Copy ID" option to the context menu on users, guilds and channels.
     * Configurable in the appearance panel.
     */
    static get developerMode() {return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserSettingsStore.developerMode;}

    /**
     * The user's selected language code.
     * Configurable in the language panel.
     */
    static get locale() {return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserSettingsStore.locale;}

    /**
     * The user's timezone offset in hours.
     * This is not configurable.
     */
    static get timezoneOffset() {return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserSettingsStore.timezoneOffset;}
}



/***/ }),

/***/ "./src/structs/dom/classname.js":
/*!**************************************!*\
  !*** ./src/structs/dom/classname.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _selector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./selector */ "./src/structs/dom/selector.js");


/** 
 * Representation of a Class Name
 * @memberof module:DOMTools
 **/
class ClassName {
    /**
     * 
     * @param {string} name - name of the class to represent
     */
    constructor(name) {
        this.value = name;
    }
    
    /**
     * Concatenates new class names to the current one using spaces.
     * @param {string} classNames - list of class names to add to this class name
     * @returns {ClassName} returns self to allow chaining
     */
    add(...classNames) {
        for (let i = 0; i < classNames.length; i++) this.value += " " + classNames[i];
        return this;
    }
    
    /**
     * Returns the raw class name, this is how native function get the value.
     * @returns {string} raw class name.
     */
    toString() {
        return this.value;
    }
    
    /**
     * Returns the raw class name, this is how native function get the value.
     * @returns {string} raw class name.
     */
    valueOf() {
        return this.value;
    }
    
    /**
     * Returns the classname represented as {@link module:DOMTools.Selector}.
     * @returns {Selector} selector representation of this class name.
     */
    get selector() {
        return new _selector__WEBPACK_IMPORTED_MODULE_0__["default"](this.value);
    }

    get single() {
        return this.value.split(" ")[0];
    }

    get first() {
        return this.value.split(" ")[0];
    }
}

/* harmony default export */ __webpack_exports__["default"] = (ClassName);

/***/ }),

/***/ "./src/structs/dom/observer.js":
/*!*************************************!*\
  !*** ./src/structs/dom/observer.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var modules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! modules */ "./src/modules/modules.js");
/**
 * BetterDiscord Client DOM Module
 * Copyright (c) 2015-present JsSucks - https://github.com/JsSucks
 * All rights reserved.
 * https://betterdiscord.net
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
*/



/* eslint-disable operator-linebreak */

/** 
 * Representation of a MutationObserver but with helpful utilities.
 * @memberof module:DOMTools
 **/
class DOMObserver {
    constructor(root, options) {
        this.observe = this.observe.bind(this);
        this.subscribe = this.subscribe.bind(this);
        this.observerCallback = this.observerCallback.bind(this);

        this.active = false;
        this.root = root || document.getElementById("app-mount");
        this.options = options || {attributes: true, childList: true, subtree: true};

        this.observer = new MutationObserver(this.observerCallback);
        this.observe();
    }

    observerCallback(mutations) {
        for (const sub of Array.from(this.subscriptions)) {
            try {
                const filteredMutations = sub.filter ? mutations.filter(sub.filter) : mutations;

                if (sub.group) {
                    if (!filteredMutations.length) continue;
                    sub.callback.call(sub.bind || sub, filteredMutations);
                }
                else {
                    for (const mutation of filteredMutations) sub.callback.call(sub.bind || sub, mutation);
                }
            }
            catch (err) {
                modules__WEBPACK_IMPORTED_MODULE_0__["Logger"].stacktrace("DOMObserver", "Error in observer callback", err);
            }
        }
    }

    /**
     * Starts observing the element. This will be called when attaching a callback.
     * You don't need to call this manually.
     */
    observe() {
        if (this.active) return;
        this.observer.observe(this.root, this.options);
        this.active = true;
    }

    /**
     * Disconnects this observer. This stops callbacks being called, but does not unbind them.
     * You probably want to use observer.unsubscribeAll instead.
     */
    disconnect() {
        if (!this.active) return;
        this.observer.disconnect();
        this.active = false;
    }

    reconnect() {
        if (this.active) {
            this.disconnect();
            this.observe();
        }
    }

    get root() {return this._root;}
    set root(root) {this._root = root; this.reconnect();}

    get options() {return this._options;}
    set options(options) {this._options = options; this.reconnect();}

    get subscriptions() {
        return this._subscriptions || (this._subscriptions = []);
    }

    /**
     * Subscribes to mutations.
     * @param {Function} callback A function to call when on a mutation
     * @param {Function} filter A function to call to filter mutations
     * @param {Any} bind Something to bind the callback to
     * @param {Boolean} group Whether to call the callback with an array of mutations instead of a single mutation
     * @return {Object}
     */
    subscribe(callback, filter, bind, group) {
        const subscription = {callback, filter, bind, group};
        this.subscriptions.push(subscription);
        this.observe();
        return subscription;
    }

    /**
     * Removes a subscription and disconnect if there are none left.
     * @param {Object} subscription A subscription object returned by observer.subscribe
     */
    unsubscribe(subscription) {
        if (!this.subscriptions.includes(subscription)) subscription = this.subscriptions.find(s => s.callback === subscription);
        modules__WEBPACK_IMPORTED_MODULE_0__["Utilities"].removeFromArray(this.subscriptions, subscription);
        if (!this.subscriptions.length) this.disconnect();
    }

    unsubscribeAll() {
        this.subscriptions.splice(0, this.subscriptions.length);
        this.disconnect();
    }

    /**
     * Subscribes to mutations that affect an element matching a selector.
     * @param {Function} callback A function to call when on a mutation
     * @param {Function} filter A function to call to filter mutations
     * @param {Any} bind Something to bind the callback to
     * @param {Boolean} group Whether to call the callback with an array of mutations instead of a single mutation
     * @return {Object}
     */
    subscribeToQuerySelector(callback, selector, bind, group) {
        return this.subscribe(callback, mutation => {
            return mutation.target.matches(selector) // If the target matches the selector
                || Array.from(mutation.addedNodes).concat(Array.from(mutation.removedNodes)) // Or if either an added or removed node
                    .find(n => n instanceof Element && (n.matches(selector) || n.querySelector(selector))); // match or contain an element matching the selector
        }, bind, group);
    }
}

/* harmony default export */ __webpack_exports__["default"] = (DOMObserver);

/***/ }),

/***/ "./src/structs/dom/selector.js":
/*!*************************************!*\
  !*** ./src/structs/dom/selector.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/** 
 * Representation of a Selector
 * @memberof module:DOMTools
 **/
class Selector {
    /**
     * 
     * @param {string} classname - class to create selector for
     */
    constructor(className) {
        this.value = " ." + className.split(" ").join(".");
    }
    
    /**
     * Returns the raw selector, this is how native function get the value.
     * @returns {string} raw selector.
     */
    toString() {
        return this.value;
    }
    
    /**
     * Returns the raw selector, this is how native function get the value.
     * @returns {string} raw selector.
     */
    valueOf() {
        return this.value;
    }
    
    selector(symbol, other) {
        this.value = `${this.toString()} ${symbol} ${other.toString()}`;
        return this;
    }
    
    /**
     * Adds another selector as a direct child `>` to this one.
     * @param {string|DOMTools.Selector} other - Selector to add as child
     * @returns {DOMTools.Selector} returns self to allow chaining
     */
    child(other) {
        return this.selector(">", other);
    }
    
    /**
     * Adds another selector as a adjacent sibling `+` to this one.
     * @param {string|DOMTools.Selector} other - Selector to add as adjacent sibling
     * @returns {DOMTools.Selector} returns self to allow chaining
     */
    adjacent(other) {
        return this.selector("+", other);
    }
    
    /**
     * Adds another selector as a general sibling `~` to this one.
     * @param {string|DOMTools.Selector} other - Selector to add as sibling
     * @returns {DOMTools.Selector} returns self to allow chaining
     */
    sibling(other) {
        return this.selector("~", other);
    }
    
    /**
     * Adds another selector as a descendent `(space)` to this one.
     * @param {string|DOMTools.Selector} other - Selector to add as descendent
     * @returns {DOMTools.Selector} returns self to allow chaining
     */
    descend(other) {
        return this.selector(" ", other);
    }

    /**
     * Adds another selector to this one via `,`.
     * @param {string|DOMTools.Selector} other - Selector to add
     * @returns {DOMTools.Selector} returns self to allow chaining
     */
    and(other) {
        return this.selector(",", other);
    }
}

/* harmony default export */ __webpack_exports__["default"] = (Selector);

/***/ }),

/***/ "./src/structs/errors/permissionserror.js":
/*!************************************************!*\
  !*** ./src/structs/errors/permissionserror.js ***!
  \************************************************/
/*! exports provided: default, InsufficientPermissions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InsufficientPermissions", function() { return InsufficientPermissions; });
class PermissionsError extends Error {
    constructor(message) {
        super(message);
        this.name = "PermissionsError";
    }
}

/**
 * @memberof module:DiscordAPI
 */
class InsufficientPermissions extends PermissionsError {
    constructor(message) {
        super(`Missing Permission â€” ${message}`);
        this.name = "InsufficientPermissions";
    }
}

/* harmony default export */ __webpack_exports__["default"] = (PermissionsError);


/***/ }),

/***/ "./src/structs/list.js":
/*!*****************************!*\
  !*** ./src/structs/list.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @memberof module:DiscordAPI
 */

/**
 * Extension of Array that adds simple utilities.
 */
class List extends Array {

    /**
     * Allows multiple filters at once
     * @param {...callable} filters - set a filters to filter the list by
     */
    get(...filters) {
        return this.find(item => {
            for (const filter of filters) {
                for (const key in filter) {
                    if (filter.hasOwnProperty(key)) {
                        if (item[key] !== filter[key]) return false;
                    }
                }
            }
            return true;
        });
    }
}

/* harmony default export */ __webpack_exports__["default"] = (List);

/***/ }),

/***/ "./src/structs/listenable.js":
/*!***********************************!*\
  !*** ./src/structs/listenable.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Acts as an interface for anything that should be listenable.
 */
class Listenable {

    constructor() {
        this.listeners = [];
    }

    /**
     * Adds a listener to the current object.
     * @param {callable} callback - callback for when the event occurs
     * @returns {callable} - a way to cancel the listener without needing to call `removeListener`
     */
    addListener(callback) {
        if (typeof(callback) !== "function") return;
        this.listeners.push(callback);
        return () => {
            this.listeners.splice(this.listeners.indexOf(callback), 1);
        };
    }

    /**
     * Removes a listener from the current object.
     * @param {callable} callback - callback that was originally registered
     */
    removeListener(callback) {
        if (typeof(callback) !== "function") return;
        this.listeners.splice(this.listeners.indexOf(callback), 1);
    }
    
    /**
     * Alerts the listeners that an event occurred. Data passed is optional
     * @param {*} [...data] - Any data desired to be passed to listeners 
     */
    alertListeners(...data) {
        for (let l = 0; l < this.listeners.length; l++) this.listeners[l](...data);
    }
}

/* harmony default export */ __webpack_exports__["default"] = (Listenable);

/***/ }),

/***/ "./src/structs/plugin.js":
/*!*******************************!*\
  !*** ./src/structs/plugin.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_pluginupdater__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/pluginupdater */ "./src/modules/pluginupdater.js");
/* harmony import */ var _modules_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modules/logger */ "./src/modules/logger.js");
/* harmony import */ var _modules_reacttools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modules/reacttools */ "./src/modules/reacttools.js");
/* harmony import */ var _ui_modals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ui/modals */ "./src/ui/modals.js");
/* harmony import */ var _modules_pluginutilities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../modules/pluginutilities */ "./src/modules/pluginutilities.js");
/* harmony import */ var _modules_utilities__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../modules/utilities */ "./src/modules/utilities.js");
/* harmony import */ var _modules_discordmodules__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../modules/discordmodules */ "./src/modules/discordmodules.js");
/* harmony import */ var _ui_settings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../ui/settings */ "./src/ui/settings/index.js");









/* harmony default export */ __webpack_exports__["default"] = (function(config) {
    return class Plugin {
        constructor() {
            this._config = config;
            this._enabled = false;
            if (typeof(config.defaultConfig) != "undefined") {
                this.defaultSettings = {};
                for (let s = 0; s < config.defaultConfig.length; s++) {
                    const current = config.defaultConfig[s];
                    if (current.type != "category") {this.defaultSettings[current.id] = current.value;}
                    else {
                        this.defaultSettings[current.id] = {};
                        for (let s = 0; s < current.settings.length; s++) {
                            const subCurrent = current.settings[s];
                            this.defaultSettings[current.id][subCurrent.id] = subCurrent.value;
                        }
                    }
                }
                this._hasConfig = true;
                this.settings = _modules_utilities__WEBPACK_IMPORTED_MODULE_5__["default"].deepclone(this.defaultSettings);
            }
        }
        getName() {return this._config.info.name.replace(" ", "");}
        getDescription() {return this._config.info.description;}
        getVersion() {return this._config.info.version;}
        getAuthor() {return this._config.info.authors.map(a => a.name).join(", ");}
        load() {
            const currentVersionInfo = _modules_pluginutilities__WEBPACK_IMPORTED_MODULE_4__["default"].loadData(this.getName(), "currentVersionInfo", {version: this.getVersion(), hasShownChangelog: false});
            if (currentVersionInfo.version != this.getVersion() || !currentVersionInfo.hasShownChangelog) {
                this.showChangelog();
                _modules_pluginutilities__WEBPACK_IMPORTED_MODULE_4__["default"].saveData(this.getName(), "currentVersionInfo", {version: this.getVersion(), hasShownChangelog: true});
            }
            _modules_pluginupdater__WEBPACK_IMPORTED_MODULE_0__["default"].checkForUpdate(this.getName(), this.getVersion(), this._config.info.github_raw);
        }
        async start() {
            _modules_logger__WEBPACK_IMPORTED_MODULE_1__["default"].info(this.getName(), `version ${this.getVersion()} has started.`);
            if (this.defaultSettings) this.settings = this.loadSettings();
            this._enabled = true;
            if (typeof(this.onStart) == "function") this.onStart();
        }
        stop() {
            _modules_logger__WEBPACK_IMPORTED_MODULE_1__["default"].info(this.getName(), `version ${this.getVersion()} has stopped.`);
            this._enabled = false;
            if (typeof(this.onStop) == "function") this.onStop();
        }

        get isEnabled() {return this._enabled;}
        get strings() {
            if (!this._config.strings) return {};
            const locale = _modules_discordmodules__WEBPACK_IMPORTED_MODULE_6__["default"].UserSettingsStore.locale.split("-")[0];
            if (this._config.strings.hasOwnProperty(locale)) return this._config.strings[locale];
            if (this._config.strings.hasOwnProperty("en")) return this._config.strings.en;
            return this._config.strings;
        }
        
        set strings(strings) {
            this._config.strings = strings;
        }

        showSettingsModal() {
            if (typeof(this.getSettingsPanel) != "function") return;
            _ui_modals__WEBPACK_IMPORTED_MODULE_3__["default"].showModal(this.getName() + " Settings", _modules_reacttools__WEBPACK_IMPORTED_MODULE_2__["default"].createWrappedElement(this.getSettingsPanel()), {
                cancelText: "",
                confirmText: "Done",
                size: _ui_modals__WEBPACK_IMPORTED_MODULE_3__["default"].ModalSizes.MEDIUM
            });
        }

        showChangelog(footer) {
            if (typeof(this._config.changelog) == "undefined") return;
            _ui_modals__WEBPACK_IMPORTED_MODULE_3__["default"].showChangelogModal(this.getName() + " Changelog", this.getVersion(), this._config.changelog, footer);
        }

        saveSettings(settings) {
            _modules_pluginutilities__WEBPACK_IMPORTED_MODULE_4__["default"].saveSettings(this.getName(), this.settings ? this.settings : settings);
        }

        loadSettings(defaultSettings) {
            // loadSettings -> loadData -> defaultSettings gets deep cloned
            return _modules_pluginutilities__WEBPACK_IMPORTED_MODULE_4__["default"].loadSettings(this.getName(), this.defaultSettings ? this.defaultSettings : defaultSettings);
        }

        buildSetting(data) {
            const {name, note, type, value, onChange, id} = data;
            let setting = null;
            if (type == "color") setting = new _ui_settings__WEBPACK_IMPORTED_MODULE_7__["ColorPicker"](name, note, value, onChange, {disabled: data.disabled, presetColors: data.presetColors});
            else if (type == "dropdown") setting = new _ui_settings__WEBPACK_IMPORTED_MODULE_7__["Dropdown"](name, note, value, data.options, onChange);
            else if (type == "file") setting = new _ui_settings__WEBPACK_IMPORTED_MODULE_7__["FilePicker"](name, note, onChange);
            else if (type == "keybind") setting = new _ui_settings__WEBPACK_IMPORTED_MODULE_7__["Keybind"](name, note, value, onChange);
            else if (type == "radio") setting = new _ui_settings__WEBPACK_IMPORTED_MODULE_7__["RadioGroup"](name, note, value, data.options, onChange, {disabled: data.disabled});
            else if (type == "slider") setting = new _ui_settings__WEBPACK_IMPORTED_MODULE_7__["Slider"](name, note, data.min, data.max, value, onChange, data);
            else if (type == "switch") setting = new _ui_settings__WEBPACK_IMPORTED_MODULE_7__["Switch"](name, note, value, onChange, {disabled: data.disabled});
            else if (type == "textbox") setting = new _ui_settings__WEBPACK_IMPORTED_MODULE_7__["Textbox"](name, note, value, onChange, {placeholder: data.placeholder || ""});
            if (id) setting.id = id;
            return setting;
        }

        buildSettingsPanel() {
            const config = this._config.defaultConfig;
            const buildGroup = (group) => {
                const {name, id, collapsible, shown, settings} = group;
                // this.settings[id] = {};

                const list = [];
                for (let s = 0; s < settings.length; s++) {
                    const current = Object.assign({}, settings[s]);
                    current.value = this.settings[id][current.id];
                    current.onChange = (value) => {
                        this.settings[id][current.id] = value;
                    };
                    if (Object.keys(this.strings).length && this.strings.settings && this.strings.settings[id] && this.strings.settings[id][current.id]) {
                        const {name, note} = this.strings.settings[id][current.id];
                        current.name = name;
                        current.note = note;
                    }
                    list.push(this.buildSetting(current));
                }
                
                const settingGroup = new _ui_settings__WEBPACK_IMPORTED_MODULE_7__["SettingGroup"](name, {shown, collapsible}).append(...list);
                settingGroup.id = id;
                return settingGroup;
            };
            const list = [];
            for (let s = 0; s < config.length; s++) {
                const current = Object.assign({}, config[s]);
                if (current.type != "category") {
                    current.value = this.settings[current.id];
                    current.onChange = (value) => {
                        this.settings[current.id] = value;
                    };
                    if (Object.keys(this.strings).length && this.strings.settings && this.strings.settings[current.id]) {
                        const {name, note} = this.strings.settings[current.id];
                        current.name = name;
                        current.note = note;
                    }
                    list.push(this.buildSetting(current));
                }
                else {
                    list.push(buildGroup(current));
                }
            }

            return new _ui_settings__WEBPACK_IMPORTED_MODULE_7__["SettingPanel"](this.saveSettings.bind(this), ...list);
        }
    };
});

/***/ }),

/***/ "./src/structs/screen.js":
/*!*******************************!*\
  !*** ./src/structs/screen.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Representation of the screen such as width and height.
 */
class Screen {
    /** Document/window width */
    static get width() {return Math.max(document.documentElement.clientWidth, window.innerWidth || 0);}
    /** Document/window height */
    static get height() {return Math.max(document.documentElement.clientHeight, window.innerHeight || 0);}
}

/* harmony default export */ __webpack_exports__["default"] = (Screen);

/***/ }),

/***/ "./src/structs/structs.js":
/*!********************************!*\
  !*** ./src/structs/structs.js ***!
  \********************************/
/*! exports provided: List, Screen, Selector, ClassName, DOMObserver, InsufficientPermissions, User, GuildMember, Role, Emoji, Guild, Channel, PermissionOverwrite, RolePermissionOverwrite, MemberPermissionOverwrite, GuildChannel, GuildTextChannel, GuildVoiceChannel, ChannelCategory, PrivateChannel, DirectMessageChannel, GroupChannel, Reaction, Embed, Message, DefaultMessage, RecipientAddMessage, RecipientRemoveMessage, CallMessage, GroupChannelNameChangeMessage, GroupChannelIconChangeMessage, MessagePinnedMessage, GuildMemberJoinMessage, UserSettings, Plugin, Listenable */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./list */ "./src/structs/list.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "List", function() { return _list__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _screen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./screen */ "./src/structs/screen.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Screen", function() { return _screen__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _dom_selector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dom/selector */ "./src/structs/dom/selector.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Selector", function() { return _dom_selector__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _dom_classname__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./dom/classname */ "./src/structs/dom/classname.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ClassName", function() { return _dom_classname__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _dom_observer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dom/observer */ "./src/structs/dom/observer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DOMObserver", function() { return _dom_observer__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _errors_permissionserror__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./errors/permissionserror */ "./src/structs/errors/permissionserror.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InsufficientPermissions", function() { return _errors_permissionserror__WEBPACK_IMPORTED_MODULE_5__["InsufficientPermissions"]; });

/* harmony import */ var _discord_user__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./discord/user */ "./src/structs/discord/user.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "User", function() { return _discord_user__WEBPACK_IMPORTED_MODULE_6__["User"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GuildMember", function() { return _discord_user__WEBPACK_IMPORTED_MODULE_6__["GuildMember"]; });

/* harmony import */ var _discord_guild__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./discord/guild */ "./src/structs/discord/guild.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Role", function() { return _discord_guild__WEBPACK_IMPORTED_MODULE_7__["Role"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Emoji", function() { return _discord_guild__WEBPACK_IMPORTED_MODULE_7__["Emoji"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Guild", function() { return _discord_guild__WEBPACK_IMPORTED_MODULE_7__["Guild"]; });

/* harmony import */ var _discord_channel__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./discord/channel */ "./src/structs/discord/channel.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Channel", function() { return _discord_channel__WEBPACK_IMPORTED_MODULE_8__["Channel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PermissionOverwrite", function() { return _discord_channel__WEBPACK_IMPORTED_MODULE_8__["PermissionOverwrite"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RolePermissionOverwrite", function() { return _discord_channel__WEBPACK_IMPORTED_MODULE_8__["RolePermissionOverwrite"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MemberPermissionOverwrite", function() { return _discord_channel__WEBPACK_IMPORTED_MODULE_8__["MemberPermissionOverwrite"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GuildChannel", function() { return _discord_channel__WEBPACK_IMPORTED_MODULE_8__["GuildChannel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GuildTextChannel", function() { return _discord_channel__WEBPACK_IMPORTED_MODULE_8__["GuildTextChannel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GuildVoiceChannel", function() { return _discord_channel__WEBPACK_IMPORTED_MODULE_8__["GuildVoiceChannel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ChannelCategory", function() { return _discord_channel__WEBPACK_IMPORTED_MODULE_8__["ChannelCategory"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PrivateChannel", function() { return _discord_channel__WEBPACK_IMPORTED_MODULE_8__["PrivateChannel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DirectMessageChannel", function() { return _discord_channel__WEBPACK_IMPORTED_MODULE_8__["DirectMessageChannel"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GroupChannel", function() { return _discord_channel__WEBPACK_IMPORTED_MODULE_8__["GroupChannel"]; });

/* harmony import */ var _discord_message__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./discord/message */ "./src/structs/discord/message.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Reaction", function() { return _discord_message__WEBPACK_IMPORTED_MODULE_9__["Reaction"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Embed", function() { return _discord_message__WEBPACK_IMPORTED_MODULE_9__["Embed"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Message", function() { return _discord_message__WEBPACK_IMPORTED_MODULE_9__["Message"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DefaultMessage", function() { return _discord_message__WEBPACK_IMPORTED_MODULE_9__["DefaultMessage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RecipientAddMessage", function() { return _discord_message__WEBPACK_IMPORTED_MODULE_9__["RecipientAddMessage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RecipientRemoveMessage", function() { return _discord_message__WEBPACK_IMPORTED_MODULE_9__["RecipientRemoveMessage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CallMessage", function() { return _discord_message__WEBPACK_IMPORTED_MODULE_9__["CallMessage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GroupChannelNameChangeMessage", function() { return _discord_message__WEBPACK_IMPORTED_MODULE_9__["GroupChannelNameChangeMessage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GroupChannelIconChangeMessage", function() { return _discord_message__WEBPACK_IMPORTED_MODULE_9__["GroupChannelIconChangeMessage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MessagePinnedMessage", function() { return _discord_message__WEBPACK_IMPORTED_MODULE_9__["MessagePinnedMessage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GuildMemberJoinMessage", function() { return _discord_message__WEBPACK_IMPORTED_MODULE_9__["GuildMemberJoinMessage"]; });

/* harmony import */ var _discord_usersettings__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./discord/usersettings */ "./src/structs/discord/usersettings.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UserSettings", function() { return _discord_usersettings__WEBPACK_IMPORTED_MODULE_10__["UserSettings"]; });

/* harmony import */ var _plugin__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./plugin */ "./src/structs/plugin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Plugin", function() { return _plugin__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _listenable__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./listenable */ "./src/structs/listenable.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Listenable", function() { return _listenable__WEBPACK_IMPORTED_MODULE_12__["default"]; });




















/***/ }),

/***/ "./src/styles/settings.css":
/*!*********************************!*\
  !*** ./src/styles/settings.css ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (".plugin-input-group {\r\n    margin-top: 5px;\r\n}\r\n\r\n.plugin-input-group .button-collapse {\r\n    background: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxOS4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iQ2FscXVlXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSItOTUwIDUzMiAxOCAxOCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAtOTUwIDUzMiAxOCAxODsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6bm9uZTt9DQoJLnN0MXtmaWxsOm5vbmU7c3Ryb2tlOiNGRkZGRkY7c3Ryb2tlLXdpZHRoOjEuNTtzdHJva2UtbWl0ZXJsaW1pdDoxMDt9DQo8L3N0eWxlPg0KPHBhdGggY2xhc3M9InN0MCIgZD0iTS05MzIsNTMydjE4aC0xOHYtMThILTkzMnoiLz4NCjxwb2x5bGluZSBjbGFzcz0ic3QxIiBwb2ludHM9Ii05MzYuNiw1MzguOCAtOTQxLDU0My4yIC05NDUuNCw1MzguOCAiLz4NCjwvc3ZnPg0K);\r\n    height: 16px;\r\n    width: 16px;\r\n    display: inline-block;\r\n    vertical-align: bottom;\r\n    transition: transform .3s ease;\r\n    transform: rotate(0);\r\n}\r\n\r\n.plugin-input-group .button-collapse.collapsed {\r\n    transition: transform .3s ease;\r\n    transform: rotate(-90deg);\r\n}\r\n\r\n.plugin-input-group h2 {\r\n    font-size: 14px;\r\n}\r\n\r\n.plugin-input-group .plugin-input-group h2 {\r\n    margin-left: 16px;\r\n}\r\n\r\n.plugin-inputs {\r\n    height: auto;\r\n    overflow: hidden;\r\n    transition: height 300ms cubic-bezier(0.47, 0, 0.745, 0.715);\r\n}\r\n\r\n.plugin-inputs.collapsed {\r\n    height: 0px;\r\n}\r\n\r\n.file-input {\r\n\r\n}\r\n\r\n.file-input::-webkit-file-upload-button {\r\n    color: white;\r\n    background: #7289DA;\r\n    outline: 0;\r\n    border: 0;\r\n    padding: 10px;\r\n    vertical-align: top;\r\n    margin-top: -10px;\r\n    margin-left: -10px;\r\n    border-radius: 3px 0 0 3px;\r\n    font-size: 14px;\r\n    font-weight: 500;\r\n    font-family: Whitney,Helvetica Neue,Helvetica,Arial,sans-serif;\r\n    cursor: pointer;\r\n}\r\n\r\n.color-input {\r\n    background: none;\r\n    padding: 0;\r\n    border: none;\r\n}\r\n\r\n.color-input:hover {\r\n    opacity: 0.8;\r\n}\r\n");

/***/ }),

/***/ "./src/styles/toasts.css":
/*!*******************************!*\
  !*** ./src/styles/toasts.css ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (".toasts {\r\n    position: fixed;\r\n    display: flex;\r\n    top: 0;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    justify-content: flex-end;\r\n    pointer-events: none;\r\n    z-index: 4000;\r\n}\r\n\r\n@keyframes toast-up {\r\n    from {\r\n        transform: translateY(0);\r\n        opacity: 0;\r\n    }\r\n}\r\n\r\n.toast {\r\n    animation: toast-up 300ms ease;\r\n    transform: translateY(-10px);\r\n    background: #36393F;\r\n    padding: 10px;\r\n    border-radius: 5px;\r\n    box-shadow: 0 0 0 1px rgba(32,34,37,.6), 0 2px 10px 0 rgba(0,0,0,.2);\r\n    font-weight: 500;\r\n    color: #fff;\r\n    user-select: text;\r\n    font-size: 14px;\r\n    opacity: 1;\r\n    margin-top: 10px;\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n}\r\n\r\n@keyframes toast-down {\r\n    to {\r\n        transform: translateY(0px);\r\n        opacity: 0;\r\n    }\r\n}\r\n\r\n.toast.closing {\r\n    animation: toast-down 200ms ease;\r\n    animation-fill-mode: forwards;\r\n    opacity: 1;\r\n    transform: translateY(-10px);\r\n}\r\n\r\n.toast.toast-info {\r\n    background-color: #4a90e2;\r\n}\r\n\r\n.toast.toast-success {\r\n    background-color: #43b581;\r\n}\r\n\r\n.toast.toast-danger,\r\n.toast.toast-error {\r\n    background-color: #f04747;\r\n}\r\n\r\n.toast.toast-warning,\r\n.toast.toast-warn {\r\n    background-color: #FFA600;\r\n}\r\n\r\n.toast-icon {\r\n    margin-right: 5px;\r\n    fill: white;\r\n    border-radius: 50%;\r\n    overflow: hidden;\r\n    height: 20px;\r\n    width: 20px;\r\n}\r\n\r\n.toast-text {\r\n    line-height: 20px;\r\n}");

/***/ }),

/***/ "./src/styles/updates.css":
/*!********************************!*\
  !*** ./src/styles/updates.css ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("#pluginNotice {\r\n    -webkit-app-region: drag;\r\n    border-radius: 0;\r\n    overflow: hidden;\r\n    height: 36px;\r\n    animation: open-updates 400ms ease;\r\n}\r\n\r\n@keyframes open-updates {\r\n    from { height: 0; }\r\n}\r\n\r\n#pluginNotice.closing {\r\n    transition: height 400ms ease;\r\n    height: 0;\r\n}\r\n\r\n#outdatedPlugins {\r\n    font-weight: 700;\r\n}\r\n\r\n#outdatedPlugins>span {\r\n    -webkit-app-region: no-drag;\r\n    color: #fff;\r\n    cursor: pointer;\r\n}\r\n\r\n#outdatedPlugins>span:hover {\r\n    text-decoration: underline;\r\n}");

/***/ }),

/***/ "./src/ui/contextmenu.js":
/*!*******************************!*\
  !*** ./src/ui/contextmenu.js ***!
  \*******************************/
/*! exports provided: updateDiscordMenu, Menu, ItemGroup, MenuItem, TextItem, ImageItem, SubMenuItem, ToggleItem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateDiscordMenu", function() { return updateDiscordMenu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Menu", function() { return Menu; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ItemGroup", function() { return ItemGroup; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MenuItem", function() { return MenuItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextItem", function() { return TextItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageItem", function() { return ImageItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubMenuItem", function() { return SubMenuItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToggleItem", function() { return ToggleItem; });
/* harmony import */ var _modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/discordclasses */ "./src/modules/discordclasses.js");
/* harmony import */ var _modules_discordselectors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modules/discordselectors */ "./src/modules/discordselectors.js");
/* harmony import */ var _modules_reacttools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modules/reacttools */ "./src/modules/reacttools.js");
/* harmony import */ var _modules_discordmodules__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../modules/discordmodules */ "./src/modules/discordmodules.js");
/* harmony import */ var _modules_domtools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../modules/domtools */ "./src/modules/domtools.js");
/* harmony import */ var _structs_screen__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../structs/screen */ "./src/structs/screen.js");
/**
 * Self-made context menus that emulate Discord's own context menus.
 * @module ContextMenu
 * @version 0.1.0
 * @deprecated 12/3/2020 in favor of DiscordContextMenu
 */








/**
 * Updates the location of a Discord menu, especially useful when adding items to the menu via DOM.
 * @param {HTMLElement|jQuery} menu - The original discord menu
 */
function updateDiscordMenu(menu) {
    const menuNode = _modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].resolveElement(menu);
    if (!(menuNode instanceof Element)) return;
    const updateHeight = _modules_reacttools__WEBPACK_IMPORTED_MODULE_2__["default"].getReactProperty(menuNode, "return.return.return.stateNode.updatePosition");
    if (updateHeight) updateHeight();
}

/** Main menu class for creating custom context menus. */
class Menu {
    /**
     *
     * @param {boolean} [scroll=false] - should this menu be a scrolling menu (usually only used for submenus)
     */
    constructor(submenu = false, scroll = false) {
        this.theme = _modules_discordmodules__WEBPACK_IMPORTED_MODULE_3__["default"].UserSettingsStore.theme == "dark" ? "theme-dark" : "theme-light";
        this.isSubmenu = submenu;
        this.element = _modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(`<div class="${_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].ContextMenu.contextMenu} plugin-context-menu ${this.theme}"></div>`);
        this.scroll = scroll;
        if (!scroll) return;
        this.scroller = _modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(`<div class="${_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].Scrollers.scroller} ${_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].ContextMenu.scroller}"></div>`);
        this.scrollerWrap = _modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(`<div class="${_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].Scrollers.scrollerWrap} ${_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].Scrollers.scrollerThemed} ${_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].Scrollers.themeGhostHairline}"></div>`);
        this.scrollerWrap.append(this.scroller);
        this.element.append(this.scrollerWrap);
    }

    /**
     * Adds an item group to the menu. The group should already be populated.
     * @param {module:ContextMenu.ItemGroup} contextGroup - group to add to the menu
     * @returns {module:ContextMenu.Menu} returns self for chaining
     */
    addGroup(contextGroup) {
        if (this.scroll) this.scroller.append(contextGroup.getElement());
        else this.element.append(contextGroup.getElement());
        return this;
    }

    /**
     * Adds items to the context menu directly. It is recommended to add to a group and use
     * {@link module:ContextMenu.Menu.addGroup} instead to behave as natively as possible.
     * @param {module:ContextMenu.MenuItem} contextItems - list of items to add to the context menu
     * @returns {module:ContextMenu.Menu} returns self for chaining
     */
    addItems(...contextItems) {
        for (let i = 0; i < contextItems.length; i++) {
            if (this.scroll) this.scroller.append(contextItems[i].getElement());
            else this.element.append(contextItems[i].getElement());
        }
        return this;
    }

    /**
     * Shows the menu at a specific x and y position. This generally comes from the
     * pointer position on a right click event.
     * @param {number} x - x coordinate for the menu to show at
     * @param {number} y - y coordinate for the menu to show at
     */
    show(x, y) {
        const mouseX = x;
        const mouseY = y;

        const parents = this.element.closest(this.parentSelector);
        const depth = parents.length;
        // if (depth == 0) {
            const layer = _modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(`<div class="${_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].TooltipLayers.layer}"></div>`);
            let elementToAdd = this.element;
            if (this.isSubmenu) {
                const submenu = _modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(`<div class="${_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].ContextMenu.subMenuContext}"></div>`);
                submenu.append(this.element);
                elementToAdd = submenu;
            }
            layer.append(elementToAdd);
            layer.appendTo(_modules_discordselectors__WEBPACK_IMPORTED_MODULE_1__["default"].Popouts.popouts.sibling(_modules_discordselectors__WEBPACK_IMPORTED_MODULE_1__["default"].TooltipLayers.layerContainer).toString());
        // }
        this.element.css("top", mouseY + "px").css("left", mouseX + "px");

        if (mouseY + this.element.outerHeight() >= _structs_screen__WEBPACK_IMPORTED_MODULE_5__["default"].height) {
            this.element.addClass("invertY").addClass(_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].ContextMenu.invertY);
            this.element.css("top", `${mouseY - this.element.outerHeight()}px`);
            if (depth > 0) this.element.css("top", `${(mouseY + this.element.parent().outerHeight()) - this.element.outerHeight()}px`);
        }
        if (this.element.offset().left + this.element.outerWidth() >= _structs_screen__WEBPACK_IMPORTED_MODULE_5__["default"].width) {
            this.element.addClass("invertX");
            this.element.css("left", `${mouseX - this.element.outerWidth()}px`);
        }
        if (this.element.offset().left + 2 * this.element.outerWidth() >= _structs_screen__WEBPACK_IMPORTED_MODULE_5__["default"].width) {
            this.element.addClass(_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].ContextMenu.invertChildX);
        }

        if (depth !== 0) return;
        _modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].on(document, "mousedown.zctx", (e) => {if (!this.element.contains(e.target) && !this.element.isSameNode(e.target)) this.removeMenu();});
        _modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].on(document, "click.zctx", (e) => {if (this.element.contains(e.target)) this.removeMenu();});
        _modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].on(document, "keyup.zctx", (e) => {if (e.keyCode === 27) this.removeMenu();});
    }

    /** Allows you to remove the menu. */
    removeMenu() {
        this.element.closest(_modules_discordselectors__WEBPACK_IMPORTED_MODULE_1__["default"].TooltipLayers.layer.toString())[0].remove();
        const childs = this.element.findAll(this.parentSelector);
        if (childs) childs.forEach(c => c.remove());
        _modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].off(document, ".zctx");
    }

    /**
     * Used to attach a menu to a menu item. This is how to create a submenu.
     * If using {@link module:ContextMenu.SubMenuItem} then you do not need
     * to call this function as it is done automatically. If you want to attach
     * a submenu to an existing Discord context menu, then you should use this
     * method.
     * @param {(HTMLElement|jQuery)} menuItem - item to attach to
     */
    attachTo(menuItem) {
        this.menuItem = menuItem;
        menuItem.addEventListener("mouseenter", () => {
            // this.element.appendTo(DiscordSelectors.Popouts.popouts.sibling(DiscordSelectors.TooltipLayers.layerContainer).toString());
            // const left = this.element.parents(this.parentSelector)[0].css("left");
            // console.log(parseInt(menuItem.offset().left), parseInt(menuItem.offset().top));
            this.show(parseInt(menuItem.offset().right), parseInt(menuItem.offset().top));
        });
        menuItem.addEventListener("mouseleave", () => {this.element.closest(_modules_discordselectors__WEBPACK_IMPORTED_MODULE_1__["default"].TooltipLayers.layer.toString())[0].remove();});
    }

    get parentSelector() {return this.element.closest(".plugin-context-menu").length > this.element.closest(_modules_discordselectors__WEBPACK_IMPORTED_MODULE_1__["default"].ContextMenu.contextMenu).length ? ".plugin-context-menu" : _modules_discordselectors__WEBPACK_IMPORTED_MODULE_1__["default"].ContextMenu.contextMenu;}
}

/** Class that represents a group of menu items. */
class ItemGroup {
    /** Creates an item group. */
    constructor() {
        this.element = _modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(`<div class="${_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].ContextMenu.itemGroup}"></div>`);
    }

    /**
     * This is the method of adding menu items to a menu group.
     * @param {module:ContextMenu.MenuItem} contextItems - list of context menu items to add to this group
     * @returns {module:ContextMenu.ItemGroup} returns self for chaining
     */
    addItems(...contextItems) {
        for (let i = 0; i < contextItems.length; i++) {
            this.element.append(contextItems[i].getElement());
        }
        return this;
    }

    /** @returns {HTMLElement} returns the DOM node for the group */
    getElement() {return this.element;}
}

/**
 * Fires when the attached menu item it clicked.
 * @param {MouseEvent} event - the mouse event from clicking the item
 * @callback module:ContextMenu~clickEvent
 */

 /**
 * Fires when the checkbox item changes state.
 * @param {boolean} isChecked - if the checkbox is now checked
 * @callback module:ContextMenu~onChange
 */

/** Base class for all other menu items. */
class MenuItem {
    /**
     * @param {string} label - label to show on the menu item
     * @param {object} options - additional options for the item
     * @param {boolean} [options.danger=false] - should the item show as danger
     * @param {module:ContextMenu~clickEvent} [options.callback] - callback for when it is clicked
     */
    constructor(label, options = {}) {
        const {danger = false, callback} = options;
        this.element = _modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(`<div class="${_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].ContextMenu.item}"></div>`);
        this.label = label;
        if (danger) this.element.addClass(_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].ContextMenu.danger);
        this.element.on("click", (event) => {
            if (!Array.from(this.element.children).some(c => c.isSameNode(event.target)) && !this.element.isSameNode(event.target)) return;
            if (typeof(callback) == "function") callback(event);
            else event.stopPropagation();
        });
    }
    getElement() {return this.element;}
}

/**
 * Creates a text menu item that can have a hint.
 * @extends module:ContextMenu.MenuItem
 */
class TextItem extends MenuItem {
    /**
     * @param {string} label - label to show on the menu item
     * @param {object} options - additional options for the item
     * @param {string} [options.hint=""] - hint to show on the item (usually used for key combos)
     * @param {boolean} [options.danger=false] - should the item show as danger
     * @param {module:ContextMenu~clickEvent} [options.callback] - callback for when it is clicked
     */
    constructor(label, options = {}) {
        super(label, options);
        const {hint = ""} = options;
        this.element.append(_modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(`<span>${label}</span>`));
        this.element.append(_modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(`<div class="${_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].ContextMenu.hint}">${hint}</div>`));
    }
}

/**
 * Creates an image menu item that can have an image.
 * @extends module:ContextMenu.MenuItem
 */
class ImageItem extends MenuItem {
    /**
     * @param {string} label - label to show on the menu item
     * @param {string} imageSrc - link to the image to embed
     * @param {object} options - additional options for the item
     * @param {string} [options.hint=""] - hint to show on the item (usually used for key combos)
     * @param {boolean} [options.danger=false] - should the item show as danger
     * @param {module:ContextMenu~clickEvent} [options.callback] - callback for when it is clicked
     */
    constructor(label, imageSrc, options = {}) {
        super(label, options);
        this.element.addClass(_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].ContextMenu.itemImage);
        this.element.append(_modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(`<div class="${_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].ContextMenu.label}">${label}</div>`));
        this.element.append(_modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(`<img src="${imageSrc}">`));
    }
}

/**
 * Creates a menu item with an attached submenu.
 * @extends module:ContextMenu.MenuItem
 */
class SubMenuItem extends MenuItem {
    /**
     * @param {string} label - label to show on the menu item
     * @param {module:ContextMenu.Menu} subMenu - context menu that should be attached to this item
     * @param {object} options - additional options for the item
     * @param {string} [options.hint=""] - hint to show on the item (usually used for key combos)
     * @param {boolean} [options.danger=false] - should the item show as danger
     * @param {module:ContextMenu~clickEvent} [options.callback] - callback for when it is clicked
     */
    constructor(label, subMenu, options = {}) {
        // if (!(subMenu instanceof ContextSubMenu)) throw "subMenu must be of ContextSubMenu type.";
        super(label, options);
        this.element.addClass(_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].ContextMenu.itemSubMenu);
        this.element.append(_modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(`<div class="${_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].ContextMenu.label}">${label}</div>`));
        this.element.append(_modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(`<svg class="caret-UIZBlm da-caret" width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" clip-rule="evenodd" d="M16.59 8.59004L12 13.17L7.41 8.59004L6 10L12 16L18 10L16.59 8.59004Z"></path></svg>`));
        this.subMenu = subMenu;
        this.subMenu.attachTo(this.getElement());
    }
}

/**
 * Creates a menu item with a checkbox.
 * @extends module:ContextMenu.MenuItem
 */
class ToggleItem extends MenuItem {
    /**
     * @param {string} label - label to show on the menu item
     * @param {boolean} checked - should the item start out checked
     * @param {object} options - additional options for the item
     * @param {string} [options.hint=""] - hint to show on the item (usually used for key combos)
     * @param {boolean} [options.danger=false] - should the item show as danger
     * @param {module:ContextMenu~onChange} [options.callback] - callback for when the checkbox changes
     */
    constructor(label, checked, options = {}) {
        const {callback: onChange} = options;
        if (options.callback) delete options.callback;
        super(label, options);
        this.element.addClass(_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].ContextMenu.itemToggle);
        this.element.append(_modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(`<div class="${_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].ContextMenu.label}">${label}</div>`));
        this.checkbox = _modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(`<div class="checkbox ${_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].Checkbox.checkbox} ${_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].ContextMenu.checkbox}" role="button"></div>`);
        this.checkbox.append(_modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(`<div class="checkbox-inner ${_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].Checkbox.checkboxInner}"></div>`));
        this.checkbox.append(_modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].createElement("<span>"));
        this.input = _modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].createElement(`<input type="checkbox" class="${_modules_discordclasses__WEBPACK_IMPORTED_MODULE_0__["default"].Checkbox.checkboxElement}">`);
        this.input.checked = checked;
        this.checkbox.find(".checkbox-inner").append(this.input);
        this.checkbox.find(".checkbox-inner").append(_modules_domtools__WEBPACK_IMPORTED_MODULE_4__["default"].createElement("<span>"));
        this.element.append(this.checkbox);
        this.element.on("click", (e) => {
            if (!Array.from(this.element.children).some(c => c.isSameNode(e.target)) && !this.element.isSameNode(e.target)) return;
            e.stopPropagation();
            this.input.checked = !this.input.checked;
            if (typeof(onChange) == "function") onChange(this.input.checked);
        });
    }
}

/***/ }),

/***/ "./src/ui/discordcontextmenu.js":
/*!**************************************!*\
  !*** ./src/ui/discordcontextmenu.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DiscordContextMenu; });
/* harmony import */ var _modules_discordmodules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/discordmodules */ "./src/modules/discordmodules.js");
/* harmony import */ var _modules_webpackmodules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modules/webpackmodules */ "./src/modules/webpackmodules.js");
/* harmony import */ var _modules_reacttools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modules/reacttools */ "./src/modules/reacttools.js");
/* harmony import */ var _modules_patcher__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../modules/patcher */ "./src/modules/patcher.js");
/* harmony import */ var _modules_utilities__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../modules/utilities */ "./src/modules/utilities.js");
/* harmony import */ var _modules_discordclasses__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../modules/discordclasses */ "./src/modules/discordclasses.js");
/* harmony import */ var _modules_domtools__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../modules/domtools */ "./src/modules/domtools.js");
/* harmony import */ var _modules_logger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../modules/logger */ "./src/modules/logger.js");









// d = e.label,
// f = e.icon,
// h = e.imageUrl,
// v = e.hint,
// m = e.subtext,
// g = e.hasSubmenu,
// y = e.disabled,
// E = e.isFocused,
// S = e.menuItemProps,
// T = e.action,
// b = e.onClose,


const React = _modules_discordmodules__WEBPACK_IMPORTED_MODULE_0__["default"].React;
const ContextMenuActions = _modules_discordmodules__WEBPACK_IMPORTED_MODULE_0__["default"].ContextMenuActions;

const ce = React.createElement;
const ContextMenu = _modules_webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getByProps("MenuRadioItem", "MenuItem");

/**
 * Fires when the item is clicked.
 * @param {MouseEvent} event - The event generated on click
 * @callback module:DiscordContextMenu~MenuItemOnClick
 */

/**
 * @interface
 * @name module:DiscordContextMenu~MenuItem
 * @description
 * This is the generic context menu item component. It is very extensible and will adapt
 * it's type depending on the props.
 * 
 * Note: The item ID should be unique to this item across the entire menu. If no `id` is 
 * provided, the system will use the `label`. Plugins should ensure there are no `label`
 * conflicts if they do not wish to provide `id`. `label` conflicts (when not using
 * unique `id`s) can cause multiple items to be hovered at once.
 * 
 * @param {object} props - props to pass to the react renderer
 * @param {string} props.label - label to show on the menu item
 * @param {string} [props.id] - specific id used for this item
 * @param {string} [props.hint] - hint to show on the right hand side (usually keyboard combo)
 * @param {string} [props.subtext] - description to show underneath
 * @param {string} [props.image] - link to image to show on the side
 * @param {function} [props.icon] - react component to render on the side
 * @param {function} [props.render] - render function for custom rendering the menu item
 * @param {module:DiscordContextMenu~MenuItemOnClick} [props.action] - function to perform on click
 * @param {module:DiscordContextMenu~MenuItemOnClick} [props.onClick] - function to perform on click (alias of `action`)
 * @param {function} [props.onClose] - function to run when this is closed
 * @param {boolean} [props.danger=false] - should the item show as danger (red)
 * @param {boolean} [props.disabled=false] - should the item be disabled/unclickable
 * 
 * @param {object} [props.style] - allows you to add custom styles
 * @param {boolean} [props.closeOnClick] - allows you to prevent closing on click
 */

/**
 * @interface
 * @name module:DiscordContextMenu~MenuToggleItem
 * @extends module:DiscordContextMenu~MenuItem
 * @description
 * This item is used for creating checkboxes in menus. Properties shown here are additional
 * to those of the main MenuItem {@link module:DiscordContextMenu~MenuItem}
 * 
 * 
 * @param {boolean} [props.checked=false] - should the checkbox be checked
 * @param {boolean} [props.active=false] - alias of `checked`
 */

/**
 * @interface
 * @name module:DiscordContextMenu~MenuRadioItem
 * @extends module:DiscordContextMenu~MenuItem
 * @description
 * This item is used for creating radio selections in menus. Properties shown here are additional
 * to those of the main MenuItem {@link module:DiscordContextMenu~MenuItem}
 * 
 * Note: for the `forceUpdate` option... Without this enabled, you will manually need to 
 * manage the state for the functional component. If you do not the toggle will appear
 * to not update. @see {@link https://reactjs.org/docs/hooks-reference.html#usestate}
 * 
 * @param {boolean} [props.checked=false] - should the checkbox be checked
 * @param {boolean} [props.active=false] - alias of `checked`
 * @param {boolean} [props.forceUpdate=true] - should the menu be force-updated after click
 */

/**
 * @interface
 * @name module:DiscordContextMenu~SubMenuItem
 * @extends module:DiscordContextMenu~MenuItem
 * @description
 * This item is used for creating nested submenus. Properties shown here are additional
 * to those of the main MenuItem {@link module:DiscordContextMenu~MenuItem}
 * 
 * @param {Array<object>} [props.render] - array of items to render in the submenu
 * @param {Array<object>} [props.items] - alias of `render`
 * @param {Array<object>} [props.children] - Already rendered elements
 */

/**
 * @interface
 * @name module:DiscordContextMenu~MenuControlItem
 * @extends module:DiscordContextMenu~MenuItem
 * @description
 * This item is used for adding custom controls like sliders to the context menu.
 * Properties shown here are additional to those of the main MenuItem {@link module:DiscordContextMenu~MenuItem}
 * 
 * @param {function} [props.control] - control function that renders the component
 */


/**
 * A utility for building and rendering Discord's own menus.
 * @module DiscordContextMenu
 * @version 0.0.1
 */
class DiscordContextMenu {

    /**
     * Builds a single menu item. The only prop shown here is the type, the rest should
     * match the actual component being built. View those to see what options exist
     * for each, they often have less in common than you might think. See {@link module:DiscordContextMenu.MenuItem}
     * for the majority of props commonly available. Check the documentation for the
     * rest of the components.
     * 
     * @param {object} props - props used to build the item
     * @param {string} [props.type="text"] - type of the item, options: text, submenu, toggle, radio, custom, separator
     * @returns {object} the created component
     * 
     * @see {@link module:DiscordContextMenu~MenuItem}
     * @see {@link module:DiscordContextMenu~MenuToggleItem}
     * @see {@link module:DiscordContextMenu~MenuRadioItem}
     * @see {@link module:DiscordContextMenu~SubMenuItem}
     * @see {@link module:DiscordContextMenu~MenuControlItem}
     * 
     * @example
     * // Creates a single menu item that prints "MENU ITEM" on click
     * DiscordContextMenu.buildMenuItem({
     *      label: "Menu Item",
     *      action: () => {console.log("MENU ITEM");}
     * });
     * 
     * @example
     * // Creates a single toggle item that starts unchecked
     * // and print the new value on every toggle
     * DiscordContextMenu.buildMenuItem({
     *      type: "toggle",
     *      label: "Item Toggle",
     *      checked: false,
     *      action: (newValue) => {console.log(newValue);}
     * });
     */
    static buildMenuItem(props) {
        const {type} = props;
        if (type === "separator") return ce(ContextMenu.MenuSeparator);

        let Component = ContextMenu.MenuItem;
        if (type === "submenu") {
            if (!props.children) props.children = this.buildMenuChildren(props.render || props.items);
        }
        else if (type === "toggle" || type === "radio") {
            Component = type === "toggle" ? ContextMenu.MenuCheckboxItem : ContextMenu.MenuRadioItem;
            if (props.active) props.checked = props.active;
        }
        else if (type === "control") {
            Component = ContextMenu.MenuControlItem;
        }
        if (!props.id) props.id = `${_modules_domtools__WEBPACK_IMPORTED_MODULE_6__["default"].escapeID(props.label)}`;
        if (props.danger) props.color = "colorDanger";
        if (props.onClick && !props.action) props.action = props.onClick;
        props.extended = true;
        return ce(Component, props);
    }

    /**
     * Creates the all the items **and groups** of a context menu recursively.
     * There is no hard limit to the number of groups within groups or number
     * of items in a menu.
     * @param {Array<object>} setup - array of item props used to build items. See {@link module:DiscordContextMenu.buildMenuItem}
     * @returns {Array<object>} array of the created component
     * 
     * @example
     * // Creates a single item group item with a toggle item
     * DiscordContextMenu.buildMenuChildren([{
     *      type: "group",
     *      items: [{
     *          type: "toggle",
     *          label: "Item Toggle",
     *          active: false,
     *          action: (newValue) => {console.log(newValue);}
     *      }]
     * }]);
     * 
     * @example
     * // Creates two item groups with a single toggle item each
     * DiscordContextMenu.buildMenuChildren([{
     *     type: "group",
     *     items: [{
     *         type: "toggle",
     *         label: "Item Toggle",
     *         active: false,
     *         action: (newValue) => {
     *             console.log(newValue);
     *         }
     *     }]
     * }, {
     *     type: "group",
     *     items: [{
     *         type: "toggle",
     *         label: "Item Toggle",
     *         active: false,
     *         action: (newValue) => {
     *             console.log(newValue);
     *         }
     *     }]
     * }]);
     */
    static buildMenuChildren(setup) {
        const mapper = s => {
            if (s.type === "group") return buildGroup(s);
            return this.buildMenuItem(s);
        };
        const buildGroup = function(group) {
            const items = group.items.map(mapper).filter(i => i);
            return ce(ContextMenu.MenuGroup, null, items);
        };
        return setup.map(mapper).filter(i => i);
    }

    /**
     * Creates the menu *component* including the wrapping `ContextMenu`.
     * Calls {@link module:DiscordContextMenu.buildMenuChildren} under the covers.
     * Used to call in combination with {@link module:DiscordContextMenu.openContextMenu}.
     * @param {Array<object>} setup - array of item props used to build items. See {@link module:DiscordContextMenu.buildMenuChildren}
     * @returns {function} the unique context menu component
     */
    static buildMenu(setup) {
        return (props) => {return ce(ContextMenu.default, props, this.buildMenuChildren(setup));};
    }

    /**
     * 
     * @param {MouseEvent} event - The context menu event. This can be emulated, requires target, and all X, Y locations.
     * @param {function} menuComponent - Component to render. This can be any react component or output of {@link module:DiscordContextMenu.buildMenu}
     * @param {object} config - configuration/props for the context menu
     * @param {string} [config.position="right"] - default position for the menu, options: "left", "right"
     * @param {string} [config.align="top"] - default alignment for the menu, options: "bottom", "top"
     * @param {function} [config.onClose] - function to run when the menu is closed
     * @param {boolean} [config.noBlurEvent=false] - No clue
     */
    static openContextMenu(event, menuComponent, config) {
        return ContextMenuActions.openContextMenu(event, function(e) {
            return ce(menuComponent, Object.assign({}, e, {onClose: ContextMenuActions.closeContextMenu}));
        }, config);
    }

    /**
     * Attempts to find and return a specific context menu type's module. Useful
     * when patching the render of these menus.
     * @param {string} type - name of the context menu type
     * @returns {Promise<object>} the webpack module the menu was found in
     */
    static async getDiscordMenu() {
        _modules_logger__WEBPACK_IMPORTED_MODULE_7__["default"].warn("DiscordContextMenu", "This function no longer applies, please update your plugin.");
        // return new Promise(resolve => {
        //     const cancel = Patcher.after("ZeresLibrary.DiscordContextMenu", ContextMenuActions, "openContextMenu", (_, [, component]) => {
        //         const rendered = component();
        //         const menuType = rendered.props && rendered.props.type || (rendered.type && rendered.type.displayName);
        //         if (!menuType || typeof(menuType) != "string" || !menuType.includes(type)) return;
        //         cancel();
        //         return resolve(WebpackModules.getModule(m => m.default == rendered.type));
        //     });
        // });
    }

    /**
     * Calls `forceUpdate()` on all context menus it can find. Useful for
     * after patching a menu.
     */
    static forceUpdateMenus() {
        const menus = document.querySelectorAll(`.${_modules_discordclasses__WEBPACK_IMPORTED_MODULE_5__["default"].ContextMenu.menu.first}`);
        for (const menu of menus) {
            const stateNode = _modules_utilities__WEBPACK_IMPORTED_MODULE_4__["default"].findInTree(_modules_reacttools__WEBPACK_IMPORTED_MODULE_2__["default"].getReactInstance(menu), m=>m && m.forceUpdate && m.updatePosition, {walkable: ["return", "stateNode"]});
            if (!stateNode) continue;
            stateNode.forceUpdate();
            stateNode.updatePosition();
        }
    }

    static patchComponents() {
        _modules_patcher__WEBPACK_IMPORTED_MODULE_3__["default"].unpatchAll("DCM");
        this.patchMenuItem();
        this.patchToggleItem();
    }

    static patchMenuItem() {
        const MenuItem = _modules_webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getModule(m => m.default && m.default.displayName == "MenuItem");
        if (!MenuItem || !MenuItem.default) return;
        _modules_patcher__WEBPACK_IMPORTED_MODULE_3__["default"].after("DCM", MenuItem, "default", (_, args, ret) => {
            if (!args || !args[0] || !args[0].extended) return;
            const [props] = args;
            if (props.style) ret.props.style = props.style;
            if (props.closeOnClick !== false || !props.action) return;
            ret.props.onClick = function(e) {
                e.preventDefault();
                e.stopPropagation();
                return props.action(...arguments);
            };
        });
    }

    static patchToggleItem() {
        const MenuToggleItem = _modules_webpackmodules__WEBPACK_IMPORTED_MODULE_1__["default"].getModule(m => m.default && m.default.displayName == "MenuCheckboxItem");
        if (!MenuToggleItem || !MenuToggleItem.default) return;
        _modules_patcher__WEBPACK_IMPORTED_MODULE_3__["default"].before("DCM", MenuToggleItem, "default", (_, args) => {
            if (!args || !args[0] || !args[0].extended) return;
            const [props] = args;
            const [active, doToggle] = React.useState(props.checked || false);
            props.checked = active;
            const originalAction = props.action;
            props.action = function(ev) {
                originalAction(ev);
                doToggle(!active);
            };
        });
    }
}

/***/ }),

/***/ "./src/ui/errorboundary.js":
/*!*********************************!*\
  !*** ./src/ui/errorboundary.js ***!
  \*********************************/
/*! exports provided: default, WrapBoundary */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ErrorBoundary; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WrapBoundary", function() { return WrapBoundary; });
/* harmony import */ var _modules_discordmodules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/discordmodules */ "./src/modules/discordmodules.js");


const React = _modules_discordmodules__WEBPACK_IMPORTED_MODULE_0__["default"].React;
const ce = React.createElement;

class ErrorBoundary extends React.Component {
    constructor(props) {
      super(props);
      this.state = {hasError: false};
    }
  
    componentDidCatch() {
      this.setState({hasError: true});
    }
  
    render() {
      if (this.state.hasError) return this.props.errorChildren ? this.props.errorChildren : ce("div", {className: "error"}, "Component Error");  
      return this.props.children; 
    }
}

function WrapBoundary(Original) {
  return class ErrorBoundaryWrapper extends React.Component {
      render() {
          return ce(ErrorBoundary, null, ce(Original, this.props));
      }
  };
}

/***/ }),

/***/ "./src/ui/icons.js":
/*!*************************!*\
  !*** ./src/ui/icons.js ***!
  \*************************/
/*! exports provided: IconError, IconInfo, IconSuccess, IconWarning */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _icons_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./icons/error */ "./src/ui/icons/error.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IconError", function() { return _icons_error__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _icons_info__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./icons/info */ "./src/ui/icons/info.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IconInfo", function() { return _icons_info__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _icons_success__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icons/success */ "./src/ui/icons/success.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IconSuccess", function() { return _icons_success__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _icons_warning__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./icons/warning */ "./src/ui/icons/warning.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IconWarning", function() { return _icons_warning__WEBPACK_IMPORTED_MODULE_3__["default"]; });






/***/ }),

/***/ "./src/ui/icons/error.js":
/*!*******************************!*\
  !*** ./src/ui/icons/error.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Error Icon
 * @param {number} size - Size of the icon.
 */
/* harmony default export */ __webpack_exports__["default"] = (function(size) {
    return `<svg width="${size || 24}" height="${size || 24}" viewBox="0 0 24 24">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z" />
        </svg>`;
});

/***/ }),

/***/ "./src/ui/icons/info.js":
/*!******************************!*\
  !*** ./src/ui/icons/info.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Info Icon
 * @param {number} size - Size of the icon.
 */
/* harmony default export */ __webpack_exports__["default"] = (function(size) {
    return `<svg width="${size || 24}" height="${size || 24}" viewBox="0 0 24 24">
                <path d="M0 0h24v24H0z" fill="none"/>
                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/>
            </svg>`;
});

/***/ }),

/***/ "./src/ui/icons/success.js":
/*!*********************************!*\
  !*** ./src/ui/icons/success.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Success Icon
 * @param {number} size - Size of the icon.
 */
/* harmony default export */ __webpack_exports__["default"] = (function(size) {
    return `<svg width="${size || 24}" height="${size || 24}" viewBox="0 0 24 24">
                <path d="M0 0h24v24H0z" fill="none"/>
                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
            </svg>`;
});

/***/ }),

/***/ "./src/ui/icons/warning.js":
/*!*********************************!*\
  !*** ./src/ui/icons/warning.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Warning Icon
 * @param {number} size - Size of the icon.
 */
/* harmony default export */ __webpack_exports__["default"] = (function(size) {
    return `<svg width="${size || 24}" height="${size || 24}" viewBox="0 0 24 24">
                <path d="M0 0h24v24H0z" fill="none"/>
                <path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/>
            </svg>`;
});

/***/ }),

/***/ "./src/ui/modals.js":
/*!**************************!*\
  !*** ./src/ui/modals.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Modals; });
/* harmony import */ var modules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! modules */ "./src/modules/modules.js");
/**
 * Allows an easy way to create and show modals.
 * @module Modals
 * @version 0.0.1
 */



const React = modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].React;
const ce = React.createElement;
const Markdown = modules__WEBPACK_IMPORTED_MODULE_0__["WebpackModules"].getByDisplayName("Markdown");

class Modals {

    /** Sizes of modals. */
    static get ModalSizes() {return {};}

    /**
     * Shows the user profile modal for a given user.
     * @param {string} userId - id of the user to show profile for
     */
    static showUserProfile(userId) {
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].UserProfileModal.open(userId);
    }

    /**
     * Acts as a wrapper for {@link module:Modals.showModal} where the `children` is a text element.
     * @param {string} title - title of the modal
     * @param {string} content - text to show inside the modal. Can be markdown.
     * @param {object} [options] - see {@link module:Modals.showModal}
     * @see module:Modals.showModal
     */
    static showConfirmationModal(title, content, options = {}) {
        this.showModal(title, ce(Markdown, null, content), options);
    }

    /**
     * Shows a very simple alert modal that has title, content and an okay button.
     * @param {string} title - title of the modal
     * @param {string} body - text to show inside the modal
     */
    static showAlertModal(title, body) {
        this.showConfirmationModal(title, body, {cancelText: null});
    }

    /**
     * Shows a generic but very customizable modal.
     * @param {string} title - title of the modal
     * @param {(ReactElement|Array<ReactElement>)} children - a single or array of rendered react elements to act as children
     * @param {object} [options] - options to modify the modal
     * @param {boolean} [options.danger=false] - whether the main button should be red or not
     * @param {string} [options.confirmText=Okay] - text for the confirmation/submit button
     * @param {string} [options.cancelText=Cancel] - text for the cancel button
     * @param {callable} [options.onConfirm=NOOP] - callback to occur when clicking the submit button
     * @param {callable} [options.onCancel=NOOP] - callback to occur when clicking the cancel button
     */
    static showModal(title, children, options = {}) {
        const {danger = false, confirmText = "Okay", cancelText = "Cancel", onConfirm = () => {}, onCancel = () => {}} = options;
        return modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].ModalActions.openModal(props => {
            return React.createElement(modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].ConfirmationModal, Object.assign({
                header: title,
                red: danger,
                confirmText: confirmText,
                cancelText: cancelText,
                onConfirm: onConfirm,
                onCancel: onCancel
            }, props), children);
        });
    }

    /**
     * @interface
     * @name module:Modals~Changelog
     * @property {string} title - title of the changelog section
     * @property {string} [type=added] - type information of the section. Options: added, improved, fixed, progress.
     * @property {Array<string>} items - itemized list of items to show in that section. Can use markdown.
     */

    /**
     * Shows a changelog modal based on changelog data.
     * @param {string} title - title of the modal
     * @param {string} version - subtitle (usually version or date) of the modal
     * @param {module:Modals~Changelog} changelog - changelog to show inside the modal
     * @param {string} footer - either an html element or text to show in the footer of the modal. Can use markdown.
     */
    static showChangelogModal(title, version, changelog, footer) {
        const TextElement = modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].TextElement;
        const changelogItems = [];
        for (let c = 0; c < changelog.length; c++) {
            const entry = changelog[c];
            const type = modules__WEBPACK_IMPORTED_MODULE_0__["DiscordClasses"].Changelog[entry.type] ? modules__WEBPACK_IMPORTED_MODULE_0__["DiscordClasses"].Changelog[entry.type] : modules__WEBPACK_IMPORTED_MODULE_0__["DiscordClasses"].Changelog.added;
            const margin = c == 0 ? modules__WEBPACK_IMPORTED_MODULE_0__["DiscordClasses"].Changelog.marginTop : "";
            changelogItems.push(ce("h1", {className: `${type} ${margin}`,}, entry.title));
            const list = ce("ul", null, entry.items.map(i => ce("li", null, ce(Markdown, null, i))));
            changelogItems.push(list);
        }
        const renderHeader = function() {
            return ce(modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].FlexChild.Child, {grow: 1, shrink: 1},
                ce(modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].Titles.default, {tag: modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].Titles.Tags.H4}, title),
                ce(TextElement,
                    {size: TextElement.Sizes.SMALL, color: TextElement.Colors.PRIMARY, className: modules__WEBPACK_IMPORTED_MODULE_0__["DiscordClasses"].Changelog.date.toString()},
                    "Version " + version
                )
            );
        };
        const renderFooter = footer ? function() {
            return ce(Markdown, null, footer);
        } : null;
        modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].ModalStack.push(function(props) {
            return ce(modules__WEBPACK_IMPORTED_MODULE_0__["DiscordModules"].Changelog, Object.assign({
                className: modules__WEBPACK_IMPORTED_MODULE_0__["DiscordClasses"].Changelog.container.toString(),
                selectable: true,
                onScroll: _ => _,
                onClose: _ => _,
                renderHeader: renderHeader,
                renderFooter: renderFooter,
                children: changelogItems
            }, props));
        });
    }
}

/***/ }),

/***/ "./src/ui/popouts.js":
/*!***************************!*\
  !*** ./src/ui/popouts.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Popouts; });
/* harmony import */ var structs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! structs */ "./src/structs/structs.js");
/* harmony import */ var modules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! modules */ "./src/modules/modules.js");
/**
 * Allows an easy way to create and show popouts.
 * @module Popouts
 * @version 0.0.1
 */




class Popouts {
    /**
     * Shows the user popout for a user relative to a target element
     * @param {HTMLElement} target - Element to show the popout in relation to
     * @param {object} user - Discord User object for the user to show
     * @param {object} [options] - Options to modify the request
     * @param {string} [options.guild="currentGuildId"] - Id of the guild  (uses current if not specified)
     * @param {string} [options.channel="currentChannelId"] - Id of the channel (uses current if not specified)
     * @param {string} [options.position="right"] - Positioning relative to element
     */
    static showUserPopout(target, user, options = {}) {
        const {guild = modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].SelectedGuildStore.getGuildId(), channel = modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].SelectedChannelStore.getChannelId()} = options;
        let {position = "right"} = options;
        target = modules__WEBPACK_IMPORTED_MODULE_1__["DOMTools"].resolveElement(target);
        if (target.getBoundingClientRect().right + 250 >= structs__WEBPACK_IMPORTED_MODULE_0__["Screen"].width) position = "left";
        modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].PopoutOpener.openPopout(target, {
            position: position,
            offsetX: 0,
            offsetY: 0,
            animationType: "default",
            preventInvert: false,
            zIndexBoost: 0,
            closeOnScroll: false,
            shadow: false,
            backdrop: false,
            toggleClose: true,
            render: (props) => {
                return modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].React.createElement(modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].UserPopout, Object.assign({}, props, {
                    userId: user.id,
                    guildId: guild,
                    channelId: channel
                }));
            }
        }, "ZeresLibrary");
    }
}

/***/ }),

/***/ "./src/ui/settings/index.js":
/*!**********************************!*\
  !*** ./src/ui/settings/index.js ***!
  \**********************************/
/*! exports provided: CSS, ReactSetting, SettingField, SettingGroup, SettingPanel, Textbox, ColorPicker, FilePicker, Slider, Switch, Dropdown, Keybind, RadioGroup */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _styles_settings_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../styles/settings.css */ "./src/styles/settings.css");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CSS", function() { return _styles_settings_css__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _settingfield__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./settingfield */ "./src/ui/settings/settingfield.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ReactSetting", function() { return _settingfield__WEBPACK_IMPORTED_MODULE_1__["ReactSetting"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SettingField", function() { return _settingfield__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _settinggroup__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./settinggroup */ "./src/ui/settings/settinggroup.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SettingGroup", function() { return _settinggroup__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _settingpanel__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./settingpanel */ "./src/ui/settings/settingpanel.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SettingPanel", function() { return _settingpanel__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _types_textbox__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types/textbox */ "./src/ui/settings/types/textbox.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Textbox", function() { return _types_textbox__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _types_color__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./types/color */ "./src/ui/settings/types/color.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColorPicker", function() { return _types_color__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _types_file__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./types/file */ "./src/ui/settings/types/file.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FilePicker", function() { return _types_file__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _types_slider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./types/slider */ "./src/ui/settings/types/slider.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Slider", function() { return _types_slider__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _types_switch__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./types/switch */ "./src/ui/settings/types/switch.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Switch", function() { return _types_switch__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _types_dropdown__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./types/dropdown */ "./src/ui/settings/types/dropdown.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Dropdown", function() { return _types_dropdown__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _types_keybind__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./types/keybind */ "./src/ui/settings/types/keybind.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Keybind", function() { return _types_keybind__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _types_radiogroup__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./types/radiogroup */ "./src/ui/settings/types/radiogroup.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RadioGroup", function() { return _types_radiogroup__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/**
 * An object that makes generating settings panel 10x easier.
 * @module Settings
 * @version 1.1.2
 */
















/***/ }),

/***/ "./src/ui/settings/settingfield.js":
/*!*****************************************!*\
  !*** ./src/ui/settings/settingfield.js ***!
  \*****************************************/
/*! exports provided: default, ReactSetting */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReactSetting", function() { return ReactSetting; });
/* harmony import */ var _structs_listenable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../structs/listenable */ "./src/structs/listenable.js");
/* harmony import */ var modules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! modules */ "./src/modules/modules.js");



const AccessibilityProvider = modules__WEBPACK_IMPORTED_MODULE_1__["WebpackModules"].getByProps("AccessibilityPreferencesContext").AccessibilityPreferencesContext.Provider;
const LayerProvider = modules__WEBPACK_IMPORTED_MODULE_1__["WebpackModules"].getByProps("AppReferencePositionLayer").AppLayerProvider().props.layerContext.Provider; // eslint-disable-line new-cap

/** 
 * Setting field to extend to create new settings
 * @memberof module:Settings
 * @version 1.0.1
 */
class SettingField extends _structs_listenable__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @param {string} name - name label of the setting 
     * @param {string} note - help/note to show underneath or above the setting
     * @param {callable} onChange - callback to perform on setting change
     * @param {(ReactComponent|HTMLElement)} settingtype - actual setting to render 
     * @param {object} [props] - object of props to give to the setting and the settingtype
     * @param {boolean} [props.noteOnTop=false] - determines if the note should be shown above the element or not.
     */
    constructor(name, note, onChange, settingtype, props = {}) {
        super();
        this.name = name;
        this.note = note;
        if (typeof(onChange) == "function") this.addListener(onChange);
        this.inputWrapper = modules__WEBPACK_IMPORTED_MODULE_1__["DOMTools"].parseHTML(`<div class="plugin-input-container"></div>`);
        this.type = typeof(settingtype) == "function" ? settingtype : modules__WEBPACK_IMPORTED_MODULE_1__["ReactTools"].wrapElement(settingtype);
        this.props = props;
        modules__WEBPACK_IMPORTED_MODULE_1__["DOMTools"].onAdded(this.getElement(), () => {this.onAdded();});
        modules__WEBPACK_IMPORTED_MODULE_1__["DOMTools"].onRemoved(this.getElement(), () => {this.onRemoved();});
    }

    /** @returns {HTMLElement} - root element for setting */
    getElement() {return this.inputWrapper;}

    /** Fires onchange to listeners */
    onChange() {
        this.alertListeners(...arguments);
    }

    /** Fired when root node added to DOM */
    onAdded() {
        const reactElement = modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].ReactDOM.render(modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].React.createElement(ReactSetting, Object.assign({
            title: this.name,
            type: this.type,
            note: this.note,
        }, this.props)), this.getElement());

        if (this.props.onChange) reactElement.props.onChange = this.props.onChange(reactElement);
        reactElement.forceUpdate();
    }

    /** Fired when root node removed from DOM */
    onRemoved() {
        modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].ReactDOM.unmountComponentAtNode(this.getElement());
    }
}

/* harmony default export */ __webpack_exports__["default"] = (SettingField);

class ReactSetting extends modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].React.Component {
    get noteElement() {
        const className = this.props.noteOnTop ? modules__WEBPACK_IMPORTED_MODULE_1__["DiscordClasses"].Margins.marginBottom8 : modules__WEBPACK_IMPORTED_MODULE_1__["DiscordClasses"].Margins.marginTop8;
        return modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].React.createElement(modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].SettingsNote, {children: this.props.note, type: "description", className: className.toString()});
    }

    get dividerElement() {return modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].React.createElement("div", {className: modules__WEBPACK_IMPORTED_MODULE_1__["DiscordClasses"].Dividers.divider.add(modules__WEBPACK_IMPORTED_MODULE_1__["DiscordClasses"].Dividers.dividerDefault).toString()});}

    render() {
        const ce = modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].React.createElement;
        const SettingElement = ce(this.props.type, this.props);
        const Context = ce(AccessibilityProvider, {value: {reducedMotion: {enabled: false, rawValue: "no-preference"}}}, ce(LayerProvider, {value: [document.querySelector("#app-mount > .layerContainer-yqaFcK")]}, SettingElement));
        if (this.props.inline) {
            const Flex = modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].FlexChild;
            const titleDefault = modules__WEBPACK_IMPORTED_MODULE_1__["WebpackModules"].getByProps("titleDefault") ? modules__WEBPACK_IMPORTED_MODULE_1__["WebpackModules"].getByProps("titleDefault").title : "titleDefault-a8-ZSr title-31JmR4 da-titleDefault da-title";
            return ce(Flex, {direction: Flex.Direction.VERTICAL},
            ce(Flex, {align: Flex.Align.START}, 
                ce(Flex.Child, {wrap: !0},
                    ce("div", {className: titleDefault}, this.props.title)
                ),
                ce(Flex.Child, {grow: 0, shrink: 0}, Context)
            ),
            this.noteElement,
            this.dividerElement
            );
        }
        
        return ce(modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].SettingsWrapper, {
            className: modules__WEBPACK_IMPORTED_MODULE_1__["DiscordClasses"].Margins.marginBottom20.toString(),
            title: this.props.title,
            children: [
                this.props.noteOnTop ? this.noteElement : Context,
                this.props.noteOnTop ? Context : this.noteElement,
                this.dividerElement
            ]
        });
    }
}



/***/ }),

/***/ "./src/ui/settings/settinggroup.js":
/*!*****************************************!*\
  !*** ./src/ui/settings/settinggroup.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _structs_listenable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../structs/listenable */ "./src/structs/listenable.js");
/* harmony import */ var modules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! modules */ "./src/modules/modules.js");
/* harmony import */ var _settingfield__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./settingfield */ "./src/ui/settings/settingfield.js");




/** 
 * Grouping of controls for easier management in settings panels.
 * @memberof module:Settings
 * @version 1.0.2
 */
class SettingGroup extends _structs_listenable__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @param {string} groupName - title for the group of settings
     * @param {object} [options] - additional options for the group
     * @param {callback} [options.callback] - callback called on settings changed
     * @param {boolean} [options.collapsible=true] - determines if the group should be collapsible
     * @param {boolean} [options.shown=false] - determines if the group should be expanded by default
     */
    constructor(groupName, options = {}) {
        super();
        const {collapsible = true, shown = false, callback = () => {}} = options;
        this.addListener(callback);
        this.onChange = this.onChange.bind(this);

        const collapsed = shown || !collapsible ? "" : "collapsed";
        const group = modules__WEBPACK_IMPORTED_MODULE_1__["DOMTools"].parseHTML(`<div class="plugin-input-group">
                                            <h2 class="${modules__WEBPACK_IMPORTED_MODULE_1__["DiscordClasses"].Titles.h5} ${modules__WEBPACK_IMPORTED_MODULE_1__["DiscordClasses"].Titles.defaultMarginh5} ${modules__WEBPACK_IMPORTED_MODULE_1__["DiscordClasses"].Titles.defaultColor}">
                                            <span class="button-collapse ${collapsed}"></span> ${groupName}
                                            </h2>
                                            <div class="plugin-inputs collapsible ${collapsed}"></div>
                                            </div>`);
        const label = group.querySelector("h2");
        const controls = group.querySelector(".plugin-inputs");

        this.group = group;
        this.label = label;
        this.controls = controls;

        if (!collapsible) return;
        label.addEventListener("click", async () => {
            const button = label.querySelector(".button-collapse");
            const wasCollapsed = button.classList.contains("collapsed");
            group.parentElement.querySelectorAll(":scope > .plugin-input-group > .collapsible:not(.collapsed)").forEach((element) => {
                element.style.setProperty("height", element.scrollHeight + "px");
                element.classList.add("collapsed");
                setImmediate(() => {element.style.setProperty("height", "");});
            });
            group.parentElement.querySelectorAll(":scope > .plugin-input-group > h2 > .button-collapse").forEach(e => e.classList.add("collapsed"));
            if (!wasCollapsed) return;
            controls.style.setProperty("height", controls.scrollHeight + "px");
            controls.classList.remove("collapsed");
            button.classList.remove("collapsed");
            await new Promise(resolve => setTimeout(resolve, 300));
            controls.style.setProperty("height", "");
        });
    }
    
    /** @returns {HTMLElement} - root node for the group. */
    getElement() {return this.group;}
    
    /**
     * Adds multiple nodes to this group.
     * @param {(...HTMLElement|...jQuery|...module:Settings.SettingField|...module:Settings.SettingGroup)} nodes - list of nodes to add to the group container 
     * @returns {module:Settings.SettingGroup} - returns self for chaining
     */
    append(...nodes) {
        for (let i = 0; i < nodes.length; i++) {
            if (modules__WEBPACK_IMPORTED_MODULE_1__["DOMTools"].resolveElement(nodes[i]) instanceof Element) this.controls.append(nodes[i]);
            else if (nodes[i] instanceof _settingfield__WEBPACK_IMPORTED_MODULE_2__["default"] || nodes[i] instanceof SettingGroup) this.controls.append(nodes[i].getElement());
            if (nodes[i] instanceof _settingfield__WEBPACK_IMPORTED_MODULE_2__["default"]) {
                nodes[i].addListener(((node) => (value) => {
                    this.onChange(node.id || node.name, value);
                })(nodes[i]));
            }
            else if (nodes[i] instanceof SettingGroup) {
                nodes[i].addListener(((node) => (settingId, value) => {
                    this.onChange(node.id || node.name, settingId, value);
                })(nodes[i]));
            }
        }
        return this;
    }
    
    /**
     * Appends this node to another
     * @param {HTMLElement} node - node to attach the group to.
     * @returns {module:Settings.SettingGroup} - returns self for chaining
     */
    appendTo(node) {
        node.append(this.group);
        return this;
    }

    /** Fires onchange to listeners */
    onChange() {
        this.alertListeners(...arguments);
    }
}

/* harmony default export */ __webpack_exports__["default"] = (SettingGroup);

/***/ }),

/***/ "./src/ui/settings/settingpanel.js":
/*!*****************************************!*\
  !*** ./src/ui/settings/settingpanel.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _structs_listenable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../structs/listenable */ "./src/structs/listenable.js");
/* harmony import */ var modules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! modules */ "./src/modules/modules.js");
/* harmony import */ var _settingfield__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./settingfield */ "./src/ui/settings/settingfield.js");
/* harmony import */ var _settinggroup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./settinggroup */ "./src/ui/settings/settinggroup.js");





/** 
 * Grouping of controls for easier management in settings panels.
 * @memberof module:Settings
 * @version 1.0.2
 */
class SettingPanel extends _structs_listenable__WEBPACK_IMPORTED_MODULE_0__["default"] {

    /**
     * Creates a new settings panel
     * @param {callable} onChange - callback to fire when settings change
     * @param {(...HTMLElement|...jQuery|...module:Settings.SettingField|...module:Settings.SettingGroup)} nodes  - list of nodes to add to the panel container 
     */
    constructor(onChange, ...nodes) {
        super();
        this.element = modules__WEBPACK_IMPORTED_MODULE_1__["DOMTools"].parseHTML(`<div class="plugin-form-container"></div>`);
        if (typeof(onChange) == "function") this.addListener(onChange);
        this.onChange = this.onChange.bind(this);
        this.append(...nodes);
    }
    
    /**
     * Creates a new settings panel
     * @param {callable} onChange - callback to fire when settings change
     * @param {(...HTMLElement|...jQuery|...module:Settings.SettingField|...module:Settings.SettingGroup)} nodes  - list of nodes to add to the panel container 
     * @returns {HTMLElement} - root node for the panel.
     */
    static build(onChange, ...nodes) {
        return (new SettingPanel(onChange, ...nodes)).getElement();
    }
    
    /** @returns {HTMLElement} - root node for the panel. */
    getElement() {return this.element;}

    /**
     * Adds multiple nodes to this panel.
     * @param {(...HTMLElement|...jQuery|...SettingField|...SettingGroup)} nodes - list of nodes to add to the panel container 
     * @returns {module:Settings.SettingPanel} - returns self for chaining
     */
    append(...nodes) {
        for (let i = 0; i < nodes.length; i++) {
            if (modules__WEBPACK_IMPORTED_MODULE_1__["DOMTools"].resolveElement(nodes[i]) instanceof Element) this.element.append(nodes[i]);
            else if (nodes[i] instanceof _settingfield__WEBPACK_IMPORTED_MODULE_2__["default"] || nodes[i] instanceof _settinggroup__WEBPACK_IMPORTED_MODULE_3__["default"]) this.element.append(nodes[i].getElement());
            if (nodes[i] instanceof _settingfield__WEBPACK_IMPORTED_MODULE_2__["default"]) {
                nodes[i].addListener(((node) => (value) => {
                    this.onChange(node.id || node.name, value);
                })(nodes[i]));
            }
            else if (nodes[i] instanceof _settinggroup__WEBPACK_IMPORTED_MODULE_3__["default"]) {
                nodes[i].addListener(((node) => (settingId, value) => {
                    this.onChange(node.id || node.name, settingId, value);
                })(nodes[i]));
            }
        }
        return this;
    }

    /** Fires onchange to listeners */
    onChange() {
        this.alertListeners(...arguments);
    }
}

/* harmony default export */ __webpack_exports__["default"] = (SettingPanel);

/***/ }),

/***/ "./src/ui/settings/types/color.js":
/*!****************************************!*\
  !*** ./src/ui/settings/types/color.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _settingfield__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../settingfield */ "./src/ui/settings/settingfield.js");
/* harmony import */ var modules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! modules */ "./src/modules/modules.js");




const presetColors = [1752220, 3066993, 3447003, 10181046, 15277667, 15844367, 15105570, 15158332, 9807270, 6323595, 1146986, 2067276, 2123412, 7419530, 11342935, 12745742, 11027200, 10038562, 9936031, 5533306];

/** 
 * Creates a color picker using Discord's built in color picker
 * as a base. Input and output using hex strings.
 * @memberof module:Settings
 * @version 0.1.0
 * @extends module:Settings.SettingField
 */
class ColorPicker extends _settingfield__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @param {string} name - name label of the setting 
     * @param {string} note - help/note to show underneath or above the setting
     * @param {string} value - current hex color
     * @param {callable} onChange - callback to perform on setting change, callback receives hex string
     * @param {object} [options] - object of options to give to the setting
     * @param {boolean} [options.disabled=false] - should the setting be disabled
     * @param {Array<number>} [options.colors=presetColors] - preset list of colors
     */
    constructor(name, note, value, onChange, options = {}) {
        if (modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].ColorPicker) {
            super(name, note, onChange, modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].ColorPicker, {
                disabled: !!options.disabled,
                onChange: reactElement => color => {
                    reactElement.props.value = color;
                    reactElement.forceUpdate();
                    this.onChange(modules__WEBPACK_IMPORTED_MODULE_1__["ColorConverter"].int2hex(color));
                },
                colors: Array.isArray(options.colors) ? options.colors : presetColors,
                defaultColor: typeof(value) == "number" ? value : modules__WEBPACK_IMPORTED_MODULE_1__["ColorConverter"].hex2int(value),
                value: 0
            });
        }
        else {
            const classes = ["color-input"];
            if (options.disabled) classes.push(modules__WEBPACK_IMPORTED_MODULE_1__["DiscordClasses"].BasicInputs.disabled);
            const ReactColorPicker = modules__WEBPACK_IMPORTED_MODULE_1__["DOMTools"].parseHTML(`<input type="color" class="${classes.join(" ")}">`);
            if (options.disabled) ReactColorPicker.setAttribute("disabled", "");
            if (value) ReactColorPicker.setAttribute("value", value);
            ReactColorPicker.addEventListener("change", (event) => {
                this.onChange(event.target.value);
            });
            super(name, note, onChange, ReactColorPicker, {inline: true});
        }
    }

    /** Default colors for ColorPicker */
    static get presetColors() {return presetColors;}
}



/* harmony default export */ __webpack_exports__["default"] = (ColorPicker);

/***/ }),

/***/ "./src/ui/settings/types/dropdown.js":
/*!*******************************************!*\
  !*** ./src/ui/settings/types/dropdown.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _settingfield__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../settingfield */ "./src/ui/settings/settingfield.js");
/* harmony import */ var modules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! modules */ "./src/modules/modules.js");



/**
 * @interface
 * @name module:Settings~DropdownItem
 * @property {string} label - label to show in the dropdown
 * @property {*} value - actual value represented by label (this is passed via onChange)
 */

/** 
 * Creates a dropdown using discord's built in dropdown.
 * @memberof module:Settings
 * @version 0.0.1
 * @extends module:Settings.SettingField
 */
class Dropdown extends _settingfield__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @param {string} name - name label of the setting 
     * @param {string} note - help/note to show underneath or above the setting
     * @param {*} defaultValue - currently selected value
     * @param {Array<module:Settings~DropdownItem>} values - array of all options available
     * @param {callable} onChange - callback to perform on setting change, callback item value
     * @param {object} [options] - object of options to give to the setting
     * @param {boolean} [options.clearable=false] - should be able to empty the field value
     * @param {boolean} [options.searchable=false] - should user be able to search the dropdown
     * @param {boolean} [options.disabled=false] - should the setting be disabled
     */
    constructor(name, note, defaultValue, values, onChange, options = {}) {
        const {clearable = false, searchable = false, disabled = false} = options;
        super(name, note, onChange, modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].Dropdown, {
            clearable: clearable,
            searchable: searchable,
            disabled: disabled,
            options: values,
            onChange: dropdown => opt => {
                dropdown.props.value = opt && opt.value;
                dropdown.forceUpdate();
                this.onChange(opt && opt.value);
            },
            value: defaultValue
        });
    }
}

/* harmony default export */ __webpack_exports__["default"] = (Dropdown);

/***/ }),

/***/ "./src/ui/settings/types/file.js":
/*!***************************************!*\
  !*** ./src/ui/settings/types/file.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _settingfield__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../settingfield */ "./src/ui/settings/settingfield.js");
/* harmony import */ var modules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! modules */ "./src/modules/modules.js");



/** 
 * Creates a file picker using chromium's default.
 * @memberof module:Settings
 * @version 0.0.1
 * @extends module:Settings.SettingField
 */
class FilePicker extends _settingfield__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @param {string} name - name label of the setting 
     * @param {string} note - help/note to show underneath or above the setting
     * @param {callable} onChange - callback to perform on setting change, callback receives File object
     * @param {object} [options] - object of options to give to the setting
     * @param {boolean} [options.disabled=false] - should the setting be disabled
     * @param {Array<string>|string} [options.accept] - what file types should be accepted
     * @param {boolean} [options.multiple=false] - should multiple files be accepted
     */
    constructor(name, note, onChange, options = {}) {
        const classes = modules__WEBPACK_IMPORTED_MODULE_1__["DiscordClasses"].BasicInputs.inputDefault.add("file-input");
        if (options.disabled) classes.add(modules__WEBPACK_IMPORTED_MODULE_1__["DiscordClasses"].BasicInputs.disabled);
        const ReactFilePicker = modules__WEBPACK_IMPORTED_MODULE_1__["DOMTools"].parseHTML(`<input type="file" class="${classes}">`);
        if (options.disabled) ReactFilePicker.setAttribute("disabled", "");
        if (options.multiple) ReactFilePicker.setAttribute("multiple", "");
        if (options.accept) ReactFilePicker.setAttribute("accept", Array.isArray(options.accept) ? options.accept.join(",") : options.accept);
        ReactFilePicker.addEventListener("change", (event) => {
            this.onChange(event.target.files[0]);
        });
        super(name, note, onChange, ReactFilePicker);
    }
}

/* harmony default export */ __webpack_exports__["default"] = (FilePicker);

/***/ }),

/***/ "./src/ui/settings/types/keybind.js":
/*!******************************************!*\
  !*** ./src/ui/settings/types/keybind.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _settingfield__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../settingfield */ "./src/ui/settings/settingfield.js");
/* harmony import */ var modules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! modules */ "./src/modules/modules.js");



/** 
 * Creates a keybind setting using discord's built in keybind recorder.
 * @memberof module:Settings
 * @version 0.0.1
 * @extends module:Settings.SettingField
 */
class Keybind extends _settingfield__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @param {string} name - name label of the setting 
     * @param {string} note - help/note to show underneath or above the setting
     * @param {Array<number>} value - array of keycodes
     * @param {callable} onChange - callback to perform on setting change, callback receives array of keycodes
     * @param {object} [options] - object of options to give to the setting
     * @param {boolean} [options.disabled=false] - should the setting be disabled
     */    
    constructor(label, help, value, onChange, options = {}) {
        const {disabled = false} = options;
        super(label, help, onChange, modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].Keybind, {
            disabled: disabled,
            defaultValue: value.map(a => [0, a]),
            onChange: element => val => {
                if (!Array.isArray(val)) return;
                element.props.value = val;
                this.onChange(value.map(a => a[1]));
            }
        });
    }
}

/* harmony default export */ __webpack_exports__["default"] = (Keybind);

/***/ }),

/***/ "./src/ui/settings/types/radiogroup.js":
/*!*********************************************!*\
  !*** ./src/ui/settings/types/radiogroup.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _settingfield__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../settingfield */ "./src/ui/settings/settingfield.js");
/* harmony import */ var modules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! modules */ "./src/modules/modules.js");



/**
 * @interface
 * @name module:Settings~RadioItem
 * @property {string} name - label to show in the dropdown
 * @property {*} value - actual value represented by label (this is passed via onChange)
 * @property {string} desc - description/help text to show below name
 * @property {string} color - hex string to color the item
 */

/** 
 * Creates a radio group using discord's built in radios.
 * @memberof module:Settings
 * @version 0.0.1
 * @extends module:Settings.SettingField
 */
class RadioGroup extends _settingfield__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @param {string} name - name label of the setting 
     * @param {string} note - help/note to show underneath or above the setting
     * @param {*} defaultValue - currently selected value
     * @param {Array<module:Settings~RadioItem>} values - array of all options available
     * @param {callable} onChange - callback to perform on setting change, callback item value
     * @param {object} [options] - object of options to give to the setting
     * @param {boolean} [options.disabled=false] - should the setting be disabled
     */
    constructor(name, note, defaultValue, values, onChange, options = {}) {
        super(name, note, onChange, modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].RadioGroup, {
            noteOnTop: true,
            disabled: !!options.disabled,
            options: values,
            onChange: reactElement => option => {
                reactElement.props.value = option.value;
                reactElement.forceUpdate();
                this.onChange(option.value);
            },
            value: defaultValue
        });
    }
}

/* harmony default export */ __webpack_exports__["default"] = (RadioGroup);



/***/ }),

/***/ "./src/ui/settings/types/slider.js":
/*!*****************************************!*\
  !*** ./src/ui/settings/types/slider.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _settingfield__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../settingfield */ "./src/ui/settings/settingfield.js");
/* harmony import */ var modules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! modules */ "./src/modules/modules.js");



/**
 * Used to render the grabber tooltip.
 * @param {Number} value - The value to render
 * @returns {string} the text to show in the tooltip
 * @callback module:Settings~SliderRenderValue
 */

/** 
 * Creates a slider/range using discord's built in slider.
 * @memberof module:Settings
 * @version 0.1.0
 * @extends module:Settings.SettingField
 */
class Slider extends _settingfield__WEBPACK_IMPORTED_MODULE_0__["default"] {
   /**
    * 
    * @param {string} name - name label of the setting 
    * @param {string} note - help/note to show underneath or above the setting
    * @param {number} min - minimum value allowed
    * @param {number} max - maximum value allowed
    * @param {number} value - currently selected value
    * @param {callable} onChange - callback to fire when setting is changed, callback receives number
    * @param {object} [options] - object of options to give to the setting
    * @param {boolean} [options.disabled=false] - should the setting be disabled
    * @param {object} [options.fillStyles] - object of css styles to add to active slider
    * @param {Array<number>} [options.markers] - array of vertical markers to show on the slider
    * @param {boolean} [options.stickToMarkers] - should the slider be forced to use markers
    * @param {boolean} [options.equidistant] - should the markers be scaled to be equidistant
    * @param {module:Settings~SliderRenderValue} [options.onValueRender] - function to call to render the value in the tooltip
    * @param {module:Settings~SliderRenderValue} [options.renderValue] - alias of `onValueRender`
    * @param {string} [options.units] - can be used in place of `onValueRender` will use this string and render Math.round(value) + units
    */
    constructor(name, note, min, max, value, onChange, options = {}) {
        const props = {
            onChange: _ => _,
            initialValue: value,
            disabled: !!options.disabled,
            minValue: min,
            maxValue: max,
            handleSize: 10
        };
        if (options.fillStyles) props.fillStyles = options.fillStyles;
        if (options.markers) props.markers = options.markers;
        if (options.stickToMarkers) props.stickToMarkers = options.stickToMarkers;
        if (typeof(options.equidistant) != "undefined") props.equidistant = options.equidistant;
        if (options.units) props.onValueRender = (val) => `${Math.round(val)}${options.units}`;
        if (options.onValueRender || options.renderValue) props.onValueRender = options.onValueRender || options.renderValue;
        super(name, note, onChange, modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].Slider, Object.assign(props, {onValueChange: v => this.onChange(v)}));
    }
}

/* harmony default export */ __webpack_exports__["default"] = (Slider);

/***/ }),

/***/ "./src/ui/settings/types/switch.js":
/*!*****************************************!*\
  !*** ./src/ui/settings/types/switch.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _settingfield__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../settingfield */ "./src/ui/settings/settingfield.js");
/* harmony import */ var modules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! modules */ "./src/modules/modules.js");



class SwitchWrapper extends modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].React.Component {
    constructor(props) {
        super(props);
        this.state = {enabled: this.props.value};
    }

    render() {
        return modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].React.createElement(modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].SwitchRow, Object.assign({}, this.props, {
            value: this.state.enabled,
            onChange: e => {
                this.props.onChange(e);
                this.setState({enabled: e});
            }
        }));
    }
}

/** 
 * Creates a switch using discord's built in switch.
 * @memberof module:Settings
 * @version 0.1.0
 * @extends module:Settings.SettingField
 */
class Switch extends _settingfield__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @param {string} name - name label of the setting 
     * @param {string} note - help/note to show underneath or above the setting
     * @param {boolean} isChecked - should switch be checked
     * @param {callable} onChange - callback to perform on setting change, callback receives boolean
     * @param {object} [options] - object of options to give to the setting
     * @param {boolean} [options.disabled=false] - should the setting be disabled
     */
    constructor(name, note, isChecked, onChange, options = {}) {
        super(name, note, onChange);
        this.disabled = !!options.disabled;
        this.value = !!isChecked;
    }

    onAdded() {
        modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].ReactDOM.render(modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].React.createElement(SwitchWrapper, {
            children: this.name,
            note: this.note,
            disabled: this.disabled,
            hideBorder: false,
            value: this.value,
            onChange: (e) => {this.onChange(e);}
        }), this.getElement());
    }
}

/* harmony default export */ __webpack_exports__["default"] = (Switch);


/***/ }),

/***/ "./src/ui/settings/types/textbox.js":
/*!******************************************!*\
  !*** ./src/ui/settings/types/textbox.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _settingfield__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../settingfield */ "./src/ui/settings/settingfield.js");
/* harmony import */ var modules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! modules */ "./src/modules/modules.js");



// TODO: Documentation

/** 
 * Creates a textbox using discord's built in textbox.
 * @memberof module:Settings
 * @version 0.1.0
 * @extends module:Settings.SettingField
 */
class Textbox extends _settingfield__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @param {string} name - name label of the setting 
     * @param {string} note - help/note to show underneath or above the setting
     * @param {string} value - current text in box
     * @param {callable} onChange - callback to perform on setting change, callback receives text
     * @param {object} [options] - object of options to give to the setting
     * @param {string} [options.placeholder=""] - placeholder for when textbox is empty
     * @param {boolean} [options.disabled=false] - should the setting be disabled
     */
    constructor(name, note, value, onChange, options = {}) {
        const {placeholder = "", disabled = false} = options;
        super(name, note, onChange, modules__WEBPACK_IMPORTED_MODULE_1__["DiscordModules"].Textbox, {
            onChange: textbox => val => {
                textbox.props.value = val;
                textbox.forceUpdate();
                this.onChange(val);
            },
            value: value,
            disabled: disabled,
            placeholder: placeholder || ""
        });
    }
}

/* harmony default export */ __webpack_exports__["default"] = (Textbox);

/***/ }),

/***/ "./src/ui/toasts.js":
/*!**************************!*\
  !*** ./src/ui/toasts.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Toast; });
/* harmony import */ var modules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! modules */ "./src/modules/modules.js");
/* harmony import */ var ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ui */ "./src/ui/ui.js");
/* harmony import */ var _styles_toasts_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../styles/toasts.css */ "./src/styles/toasts.css");
/** 
 * Toast maker similar to Android.
 * 
 * @module Toasts
 * @version 0.0.1
 */





class Toast {

    static get CSS() {return _styles_toasts_css__WEBPACK_IMPORTED_MODULE_2__["default"];}

    /** Shorthand for `type = "success"` for {@link module:Toasts.show} */
    static async success(content, options = {}) {return this.show(content, Object.assign(options, {type: "success"}));}

    /** Shorthand for `type = "info"` for {@link module:Toasts.show} */
    static async info(content, options = {}) {return this.show(content, Object.assign(options, {type: "info"}));}

    /** Shorthand for `type = "warning"` for {@link module:Toasts.show} */
    static async warning(content, options = {}) {return this.show(content, Object.assign(options, {type: "warning"}));}

    /** Shorthand for `type = "error"` for {@link module:Toasts.show} */
    static async error(content, options = {}) {return this.show(content, Object.assign(options, {type: "error"}));}

    /** Shorthand for `type = "default"` for {@link module:Toasts.show} */
    static async default(content, options = {}) {return this.show(content, Object.assign(options, {type: "default"}));}


    /**
     * Shows a simple toast, similar to Android, centered over 
     * the textarea if it exists, and center screen otherwise.
     * Vertically it shows towards the bottom like in Android.
     * @param {string} content - The string to show in the toast.
     * @param {object} options - additional options for the toast
     * @param {string} [options.type] - Changes the type of the toast stylistically and semantically. {@link module:Toasts.ToastTypes}
     * @param {string} [options.icon] - URL to an optional icon
     * @param {number} [options.timeout=3000] - Adjusts the time (in ms) the toast should be shown for before disappearing automatically
     * @returns {Promise} - Promise that resolves when the toast is removed from the DOM
     */
    static async show(content, options = {}) {
        const {type = "", icon = "", timeout = 3000} = options;
        this.ensureContainer();
        const toast = modules__WEBPACK_IMPORTED_MODULE_0__["DOMTools"].parseHTML(this.buildToast(content, this.parseType(type), icon));
        document.querySelector(".toasts").appendChild(toast);
        await new Promise(resolve => setTimeout(resolve, timeout));
        toast.classList.add("closing");
        await new Promise(resolve => setTimeout(resolve, 300));
        toast.remove();
        if (!document.querySelectorAll(".toasts .toast").length) document.querySelector(".toasts").remove();
    }

    static buildToast(message, type, icon) {
        const hasIcon = type || icon;
        const className = `toast ${hasIcon ? "toast-has-icon" : ""} ${type && type != "default" ? `toast-${type}` : ""}`;
        if (!icon && type) icon = type;
        return modules__WEBPACK_IMPORTED_MODULE_0__["Utilities"].formatString(`<div class="{{className}}">{{icon}}<div class="toast-text">{{message}}</div></div>`, {
            className: className,
            icon: hasIcon ? this.getIcon(icon) : "",
            message: message
        });
    }

    static getIcon(icon) {
        let iconInner = `<img src="${icon}" width="20" height="20" />`;
        switch (icon) {
            case "success": iconInner = ui__WEBPACK_IMPORTED_MODULE_1__["Icons"].IconSuccess(20); break; // eslint-disable-line new-cap
            case "warning": iconInner = ui__WEBPACK_IMPORTED_MODULE_1__["Icons"].IconWarning(20); break; // eslint-disable-line new-cap
            case "info": iconInner = ui__WEBPACK_IMPORTED_MODULE_1__["Icons"].IconInfo(20); break; // eslint-disable-line new-cap
            case "error": iconInner = ui__WEBPACK_IMPORTED_MODULE_1__["Icons"].IconError(20); // eslint-disable-line new-cap
        }
        return modules__WEBPACK_IMPORTED_MODULE_0__["Utilities"].formatString(`<div class="toast-icon">{{icon}}</div>`, {icon: iconInner});
    }

    static ensureContainer() {
        if (document.querySelector(".toasts")) return;
        const channelClass = modules__WEBPACK_IMPORTED_MODULE_0__["DiscordSelectors"].ChannelList.sidebar;
        const container = channelClass ? document.querySelector(channelClass.adjacent("div")) : null;
        const memberlist = container ? container.querySelector(modules__WEBPACK_IMPORTED_MODULE_0__["DiscordSelectors"].MemberList.membersWrap) : null;
        const form = container ? container.querySelector("form") : null;
        const left = container ? container.getBoundingClientRect().left : 310;
        const right = memberlist ? memberlist.getBoundingClientRect().left : 0;
        const width = right ? right - container.getBoundingClientRect().left : container.offsetWidth;
        const bottom = form ? form.offsetHeight : 80;
        const toastWrapper = document.createElement("div");
        toastWrapper.classList.add("toasts");
        toastWrapper.style.setProperty("left", left + "px");
        toastWrapper.style.setProperty("width", width + "px");
        toastWrapper.style.setProperty("bottom", bottom + "px");
        document.querySelector("#app-mount").appendChild(toastWrapper);
    }

    static parseType(type) {
        return this.ToastTypes.hasOwnProperty(type) ? this.ToastTypes[type] : "";
    }

    /**
     * Enumeration of accepted types.
     */
    static get ToastTypes() {
        return {
            "default": "",
            "error": "error",
            "success": "success",
            "warning": "warning",
            "info": "info"
        };
    }
}

/***/ }),

/***/ "./src/ui/tooltip.js":
/*!***************************!*\
  !*** ./src/ui/tooltip.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Tooltip; });
/* harmony import */ var modules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! modules */ "./src/modules/modules.js");
/* harmony import */ var _structs_screen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../structs/screen */ "./src/structs/screen.js");
/**
 * Tooltip that automatically show and hide themselves on mouseenter and mouseleave events.
 * Will also remove themselves if the node to watch is removed from DOM through
 * a MutationObserver.
 *
 * Note this is not using Discord's internals but normal DOM manipulation and emulates
 * Discord's own tooltips as closely as possible.
 *
 * @module Tooltip
 * @version 1.0.0
 */




const getClass = function(sideOrColor) {
    const upperCase = sideOrColor[0].toUpperCase() + sideOrColor.slice(1);
    const tooltipClass = modules__WEBPACK_IMPORTED_MODULE_0__["DiscordClasses"].Tooltips[`tooltip${upperCase}`];
    if (tooltipClass) return tooltipClass.value;
    return null;
};

const classExists = function(sideOrColor) {
    return !!getClass(sideOrColor);
};

const toPx = function(value) {
    return `${value}px`;
};

/* <div class="layer-v9HyYc da-layer" style="left: 234.5px; bottom: 51px;">
    <div class="tooltip-2QfLtc da-tooltip tooltipTop-XDDSxx tooltipBlack-PPG47z">
        <div class="tooltipPointer-3ZfirK da-tooltipPointer"></div>
        User Settings
    </div>
</div> */

class Tooltip {
    /**
     *
     * @constructor
     * @param {(HTMLElement|jQuery)} node - DOM node to monitor and show the tooltip on
     * @param {string} tip - string to show in the tooltip
     * @param {object} options - additional options for the tooltip
     * @param {string} [options.style=black] - correlates to the discord styling/colors (black, brand, green, grey, red, yellow)
     * @param {string} [options.side=top] - can be any of top, right, bottom, left
     * @param {boolean} [options.preventFlip=false] - prevents moving the tooltip to the opposite side if it is too big or goes offscreen
     * @param {boolean} [options.isTimestamp=false] - adds the timestampTooltip class (disables text wrapping)
     * @param {boolean} [options.disablePointerEvents=false] - disables pointer events
     * @param {boolean} [options.disabled=false] - whether the tooltip should be disabled from showing on hover
     */
    constructor(node, text, options = {}) {
        const {style = "black", side = "top", preventFlip = false, isTimestamp = false, disablePointerEvents = false, disabled = false} = options;
        this.node = modules__WEBPACK_IMPORTED_MODULE_0__["DOMTools"].resolveElement(node);
        this.label = text;
        this.style = style.toLowerCase();
        this.side = side.toLowerCase();
        this.preventFlip = preventFlip;
        this.isTimestamp = isTimestamp;
        this.disablePointerEvents = disablePointerEvents;
        this.disabled = disabled;
        this.active = false;

        if (!classExists(this.side)) return modules__WEBPACK_IMPORTED_MODULE_0__["Logger"].err("Tooltip", `Side ${this.side} does not exist.`);
        if (!classExists(this.style)) return modules__WEBPACK_IMPORTED_MODULE_0__["Logger"].err("Tooltip", `Style ${this.style} does not exist.`);

        this.element = modules__WEBPACK_IMPORTED_MODULE_0__["DOMTools"].createElement(`<div class="${modules__WEBPACK_IMPORTED_MODULE_0__["DiscordClasses"].TooltipLayers.layer}">`);
        this.tooltipElement = modules__WEBPACK_IMPORTED_MODULE_0__["DOMTools"].createElement(`<div class="${modules__WEBPACK_IMPORTED_MODULE_0__["DiscordClasses"].Tooltips.tooltip} ${getClass(this.style)}"><div class="${modules__WEBPACK_IMPORTED_MODULE_0__["DiscordClasses"].Tooltips.tooltipPointer}"></div><div class="${modules__WEBPACK_IMPORTED_MODULE_0__["DiscordClasses"].Tooltips.tooltipContent}">${this.label}</div></div>`);
        this.labelElement = this.tooltipElement.childNodes[1];
        this.element.append(this.tooltipElement);

        if (this.disablePointerEvents) {
            this.element.classList.add(modules__WEBPACK_IMPORTED_MODULE_0__["DiscordClasses"].TooltipLayers.disabledPointerEvents);
            this.tooltipElement.classList.add(modules__WEBPACK_IMPORTED_MODULE_0__["DiscordClasses"].Tooltips.tooltipDisablePointerEvents);
        }
        if (this.isTimestamp) this.tooltipElement.classList.add(modules__WEBPACK_IMPORTED_MODULE_0__["WebpackModules"].getByProps("timestampTooltip").timestampTooltip);


        this.node.addEventListener("mouseenter", () => {
            if (this.disabled) return;
            this.show();
        });

        this.node.addEventListener("mouseleave", () => {
            this.hide();
        });
    }

    /** Alias for the constructor */
    static create(node, text, options = {}) {return new Tooltip(node, text, options);}

    /** Container where the tooltip will be appended. */
    get container() {return document.querySelector(modules__WEBPACK_IMPORTED_MODULE_0__["DiscordSelectors"].Popouts.popouts.sibling(modules__WEBPACK_IMPORTED_MODULE_0__["DiscordSelectors"].TooltipLayers.layerContainer));}
    /** Boolean representing if the tooltip will fit on screen above the element */
    get canShowAbove() {return this.node.getBoundingClientRect().top - this.element.offsetHeight >= 0;}
    /** Boolean representing if the tooltip will fit on screen below the element */
    get canShowBelow() {return this.node.getBoundingClientRect().top + this.node.offsetHeight + this.element.offsetHeight <= _structs_screen__WEBPACK_IMPORTED_MODULE_1__["default"].height;}
    /** Boolean representing if the tooltip will fit on screen to the left of the element */
    get canShowLeft() {return this.node.getBoundingClientRect().left - this.element.offsetWidth >= 0;}
    /** Boolean representing if the tooltip will fit on screen to the right of the element */
    get canShowRight() {return this.node.getBoundingClientRect().left + this.node.offsetWidth + this.element.offsetWidth <= _structs_screen__WEBPACK_IMPORTED_MODULE_1__["default"].width;}

    /** Hides the tooltip. Automatically called on mouseleave. */
    hide() {
        /** Don't rehide if already inactive */
        if (!this.active) return;
        this.active = false;
        this.element.remove();
        this.tooltipElement.className = this._className;
    }

    /** Shows the tooltip. Automatically called on mouseenter. Will attempt to flip if position was wrong. */
    show() {
        /** Don't reshow if already active */
        if (this.active) return;
        this.active = true;
        this.tooltipElement.className = `${modules__WEBPACK_IMPORTED_MODULE_0__["DiscordClasses"].Tooltips.tooltip} ${getClass(this.style)}`;
        if (this.disablePointerEvents) this.tooltipElement.classList.add(modules__WEBPACK_IMPORTED_MODULE_0__["DiscordClasses"].Tooltips.tooltipDisablePointerEvents);
        if (this.isTimestamp) this.tooltipElement.classList.add(modules__WEBPACK_IMPORTED_MODULE_0__["WebpackModules"].getByProps("timestampTooltip").timestampTooltip);
        this.labelElement.textContent = this.label;
        this.container.append(this.element);

        if (this.side == "top") {
            if (this.canShowAbove || (!this.canShowAbove && this.preventFlip)) this.showAbove();
            else this.showBelow();
        }

        if (this.side == "bottom") {
            if (this.canShowBelow || (!this.canShowBelow && this.preventFlip)) this.showBelow();
            else this.showAbove();
        }

        if (this.side == "left") {
            if (this.canShowLeft || (!this.canShowLeft && this.preventFlip)) this.showLeft();
            else this.showRight();
        }

        if (this.side == "right") {
            if (this.canShowRight || (!this.canShowRight && this.preventFlip)) this.showRight();
            else this.showLeft();
        }

        /** Do not create a new observer each time if one already exists! */
        if (this.observer) return;
        /** Use an observer in show otherwise you'll cause unclosable tooltips */
        this.observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                const nodes = Array.from(mutation.removedNodes);
                const directMatch = nodes.indexOf(this.node) > -1;
                const parentMatch = nodes.some(parent => parent.contains(this.node));
                if (directMatch || parentMatch) {
                    this.hide();
                    this.observer.disconnect();
                }
            });
        });

        this.observer.observe(document.body, {subtree: true, childList: true});
    }

    /** Force showing the tooltip above the node. */
    showAbove() {
        this.tooltipElement.classList.add(getClass("top"));
        this.element.style.setProperty("top", toPx(this.node.getBoundingClientRect().top - this.element.offsetHeight - 10));
        this.centerHorizontally();
    }

    /** Force showing the tooltip below the node. */
    showBelow() {
        this.tooltipElement.classList.add(getClass("bottom"));
        this.element.style.setProperty("top", toPx(this.node.getBoundingClientRect().top + this.node.offsetHeight + 10));
        this.centerHorizontally();
    }

    /** Force showing the tooltip to the left of the node. */
    showLeft() {
        this.tooltipElement.classList.add(getClass("left"));
        this.element.style.setProperty("left", toPx(this.node.getBoundingClientRect().left - this.element.offsetWidth - 10));
        this.centerVertically();
    }

    /** Force showing the tooltip to the right of the node. */
    showRight() {
        this.tooltipElement.classList.add(getClass("right"));
        this.element.style.setProperty("left", toPx(this.node.getBoundingClientRect().left + this.node.offsetWidth + 10));
        this.centerVertically();
    }

    centerHorizontally() {
        const nodecenter = this.node.getBoundingClientRect().left + (this.node.offsetWidth / 2);
        this.element.style.setProperty("left", toPx(nodecenter - (this.element.offsetWidth / 2)));
    }

    centerVertically() {
        const nodecenter = this.node.getBoundingClientRect().top + (this.node.offsetHeight / 2);
        this.element.style.setProperty("top", toPx(nodecenter - (this.element.offsetHeight / 2)));
    }
}

/***/ }),

/***/ "./src/ui/ui.js":
/*!**********************!*\
  !*** ./src/ui/ui.js ***!
  \**********************/
/*! exports provided: Tooltip, Toasts, Popouts, Modals, DiscordContextMenu, ErrorBoundary, Settings, ContextMenu, Icons */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./settings */ "./src/ui/settings/index.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "Settings", function() { return _settings__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _contextmenu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contextmenu */ "./src/ui/contextmenu.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "ContextMenu", function() { return _contextmenu__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _icons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icons */ "./src/ui/icons.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "Icons", function() { return _icons__WEBPACK_IMPORTED_MODULE_2__; });
/* harmony import */ var _tooltip__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tooltip */ "./src/ui/tooltip.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Tooltip", function() { return _tooltip__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _toasts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./toasts */ "./src/ui/toasts.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Toasts", function() { return _toasts__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _popouts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./popouts */ "./src/ui/popouts.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Popouts", function() { return _popouts__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _modals__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modals */ "./src/ui/modals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Modals", function() { return _modals__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _discordcontextmenu__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./discordcontextmenu */ "./src/ui/discordcontextmenu.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DiscordContextMenu", function() { return _discordcontextmenu__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _errorboundary__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./errorboundary */ "./src/ui/errorboundary.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrorBoundary", function() { return _errorboundary__WEBPACK_IMPORTED_MODULE_8__["default"]; });













/***/ })

/******/ })["default"];
/*@end@*/
{
	"general": {
		"addTotalAmount": true,
		"addSortOptions": true,
		"addSearchbar": true,
		"addMutualGuild": true
	},
	"settings": {
		"addTotalAmount": true,
		"addSortOptions": true,
		"addSearchbar": true,
		"addMutualGuild": true
	}
}
@import url(https://mwittrien.github.io/BetterDiscordAddons/Themes/_res/SupporterBadge.css);

:root {
	--bdfdb-blurple: var(--brand-experiment, #5865f2);
	--bdfdb-green: var(--status-positive-background, #3ba55c);
	--bdfdb-yellow: var(--status-warning-background, #faa61a);
	--bdfdb-red: var(--status-danger-background, #ed4245);
}

img:not([src]), img[src=""], img[src="null"] {
	opacity: 0;
}

[REPLACE_CLASS_appmount] > [REPLACE_CLASS_itemlayercontainer],
[REPLACE_CLASS_appmount] > [REPLACE_CLASS_popouts] {
	position: fixed;
	z-index: 1001;
}

[REPLACE_CLASS_titlebarmac] {
	z-index: 1000001;
}

[REPLACE_CLASS_itemlayercontainerzindexdisabled] {
	position: absolute !important;
	z-index: unset !important;
}
[REPLACE_CLASS_itemlayercontainerzindexdisabled] > * {
	z-index: 1002;
}
[REPLACE_CLASS_itemlayer] ~ [REPLACE_CLASS_itemlayer] [REPLACE_CLASS_menu] {
	z-index: 1001;
}
[REPLACE_CLASS_menu] [REPLACE_CLASS_itemlayer] {
	z-index: 1002;
}

[REPLACE_CLASS_loadingiconwrapper] {
	position: absolute;
	bottom: 0;
	right: 0;
	z-index: 1000;
	animation: loadingwrapper-fade 3s infinite ease;
}
[REPLACE_CLASS_loadingiconwrapper] [REPLACE_CLASS_loadingicon] {
	margin: 0 5px;
}
@keyframes loadingwrapper-fade {
	from {opacity: 0.1;}
	50% {opacity: 0.9;}
	to {opacity: 0.1;}
}

[REPLACE_CLASS_settingspanellistwrapper] {
	margin-bottom: 8px;
}
[REPLACE_CLASS_settingspanellistwrapper][REPLACE_CLASS_settingspanellistwrappermini] {
	margin-bottom: 4px;
}
[REPLACE_CLASS_settingspanellist] {
	padding-left: 15px;
}
[REPLACE_CLASS_settingspanellistwrapper][REPLACE_CLASS_settingspanellistwrappermini] [REPLACE_CLASS_settingspanellist] {
	padding-left: 10px;
}

[REPLACE_CLASS_settingsrowcontainer][REPLACE_CLASS_marginreset] {
	margin-bottom: 0;
}
[REPLACE_CLASS_settingsrowcontainer][REPLACE_CLASS_marginbottom4] {
	margin-bottom: 4px;
}
[REPLACE_CLASS_settingsrowcontainer][REPLACE_CLASS_marginbottom8] {
	margin-bottom: 8px;
}
[REPLACE_CLASS_settingsrowcontainer][REPLACE_CLASS_marginbottom20] {
	margin-bottom: 20px;
}
[REPLACE_CLASS_settingsrowcontainer][REPLACE_CLASS_marginbottom40] {
	margin-bottom: 40px;
}
[REPLACE_CLASS_settingsrowcontainer][REPLACE_CLASS_marginbottom60] {
	margin-bottom: 60px;
}
[REPLACE_CLASS_flexdirectionrow] > [REPLACE_CLASS_settingsrowcontainer] + [REPLACE_CLASS_settingsrowcontainer] {
	margin-left: 8px;
}
[REPLACE_CLASS_settingsrowcontainer] [REPLACE_CLASS_settingsrowlabel] {
	align-items: center;
}
[REPLACE_CLASS_settingsrowcontainer] [REPLACE_CLASS_settingsrowcontrol] {
	margin-left: 8px;
}
[REPLACE_CLASS_settingsrowcontainer] [REPLACE_CLASS_settingsrowtitlemini] {
	line-height: 18px;
	font-size: 12px;
	font-weight: 400;
}

[REPLACE_CLASS_switch][REPLACE_CLASS_switchmini] {
	width: 26px;
	height: 16px;
}
[REPLACE_CLASS_switch][REPLACE_CLASS_switchmini] [REPLACE_CLASS_switchslider] {
	width: 16px;
	height: 14px;
	margin: 1px;
}

[REPLACE_CLASS_marginleft4] {
	margin-left: 4px;
}
[REPLACE_CLASS_marginleft8] {
	margin-left: 8px;
}

[REPLACE_CLASS_collapsecontainer] {
	margin-bottom: 20px;
}
[REPLACE_CLASS_collapsecontainermini] {
	margin-bottom: 8px;
}
[REPLACE_CLASS_collapsecontainerheader] {
	margin-bottom: 4px;
}
[REPLACE_CLASS_collapsecontainercollapsed] [REPLACE_CLASS_collapsecontainertitle] {
	margin-bottom: 0;
}
[REPLACE_CLASS_collapsecontainertitle] {
	display: flex;
	justify-content: space-between;
	align-items: center;
	cursor: pointer;
	order: 1;
}
[REPLACE_CLASS_collapsecontainertitle]:hover {
	color: var(--text-normal);
}
[REPLACE_CLASS_collapsecontainertitle]::before {
	content: "";
	flex: 1 1 auto;
	background-color: currentColor;
	height: 2px;
	margin: 0 10px 0 15px;
	opacity: 0.2;
	order: 2;
}
[REPLACE_CLASS_collapsecontainertitle]::after {
	content: "";
	-webkit-mask: url('data:image/svg+xml; utf8, <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 18 18"><path fill="none" stroke="black" stroke-width="1.5" d="M 4.5,6.5 9,11 13.5,6.5"/></svg>') center/cover no-repeat;
	background-color: currentColor;
	width: 20px;
	height: 20px;
	order: 3;
	transition: transform .3s ease;
	transform: rotate(0);
}
[REPLACE_CLASS_collapsecontainercollapsed] [REPLACE_CLASS_collapsecontainertitle]::after {
	transform: rotate(90deg)
}
[REPLACE_CLASS_collapsecontainerinner] {
	padding-left: 15px;
}

[REPLACE_CLASS_settingsguild] {
	border-radius: 50%;
	border: 3px solid #43b581;
	box-sizing: border-box;
	cursor: pointer;
	margin: 3px;
	overflow: hidden;
}
[REPLACE_CLASS_settingsguilddisabled] {
	border-color: #747f8d;
	filter: grayscale(100%) brightness(50%);
}

[REPLACE_CLASS_guildslabel] {
	color: var(--text-muted);
	text-align: center;
	text-transform: uppercase;
	font-size: 9px;
	font-weight: 500;
	line-height: 1.3;
	width: 70px;
	word-wrap: normal;
	white-space: nowrap;
}
[REPLACE_CLASS_guildslabel]:hover {
	color: var(--header-secondary);
}
[REPLACE_CLASS_guildslabel]:active {
	color: var(--header-primary);
}

[REPLACE_CLASS_searchbarwrapper] {
	padding: 10px;
}
[REPLACE_CLASS_popout] [REPLACE_CLASS_searchbarwrapper] {
	padding: 0 0 5px 0;
	border-bottom: 1px solid var(--background-modifier-accent);
}

[REPLACE_CLASS_pagination] {
	display: flex;
	justify-content: center;
	align-items: center;
	width: 100%;
}
[REPLACE_CLASS_paginationtop] {
	margin-bottom: 10px;
}
[REPLACE_CLASS_paginationbottom] {
	margin-top: 10px;
}
[REPLACE_CLASS_pagination] [REPLACE_CLASS_paginationcontainer] {
	width: unset;
	margin: 0;
}
[REPLACE_CLASS_paginationmini][REPLACE_CLASS_paginationtop] {
	margin-bottom: 5px;
}
[REPLACE_CLASS_paginationmini][REPLACE_CLASS_paginationbottom] {
	margin-top: 5px;
}
[REPLACE_CLASS_paginationmini] [REPLACE_CLASS_paginationbutton],
[REPLACE_CLASS_paginationmini] [REPLACE_CLASS_paginationgap] {
	font-size: 14px;
	margin: 4px 2px;
}
[REPLACE_CLASS_paginationmini] [REPLACE_CLASS_paginationgap] {
	width: 20px;
}
[REPLACE_CLASS_paginationmini] [REPLACE_CLASS_inputwrapper] {
	min-width: 54px;
}

[REPLACE_CLASS_paginationlist] {
	height: 100%;
}
[REPLACE_CLASS_paginationlistalphabet] {
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 16px;
	line-height: 20px;
	margin-bottom: 10px;
	color: var(--text-normal);
}
[REPLACE_CLASS_paginationlistalphabetchar] {
	min-width: 12px;
	text-align: center;
	margin: 0 4px;
}
[REPLACE_CLASS_paginationlistalphabetchar]:not([REPLACE_CLASS_paginationlistalphabetchardisabled]):hover {
	color: var(--header-primary);
}
[REPLACE_CLASS_paginationlistalphabetchar][REPLACE_CLASS_paginationlistalphabetchardisabled] {
	color: var(--text-muted);
}
[REPLACE_CLASS_paginationlistmini] [REPLACE_CLASS_paginationlistalphabet] {
	font-size: 14px;
	line-height: 18px;
	margin-bottom: 5px;
}
[REPLACE_CLASS_paginationlistmini] [REPLACE_CLASS_paginationlistalphabetchar] {
	min-width: 10px;
	margin: 0 3px;
}

[REPLACE_CLASS_discoverycards] {
	display: grid;
	grid-gap: 16px;
	grid-template-columns: repeat(auto-fill, minmax(248px, 1fr));
	padding: 10px 0;
}
[REPLACE_CLASS_discoverycard] {
	display: flex;
	flex-direction: column;
	position: relative;
	background-color: var(--activity-card-background);
	border: 2px solid var(--activity-card-background);
	border-radius: 8px;
	box-shadow: var(--elevation-medium);
	height: 370px;
	width: 100%;
	overflow: hidden;
	transition: box-shadow .2s ease-out,transform .2s ease-out,background .2s ease-out,border .2s ease-out,opacity .2s ease-in;
}
[REPLACE_CLASS_themedark] [REPLACE_CLASS_discoverycard] {
	background-color: var(--background-secondary-alt);
	border-color: var(--background-secondary-alt);
}
[REPLACE_CLASS_discoverycard]:focus,
[REPLACE_CLASS_discoverycard]:hover {
	background-color: var(--background-tertiary);
	border-color: var(--background-tertiary);
	box-shadow: var(--elevation-high);
	transform: translateY(-1px);
}
[REPLACE_CLASS_discoverycardheader] {
	display: block;
	flex: 0 0 auto;
	position: relative;
	height: 143px;
	overflow: visible;
	margin-bottom: 28px;
}
[REPLACE_CLASS_discoverycardcoverwrapper] {
	display: block;
	position: absolute;
	top: 0;
	left: 0;
	background: url(https://mwittrien.github.io/_res/imgs/cardplaceholder.svg) center/cover no-repeat;
	transform: scale(1);
	transition: transform .2s ease-out;
}
[REPLACE_CLASS_discoverycard]:focus [REPLACE_CLASS_discoverycardcoverwrapper],
[REPLACE_CLASS_discoverycard]:hover [REPLACE_CLASS_discoverycardcoverwrapper] {
	transform: scale(1.01) translateZ(0);
}
[REPLACE_CLASS_discoverycardcoverwrapper],
[REPLACE_CLASS_discoverycardcover] {
	width: 100%;
	height: 100%;
}
[REPLACE_CLASS_discoverycardcover] {
	object-fit: cover;
	cursor: pointer;
}
[REPLACE_CLASS_discoverycardcoverbadge] {
	position: absolute;
	top: 6px;
	right: 8px;
}
[REPLACE_CLASS_discoverycardiconwrapper] {
	position: absolute;
	bottom: -21px;
	left: 12px;
	background-color: var(--activity-card-background);
	border-radius: 10px;
	padding: 6px;
	transition: box-shadow .2s ease-out,transform .2s ease-out,background .2s ease-out;
}
[REPLACE_CLASS_themedark] [REPLACE_CLASS_discoverycardiconwrapper] {
	background-color: var(--background-secondary-alt);
}
[REPLACE_CLASS_discoverycard]:focus [REPLACE_CLASS_discoverycardiconwrapper],
[REPLACE_CLASS_discoverycard]:hover [REPLACE_CLASS_discoverycardiconwrapper] {
	background-color: var(--background-tertiary);
}
[REPLACE_CLASS_discoverycardicon] {
	color: var(--header-primary);
	border-radius: 10px;
	width: 32px;
	height: 32px;
}
[REPLACE_CLASS_discoverycardiconloading] {
	visibility: hidden;
}
[REPLACE_CLASS_discoverycardinfo] {
	display: flex;
	flex: 1 1 auto;
	position: relative;
	flex-direction: column;
	align-content: stretch;
	padding: 0 16px 16px;
	overflow: hidden;
}
[REPLACE_CLASS_discoverycardtitle] {
	display: flex;
	align-items: center;
	color: var(--header-primary);
	width: 100%;
	font-weight: 600;
	font-size: 16px;
	line-height: 20px;
	flex: 0 0 auto;
}
[REPLACE_CLASS_discoverycardname] {
	overflow: hidden;
	white-space: nowrap;
	text-overflow: ellipsis;
	flex: 1 1 auto;
}
[REPLACE_CLASS_discoverycardtitlebutton] {
	display: flex;
	margin-left: 4px;
}
[REPLACE_CLASS_discoverycard] [REPLACE_CLASS_favbuttoncontainer] {
	width: 20px;
	height: 20px;
	flex: 0 0 auto;
}
[REPLACE_CLASS_discoverycard] [REPLACE_CLASS_favbuttoncontainer] [REPLACE_CLASS_giffavoritesize] {
	width: 20px;
	height: 20px;
}
[REPLACE_CLASS_discoverycardauthor] {
	color: var(--header-secondary);
	margin: 3px 0 6px;
	font-size: 14px;
	flex: 0 0 auto;
}
[REPLACE_CLASS_discoverycarddescription] {
	color: var(--header-secondary);
	margin: 4px 0 12px;
	font-size: 14px;
	line-height: 18px;
}
[REPLACE_CLASS_discoverycardfooter] {
	flex: 0 0 auto;
}
[REPLACE_CLASS_discoverycardtags] {
	display: flex;
	flex-wrap: wrap;
	align-items: center;
	margin-bottom: 4px;
}
[REPLACE_CLASS_discoverycardtag] {
	margin-right: 6px;
	margin-bottom: 6px;
	font-weight: 500;
}
[REPLACE_CLASS_discoverycardcontrols] {
	display: flex;
	justify-content: space-between;
	align-items: flex-end;
	align-items: center;
	flex: 0 0 auto;
}
[REPLACE_CLASS_discoverycardbutton] {
	display: flex;
	justify-content: center;
	align-items: center;
	border-radius: 3px;
	color: var(--header-primary);
	font-size: 14px;
	font-weight: 500;
	padding: 6px 8px;
}
[REPLACE_CLASS_discoverycardstats] {
	display: flex;
	justify-content: center;
	align-items: center;
	color: var(--header-secondary);
	font-size: 14px;
}
[REPLACE_CLASS_discoverycardstat] {
	display: flex;
	justify-content: center;
	align-items: center;
	margin-right: 8px;
}
[REPLACE_CLASS_discoverycardstaticon] {
	margin-right: 4px;
}

[REPLACE_CLASS_overflowellipsis] {
	overflow: hidden;
	text-overflow: ellipsis;
}


[REPLACE_CLASS_userpopoutheaderbottag] {
	margin-top: 4px !important;
}
[REPLACE_CLASS_userinfodate] {
	color: var(--header-secondary);
	margin-top: 8px;
	user-select: text;
}
[REPLACE_CLASS_userinfodate] + [REPLACE_CLASS_userinfodate] {
	margin-top: 0;
}
[REPLACE_CLASS_userinfodate] + *:not([REPLACE_CLASS_userinfodate]) {
	margin-top: 6px;
}
[REPLACE_CLASS_userprofile] [class*='topSection']:not([class*='topSectionNormal']) [REPLACE_CLASS_userinfodate] {
	color: hsla(0,0%,100%,.6);
}

[REPLACE_CLASS_avatardisabled] {
	filter: grayscale(100%) brightness(50%);
}

[REPLACE_CLASS_messagebottag] {
	top: .15rem;
}
[REPLACE_CLASS_messageusername] ~ [REPLACE_CLASS_messagebottagcompact] {
	margin-right: 0;
	margin-left: .25rem;
}

[REPLACE_CLASS_messageavatar][REPLACE_CLASS_bdfdbbadgeavatar] [REPLACE_CLASS_avatarwrapper] {
	width: inherit !important;
	height: inherit !important;
}

[REPLACE_CLASS_favbuttoncontainer] {
	display: flex;
	position: relative;
	cursor: pointer;
}

[REPLACE_CLASS_menuhint] {
	width: 42px;
	max-width: 42px;
	margin-left: 8px;
}

[REPLACE_CLASS_cursordefault] {
	cursor: default !important;
}
[REPLACE_CLASS_cursorpointer] {
	cursor: pointer !important;
}

[REPLACE_CLASS_slidergrabber]:active [REPLACE_CLASS_sliderbubble],
[REPLACE_CLASS_slidergrabber]:hover [REPLACE_CLASS_sliderbubble] {
	visibility: visible;
}
[REPLACE_CLASS_sliderbubble] {
	background-color: var(--background-floating);
	border-radius: 3px;
	top: -32px;
	height: 22px;
	width: auto;
	padding: 0 5px;
	white-space: pre;
	transform: translateX(-50%);
	line-height: 22px;
	text-align: center;
	font-weight: 600;
	font-size: 12px;
	color: var(--header-primary);
	visibility: hidden;
}
[REPLACE_CLASS_sliderbubble],
[REPLACE_CLASS_sliderbubble]::before {
	position: absolute;
	left: 50%;
	pointer-events: none;
}
[REPLACE_CLASS_sliderbubble]::before {
	border: 5px solid transparent;
	border-top-color: var(--background-floating);
	content: " ";
	width: 0;
	height: 0;
	margin-left: -5px;
	top: 100%;
}

[REPLACE_CLASS_quickselectwrapper] {
	margin-left: 12px;
}

[REPLACE_CLASS_selectwrapper] {
	display: flex;
	align-items: center;
	flex: 1 1 auto;
}
[REPLACE_CLASS_selectwrapper] [REPLACE_CLASS_select] {
	flex: 1 1 auto;
}
[REPLACE_CLASS_selectwrapper] [REPLACE_CLASS_selectsearchinput] {
	width: 100%;
}
[REPLACE_CLASS_selectoption] [REPLACE_CLASS_giffavoritesize] {
	width: 20px;
	height: 20px;
}

[REPLACE_CLASS_hotkeywrapper] [REPLACE_CLASS_hotkeycontainer] {
	flex: 1 1 auto;
}
[REPLACE_CLASS_hotkeyresetbutton] {
	cursor: pointer;
	margin-left: 5px;
}
[REPLACE_CLASS_hotkeyresetbutton] [REPLACE_CLASS_svgicon]:hover {
	color: #f04747;
}

[REPLACE_CLASS_hovercardwrapper] {
	position: relative;
	display: flex;
	flex-direction: column;
	align-items: center;
}
[REPLACE_CLASS_hovercardhorizontal] {
	flex-direction: row;
}
[REPLACE_CLASS_hovercardhorizontal] > [REPLACE_CLASS_flexchild] + [REPLACE_CLASS_flexchild] {
	margin-left: 8px;
}
[REPLACE_CLASS_hovercarddisabled] {
	opacity: 0.7;
	filter: grayscale(0.2);
}
[REPLACE_CLASS_settingspanel] [REPLACE_CLASS_hovercardwrapper] {
	width: calc(100% - 22px);
}
[REPLACE_CLASS_hovercardwrapper][REPLACE_CLASS_hovercard] {
	padding: 10px 0;
}
[REPLACE_CLASS_hovercardwrapper][REPLACE_CLASS_hovercard] > * {
	z-index: 1;
}
[REPLACE_CLASS_hovercardwrapper], [REPLACE_CLASS_hovercardinner] {
	min-height: 28px;
}
[REPLACE_CLASS_hovercardinner] {
	width: 100%;
	padding-right: 5px;
	display: flex;
	align-items: center;
	z-index: 1;
}
[REPLACE_CLASS_hovercardwrapper] [REPLACE_CLASS_hovercardbutton] {
	position: absolute;
	top: -6px;
	right: -6px;
	opacity: 0;
}
[REPLACE_CLASS_hovercardwrapper][REPLACE_CLASS_hovercard] [REPLACE_CLASS_hovercardbutton] {
	right: -25px;
}
[REPLACE_CLASS_hovercardwrapper]:hover [REPLACE_CLASS_hovercardbutton] {
	opacity: 1;
}

[REPLACE_CLASS_textareabuttonwrapper] {
	display: flex;
	justify-content: center;
	align-items: center;
}

[REPLACE_CLASS_guildsummarycontainer] {
	display: -webkit-box;
	display: -ms-flexbox;
	display: flex;
	-webkit-box-align: center;
	-ms-flex-align: center;
	align-items: center;
}
[REPLACE_CLASS_guildsummarysvgicon] {
	-webkit-box-flex: 0;
	-ms-flex: 0 0 auto;
	flex: 0 0 auto;
	color: var(--text-muted);
	width: 20px;
	height: 20px;
	margin-right: 8px;
}
[REPLACE_CLASS_guildsummaryiconcontainer] {
	width: 24px;
	height: 24px;
}
[REPLACE_CLASS_guildsummaryiconcontainermasked] {
	margin-right: -4px;
	-webkit-mask: url('data:image/svg+xml; utf8, <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1 1"><path fill="white" d="M 0 0 L 0 1 L 1 1 L 1 0.99804688 A 0.54166669 0.54166669 0 0 1 0.66601562 0.5 A 0.54166669 0.54166669 0 0 1 1 0.001953125 L 1 0 L 0 0 z"/></svg>') center/cover no-repeat;
}
[REPLACE_CLASS_guildsummaryclickableicon] {
	cursor: pointer;
}
[REPLACE_CLASS_guildsummaryicon],
[REPLACE_CLASS_guildsummaryclickableicon],
[REPLACE_CLASS_guildsummaryemptyguild] {
	width: 24px;
	height: 24px;
	border-radius: 50%;
}
[REPLACE_CLASS_guildsummaryemptyguild] {
	background: var(--background-accent);
}
[REPLACE_CLASS_guildsummarymoreguilds] {
	-webkit-box-sizing: border-box;
	box-sizing: border-box;
	background-color: var(--background-tertiary);
	font-size: 12px;
	line-height: 24px;
	font-weight: 500;
	text-align: center;
	color: var(--text-normal);
	height: 24px;
	min-width: 24px;
	border-radius: 12px;
	padding: 0 8px;
}

[REPLACE_CLASS_table] {
	position: relative;
	width: 100%;
}
[REPLACE_CLASS_table] [REPLACE_CLASS_tablespacerheader],
[REPLACE_CLASS_table] [REPLACE_CLASS_tablestickyheader] {
	padding: 0px 12px 8px 0;
	margin-bottom: 5px;
	box-sizing: border-box;
	background-color: var(--background-primary);
	border-bottom: 1px solid var(--background-modifier-accent);
}
[REPLACE_CLASS_table] [REPLACE_CLASS_tablestickyheader]:first-child {
	position: absolute;
	width: 100%;
}
[REPLACE_CLASS_modalsub] [REPLACE_CLASS_table] [REPLACE_CLASS_tablestickyheader]:first-child {
	padding-left: 20px;
}
[REPLACE_CLASS_tableheadercell] {
	color: var(--interactive-normal);
	font-size: 12px;
	font-weight: 600;
	text-transform: uppercase;
}
[REPLACE_CLASS_tableheadercell],
[REPLACE_CLASS_tablebodycell] {
	border-left: 1px solid var(--background-modifier-accent);
	box-sizing: border-box;
	padding: 0 12px;
}
[REPLACE_CLASS_tableheadercell]:first-child,
[REPLACE_CLASS_tablebodycell]:first-child {
	border-left: none;
	padding-left: 0;
}
[REPLACE_CLASS_table] [REPLACE_CLASS_tablerow] {
	position: relative;
	display: flex;
	margin-bottom: 5px;
	align-items: center;
	color: var(--header-secondary);
}
[REPLACE_CLASS_tablebodycell] {
	font-size: 15px;
}

[REPLACE_CLASS_settingstableheaders] {
	display: flex;
	align-items: center;
	flex: 1 0 auto;
	margin-right: 10px;
	margin-left: 10px;
}
[REPLACE_CLASS_settingstableheaderoptions] {
	display: flex;
	align-items: center;
	justify-content: space-between;
	flex: 0 0 auto;
}
[REPLACE_CLASS_settingstablelist] [REPLACE_CLASS_settingstableheader] {
	min-height: 10px;
	text-transform: uppercase;
}
[REPLACE_CLASS_settingstablelist] [REPLACE_CLASS_settingstableheaderoption] {
	width: unset;
}
[REPLACE_CLASS_settingstablelist] [REPLACE_CLASS_settingstableheaderoption][REPLACE_CLASS_settingstableheadervertical] {
	width: 24px;
}
[REPLACE_CLASS_settingstableheadervertical] {
	position: relative;
}
[REPLACE_CLASS_settingstableheadervertical] > span {
	position: absolute;
	bottom: 50%;
	right: calc(50% - 4px);
	margin-bottom: -5px;
	writing-mode: vertical-rl;
}
[REPLACE_CLASS_settingstablecard] {
	height: 60px;
	padding: 0 10px;
	margin-bottom: 10px;
}
[REPLACE_CLASS_settingstablecardlabel] {
	display: flex;
	align-items: center;
	flex: 1 1 auto;
	overflow: hidden;
	color: var(--header-primary);
}
[REPLACE_CLASS_settingstablecardconfigs] {
	display: flex;
	align-items: center;
	justify-content: space-between;
	flex: 0 0 auto;
}
[REPLACE_CLASS_settingstablecard] [REPLACE_CLASS_settingstablecardlabel] {
	padding-right: 10px;
}
[REPLACE_CLASS_settingstablecard] [REPLACE_CLASS_settingstablecardlabel],
[REPLACE_CLASS_settingstablecard] [REPLACE_CLASS_settingstablecardconfigs] {
	margin: 0;
}
[REPLACE_CLASS_settingstablelist] [REPLACE_CLASS_checkboxcontainer]::before {
	display: none;
}

[REPLACE_CLASS_popoutwrapper] [REPLACE_CLASS_messagespopouttabbarheader] {
	flex: 1 0 auto;
	align-items: center;
	height: unset;
	min-height: 56px;
}
[REPLACE_CLASS_popoutwrapper] [REPLACE_CLASS_messagespopouttabbarheader] [REPLACE_CLASS_messagespopouttabbar] {
	align-items: center;
	flex: 1 1 auto;
	min-height: 32px;
}

[REPLACE_CLASS_charcounter] {
	color: var(--channels-default);
}

[REPLACE_CLASS_inputmulti] {
	display: flex;
	justify-content: space-between;
	align-items: center;
}
[REPLACE_CLASS_inputmultifirst] {
	flex-grow: 1;
	padding: 0 8px;
}
[REPLACE_CLASS_inputmultilast]::before {
	content: "";
	position: absolute;
	border: 1px solid var(--header-primary);
	width: 1px;
	height: 30px;
	margin-top: 5px;
	opacity: .1;
}
[REPLACE_CLASS_inputmultilast] input {
	width: 250px;
	padding-left: 16px;
}
[REPLACE_CLASS_inputmultifield] {
	border: none !important;
}

[REPLACE_CLASS_inputlistitems] {
	display: flex;
	flex-direction: row;
	justify-content: flex-start;
	align-items: center;
	flex-wrap: wrap;
}
[REPLACE_CLASS_inputlistitem] {
	display: flex;
	justify-content: center;
	align-items: center;
}
[REPLACE_CLASS_inputlistitem]:not(:last-child) {
	margin-right: 4px;
}
[REPLACE_CLASS_inputlistdelete] {
	cursor: pointer;
	margin-left: 6px;
}

[REPLACE_CLASS_dateinputwrapper] {
	display: flex;
	align-items: center;
	margin-bottom: 8px;
}
[REPLACE_CLASS_dateinputinner] {
	flex: 1 1 auto;
	color: var(--header-primary);
	max-width: calc(100% - 150px);
	margin-left: 8px;
}
[REPLACE_CLASS_dateinputcontrols] {
	display: flex;
	align-items: center;
}
[REPLACE_CLASS_dateinputpreview] {
	display: flex;
	align-items: center;
	color: var(--header-primary);
	margin-top: 8px;
	font-weight: normal;
}
[REPLACE_CLASS_dateinputpreviewprefix],
[REPLACE_CLASS_dateinputpreviewsuffix] {
	font-weight: 600;
}
[REPLACE_CLASS_dateinputpreviewprefix]:not(:empty) {
	margin-right: 6px;
}
[REPLACE_CLASS_dateinputpreviewsuffix]:not(:empty) {
	margin-left: 6px;
}
[REPLACE_CLASS_dateinputfield] {
	flex: 1 1 auto;
}
[REPLACE_CLASS_dateinputbutton] {
	margin-left: 8px;
}
[REPLACE_CLASS_dateinputbuttonselected] [REPLACE_CLASS_svgicon],
[REPLACE_CLASS_dateinputbuttonselected] [REPLACE_CLASS_svgicon]:hover {
	color: var(--interactive-active);
}

[REPLACE_CLASS_inputnumberwrapper] {
	position: relative;
}
[REPLACE_CLASS_inputnumberbuttons]:hover + [REPLACE_CLASS_input]:not([REPLACE_CLASS_inputfocused]):not([REPLACE_CLASS_inputerror]):not([REPLACE_CLASS_inputsuccess]):not([REPLACE_CLASS_inputdisabled]):not(:focus) {
	border-color: #040405;
}
[REPLACE_CLASS_inputnumberwrapperdefault] [REPLACE_CLASS_input] {
	padding-right: 25px;
}
[REPLACE_CLASS_inputnumberwrappermini] [REPLACE_CLASS_input] {
	padding-left: 6px;
	padding-right: 17px;
}
[REPLACE_CLASS_inputnumberwrapper] [REPLACE_CLASS_input]::-webkit-inner-spin-button, 
[REPLACE_CLASS_inputnumberwrapper] [REPLACE_CLASS_input]::-webkit-outer-spin-button{
	-webkit-appearance: none !important;
}
[REPLACE_CLASS_inputnumberbuttons] {
	position: absolute;
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: space-around;
	height: 110%;
	top: -2%;
}
[REPLACE_CLASS_inputnumberwrapperdefault] [REPLACE_CLASS_inputnumberbuttons] {
	right: 8px;
}
[REPLACE_CLASS_inputnumberwrappermini] [REPLACE_CLASS_inputnumberbuttons] {
	right: 4px;
}
[REPLACE_CLASS_inputnumberbutton] {
	cursor: pointer;
	border: transparent solid 5px;
	border-top-width: 2.5px;
	display: inline-block;
}
[REPLACE_CLASS_inputnumberbutton] {
	border-bottom-color: var(--interactive-normal);
}
[REPLACE_CLASS_inputnumberbutton]:hover {
	border-bottom-color: var(--interactive-active);
}
[REPLACE_CLASS_inputnumberbuttondown] {
	transform: rotate(180deg);
}

[REPLACE_CLASS_guildupperleftbadge] {
	top: 0;
}
[REPLACE_CLASS_guildlowerleftbadge] {
	bottom: 0;
}
[REPLACE_CLASS_guildlowerleftbadge], [REPLACE_CLASS_guildupperleftbadge] {
	pointer-events: none;
	position: absolute;
	left: 0;
}

[REPLACE_CLASS_svgiconwrapper] {
	display: flex;
	justify-content: center;
	align-items: center;
}
[REPLACE_CLASS_svgicon] {
	color: var(--interactive-normal);
}
[REPLACE_CLASS_svgicon]:hover {
	color: var(--interactive-hover);
}
[REPLACE_CLASS_svgicon]:active {
	color: var(--interactive-active);
}

[REPLACE_CLASS_listrowwrapper] [REPLACE_CLASS_listavatar] {
	display: flex;
	justify-content: center;
	align-items: center;
}

[REPLACE_CLASS_sidebarlist] {
	display: flex;
	flex-direction: row;
	flex: 1 1 auto;
}
[REPLACE_CLASS_sidebar] {
	padding: 8px;
	flex: 0 1 auto;
}
[REPLACE_CLASS_sidebarcontent] {
	padding: 8px 0;
	flex: 1 1 auto;
}

[REPLACE_CLASS_modalwrapper] [REPLACE_CLASS_modalheader] > [REPLACE_CLASS_headerwrapper]  {
	flex: 1 0 auto;
}
[REPLACE_CLASS_modalwrapper] [REPLACE_CLASS_modalclose] [REPLACE_CLASS_buttoncontents] {
	display: flex;
	justify-content: center;
	align-items: center;
}
[REPLACE_CLASS_modalsubinner] {
	padding-left: 16px;
	padding-right: 8px;
}
[REPLACE_CLASS_modaltextcontent] {
	margin-bottom: 10px;
}
[REPLACE_CLASS_modalnoscroller] {
	overflow: hidden;
}
[REPLACE_CLASS_modalcontent][REPLACE_CLASS_modalnoscroller] {
	padding-bottom: 10px;
}
[REPLACE_CLASS_modaltabcontent] {
	margin-top: 10px;
}
[REPLACE_CLASS_listscroller] [REPLACE_CLASS_modaltabcontent] {
	margin-top: 0;
}
[REPLACE_CLASS_modalheaderhassibling] {
	padding-bottom: 10px;
}
[REPLACE_CLASS_modalheadershade],
[REPLACE_CLASS_modalsidebar] {
	background: rgba(0, 0, 0, 0.1);
}
[REPLACE_CLASS_themedark] [REPLACE_CLASS_modalheadershade],
[REPLACE_CLASS_themedark] [REPLACE_CLASS_modalsidebar] {
	background: rgba(0, 0, 0, 0.2);
}
[REPLACE_CLASS_tabbarcontainer][REPLACE_CLASS_tabbarcontainerbottom] {
	border-top: unset;
	border-bottom: 1px solid hsla(0,0%,100%,.1);
}
[REPLACE_CLASS_modalwrapper] [REPLACE_CLASS_tabbarcontainer] {
	background: rgba(0, 0, 0, 0.1);
	border: none;
	box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.05);
	padding-right: 12px;
}
[REPLACE_CLASS_themedark] [REPLACE_CLASS_modalwrapper] [REPLACE_CLASS_tabbarcontainer] {
	background: rgba(0, 0, 0, 0.2);
	box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.1);
}
[REPLACE_CLASS_modalchangelogmodal] [REPLACE_CLASS_changelogsociallink] {
	margin-right: 12px;
}

[REPLACE_CLASS_themedark] [REPLACE_CLASS_popoutwrapper][REPLACE_CLASS_popoutright][REPLACE_CLASS_popoutarrowalignmentmiddle]::before {
	border-right-color: #2f3136;
}
[REPLACE_CLASS_themedark] [REPLACE_CLASS_popoutwrapper][REPLACE_CLASS_popoutleft][REPLACE_CLASS_popoutarrowalignmentmiddle]::before {
	border-left-color: #2f3136;
}
[REPLACE_CLASS_themedark] [REPLACE_CLASS_popoutwrapper][REPLACE_CLASS_popoutbottom][REPLACE_CLASS_popoutarrowalignmentmiddle]::before,
[REPLACE_CLASS_themedark] [REPLACE_CLASS_popoutwrapper][REPLACE_CLASS_popoutbottom][REPLACE_CLASS_popoutarrowalignmenttop]::before,
[REPLACE_CLASS_themedark] [REPLACE_CLASS_popoutwrapper][REPLACE_CLASS_popoutbottomleft][REPLACE_CLASS_popoutarrowalignmentmiddle]::before,
[REPLACE_CLASS_themedark] [REPLACE_CLASS_popoutwrapper][REPLACE_CLASS_popoutbottomleft][REPLACE_CLASS_popoutarrowalignmenttop]::before,
[REPLACE_CLASS_themedark] [REPLACE_CLASS_popoutwrapper][REPLACE_CLASS_popoutbottomright][REPLACE_CLASS_popoutarrowalignmentmiddle]::before,
[REPLACE_CLASS_themedark] [REPLACE_CLASS_popoutwrapper][REPLACE_CLASS_popoutbottomright][REPLACE_CLASS_popoutarrowalignmenttop]::before {
	border-bottom-color: #2f3136;
}
[REPLACE_CLASS_themedark] [REPLACE_CLASS_popoutwrapper][REPLACE_CLASS_popouttop]::after,
[REPLACE_CLASS_themedark] [REPLACE_CLASS_popoutwrapper][REPLACE_CLASS_popouttopleft]::after,
[REPLACE_CLASS_themedark] [REPLACE_CLASS_popoutwrapper][REPLACE_CLASS_popouttopright]::after {
	border-top-color: #2f3136;
}
[REPLACE_CLASS_popoutthemedpopout] {
	background-color: var(--background-secondary);
	-webkit-box-shadow: var(--elevation-stroke),var(--elevation-high);
	box-shadow: var(--elevation-stroke),var(--elevation-high);
	box-sizing: border-box;
	border-radius: 5px;
	display: -webkit-box;
	display: -ms-flexbox;
	display: flex;
	-webkit-box-orient: vertical;
	-webkit-box-direction: normal;
	-ms-flex-direction: column;
	flex-direction: column;
}
[REPLACE_CLASS_popoutwrapper][REPLACE_CLASS_popoutarrowalignmentmiddle] [REPLACE_CLASS_popoutthemedpopout],
[REPLACE_CLASS_popoutwrapper][REPLACE_CLASS_popoutarrowalignmenttop] [REPLACE_CLASS_popoutthemedpopout] {
	border-color: transparent;
}

[REPLACE_CLASS__repomodal] {
	min-height: unset;
}
[REPLACE_CLASS__repomodalsettings] {
    padding: 0 16px 16px 16px;
}

[REPLACE_CLASS__repolistwrapper] [REPLACE_CLASS_settingswindowtoolscontainer] {
	margin-top: -140px;
}
[REPLACE_CLASS__repolistwrapper] [REPLACE_CLASS_settingswindowcontentregionscroller] {
	height: calc(100% - 140px);
}
[REPLACE_CLASS__repolistwrapper] [REPLACE_CLASS_settingswindowcontentcolumn] {
	padding-top: 20px;
}
[REPLACE_CLASS__repolistheader] {
	display: flex;
	flex-direction: column;
	padding-top: 60px;
	padding-right: 70px;
}
[REPLACE_CLASS__repolistheader] > * {
	max-width: 740px;
	min-width: 460px;
	padding-left: 40px;
	padding-right: 40px;
}
[REPLACE_CLASS__repoentry] [REPLACE_CLASS__repofooter] {
	display: flex;
	align-items: center;
	justify-content: space-between;
}
[REPLACE_CLASS__repoentry] [REPLACE_CLASS__repofooter] > *:only-child {
	margin-left: auto;
}
[REPLACE_CLASS__repoentry] [REPLACE_CLASS__repoheadercontrols],
[REPLACE_CLASS__repoentry] [REPLACE_CLASS__repofootercontrols] {
	display: flex;
	align-items: center;
	justify-content: center;
	flex: 0 0 auto;
}
[REPLACE_CLASS__repoentry] [REPLACE_CLASS__repoheadercontrols] > *,
[REPLACE_CLASS__repoentry] [REPLACE_CLASS__repocontrols] > * {
	margin-left: 10px;
}
[REPLACE_CLASS__repoentry] [REPLACE_CLASS__repofootercontrols][REPLACE_CLASS__repocontrols] > * {
	margin-left: 0;
}
[REPLACE_CLASS__repoentry] [REPLACE_CLASS__repocontrolsbutton] {
	display: flex;
	align-items: center;
	justify-content: center;
	cursor: pointer;
}
[REPLACE_CLASS__repoentry] [REPLACE_CLASS__repocontrols] > [REPLACE_CLASS__repocontrolsbutton]:only-child {
	border-radius: 3px;
}

[REPLACE_CLASS_noticewrapper] {
	display: flex;
	justify-content: center;
	align-items: center;
	height: 36px !important;
	border-radius: 0 !important;
	transition: height 0.5s ease !important;
}
[REPLACE_CLASS_noticeclosing] {
	height: 0 !important;
	overflow: hidden !important;
}
[REPLACE_CLASS_noticetext] {
	display: inline-flex;
	flex: 0 1 auto;
	white-space: pre;
	overflow: hidden;
}
[REPLACE_CLASS_noticewrapper] [REPLACE_CLASS_noticeplatformicon] {
	display: inline-flex;
	flex: 0 0 auto;
	position: static;
	margin: 0 10px 0 0;
}
[REPLACE_CLASS_noticewrapper] svg[REPLACE_CLASS_noticeplatformicon] {
	max-height: 28px;
	width: unset;
}
[REPLACE_CLASS_noticewrapper] [REPLACE_CLASS_noticebutton] {
	display: inline-flex;
	flex: 0 0 auto;
	position: static;
}

#pluginNotice .notice-message {
	white-space: pre;
}
#pluginNotice #outdatedPlugins {
	font-weight: 700;
}
#pluginNotice #outdatedPlugins span {
	-webkit-app-region: no-drag;
	color: #fff;
	cursor: pointer;
}
#pluginNotice #outdatedPlugins span:hover {
	text-decoration: underline;
}
[REPLACE_CLASS_noticeupdateentries] {
	display: flex;
	font-weight: 700;
}
[REPLACE_CLASS_noticeupdateentry] {
	cursor: pointer;
	-webkit-app-region: no-drag;
}
[REPLACE_CLASS_noticeupdateentry]:hover {
	text-decoration: underline;
}
[REPLACE_CLASS_noticeupdateseparator] {
	pointer-events: none;
}

.platform-osx [REPLACE_CLASS_noticewrapper] ~ * [REPLACE_CLASS_guildswrapper] {
	margin-top: 0;
}
.platform-osx [REPLACE_CLASS_noticewrapper] ~ * [REPLACE_CLASS_guildsscroller] {
	padding-top: 4px;
}

[REPLACE_CLASS_tooltipnote] {
	color: var(--text-muted);
	font-size: 11px;
	margin-top: 2px;
}
[REPLACE_CLASS_tooltip][REPLACE_CLASS_tooltipcustom],
[REPLACE_CLASS_tooltiplistitem][REPLACE_CLASS_tooltipcustom] {
	color: #fff;
}
[REPLACE_CLASS_tooltip][REPLACE_CLASS_tooltipcustom] [REPLACE_CLASS_tooltipnote],
[REPLACE_CLASS_tooltiplistitem][REPLACE_CLASS_tooltipcustom] [REPLACE_CLASS_tooltipnote] {
	color: #bbb;
}
[REPLACE_CLASS_tooltipcustom] [REPLACE_CLASS_tooltippointer] {
	border-top-color: inherit !important;
}
[REPLACE_CLASS_tooltipcustom] [REPLACE_CLASS_tooltipguildnametext],
[REPLACE_CLASS_tooltipcustom] [REPLACE_CLASS_tooltipmutetext] {
	color: inherit;
}
[REPLACE_CLASS_tooltipcustom] [REPLACE_CLASS_tooltipmutetext] {
	opacity: .7;
}
[REPLACE_CLASS_tooltiprowextra]:empty {
	display: none;
}
[REPLACE_CLASS_tooltiprowextra]:not(:empty) [REPLACE_CLASS_tooltipmutetext] {
	margin-top: 8px;
}

[REPLACE_CLASS_colorpickerswatchsinglewrapper] {
	position: relative;
	z-index: 1;
}
[REPLACE_CLASS_colorpickerswatchsingle] {
	height: 30px;
	width: 30px;
}
[REPLACE_CLASS_colorpickerswatchesdisabled] {
	cursor: no-drop;
	filter: grayscale(70%) brightness(50%);
}
[REPLACE_CLASS_colorpickerswatch][REPLACE_CLASS_colorpickerswatchnocolor] {
	border-color: var(--text-muted);
}
[REPLACE_CLASS_colorpickerswatch][style*="background: rgb(255, 255, 255)"] {
	border-color: var(--header-primary) !important;
}
[REPLACE_CLASS_colorpickerswatch][REPLACE_CLASS_colorpickerswatchnocolor] [REPLACE_CLASS_colorpickerswatchdropperfg] {
	border-color: var(--text-muted);
}
[REPLACE_CLASS_colorpickerswatch]:not([REPLACE_CLASS_colorpickerswatchnocolor]):not([REPLACE_CLASS_colorpickerswatchdefault]):not([REPLACE_CLASS_colorpickerswatchdisabled]) {
	overflow: hidden;
}
[REPLACE_CLASS_colorpickerswatch][REPLACE_CLASS_colorpickerswatchcustom][style*="background"] {
	border: none;
}
[REPLACE_CLASS_colorpickerswatch]:not([REPLACE_CLASS_colorpickerswatchdefault])::after {
	border-radius: 3px;
}
[REPLACE_CLASS_colorpickerswatch][REPLACE_CLASS_colorpickerswatchcustom]:not([REPLACE_CLASS_colorpickerswatchdefault])::after {
	border-radius: 5px;
}
[REPLACE_CLASS_colorpickerswatch]:not([REPLACE_CLASS_colorpickerswatchnocolor]):not([REPLACE_CLASS_colorpickerswatchdefault]):not([REPLACE_CLASS_colorpickerswatchdisabled])::after {
	content: "";
	background: url('data:image/svg+xml; utf8, <svg xmlns="http://www.w3.org/2000/svg" width="8" height="8"><rect x="0" y="0" width="4" height="4" fill="black"></rect><rect x="0" y="4" width="4" height="4" fill="white"></rect><rect x="4" y="0" width="4" height="4" fill="white"></rect><rect x="4" y="4" width="4" height="4" fill="black"></rect></svg>') center repeat;
	position: absolute;
	top: 0;
	right: 0;
	bottom: 0;
	left: 0;
	z-index: -1;
}

[REPLACE_CLASS_colorpickeralpha] {
	position: relative;
	height: 8px;
	margin: 16px 0 8px;
}
[REPLACE_CLASS_colorpickergradient] {
	position: relative;
	height: 8px;
	margin: 27px 2px 2px 2px;
}
[REPLACE_CLASS_colorpickeralpha] > div > div > div > div {
	height: 16px !important;
	width: 8px !important;
	margin-top: -3px !important;
	border-radius: 3px !important;
}
[REPLACE_CLASS_colorpickersaturation] > div > div > div > div {
	box-shadow: var(--header-primary) 0px 0px 0px 1.5px, var(--background-floating) 0px 0px 1px 1px inset, var(--background-floating) 0px 0px 1px 2px !important;
}
[REPLACE_CLASS_colorpickerhue] > div > div > div > div,
[REPLACE_CLASS_colorpickeralpha] > div > div > div > div {
	background: var(--header-primary) !important;
	box-shadow: var(--background-floating) 0px 0px 2px !important;
}
[REPLACE_CLASS_colorpickeralpha] > div > div,
[REPLACE_CLASS_colorpickergradient] > div > div {
	border-radius: 3px;
}
[REPLACE_CLASS_colorpickeralpha] [REPLACE_CLASS_colorpickeralphacheckered],
[REPLACE_CLASS_colorpickergradient] [REPLACE_CLASS_colorpickergradientcheckered],
[REPLACE_CLASS_colorpickergradient] [REPLACE_CLASS_colorpickergradientcursor] > div::after {
	background: url('data:image/svg+xml; utf8, <svg xmlns="http://www.w3.org/2000/svg" width="8" height="8"><rect x="0" y="0" width="4" height="4" fill="black"></rect><rect x="0" y="4" width="4" height="4" fill="white"></rect><rect x="4" y="0" width="4" height="4" fill="white"></rect><rect x="4" y="4" width="4" height="4" fill="black"></rect></svg>') center repeat;
}
[REPLACE_CLASS_colorpickergradient] [REPLACE_CLASS_colorpickergradientcursor] > div {
	height: 8px;
	width: 8px;
	margin-top: -15px;
	border: 1px solid rgb(128, 128, 128);
	border-radius: 3px;
	transform: translateX(-5px);
	transform-style: preserve-3d;
}
[REPLACE_CLASS_colorpickergradient] [REPLACE_CLASS_colorpickergradientcursor] > div::after {
	content: "";
	position: absolute;
	top: 0;
	right: 0;
	bottom: 0;
	left: 0;
	z-index: -1;
	border-radius: 3px;
	transform: translateZ(-1px);
}
[REPLACE_CLASS_colorpickergradient] [REPLACE_CLASS_colorpickergradientcursor] > div::before {
	content: "";
	position: absolute;
	border: 3px solid transparent;
	border-top-width: 5px;
	border-top-color: rgb(128, 128, 128);
	width: 0;
	height: 0;
	top: 100%;
	left: -50%;
	transform: translateX(5px);
}
[REPLACE_CLASS_colorpickergradient] [REPLACE_CLASS_colorpickergradientcursor][REPLACE_CLASS_colorpickergradientcursoredge] > div::before {
	border-right-width: 0;
	border-left-width: 5px;
}
[REPLACE_CLASS_colorpickergradient] [REPLACE_CLASS_colorpickergradientcursor][REPLACE_CLASS_colorpickergradientcursoredge] ~ [REPLACE_CLASS_colorpickergradientcursor][REPLACE_CLASS_colorpickergradientcursoredge] > div::before {
	border-right-width: 5px;
	border-left-width: 0;
}
[REPLACE_CLASS_colorpickergradient] [REPLACE_CLASS_colorpickergradientcursor][REPLACE_CLASS_colorpickergradientcursorselected] > div {
	border-color: var(--header-secondary);
	width: 10px;
	height: 10px;
	margin-top: -17px;
	transform: translateX(-6px);
}
[REPLACE_CLASS_colorpickergradient] [REPLACE_CLASS_colorpickergradientcursor][REPLACE_CLASS_colorpickergradientcursorselected] > div::before {
	border-top-color: var(--header-secondary);
	transform: translateX(7px);
}
[REPLACE_CLASS_colorpickergradientbutton] {
	color: var(--interactive-normal);
	opacity: 0.6;
	margin-left: 6px;
	transition: color 200ms ease, opactity 200ms ease;
}
[REPLACE_CLASS_colorpickergradientbutton]:hover {
	color: var(--interactive-hover);
	opacity: 1;
}
[REPLACE_CLASS_colorpickergradientbutton][REPLACE_CLASS_colorpickergradientbuttonenabled],
[REPLACE_CLASS_colorpickergradientbutton][REPLACE_CLASS_colorpickergradientbuttonenabled]:hover {
	color: var(--interactive-active);
	opacity: 1;
}

[REPLACE_CLASS_layermodallarge], [REPLACE_CLASS_modalsizelarge] {
	max-height: 95vh;
}
@media only screen and (max-height: 900px) {
	[REPLACE_CLASS_layermodalmedium], [REPLACE_CLASS_modalsizemedium] {
		max-height: 75vh;
	}
}

.platform-win [REPLACE_CLASS_toasts] {
	padding-top: 22px;
}
[REPLACE_CLASS_toasts] {
	position: absolute;
	top: 10px;
	right: 10px;
	left: 10px;
	display: flex;
	flex-direction: column;
	pointer-events: none;
	z-index: 100001;
}
[REPLACE_CLASS_toasts][REPLACE_CLASS_toastsleft] {
	bottom: 10px;
	justify-content: flex-start;
	align-items: flex-start;
}
[REPLACE_CLASS_toasts][REPLACE_CLASS_toastscenter] {
	bottom: 80px;
	justify-content: flex-end;
	align-items: center;
}
[REPLACE_CLASS_toasts][REPLACE_CLASS_toastsright] {
	bottom: 10px;
	justify-content: flex-start;
	align-items: flex-end;
}
[REPLACE_CLASS_toast] {
	position: relative;
	display: flex;
	align-items: center;
	backdrop-filter: blur(5px);
	border-radius: 3px;
	box-shadow: var(--elevation-medium);
	margin-top: 10px;
	padding: 10px 10px 12px 10px;
	overflow: hidden;
	max-width: 50vw;
	min-height: 24px;
	height: unset;
	opacity: 1;
	transform: scale(1);
	transition: all 300ms ease;
}
[REPLACE_CLASS_toastclosable] {
	cursor: pointer;
	pointer-events: auto;
}
[REPLACE_CLASS_toasts][REPLACE_CLASS_toastsleft] [REPLACE_CLASS_toast] {
	min-width: 200px;
	transform-origin: left top;
}
[REPLACE_CLASS_toasts][REPLACE_CLASS_toastscenter] [REPLACE_CLASS_toast] {
	min-width: 100px;
	transform-origin: center bottom;
}
[REPLACE_CLASS_toasts][REPLACE_CLASS_toastsright] [REPLACE_CLASS_toast] {
	min-width: 200px;
	transform-origin: right top;
}
[REPLACE_CLASS_toastopening],
[REPLACE_CLASS_toastclosing] {
	opacity: 0;
	transform: scale(0);
}
[REPLACE_CLASS_toastclosing] {
	min-height: 0;
	height: 0;
}
[REPLACE_CLASS_toastbg] {
	position: absolute;
	top: 0;
	right: 0;
	bottom: 0;
	left: 0;
	opacity: 0.9;
	z-index: 1;
}
[REPLACE_CLASS_toastinner] {
	position: relative;
	display: flex;
	align-items: center;
	flex: 1 0 auto;
	z-index: 2;
}
[REPLACE_CLASS_toasticon] {
	display: flex;
	justify-content: center;
	align-items: center;
	flex: 0 0 auto;
	margin-right: 10px;
}
[REPLACE_CLASS_toastavatar] {
	width: 24px;
	height: 24px;
}
[REPLACE_CLASS_toasttext] {
	max-width: calc(50vw - 50px);
	flex: 1 0 auto;
	font-size: 14px;
	font-weight: 500;
	white-space: pre-wrap;
	word-wrap: break-word;
}
[REPLACE_CLASS_toastcloseicon] {
	display: none;
	margin-left: 6px;
}
[REPLACE_CLASS_toast]:hover [REPLACE_CLASS_toastcloseicon] {
	display: block;
}
[REPLACE_CLASS_toastbar] {
	position: absolute;
	right: 0;
	bottom: 0;
	left: 0;
	height: 4px;
	background: black;
	opacity: 0.3;
	z-index: 3;
	transition: all;
}
[REPLACE_CLASS_toastdefault] [REPLACE_CLASS_toastbar] {
	background: var(--header-primary);
}
[REPLACE_CLASS_toastbar][REPLACE_CLASS_toastcustombar] {
	opacity: 1;
}
[REPLACE_CLASS_toastdefault] [REPLACE_CLASS_toastbg] {
	background-color: var(--background-floating);
}
[REPLACE_CLASS_toastdefault] [REPLACE_CLASS_toastinner] {
	color: var(--header-primary);
}
[REPLACE_CLASS_toastbrand] [REPLACE_CLASS_toastbg] {
	background-color: var(--bdfdb-blurple);
}
[REPLACE_CLASS_toastbrand] [REPLACE_CLASS_toastinner] {
	color: #fff;
}
[REPLACE_CLASS_toastdanger] [REPLACE_CLASS_toastbg] {
	background-color: var(--bdfdb-red);
}
[REPLACE_CLASS_toastdanger] [REPLACE_CLASS_toastinner] {
	color: #fff;
}
[REPLACE_CLASS_toastinfo] [REPLACE_CLASS_toastbg] {
	background-color: #4A90E2;
}
[REPLACE_CLASS_toastinfo] [REPLACE_CLASS_toastinner] {
	color: #fff;
}
[REPLACE_CLASS_toastsuccess] [REPLACE_CLASS_toastbg] {
	background-color: var(--bdfdb-green);
}
[REPLACE_CLASS_toastsuccess] [REPLACE_CLASS_toastinner] {
	color: #fff;
}
[REPLACE_CLASS_toastwarning] [REPLACE_CLASS_toastbg] {
	background-color: var(--bdfdb-yellow);
}
[REPLACE_CLASS_toastwarning] [REPLACE_CLASS_toastinner] {
	color: #fff;
}
/**
 * @name BDFDB
 * @author DevilBro
 * @authorId 278543574059057154
 * @version 1.6.6
 * @description Required Library for DevilBro's Plugins
 * @invite Jx3TjNS
 * @donate https://www.paypal.me/MircoWittrien
 * @patreon https://www.patreon.com/MircoWittrien
 * @website https://mwittrien.github.io/
 * @source https://github.com/mwittrien/BetterDiscordAddons/tree/master/Library/
 * @updateUrl https://mwittrien.github.io/BetterDiscordAddons/Library/0BDFDB.plugin.js
 */

module.exports = (_ => {
	const BdApi = window.BdApi;
	
	const config = {
		"info": {
			"name": "BDFDB",
			"author": "DevilBro",
			"version": "1.6.6",
			"description": "Required Library for DevilBro's Plugins"
		},
		"rawUrl": `https://mwittrien.github.io/BetterDiscordAddons/Library/0BDFDB.plugin.js`,
		"changeLog": {
			"improved": {
				"Patron Badges": "All Badges will now say that they are from by BDFDB Patreon, even the T3 Custom Badges",
				"Toasts": "You can now hover Toasts to stop them from disappearing"
			},
			"fixed": {
				"Color Picker": "Copy Pasting a 6-digit HEX Color, when the alpha channel is enabled will autocomplete it to a 8-digit HEXA Color",
				"Tooltips": "Fixed some rendering Issues with Tooltips"
			}
		}
	};
	
	const DiscordObjects = {};
	const LibraryRequires = {};
	const LibraryModules = {};
	const InternalComponents = {NativeSubComponents: {}, LibraryComponents: {}};
	const Cache = {data: {}, modules: {}};
	
	var libraryInstance;
	var changeLogs = {};
	
	if (window.BDFDB_Global && window.BDFDB_Global.PluginUtils && typeof window.BDFDB_Global.PluginUtils.cleanUp == "function") {
		window.BDFDB_Global.PluginUtils.cleanUp(window.BDFDB_Global);
	}
	
	const BDFDB = {
		started: true
	};
	for (let key in config) key == "info" ? Object.assign(BDFDB, config[key]) : (BDFDB[key] = config[key]);
	
	const InternalBDFDB = Object.assign({}, BDFDB, {
		patchPriority: 0,
		settings: {},
		defaults: {
			general: {
				showToasts: {
					value: true,
					isDisabled: data => data.nativeValue,
					hasNote: data => data.disabled && data.value
				},
				showSupportBadges: {
					value: true
				},
				useChromium: {
					value: false,
					isHidden: data => !LibraryRequires.electron || !LibraryRequires.electron.remote,
					getValue: data => !data.disabled
				}
			},
			choices: {
				toastPosition: {
					value: "right",
					items: "ToastPositions"
				}
			}
		},
	});
	for (let key in InternalBDFDB.defaults) InternalBDFDB.settings[key] = {};
	
	const LibraryConstants = {
		ToastIcons: {
			info: "INFO",
			danger: "CLOSE_CIRCLE",
			success: "CHECKMARK_CIRCLE",
			warning: "WARNING"
		},
		ToastPositions: {
			center: "toastscenter",
			left: "toastsleft",
			right: "toastsright"
		}
	};
	
	const PluginStores = {
		loaded: {},
		delayed: {
			loads: [],
			starts: []
		},
		updateData: {
			plugins: {},
			timeouts: [],
			downloaded: [],
			interval: null
		},
		patchQueues: {}
	};
	const Plugin = function(config) {
		return class Plugin {
			getName () {return config.info.name;}
			getAuthor () {return config.info.author;}
			getVersion () {return config.info.version;}
			getDescription () {return config.info.description;}
			load () {
				this.loaded = true;
				this.defaults = {};
				this.labels = {};
				if (window.BDFDB_Global.loading) {
					if (!PluginStores.delayed.loads.includes(this)) PluginStores.delayed.loads.push(this);
				}
				else {
					Object.assign(this, config.info, BDFDB.ObjectUtils.exclude(config, "info"));
					BDFDB.TimeUtils.suppress(_ => {
						PluginStores.loaded[config.info.name] = this;
						BDFDB.PluginUtils.load(this);
						if (typeof this.onLoad == "function") this.onLoad();
					}, "Failed to load Plugin!", config.info)();
				}
			}
			start () {
				if (!this.loaded) this.load();
				if (window.BDFDB_Global.loading) {
					if (!PluginStores.delayed.starts.includes(this)) PluginStores.delayed.starts.push(this);
				}
				else {
					if (this.started) return;
					this.started = true;
					BDFDB.TimeUtils.suppress(_ => {
						BDFDB.PluginUtils.init(this);
						if (typeof this.onStart == "function") this.onStart();
					}, "Failed to start Plugin!", config.info)();
					delete this.stopping;
				}
			}
			stop () {
				if (this.stopping) return;
				this.stopping = true;
				BDFDB.TimeUtils.timeout(_ => {delete this.stopping;});
				
				BDFDB.TimeUtils.suppress(_ => {
					if (typeof this.onStop == "function") this.onStop();
					BDFDB.PluginUtils.clear(this);
				}, "Failed to stop Plugin!", config.info)();

				delete this.started;
			}
		};
	};

	BDFDB.LogUtils = {};
	InternalBDFDB.console = function (type, config = {}) {
		if (!console[type]) return;
		let name, version;
		if (typeof config.name == "string" && config.name) {
			name = config.name;
			version = typeof config.version == "string" ? config.version : "";
		}
		else {
			name = BDFDB.name;
			version = BDFDB.version;
		}
		console[type](...[[name && `%c[${name}]`, version && `%c(v${version})`].filter(n => n).join(" "), name && "color: #3a71c1; font-weight: 700;", version && "color: #666; font-weight: 600; font-size: 11px;", [config.strings].flat(10).filter(n => n).join(" ").trim()].filter(n => n));
	};
	BDFDB.LogUtils.log = function (strings, config = {}) {
		InternalBDFDB.console("log", Object.assign({}, config, {name: typeof config == "string" ? config : config.name, strings}));
	};
	BDFDB.LogUtils.warn = function (strings, config = {}) {
		InternalBDFDB.console("warn", Object.assign({}, config, {name: typeof config == "string" ? config : config.name, strings}));
	};
	BDFDB.LogUtils.error = function (strings, config = {}) {
		InternalBDFDB.console("error", Object.assign({}, config, {name: typeof config == "string" ? config : config.name, strings: ["Fatal Error:", strings]}));
	};

	BDFDB.TimeUtils = {};
	BDFDB.TimeUtils.interval = function (callback, delay, ...args) {
		if (typeof callback != "function" || typeof delay != "number" || delay < 1) return;
		else {
			let count = 0, interval = setInterval(_ => BDFDB.TimeUtils.suppress(callback, "Interval")(...[interval, count++, args].flat()), delay);
			return interval;
		}
	};
	BDFDB.TimeUtils.timeout = function (callback, delay, ...args) {
		delay = parseFloat(delay);
		if (typeof callback != "function") return;
		if (isNaN(delay) || typeof delay != "number" || delay < 1) {
			let immediate = setImmediate(_ => BDFDB.TimeUtils.suppress(callback, "Immediate")(...[immediate, args].flat()));
			return immediate;
		}
		else {
			let start, paused = true, timeout = {
				pause: _ => {
					if (paused) return;
					paused = true;
					BDFDB.TimeUtils.clear(timeout.timer);
					delay -= performance.now() - start;
				},
				resume: _ => {
					if (!paused) return;
					paused = false;
					start = performance.now();
					timeout.timer = setTimeout(_ => BDFDB.TimeUtils.suppress(callback, "Timeout")(...[timeout, args].flat()), delay)
				}
			};
			timeout.resume();
			return timeout;
		}
	};
	BDFDB.TimeUtils.clear = function (...timeObjects) {
		for (let t of timeObjects.flat(10).filter(n => n)) {
			t = t.timer != undefined ? t.timer : t;
			if (typeof t == "number") {
				clearInterval(t);
				clearTimeout(t);
			}
			else if (typeof t == "object") clearImmediate(t);
		}
	};
	BDFDB.TimeUtils.suppress = function (callback, strings, config) {return function (...args) {
		try {return callback(...args);}
		catch (err) {BDFDB.LogUtils.error([strings, err], config);}
	}};

	BDFDB.LogUtils.log("Loading Library");

	BDFDB.sameProto = function (a, b) {
		if (a != null && typeof a == "object") return a.constructor && a.constructor.prototype && typeof a.constructor.prototype.isPrototypeOf == "function" && a.constructor.prototype.isPrototypeOf(b);
		else return typeof a == typeof b;
	};
	BDFDB.equals = function (mainA, mainB, sorted) {
		let i = -1;
		if (sorted === undefined || typeof sorted !== "boolean") sorted = false;
		return equal(mainA, mainB);
		function equal(a, b) {
			i++;
			let result = true;
			if (i > 1000) result = null;
			else {
				if (typeof a !== typeof b) result = false;
				else if (typeof a == "function") result = a.toString() == b.toString();
				else if (typeof a === "undefined") result = true;
				else if (typeof a === "symbol") result = true;
				else if (typeof a === "boolean") result = a == b;
				else if (typeof a === "string") result = a == b;
				else if (typeof a === "number") {
					if (isNaN(a) || isNaN(b)) result = isNaN(a) == isNaN(b);
					else result = a == b;
				}
				else if (!a && !b) result = true;
				else if (!a || !b) result = false;
				else if (typeof a === "object") {
					let keysA = Object.getOwnPropertyNames(a);
					let keysB = Object.getOwnPropertyNames(b);
					if (keysA.length !== keysB.length) result = false;
					else for (let j = 0; result === true && j < keysA.length; j++) {
						if (sorted) result = equal(a[keysA[j]], b[keysB[j]]);
						else result = equal(a[keysA[j]], b[keysA[j]]);
					}
				}
			}
			i--;
			return result;
		}
	};

	BDFDB.ObjectUtils = {};
	BDFDB.ObjectUtils.is = function (obj) {
		return obj && !Array.isArray(obj) && !Set.prototype.isPrototypeOf(obj) && (typeof obj == "function" || typeof obj == "object");
	};
	BDFDB.ObjectUtils.get = function (nodeOrObj, valuePath) {
		if (!nodeOrObj || !valuePath) return null;
		let obj = Node.prototype.isPrototypeOf(nodeOrObj) ? BDFDB.ReactUtils.getInstance(nodeOrObj) : nodeOrObj;
		if (!BDFDB.ObjectUtils.is(obj)) return null;
		let found = obj, values = valuePath.split(".").filter(n => n);
		for (value of values) {
			if (!found) return null;
			found = found[value];
		}
		return found;
	};
	BDFDB.ObjectUtils.extract = function (obj, ...keys) {
		let newObj = {};
		if (BDFDB.ObjectUtils.is(obj)) for (let key of keys.flat(10).filter(n => n)) if (obj[key] != null) newObj[key] = obj[key];
		return newObj;
	};
	BDFDB.ObjectUtils.exclude = function (obj, ...keys) {
		let newObj = Object.assign({}, obj);
		BDFDB.ObjectUtils.delete(newObj, ...keys)
		return newObj;
	};
	BDFDB.ObjectUtils.delete = function (obj, ...keys) {
		if (BDFDB.ObjectUtils.is(obj)) for (let key of keys.flat(10).filter(n => n)) delete obj[key];
	};
	BDFDB.ObjectUtils.sort = function (obj, sort, except) {
		if (!BDFDB.ObjectUtils.is(obj)) return {};
		let newObj = {};
		if (sort === undefined || !sort) for (let key of Object.keys(obj).sort()) newObj[key] = obj[key];
		else {
			let values = [];
			for (let key in obj) values.push(obj[key]);
			values = BDFDB.ArrayUtils.keySort(values, sort, except);
			for (let value of values) for (let key in obj) if (BDFDB.equals(value, obj[key])) {
				newObj[key] = value;
				break;
			}
		}
		return newObj;
	};
	BDFDB.ObjectUtils.group = function (obj, key) {
		if (!BDFDB.ObjectUtils.is(obj)) return {};
		if (typeof key != "string") return obj;
		return Object.entries(obj).reduce((newObj, objPair) => {
			if (!newObj[objPair[1][key]]) newObj[objPair[1][key]] = {};
			newObj[objPair[1][key]][objPair[0]] = objPair[1];
			return newObj;
		}, {});
	};
	BDFDB.ObjectUtils.reverse = function (obj, sort) {
		if (!BDFDB.ObjectUtils.is(obj)) return {};
		let newObj = {};
		for (let key of (sort === undefined || !sort) ? Object.keys(obj).reverse() : Object.keys(obj).sort().reverse()) newObj[key] = obj[key];
		return newObj;
	};
	BDFDB.ObjectUtils.filter = function (obj, filter, byKey = false) {
		if (!BDFDB.ObjectUtils.is(obj)) return {};
		if (typeof filter != "function") return obj;
		return Object.keys(obj).filter(key => filter(byKey ? key : obj[key])).reduce((newObj, key) => (newObj[key] = obj[key], newObj), {});
	};
	BDFDB.ObjectUtils.push = function (obj, value) {
		if (BDFDB.ObjectUtils.is(obj)) obj[Object.keys(obj).length] = value;
	};
	BDFDB.ObjectUtils.pop = function (obj, value) {
		if (BDFDB.ObjectUtils.is(obj)) {
			let keys = Object.keys(obj);
			if (!keys.length) return;
			let value = obj[keys[keys.length-1]];
			delete obj[keys[keys.length-1]];
			return value;
		}
	};
	BDFDB.ObjectUtils.map = function (obj, mapFunc) {
		if (!BDFDB.ObjectUtils.is(obj)) return {};
		if (typeof mapFunc != "string" && typeof mapFunc != "function") return obj;
		let newObj = {};
		for (let key in obj) if (BDFDB.ObjectUtils.is(obj[key])) newObj[key] = typeof mapFunc == "string" ? obj[key][mapFunc] : mapFunc(obj[key], key);
		return newObj;
	};
	BDFDB.ObjectUtils.toArray = function (obj) {
		if (!BDFDB.ObjectUtils.is(obj)) return [];
		return Object.entries(obj).map(n => n[1]);
	};
	BDFDB.ObjectUtils.deepAssign = function (obj, ...objs) {
		if (!objs.length) return obj;
		let nextObj = objs.shift();
		if (BDFDB.ObjectUtils.is(obj) && BDFDB.ObjectUtils.is(nextObj)) {
			for (let key in nextObj) {
				if (BDFDB.ObjectUtils.is(nextObj[key])) {
					if (!obj[key]) Object.assign(obj, {[key]:{}});
					BDFDB.ObjectUtils.deepAssign(obj[key], nextObj[key]);
				}
				else Object.assign(obj, {[key]:nextObj[key]});
			}
		}
		return BDFDB.ObjectUtils.deepAssign(obj, ...objs);
	};
	BDFDB.ObjectUtils.isEmpty = function (obj) {
		return !BDFDB.ObjectUtils.is(obj) || Object.getOwnPropertyNames(obj).length == 0;
	};
	BDFDB.ObjectUtils.mirror = function (obj) {
		if (!BDFDB.ObjectUtils.is(obj)) return {};
		let newObj = Object.assign({}, obj);
		for (let key in newObj) if (newObj[newObj[key]] == undefined && (typeof key == "number" || typeof key == "string")) newObj[newObj[key]] = key;
		return newObj;
	};

	BDFDB.ArrayUtils = {};
	BDFDB.ArrayUtils.is = function (array) {
		return array && Array.isArray(array);
	};
	BDFDB.ArrayUtils.sum = function (array) {
		return Array.isArray(array) ? array.reduce((total, num) => total + Math.round(num), 0) : 0;
	};
	BDFDB.ArrayUtils.keySort = function (array, key, except) {
		if (!BDFDB.ArrayUtils.is(array)) return [];
		if (key == null) return array;
		if (except === undefined) except = null;
		return array.sort((x, y) => {
			let xValue = x[key], yValue = y[key];
			if (xValue !== except) return xValue < yValue ? -1 : xValue > yValue ? 1 : 0;
		});
	};
	BDFDB.ArrayUtils.numSort = function (array) {
		return array.sort((x, y) => (x < y ? -1 : x > y ? 1 : 0));
	};
	BDFDB.ArrayUtils.includes = function (array, ...values) {
		if (!BDFDB.ArrayUtils.is(array)) return null;
		if (!array.length) return false;
		let all = values.pop();
		if (typeof all != "boolean") {
			values.push(all);
			all = true;
		}
		if (!values.length) return false;
		let contained = undefined;
		for (let v of values) {
			if (contained === undefined) contained = all;
			if (all && !array.includes(v)) contained = false;
			if (!all && array.includes(v)) contained = true;
		}
		return contained;
	};
	BDFDB.ArrayUtils.remove = function (array, value, all = false) {
		if (!BDFDB.ArrayUtils.is(array)) return [];
		if (!array.includes(value)) return array;
		if (!all) array.splice(array.indexOf(value), 1);
		else while (array.indexOf(value) > -1) array.splice(array.indexOf(value), 1);
		return array;
	};
	BDFDB.ArrayUtils.getAllIndexes = function (array, value) {
		if (!BDFDB.ArrayUtils.is(array) && typeof array != "string") return [];
		var indexes = [], index = -1;
		while ((index = array.indexOf(value, index + 1)) !== -1) indexes.push(index);
		return indexes;
	};
	BDFDB.ArrayUtils.removeCopies = function (array) {
		if (!BDFDB.ArrayUtils.is(array)) return [];
		return [...new Set(array)];
	};

	BDFDB.BDUtils = {};
	BDFDB.BDUtils.getPluginsFolder = function () {
		if (BdApi && BdApi.Plugins && BdApi.Plugins.folder && typeof BdApi.Plugins.folder == "string") return BdApi.Plugins.folder;
		else if (LibraryRequires.process.env.BETTERDISCORD_DATA_PATH) return LibraryRequires.path.resolve(LibraryRequires.process.env.BETTERDISCORD_DATA_PATH, "plugins/");
		else if (LibraryRequires.process.env.injDir) return LibraryRequires.path.resolve(LibraryRequires.process.env.injDir, "plugins/");
		else switch (LibraryRequires.process.platform) {
			case "win32":
				return LibraryRequires.path.resolve(LibraryRequires.process.env.appdata, "BetterDiscord/plugins/");
			case "darwin":
				return LibraryRequires.path.resolve(LibraryRequires.process.env.HOME, "Library/Preferences/BetterDiscord/plugins/");
			default:
				if (LibraryRequires.process.env.XDG_CONFIG_HOME) return LibraryRequires.path.resolve(LibraryRequires.process.env.XDG_CONFIG_HOME, "BetterDiscord/plugins/");
				else return LibraryRequires.path.resolve(LibraryRequires.process.env.HOME, ".config/BetterDiscord/plugins/");
			}
	};
	BDFDB.BDUtils.getThemesFolder = function () {
		if (BdApi && BdApi.Themes && BdApi.Themes.folder && typeof BdApi.Themes.folder == "string") return BdApi.Themes.folder;
		else if (LibraryRequires.process.env.BETTERDISCORD_DATA_PATH) return LibraryRequires.path.resolve(LibraryRequires.process.env.BETTERDISCORD_DATA_PATH, "themes/");
		else if (LibraryRequires.process.env.injDir) return LibraryRequires.path.resolve(LibraryRequires.process.env.injDir, "plugins/");
		else switch (LibraryRequires.process.platform) {
			case "win32": 
				return LibraryRequires.path.resolve(LibraryRequires.process.env.appdata, "BetterDiscord/themes/");
			case "darwin": 
				return LibraryRequires.path.resolve(LibraryRequires.process.env.HOME, "Library/Preferences/BetterDiscord/themes/");
			default:
				if (LibraryRequires.process.env.XDG_CONFIG_HOME) return LibraryRequires.path.resolve(LibraryRequires.process.env.XDG_CONFIG_HOME, "BetterDiscord/themes/");
				else return LibraryRequires.path.resolve(LibraryRequires.process.env.HOME, ".config/BetterDiscord/themes/");
			}
	};
	BDFDB.BDUtils.isPluginEnabled = function (pluginName) {
		if (!BdApi) return null;
		else if (BdApi.Plugins && typeof BdApi.Plugins.isEnabled == "function") return BdApi.Plugins.isEnabled(pluginName);
		else if (typeof BdApi.isPluginEnabled == "function") return BdApi.isPluginEnabled(pluginName);
	};
	BDFDB.BDUtils.reloadPlugin = function (pluginName) {
		if (!BdApi) return;
		else if (BdApi.Plugins && typeof BdApi.Plugins.reload == "function") BdApi.Plugins.reload(pluginName);
		else if (window.pluginModule) window.pluginModule.reloadPlugin(pluginName);
	};
	BDFDB.BDUtils.enablePlugin = function (pluginName) {
		if (!BdApi) return;
		else if (BdApi.Plugins && typeof BdApi.Plugins.enable == "function") BdApi.Plugins.enable(pluginName);
		else if (window.pluginModule) window.pluginModule.startPlugin(pluginName);
	};
	BDFDB.BDUtils.disablePlugin = function (pluginName) {
		if (!BdApi) return;
		else if (BdApi.Plugins && typeof BdApi.Plugins.disable == "function") BdApi.Plugins.disable(pluginName);
		else if (window.pluginModule) window.pluginModule.stopPlugin(pluginName);
	};
	BDFDB.BDUtils.getPlugin = function (pluginName, hasToBeEnabled = false, overHead = false) {
		if (BdApi && !hasToBeEnabled || BDFDB.BDUtils.isPluginEnabled(pluginName)) {	
			if (BdApi.Plugins && typeof BdApi.Plugins.get == "function") {
				let plugin = BdApi.Plugins.get(pluginName);
				if (!plugin) return null;
				if (overHead) return plugin.filename && plugin.exports && plugin.instance ? plugin : {filename: LibraryRequires.fs.existsSync(LibraryRequires.path.join(BDFDB.BDUtils.getPluginsFolder(), `${pluginName}.plugin.js`)) ? `${pluginName}.plugin.js` : null, id: pluginName, name: pluginName, plugin: plugin};
				else return plugin.filename && plugin.exports && plugin.instance ? plugin.instance : plugin;
			}
			else if (window.bdplugins) overHead ? window.bdplugins[pluginName] : (window.bdplugins[pluginName] || {}).plugin;
		}
		return null;
	};
	BDFDB.BDUtils.isThemeEnabled = function (themeName) {
		if (!BdApi) return null;
		else if (BdApi.Themes && typeof BdApi.Themes.isEnabled == "function") return BdApi.Themes.isEnabled(themeName);
		else if (typeof BdApi.isThemeEnabled == "function") return BdApi.isThemeEnabled(themeName);
	};
	BDFDB.BDUtils.enableTheme = function (themeName) {
		if (!BdApi) return;
		else if (BdApi.Themes && typeof BdApi.Themes.enable == "function") BdApi.Themes.enable(themeName);
		else if (window.themeModule) window.themeModule.enableTheme(themeName);
	};
	BDFDB.BDUtils.disableTheme = function (themeName) {
		if (!BdApi) return;
		else if (BdApi.Themes && typeof BdApi.Themes.disable == "function") BdApi.Themes.disable(themeName);
		else if (window.themeModule) window.themeModule.disableTheme(themeName);
	};
	BDFDB.BDUtils.getTheme = function (themeName, hasToBeEnabled = false) {
		if (BdApi && !hasToBeEnabled || BDFDB.BDUtils.isThemeEnabled(themeName)) {
			if (BdApi.Themes && typeof BdApi.Themes.get == "function") return BdApi.Themes.get(themeName);
			else if (window.bdthemes) window.bdthemes[themeName];
		}
		return null;
	};
	BDFDB.BDUtils.settingsIds = {
		automaticLoading: "settings.addons.autoReload",
		coloredText: "settings.appearance.coloredText",
		normalizedClasses: "settings.general.classNormalizer",
		showToasts: "settings.general.showToasts"
	};
	BDFDB.BDUtils.toggleSettings = function (key, state) {
		if (BdApi && typeof key == "string") {
			let path = key.split(".");
			let currentState = BDFDB.BDUtils.getSettings(key);
			if (state === true) {
				if (currentState === false && typeof BdApi.enableSetting == "function") BdApi.enableSetting(...path);
			}
			else if (state === false) {
				if (currentState === true && typeof BdApi.disableSetting == "function") BdApi.disableSetting(...path);
			}
			else if (currentState === true || currentState === false) BDFDB.BDUtils.toggleSettings(key, !currentState);
		}
	};
	BDFDB.BDUtils.getSettings = function (key) {
		if (!BdApi) return {};
		if (typeof key == "string") return typeof BdApi.isSettingEnabled == "function" && BdApi.isSettingEnabled(...key.split("."));
		else return BDFDB.ArrayUtils.is(BdApi.settings) ? BdApi.settings.map(n => n.settings.map(m => m.settings.map(l => ({id: [n.id, m.id, l.id].join("."), value: l.value})))).flat(10).reduce((newObj, setting) => (newObj[setting.id] = setting.value, newObj), {}) : {};
	};
	BDFDB.BDUtils.getSettingsProperty = function (property, key) {
		if (!BdApi || !BDFDB.ArrayUtils.is(BdApi.settings)) return key ? "" : {};
		else {
			let settingsMap = BdApi.settings.map(n => n.settings.map(m => m.settings.map(l => ({id: [n.id, m.id, l.id].join("."), value: l[property]})))).flat(10).reduce((newObj, setting) => (newObj[setting.id] = setting.value, newObj), {});
			return key ? (settingsMap[key] != null ? settingsMap[key] : "") : "";
		}
	};
	
	
	BDFDB.PluginUtils = {};
	BDFDB.PluginUtils.buildPlugin = function (config) {
		return [Plugin(config), BDFDB];
	};
	BDFDB.PluginUtils.load = function (plugin) {
		if (!PluginStores.updateData.timeouts.includes(plugin.name)) {
			PluginStores.updateData.timeouts.push(plugin.name);
			const url = InternalBDFDB.getPluginURL(plugin);

			PluginStores.updateData.plugins[url] = {name: plugin.name, raw: url, version: plugin.version};
			
			BDFDB.PluginUtils.checkUpdate(plugin.name, url);
			
			if (!PluginStores.updateData.interval) PluginStores.updateData.interval = BDFDB.TimeUtils.interval(_ => {
				BDFDB.PluginUtils.checkAllUpdates();
			}, 1000*60*60*4);
			
			BDFDB.TimeUtils.timeout(_ => {BDFDB.ArrayUtils.remove(PluginStores.updateData.timeouts, plugin.name, true);}, 30000);
		}
	};
	BDFDB.PluginUtils.init = function (plugin) {
		BDFDB.PluginUtils.load(plugin);
		
		plugin.settings = BDFDB.DataUtils.get(plugin);
		
		BDFDB.LogUtils.log(BDFDB.LanguageUtils.LibraryStringsFormat("toast_plugin_started", ""), plugin);
		if (InternalBDFDB.settings.general.showToasts && !BDFDB.BDUtils.getSettings(BDFDB.BDUtils.settingsIds.showToasts)) BDFDB.NotificationUtils.toast(BDFDB.LanguageUtils.LibraryStringsFormat("toast_plugin_started", `${plugin.name} v${plugin.version}`), {
			disableInteractions: true,
			barColor: BDFDB.DiscordConstants.Colors.STATUS_GREEN
		});
		
		if (plugin.css) BDFDB.DOMUtils.appendLocalStyle(plugin.name, plugin.css);
		
		InternalBDFDB.patchPlugin(plugin);
		InternalBDFDB.addSpecialListeners(plugin);

		BDFDB.PluginUtils.translate(plugin);

		BDFDB.PluginUtils.checkChangeLog(plugin);
	};
	BDFDB.PluginUtils.clear = function (plugin) {
		BDFDB.LogUtils.log(BDFDB.LanguageUtils.LibraryStringsFormat("toast_plugin_stopped", ""), plugin);
		if (InternalBDFDB.settings.general.showToasts && !BDFDB.BDUtils.getSettings(BDFDB.BDUtils.settingsIds.showToasts)) BDFDB.NotificationUtils.toast(BDFDB.LanguageUtils.LibraryStringsFormat("toast_plugin_stopped", `${plugin.name} v${plugin.version}`), {
			disableInteractions: true,
			barColor: BDFDB.DiscordConstants.Colors.STATUS_RED
		});
		
		const url = InternalBDFDB.getPluginURL(plugin);

		BDFDB.PluginUtils.cleanUp(plugin);
		
		for (const type in PluginStores.patchQueues) BDFDB.ArrayUtils.remove(PluginStores.patchQueues[type].query, plugin, true);
		
		for (const modal of document.querySelectorAll(`.${plugin.name}-modal, .${plugin.name.toLowerCase()}-modal, .${plugin.name}-settingsmodal, .${plugin.name.toLowerCase()}-settingsmodal`)) {
			const closeButton = modal.querySelector(BDFDB.dotCN.modalclose);
			if (closeButton) closeButton.click();
		}
		
		delete Cache.data[plugin.name]
		delete PluginStores.updateData.plugins[url];
	};
	BDFDB.PluginUtils.translate = function (plugin) {
		if (typeof plugin.setLabelsByLanguage == "function" || typeof plugin.changeLanguageStrings == "function") {
			const translate = _ => {
				if (typeof plugin.setLabelsByLanguage == "function") plugin.labels = plugin.setLabelsByLanguage();
				if (typeof plugin.changeLanguageStrings == "function") plugin.changeLanguageStrings();
			};
			if (LibraryModules.LanguageStore.chosenLocale) translate();
			else BDFDB.TimeUtils.interval(interval => {
				if (LibraryModules.LanguageStore.chosenLocale) {
					BDFDB.TimeUtils.clear(interval);
					translate();
				}
			}, 100);
		}
	};
	BDFDB.PluginUtils.cleanUp = function (plugin) {
		BDFDB.TimeUtils.suppress(_ => {
			if (!BDFDB.ObjectUtils.is(plugin)) return;
			if (plugin == window.BDFDB_Global) {
				let updateNotice = BDFDB.dotCN && document.querySelector(BDFDB.dotCN.noticeupdate);
				if (updateNotice) updateNotice.close();
				BDFDB.TimeUtils.clear(PluginStores && PluginStores.updateData && PluginStores.updateData.interval);
				delete window.BDFDB_Global.loaded;
				if (PluginStores) BDFDB.TimeUtils.interval((interval, count) => {
					if (count > 60 || window.BDFDB_Global.loaded) BDFDB.TimeUtils.clear(interval);
					if (window.BDFDB_Global.loaded) for (let pluginName in BDFDB.ObjectUtils.sort(PluginStores.loaded)) BDFDB.TimeUtils.timeout(_ => {
						if (PluginStores.loaded[pluginName].started) BDFDB.BDUtils.reloadPlugin(pluginName);
					});
				}, 1000);
			}
			if (BDFDB.DOMUtils) BDFDB.DOMUtils.removeLocalStyle(plugin.name);
			if (BDFDB.ListenerUtils) BDFDB.ListenerUtils.remove(plugin);
			if (BDFDB.StoreChangeUtils) BDFDB.StoreChangeUtils.remove(plugin);
			if (BDFDB.ObserverUtils) BDFDB.ObserverUtils.disconnect(plugin);
			if (BDFDB.PatchUtils) BDFDB.PatchUtils.unpatch(plugin);
			if (BDFDB.WindowUtils) {
				BDFDB.WindowUtils.closeAll(plugin);
				BDFDB.WindowUtils.removeListener(plugin);
			}
		}, "Failed to clean up Plugin!", plugin)();
	};
	BDFDB.PluginUtils.checkUpdate = function (pluginName, url) {
		if (pluginName && url && PluginStores.updateData.plugins[url]) return new Promise(callback => {
			LibraryRequires.request(url, (error, response, body) => {
				if (error || !PluginStores.updateData.plugins[url]) return callback(null);
				let newName = (body.match(/"name"\s*:\s*"([^"]+)"/) || [])[1] || pluginName;
				let newVersion = (body.match(/@version ([0-9]+\.[0-9]+\.[0-9]+)|['"]([0-9]+\.[0-9]+\.[0-9]+)['"]/i) || []).filter(n => n)[1];
				if (!newVersion) return callback(null);
				if (pluginName == newName && BDFDB.NumberUtils.getVersionDifference(newVersion, PluginStores.updateData.plugins[url].version) > 0.2) {
					BDFDB.NotificationUtils.toast(BDFDB.LanguageUtils.LibraryStringsFormat("toast_plugin_force_updated", pluginName), {
						type: "warning",
						disableInteractions: true
					});
					BDFDB.PluginUtils.downloadUpdate(pluginName, url);
					return callback(2);
				}
				else if (BDFDB.NumberUtils.compareVersions(newVersion, PluginStores.updateData.plugins[url].version)) {
					if (PluginStores.updateData.plugins[url]) PluginStores.updateData.plugins[url].outdated = true;
					BDFDB.PluginUtils.showUpdateNotice(pluginName, url);
					return callback(1);
				}
				else {
					BDFDB.PluginUtils.removeUpdateNotice(pluginName);
					return callback(0);
				}
			});
		});
		return new Promise(callback => {callback(null);});
	};
	BDFDB.PluginUtils.checkAllUpdates = function () {
		return new Promise(callback => {
			let finished = 0, amount = 0;
			for (let url in PluginStores.updateData.plugins) {
				let plugin = PluginStores.updateData.plugins[url];
				if (plugin) BDFDB.PluginUtils.checkUpdate(plugin.name, plugin.raw).then(state => {
					finished++;
					if (state == 1) amount++;
					if (finished >= Object.keys(PluginStores.updateData.plugins).length) callback(amount);
				});
			}
		});
	};
	BDFDB.PluginUtils.hasUpdateCheck = function (url) {
		if (!url || typeof url != "string") return false;
		let updateStore = Object.assign({}, window.PluginUpdates && window.PluginUpdates.plugins, PluginStores.updateData.plugins);
		if (updateStore[url]) return true;
		else {
			let temp = url.replace("//raw.githubusercontent.com", "//").split("/");
			let gitName = temp.splice(3, 1);
			temp.splice(4, 1);
			temp.splice(2, 1, gitName + ".github.io");
			let pagesUrl = temp.join("/");
			return !!updateStore[pagesUrl];
		}
	};
	BDFDB.PluginUtils.showUpdateNotice = function (pluginName, url) {
		if (!pluginName || !url) return;
		let updateNotice = document.querySelector(BDFDB.dotCN.noticeupdate);
		if (!updateNotice) {
			let vanishObserver = new MutationObserver(changes => {
				if (!document.contains(updateNotice)) {
					if (updateNotice.querySelector(BDFDB.dotCN.noticeupdateentry)) {
						let layers = document.querySelector(BDFDB.dotCN.layers) || document.querySelector(BDFDB.dotCN.appmount);
						if (layers) layers.parentElement.insertBefore(updateNotice, layers);
					}
					else vanishObserver.disconnect();
				}
				else if (document.contains(updateNotice) && !updateNotice.querySelector(BDFDB.dotCNC.noticeupdateentry + BDFDB.dotCN.noticebutton)) vanishObserver.disconnect();
			});
			vanishObserver.observe(document.body, {childList: true, subtree: true});
			updateNotice = BDFDB.NotificationUtils.notice(`${BDFDB.LanguageUtils.LibraryStrings.update_notice_update}&nbsp;&nbsp;&nbsp;&nbsp;<div class="${BDFDB.disCN.noticeupdateentries}"></div>`, {
				type: "info",
				className: BDFDB.disCN.noticeupdate,
				html: true,
				forceStyle: true,
				customIcon: `<svg width="24" height="24" viewBox="0 0 24 24"><path fill="currentColor" d="M 15.46875 0.859375 C 15.772992 1.030675 16.059675 1.2229406 16.326172 1.4316406 C 17.134815 2.0640406 17.768634 2.8677594 18.208984 3.8183594 C 18.665347 4.8050594 18.913286 5.9512625 18.945312 7.2265625 L 18.945312 7.2421875 L 18.945312 7.2597656 L 18.945312 16.753906 L 18.945312 16.769531 L 18.945312 16.785156 C 18.914433 18.060356 18.666491 19.206759 18.208984 20.193359 C 17.768634 21.144059 17.135961 21.947578 16.326172 22.580078 C 16.06768 22.782278 15.790044 22.967366 15.496094 23.134766 L 16.326172 23.134766 C 20.285895 23.158766 24 20.930212 24 15.820312 L 24 8.3535156 C 24.021728 3.1431156 20.305428 0.86132812 16.345703 0.86132812 L 15.46875 0.859375 z M 0 0.8671875 L 0 10.064453 L 4.4492188 15.191406 L 4.4492188 5.4394531 L 8.4394531 5.4394531 C 11.753741 5.4394531 11.753741 9.8828125 8.4394531 9.8828125 L 7.0234375 9.8828125 L 7.0234375 14.126953 L 8.4394531 14.126953 C 11.753741 14.126953 11.753741 18.568359 8.4394531 18.568359 L 0 18.568359 L 0 23.138672 L 8.3457031 23.138672 C 12.647637 23.138672 15.987145 21.3021 16.105469 16.75 C 16.105469 14.6555 15.567688 13.090453 14.621094 12.001953 C 15.567688 10.914853 16.105469 9.3502594 16.105469 7.2558594 C 15.988351 2.7036594 12.648845 0.8671875 8.3457031 0.8671875 L 0 0.8671875 z"/></svg>`,
				buttons: !BDFDB.BDUtils.getSettings(BDFDB.BDUtils.settingsIds.automaticLoading) && [{
					className: BDFDB.disCN.noticeupdatebuttonreload,
					contents: BDFDB.LanguageUtils.LanguageStrings.ERRORS_RELOAD,
					onClick: _ => location.reload(),
					onMouseEnter: _ => {
						if (PluginStores.updateData.downloaded) BDFDB.TooltipUtils.create(reloadButton, PluginStores.updateData.downloaded.join(", "), {
							type: "bottom",
							style: "max-width: 420px"
						});
					}
				}],
				buttons: [{
					className: BDFDB.disCN.noticeupdatebuttonall,
					contents: BDFDB.LanguageUtils.LanguageStrings.FORM_LABEL_ALL,
					onClick: _ => {for (let notice of updateNotice.querySelectorAll(BDFDB.dotCN.noticeupdateentry)) notice.click();}
				}],
				onClose: _ => {vanishObserver.disconnect();}
			});
			updateNotice.style.setProperty("position", "relative", "important");
			updateNotice.style.setProperty("visibility", "visible", "important");
			updateNotice.style.setProperty("opacity", "1", "important");
			updateNotice.style.setProperty("z-index", "100000", "important");
			let reloadButton = updateNotice.querySelector(BDFDB.dotCN.noticeupdatebuttonreload);
			if (reloadButton) BDFDB.DOMUtils.hide(reloadButton);
		}
		if (updateNotice) {
			let updateNoticeList = updateNotice.querySelector(BDFDB.dotCN.noticeupdateentries);
			if (updateNoticeList && !updateNoticeList.querySelector(`#${pluginName}-notice`)) {
				if (updateNoticeList.childElementCount) updateNoticeList.appendChild(BDFDB.DOMUtils.create(`<div class="${BDFDB.disCN.noticeupdateseparator}">, </div>`));
				let updateEntry = BDFDB.DOMUtils.create(`<div class="${BDFDB.disCN.noticeupdateentry}" id="${pluginName}-notice">${pluginName}</div>`);
				updateEntry.addEventListener("click", _ => {
					if (!updateEntry.wasClicked) {
						updateEntry.wasClicked = true;
						BDFDB.PluginUtils.downloadUpdate(pluginName, url);
					}
				});
				updateNoticeList.appendChild(updateEntry);
				if (!updateNoticeList.hasTooltip) {
					updateNoticeList.hasTooltip = true;
					updateNotice.tooltip = BDFDB.TooltipUtils.create(updateNoticeList, BDFDB.LanguageUtils.LibraryStrings.update_notice_click, {
						type: "bottom",
						zIndex: 100001,
						delay: 500,
						onHide: _ => {updateNoticeList.hasTooltip = false;}
					});
				}
			}
		}
	};
	BDFDB.PluginUtils.removeUpdateNotice = function (pluginName, updateNotice = document.querySelector(BDFDB.dotCN.noticeupdate)) {
		if (!pluginName || !updateNotice) return;
		let updateNoticeList = updateNotice.querySelector(BDFDB.dotCN.noticeupdateentries);
		if (updateNoticeList) {
			let noticeEntry = updateNoticeList.querySelector(`#${pluginName}-notice`);
			if (noticeEntry) {
				let nextSibling = noticeEntry.nextSibling;
				let prevSibling = noticeEntry.prevSibling;
				if (nextSibling && BDFDB.DOMUtils.containsClass(nextSibling, BDFDB.disCN.noticeupdateseparator)) nextSibling.remove();
				else if (prevSibling && BDFDB.DOMUtils.containsClass(prevSibling, BDFDB.disCN.noticeupdateseparator)) prevSibling.remove();
				noticeEntry.remove();
			}
			if (!updateNoticeList.childElementCount) {
				let reloadButton = updateNotice.querySelector(BDFDB.dotCN.noticeupdatebuttonreload);
				if (reloadButton) {
					updateNotice.querySelector(BDFDB.dotCN.noticetext).innerText = BDFDB.LanguageUtils.LibraryStrings.update_notice_reload;
					BDFDB.DOMUtils.show(reloadButton);
				}
				else updateNotice.querySelector(BDFDB.dotCN.noticedismiss).click();
			}
		}
	};
	BDFDB.PluginUtils.downloadUpdate = function (pluginName, url) {
		if (pluginName && url) LibraryRequires.request(url, (error, response, body) => {
			if (error) {
				BDFDB.PluginUtils.removeUpdateNotice(pluginName);
				BDFDB.NotificationUtils.toast(BDFDB.LanguageUtils.LibraryStringsFormat("toast_plugin_update_failed", pluginName), {
					type: "danger",
					disableInteractions: true
				});
			}
			else {
				let wasEnabled = BDFDB.BDUtils.isPluginEnabled(pluginName);
				let newName = (body.match(/"name"\s*:\s*"([^"]+)"/) || [])[1] || pluginName;
				let newVersion = (body.match(/@version ([0-9]+\.[0-9]+\.[0-9]+)|['"]([0-9]+\.[0-9]+\.[0-9]+)['"]/i) || []).filter(n => n)[1];
				let oldVersion = PluginStores.updateData.plugins[url].version;
				let fileName = pluginName == "BDFDB" ? "0BDFDB" : pluginName;
				let newFileName = newName == "BDFDB" ? "0BDFDB" : newName;
				LibraryRequires.fs.writeFile(LibraryRequires.path.join(BDFDB.BDUtils.getPluginsFolder(), newFileName + ".plugin.js"), body, _ => {
					if (PluginStores.updateData.plugins[url]) PluginStores.updateData.plugins[url].version = newVersion;
					if (fileName != newFileName) {
						LibraryRequires.fs.unlink(LibraryRequires.path.join(BDFDB.BDUtils.getPluginsFolder(), fileName + ".plugin.js"), _ => {});
						let configPath = LibraryRequires.path.join(BDFDB.BDUtils.getPluginsFolder(), fileName + ".config.json");
						LibraryRequires.fs.exists(configPath, exists => {
							if (exists) LibraryRequires.fs.rename(configPath, LibraryRequires.path.join(BDFDB.BDUtils.getPluginsFolder(), newFileName + ".config.json"), _ => {});
						});
						BDFDB.TimeUtils.timeout(_ => {if (wasEnabled && !BDFDB.BDUtils.isPluginEnabled(newName)) BDFDB.BDUtils.enablePlugin(newName);}, 3000);
					}
					BDFDB.NotificationUtils.toast(BDFDB.LanguageUtils.LibraryStringsFormat("toast_plugin_updated", pluginName, "v" + oldVersion, newName, "v" + newVersion), {
						disableInteractions: true
					});
					let updateNotice = document.querySelector(BDFDB.dotCN.noticeupdate);
					if (updateNotice) {
						if (updateNotice.querySelector(BDFDB.dotCN.noticebutton) && !PluginStores.updateData.downloaded.includes(pluginName)) {
							PluginStores.updateData.downloaded.push(pluginName);
						}
						BDFDB.PluginUtils.removeUpdateNotice(pluginName, updateNotice);
					}
				});
			}
		});
	};
	BDFDB.PluginUtils.checkChangeLog = function (plugin) {
		if (!BDFDB.ObjectUtils.is(plugin) || !BDFDB.ObjectUtils.is(plugin.changeLog)) return;
		if (!changeLogs[plugin.name] || BDFDB.NumberUtils.compareVersions(plugin.version, changeLogs[plugin.name])) {
			changeLogs[plugin.name] = plugin.version;
			BDFDB.DataUtils.save(changeLogs, BDFDB, "changeLogs");
			BDFDB.PluginUtils.openChangeLog(plugin);
		}
	};
	BDFDB.PluginUtils.openChangeLog = function (plugin) {
		if (!BDFDB.ObjectUtils.is(plugin) || !BDFDB.ObjectUtils.is(plugin.changeLog)) return;
		let changeLogHTML = "", headers = {
			added: "New Features",
			fixed: "Bug Fixes",
			improved: "Improvements",
			progress: "Progress"
		};
		for (let type in plugin.changeLog) {
			type = type.toLowerCase();
			let className = BDFDB.disCN["changelog" + type];
			if (className) {
				changeLogHTML += `<h1 class="${className} ${BDFDB.disCN.margintop20}"${changeLogHTML.indexOf("<h1") == -1 ? `style="margin-top: 0px !important;"` : ""}>${BDFDB.LanguageUtils && BDFDB.LanguageUtils.LibraryStrings ? BDFDB.LanguageUtils.LibraryStrings["changelog_" + type]  : headers[type]}</h1><ul>`;
				for (let key in plugin.changeLog[type]) changeLogHTML += `<li><strong>${key}</strong>${plugin.changeLog[type][key] ? (": " + plugin.changeLog[type][key] + ".") : ""}</li>`;
				changeLogHTML += `</ul>`
			}
		}
		if (changeLogHTML) BDFDB.ModalUtils.open(plugin, {
			header: `${plugin.name} ${BDFDB.LanguageUtils.LanguageStrings.CHANGE_LOG}`,
			subHeader: `Version ${plugin.version}`,
			className: BDFDB.disCN.modalchangelogmodal,
			contentClassName: BDFDB.disCNS.changelogcontainer + BDFDB.disCN.modalminicontent,
			footerDirection: InternalComponents.LibraryComponents.Flex.Direction.HORIZONTAL,
			children: BDFDB.ReactUtils.elementToReact(BDFDB.DOMUtils.create(changeLogHTML)),
			footerChildren: (plugin == BDFDB || plugin == libraryInstance || PluginStores.loaded[plugin.name] && PluginStores.loaded[plugin.name] == plugin && plugin.author == "DevilBro") && BDFDB.ReactUtils.createElement("div", {
				className: BDFDB.disCN.changelogfooter,
				children: [
					{href: "https://www.paypal.me/MircoWittrien", name: "PayPal", icon: "PAYPAL"},
					{href: "https://www.patreon.com/MircoWittrien", name: "Patreon", icon: "PATREON"}
				].map(data => BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Anchor, {
					className: BDFDB.disCN.changelogsociallink,
					href: data.href,
					children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TooltipContainer, {
						text: data.name,
						children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SvgIcon, {
							name: InternalComponents.LibraryComponents.SvgIcon.Names[data.icon],
							width: 16,
							height: 16
						})
					})
				})).concat(BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TextElement, {
					size: InternalComponents.LibraryComponents.TextElement.Sizes.SIZE_12,
					children: BDFDB.LanguageUtils.LibraryStrings.donate_message
				}))
			})
		});
	};
	BDFDB.PluginUtils.addLoadingIcon = function (icon) {
		if (!Node.prototype.isPrototypeOf(icon)) return;
		let app = document.querySelector(BDFDB.dotCN.app);
		if (!app) return;
		BDFDB.DOMUtils.addClass(icon, BDFDB.disCN.loadingicon);
		let loadingIconWrapper = document.querySelector(BDFDB.dotCN.app + ">" + BDFDB.dotCN.loadingiconwrapper)
		if (!loadingIconWrapper) {
			loadingIconWrapper = BDFDB.DOMUtils.create(`<div class="${BDFDB.disCN.loadingiconwrapper}"></div>`);
			app.appendChild(loadingIconWrapper);
			let killObserver = new MutationObserver(changes => {if (!loadingIconWrapper.firstElementChild) BDFDB.DOMUtils.remove(loadingIconWrapper);});
			killObserver.observe(loadingIconWrapper, {childList: true});
		}
		loadingIconWrapper.appendChild(icon);
	};
	BDFDB.PluginUtils.createSettingsPanel = function (addon, props) {
		if (!window.BDFDB_Global.loaded) return "Could not initiate BDFDB Library Plugin! Can not create Settings Panel!";
		addon = addon == BDFDB && InternalBDFDB || addon;
		if (!BDFDB.ObjectUtils.is(addon)) return;
		let settingsProps = props;
		if (settingsProps && !BDFDB.ObjectUtils.is(settingsProps) && (BDFDB.ReactUtils.isValidElement(settingsProps) || BDFDB.ArrayUtils.is(settingsProps))) settingsProps = {
			children: settingsProps
		};
		return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SettingsPanel, Object.assign({
			addon: addon,
			collapseStates: settingsProps && settingsProps.collapseStates
		}, settingsProps));
	};
	BDFDB.PluginUtils.refreshSettingsPanel = function (plugin, settingsPanel, ...args) {
		if (BDFDB.ObjectUtils.is(plugin)) {
			if (settingsPanel && settingsPanel.props && BDFDB.ObjectUtils.is(settingsPanel.props._instance)) {
				settingsPanel.props._instance.props = Object.assign({}, settingsPanel.props._instance.props, ...args);
				BDFDB.ReactUtils.forceUpdate(settingsPanel.props._instance);
			}
			else if (typeof plugin.getSettingsPanel == "function" && Node.prototype.isPrototypeOf(settingsPanel) && settingsPanel.parentElement) {
				settingsPanel.parentElement.appendChild(plugin.getSettingsPanel(...args));
				settingsPanel.remove();
			}
		}
	};
	InternalBDFDB.addSpecialListeners = function (plugin) {
		plugin = plugin == BDFDB && InternalBDFDB || plugin;
		if (BDFDB.ObjectUtils.is(plugin)) {
			if (typeof plugin.onSwitch == "function") {
				let spacer = document.querySelector(`${BDFDB.dotCN.guildswrapper} ~ * > ${BDFDB.dotCN.chatspacer}`);
				if (spacer) {
					let noChannelObserver = new MutationObserver(changes => {changes.forEach(change => {
						if (change.target && BDFDB.DOMUtils.containsClass(change.target, BDFDB.disCN.nochannel)) plugin.onSwitch();
					});});
					BDFDB.ObserverUtils.connect(plugin, spacer.querySelector(BDFDB.dotCNC.chat + BDFDB.dotCN.nochannel), {name: "switchFixNoChannelObserver", instance: noChannelObserver}, {attributes: true});
					let spacerObserver = new MutationObserver(changes => {changes.forEach(change => {if (change.addedNodes) {change.addedNodes.forEach(node => {
						if (BDFDB.DOMUtils.containsClass(node, BDFDB.disCN.chat, BDFDB.disCN.nochannel, false)) {
							BDFDB.ObserverUtils.connect(plugin, node, {name: "switchFixNoChannelObserver", instance: noChannelObserver}, {attributes: true});
						}
					});}});});
					BDFDB.ObserverUtils.connect(plugin, spacer, {name: "switchFixSpacerObserver", instance: spacerObserver}, {childList: true});
				}
			}
			InternalBDFDB.addContextListeners(plugin);
		}
	};

	window.BDFDB_Global = Object.assign({
		started: true,
		loading: true,
		PluginUtils: {
			buildPlugin: BDFDB.PluginUtils.buildPlugin,
			cleanUp: BDFDB.PluginUtils.cleanUp
		}
	}, config, window.BDFDB_Global);

	
	const request = require("request"), fs = require("fs"), path = require("path");
	const cssPath = path.join(BDFDB.BDUtils.getPluginsFolder(), "0BDFDB.raw.css");
	const dataPath = path.join(BDFDB.BDUtils.getPluginsFolder(), "0BDFDB.data.json");
	
	const loadBackup = _ => {
		const backup = fs.existsSync(dataPath) && (fs.readFileSync(dataPath) || "").toString() || null;
		if (!backup) BdApi.alert("Error", "Could not initiate BDFDB Library Plugin. Check your Internet Connection and make sure GitHub isn't blocked by your Network or try disabling your VPN/Proxy.");
		return backup;
	};
	const loadLibrary = tryAgain => {
		request.get(`https://mwittrien.github.io/BetterDiscordAddons/Library/_res/BDFDB.raw.css`, (e, r, b) => {
			if ((e || !b || r.statusCode != 200) && tryAgain) return BDFDB.TimeUtils.timeout(_ => loadLibrary(), 10000);
			const css = !e && b && r.statusCode == 200 ? b : fs.existsSync(cssPath) && (fs.readFileSync(cssPath) || "").toString();
			request.get(`https://mwittrien.github.io/BetterDiscordAddons/Library/_res/BDFDB.data.json`, BDFDB.TimeUtils.suppress((e2, r2, b2) => {
				if (e2 || !b2 || r2.statusCode != 200) {
					if (tryAgain) return BDFDB.TimeUtils.timeout(_ => loadLibrary(), 10000);
					else {
						BDFDB.LogUtils.error(["Failed to fetch JSON from GitHub. Could not load data.json!", e2 || ""]);
						b2 = loadBackup(dataPath);
					}
				}
				let InternalData;
				try {InternalData = JSON.parse(b2);}
				catch (err) {
					BDFDB.LogUtils.error(["Failed to parse fetched JSON. Could not load data.json!", err]);
					b2 = null;
					InternalData = JSON.parse(loadBackup(dataPath));
				}
				if (!e && b && r.statusCode == 200) fs.writeFile(cssPath, b, _ => {});
				if (!e2 && b2 && r2.statusCode == 200) fs.writeFile(dataPath, b2, _ => {});
				
				InternalData.UserBackgrounds = {};
				if (InternalData.userBackgroundsUrl && InternalData.userBackgroundsProperties) request(InternalData.userBackgroundsUrl, (e3, r3, b3) => {
					if (!e3 && b3 && r3.statusCode == 200) {
						const log = BDFDB.UserUtils.me.id == InternalData.myId || BDFDB.UserUtils.me.id == "350635509275557888", notUsedValues = [];
						try {
							InternalData.UserBackgrounds = JSON.parse(b3);
							for (let id in InternalData.UserBackgrounds) {
								let user = {};
								for (let key in InternalData.UserBackgrounds[id]) {
									if (InternalData.userBackgroundsProperties[key]) user[InternalData.userBackgroundsProperties[key]] = key == "background" ? `url(${InternalData.UserBackgrounds[id][key]})` : InternalData.UserBackgrounds[id][key];
									else if (log && !notUsedValues.includes(key)) notUsedValues.push(key);
								}
								InternalData.UserBackgrounds[id] = user;
							}
							if (notUsedValues.length) BDFDB.LogUtils.warn(["Found unused variables in usrbgs!", notUsedValues]);
						}
						catch (err) {
							InternalData.UserBackgrounds = {};
							if (log) BDFDB.LogUtils.error(["Could not load usrbgs!", err]);
						}
					}
				});
				
				InternalBDFDB.getPluginURL = function (plugin) {
					plugin = plugin == BDFDB && InternalBDFDB || plugin;
					if (BDFDB.ObjectUtils.is(plugin)) {
						if (plugin.rawUrl) return plugin.rawUrl;
						else {
							let name = InternalData.PluginNameMap && InternalData.PluginNameMap[plugin.name] || plugin.name;
							return `https://mwittrien.github.io/BetterDiscordAddons/Plugins/${name}/${name}.plugin.js`;
						}
					}
					else return "";
				};
			
				BDFDB.ObserverUtils = {};
				BDFDB.ObserverUtils.connect = function (plugin, eleOrSelec, observer, config = {childList: true}) {
					plugin = plugin == BDFDB && InternalBDFDB || plugin;
					if (!BDFDB.ObjectUtils.is(plugin) || !eleOrSelec || !observer) return;
					if (BDFDB.ObjectUtils.isEmpty(plugin.observers)) plugin.observers = {};
					if (!BDFDB.ArrayUtils.is(plugin.observers[observer.name])) plugin.observers[observer.name] = [];
					if (!observer.multi) for (let subinstance of plugin.observers[observer.name]) subinstance.disconnect();
					if (observer.instance) plugin.observers[observer.name].push(observer.instance);
					let instance = plugin.observers[observer.name][plugin.observers[observer.name].length - 1];
					if (instance) {
						let node = Node.prototype.isPrototypeOf(eleOrSelec) ? eleOrSelec : typeof eleOrSelec === "string" ? document.querySelector(eleOrSelec) : null;
						if (node) instance.observe(node, config);
					}
				};
				BDFDB.ObserverUtils.disconnect = function (plugin, observer) {
					plugin = plugin == BDFDB && InternalBDFDB || plugin;
					if (BDFDB.ObjectUtils.is(plugin) && !BDFDB.ObjectUtils.isEmpty(plugin.observers)) {
						let observername = typeof observer == "string" ? observer : (BDFDB.ObjectUtils.is(observer) ? observer.name : null);
						if (!observername) {
							for (let observer in plugin.observers) for (let instance of plugin.observers[observer]) instance.disconnect();
							delete plugin.observers;
						}
						else if (!BDFDB.ArrayUtils.is(plugin.observers[observername])) {
							for (let instance of plugin.observers[observername]) instance.disconnect();
							delete plugin.observers[observername];
						}
					}
				};

				BDFDB.StoreChangeUtils = {};
				BDFDB.StoreChangeUtils.add = function (plugin, store, callback) {
					plugin = plugin == BDFDB && InternalBDFDB || plugin;
					if (!BDFDB.ObjectUtils.is(plugin) || !BDFDB.ObjectUtils.is(store) || typeof store.addChangeListener != "function" ||  typeof callback != "function") return;
					BDFDB.StoreChangeUtils.remove(plugin, store, callback);
					if (!BDFDB.ArrayUtils.is(plugin.changeListeners)) plugin.changeListeners = [];
					plugin.changeListeners.push({store, callback});
					store.addChangeListener(callback);
				};
				BDFDB.StoreChangeUtils.remove = function (plugin, store, callback) {
					plugin = plugin == BDFDB && InternalBDFDB || plugin;
					if (!BDFDB.ObjectUtils.is(plugin) || !BDFDB.ArrayUtils.is(plugin.changeListeners)) return;
					if (!store) {
						while (plugin.changeListeners.length) {
							let listener = plugin.changeListeners.pop();
							listener.store.removeChangeListener(listener.callback);
						}
					}
					else if (BDFDB.ObjectUtils.is(store) && typeof store.addChangeListener == "function") {
						if (!callback) {
							for (let listener of plugin.changeListeners) {
								let removedListeners = [];
								if (listener.store == store) {
									listener.store.removeChangeListener(listener.callback);
									removedListeners.push(listener);
								}
								if (removedListeners.length) plugin.changeListeners = plugin.changeListeners.filter(listener => !removedListeners.includes(listener));
							}
						}
						else if (typeof callback == "function") {
							store.removeChangeListener(callback);
							plugin.changeListeners = plugin.changeListeners.filter(listener => listener.store == store && listener.callback == callback);
						}
					}
				};

				var pressedKeys = [], mousePosition;
				BDFDB.ListenerUtils = {};
				BDFDB.ListenerUtils.isPressed = function (key) {
					return pressedKeys.includes(key);
				};
				BDFDB.ListenerUtils.getPosition = function (key) {
					return mousePosition;
				};
				BDFDB.ListenerUtils.add = function (plugin, ele, actions, selectorOrCallback, callbackOrNothing) {
					plugin = plugin == BDFDB && InternalBDFDB || plugin;
					if (!BDFDB.ObjectUtils.is(plugin) || (!Node.prototype.isPrototypeOf(ele) && ele !== window) || !actions) return;
					let callbackIs4th = typeof selectorOrCallback == "function";
					let selector = callbackIs4th ? undefined : selectorOrCallback;
					let callback = callbackIs4th ? selectorOrCallback : callbackOrNothing;
					if (typeof callback != "function") return;
					BDFDB.ListenerUtils.remove(plugin, ele, actions, selector);
					for (let action of actions.split(" ")) {
						action = action.split(".");
						let eventName = action.shift().toLowerCase();
						if (!eventName) return;
						let origEventName = eventName;
						eventName = eventName == "mouseenter" || eventName == "mouseleave" ? "mouseover" : eventName;
						let namespace = (action.join(".") || "") + plugin.name;
						if (!BDFDB.ArrayUtils.is(plugin.eventListeners)) plugin.eventListeners = [];
						let eventCallback = null;
						if (selector) {
							if (origEventName == "mouseenter" || origEventName == "mouseleave") {
								eventCallback = e => {
									for (let child of e.path) if (typeof child.matches == "function" && child.matches(selector) && !child[namespace + "BDFDB" + origEventName]) {
										child[namespace + "BDFDB" + origEventName] = true;
										if (origEventName == "mouseenter") callback(BDFDB.ListenerUtils.copyEvent(e, child));
										let mouseOut = e2 => {
											if (e2.target.contains(child) || e2.target == child || !child.contains(e2.target)) {
												if (origEventName == "mouseleave") callback(BDFDB.ListenerUtils.copyEvent(e, child));
												delete child[namespace + "BDFDB" + origEventName];
												document.removeEventListener("mouseout", mouseOut);
											}
										};
										document.addEventListener("mouseout", mouseOut);
										break;
									}
								};
							}
							else {
								eventCallback = e => {
									for (let child of e.path) if (typeof child.matches == "function" && child.matches(selector)) {
										callback(BDFDB.ListenerUtils.copyEvent(e, child));
										break;
									}
								};
							}
						}
						else eventCallback = e => {callback(BDFDB.ListenerUtils.copyEvent(e, ele));};

						plugin.eventListeners.push({ele, eventName, origEventName, namespace, selector, eventCallback});
						ele.addEventListener(eventName, eventCallback, true);
					}
				};
				BDFDB.ListenerUtils.remove = function (plugin, ele, actions = "", selector) {
					plugin = plugin == BDFDB && InternalBDFDB || plugin;
					if (!BDFDB.ObjectUtils.is(plugin) || !BDFDB.ArrayUtils.is(plugin.eventListeners)) return;
					if (!ele) {
						while (plugin.eventListeners.length) {
							let listener = plugin.eventListeners.pop();
							listener.ele.removeEventListener(listener.eventName, listener.eventCallback, true);
						}
					}
					else if (Node.prototype.isPrototypeOf(ele) || ele === window) {
						for (let action of actions.split(" ")) {
							action = action.split(".");
							let eventName = action.shift().toLowerCase();
							let namespace = (action.join(".") || "") + plugin.name;
							for (let listener of plugin.eventListeners) {
								let removedListeners = [];
								if (listener.ele == ele && (!eventName || listener.origEventName == eventName) && listener.namespace == namespace && (selector === undefined || listener.selector == selector)) {
									listener.ele.removeEventListener(listener.eventName, listener.eventCallback, true);
									removedListeners.push(listener);
								}
								if (removedListeners.length) plugin.eventListeners = plugin.eventListeners.filter(listener => !removedListeners.includes(listener));
							}
						}
					}
				};
				BDFDB.ListenerUtils.multiAdd = function (node, actions, callback) {
					if (!Node.prototype.isPrototypeOf(node) || !actions || typeof callback != "function") return;
					for (let action of actions.trim().split(" ").filter(n => n)) node.addEventListener(action, callback, true);
				};
				BDFDB.ListenerUtils.multiRemove = function (node, actions, callback) {
					if (!Node.prototype.isPrototypeOf(node) || !actions || typeof callback != "function") return;
					for (let action of actions.trim().split(" ").filter(n => n)) node.removeEventListener(action, callback, true);
				};
				BDFDB.ListenerUtils.addToChildren = function (node, actions, selector, callback) {
					if (!Node.prototype.isPrototypeOf(node) || !actions || !selector || !selector.trim() || typeof callback != "function") return;
					for (let action of actions.trim().split(" ").filter(n => n)) {
						let eventCallback = callback;
						if (action == "mouseenter" || action == "mouseleave") eventCallback = e => {if (e.target.matches(selector)) callback(e);};
						node.querySelectorAll(selector.trim()).forEach(child => {child.addEventListener(action, eventCallback, true);});
					}
				};
				BDFDB.ListenerUtils.copyEvent = function (e, ele) {
					if (!e || !e.constructor || !e.type) return e;
					let eCopy = new e.constructor(e.type, e);
					Object.defineProperty(eCopy, "originalEvent", {value: e});
					Object.defineProperty(eCopy, "which", {value: e.which});
					Object.defineProperty(eCopy, "keyCode", {value: e.keyCode});
					Object.defineProperty(eCopy, "path", {value: e.path});
					Object.defineProperty(eCopy, "relatedTarget", {value: e.relatedTarget});
					Object.defineProperty(eCopy, "srcElement", {value: e.srcElement});
					Object.defineProperty(eCopy, "target", {value: e.target});
					Object.defineProperty(eCopy, "toElement", {value: e.toElement});
					if (ele) Object.defineProperty(eCopy, "currentTarget", {value: ele});
					return eCopy;
				};
				BDFDB.ListenerUtils.stopEvent = function (e) {
					if (BDFDB.ObjectUtils.is(e)) {
						if (typeof e.preventDefault == "function") e.preventDefault();
						if (typeof e.stopPropagation == "function") e.stopPropagation();
						if (typeof e.stopImmediatePropagation == "function") e.stopImmediatePropagation();
						if (BDFDB.ObjectUtils.is(e.originalEvent)) {
							if (typeof e.originalEvent.preventDefault == "function") e.originalEvent.preventDefault();
							if (typeof e.originalEvent.stopPropagation == "function") e.originalEvent.stopPropagation();
							if (typeof e.originalEvent.stopImmediatePropagation == "function") e.originalEvent.stopImmediatePropagation();
						}
					}
				};
				
				var Toasts = [], NotificationBars = [];
				var ToastQueues = {}, DesktopNotificationQueue = {queue: [], running: false};
				for (let key in LibraryConstants.ToastPositions) ToastQueues[LibraryConstants.ToastPositions[key]] = {queue: [], full: false};
				
				BDFDB.NotificationUtils = {};
				BDFDB.NotificationUtils.toast = function (children, config = {}) {
					if (!children) return;
					let app = document.querySelector(BDFDB.dotCN.appmount) || document.body;
					if (!app) return;
					let position = config.position && LibraryConstants.ToastPositions[config.position] || InternalBDFDB.settings.choices.toastPosition && LibraryConstants.ToastPositions[InternalBDFDB.settings.choices.toastPosition] || LibraryConstants.ToastPositions.right;
					
					const runQueue = _ => {
						if (ToastQueues[position].full) return;
						let data = ToastQueues[position].queue.shift();
						if (!data) return;
						
						let id = BDFDB.NumberUtils.generateId(Toasts);
						let toasts = document.querySelector(BDFDB.dotCN.toasts + BDFDB.dotCN[position]);
						if (!toasts) {
							toasts = BDFDB.DOMUtils.create(`<div class="${BDFDB.DOMUtils.formatClassName(BDFDB.disCN.toasts, BDFDB.disCN[position])}"></div>`);
							app.appendChild(toasts);
						}
						
						if (data.config.id) data.toast.id = data.config.id.split(" ").join("");
						if (data.config.className) BDFDB.DOMUtils.addClass(data.toast, data.config.className);
						if (data.config.css) BDFDB.DOMUtils.appendLocalStyle("BDFDBcustomToast" + id, data.config.css);
						if (data.config.style) data.toast.style = Object.assign({}, data.toast.style, data.config.style);
						
						let backgroundColor, fontColor, barColor;
						
						let type = data.config.type && BDFDB.disCN["toast" + data.config.type];
						if (!type) {
							barColor = BDFDB.ColorUtils.convert(data.config.barColor, "HEX");
							let comp = BDFDB.ColorUtils.convert(data.config.color, "RGBCOMP");
							if (comp) {
								backgroundColor = BDFDB.ColorUtils.convert(comp, "HEX");
								fontColor = comp[0] > 180 && comp[1] > 180 && comp[2] > 180 ? "#000" : "#FFF";
								BDFDB.DOMUtils.addClass(data.toast, BDFDB.disCN.toastcustom);
							}
							else BDFDB.DOMUtils.addClass(data.toast, BDFDB.disCN.toastdefault);
						}
						else BDFDB.DOMUtils.addClass(data.toast, type);
						
						let disableInteractions = data.config.disableInteractions && typeof data.config.onClick != "function";
						let start, progress = 0, paused = false
						let timeout = typeof data.config.timeout == "number" && !disableInteractions ? data.config.timeout : 3000;
						timeout = (timeout > 0 ? timeout : 600000) + 300;
						
						let progressInterval, closeTimeout = BDFDB.TimeUtils.timeout(_ => data.toast.close(), timeout);
						data.toast.close = _ => {
							BDFDB.TimeUtils.clear(closeTimeout);
							if (document.contains(data.toast)) {
								BDFDB.DOMUtils.addClass(data.toast, BDFDB.disCN.toastclosing);
								data.toast.style.setProperty("pointer-events", "none", "important");
								BDFDB.TimeUtils.timeout(_ => {
									if (typeof data.config.onClose == "function") data.config.onClose();
									BDFDB.ArrayUtils.remove(Toasts, id);
									BDFDB.DOMUtils.removeLocalStyle("BDFDBcustomToast" + id);
									data.toast.remove();
									if (!toasts.querySelectorAll(BDFDB.dotCN.toast).length) toasts.remove();
								}, 300);
							}
							ToastQueues[position].full = false;
							runQueue();
						};
						
						if (disableInteractions) data.toast.style.setProperty("pointer-events", "none", "important");
						else {
							BDFDB.DOMUtils.addClass(data.toast, BDFDB.disCN.toastclosable);
							data.toast.addEventListener("click", event => {
								if (typeof data.config.onClick == "function" && !BDFDB.DOMUtils.getParent(BDFDB.dotCN.toastcloseicon, event.target)) data.config.onClick();
								data.toast.close();
							});
							if (typeof closeTimeout.pause == "function") {
								data.toast.addEventListener("mouseenter", _ => {
									if (paused) return;
									paused = true;
									closeTimeout.pause();
								});
								data.toast.addEventListener("mouseleave", _ => {
									if (!paused) return;
									paused = false;
									start = performance.now() - progress;
									closeTimeout.resume();
								});
							}
						}
						
						toasts.appendChild(data.toast);
						BDFDB.TimeUtils.timeout(_ => BDFDB.DOMUtils.removeClass(data.toast, BDFDB.disCN.toastopening));
						
						let icon = data.config.avatar ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.AvatarComponents.default, {
							src: data.config.avatar,
							size: InternalComponents.LibraryComponents.AvatarComponents.Sizes.SIZE_24
						}) : ((data.config.icon || data.config.type && LibraryConstants.ToastIcons[data.config.type]) ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SvgIcon, {
							name: data.config.type && LibraryConstants.ToastIcons[data.config.type] && InternalComponents.LibraryComponents.SvgIcon.Names[LibraryConstants.ToastIcons[data.config.type]],
							iconSVG: data.config.icon,
							width: 18,
							height: 18,
							nativeClass: true
						}) : null);
						
						BDFDB.ReactUtils.render(BDFDB.ReactUtils.createElement(class BDFDB_Toast extends LibraryModules.React.Component {
							componentDidMount() {
								data.toast.update = newChildren => {
									if (!newChildren) return;
									this.props.children = newChildren;
									BDFDB.ReactUtils.forceUpdate(this);
								};
							}
							render() {
								return BDFDB.ReactUtils.createElement(BDFDB.ReactUtils.Fragment, {
									children: [
										BDFDB.ReactUtils.createElement("div", {
											className: BDFDB.disCN.toastbg,
											style: {backgroundColor: backgroundColor}
										}),
										BDFDB.ReactUtils.createElement("div", {
											className: BDFDB.disCN.toastinner,
											style: {color: fontColor},
											children: [
												icon && BDFDB.ReactUtils.createElement("div", {
													className: BDFDB.DOMUtils.formatClassName(data.config.avatar && BDFDB.disCN.toastavatar, BDFDB.disCN.toasticon, data.config.iconClassName),
													children: icon
												}),
												BDFDB.ReactUtils.createElement("div", {
													className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.toasttext, data.config.textClassName),
													children: this.props.children
												}),
												!disableInteractions && BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SvgIcon, {
													className: BDFDB.disCN.toastcloseicon,
													name: InternalComponents.LibraryComponents.SvgIcon.Names.CLOSE,
													width: 16,
													height: 16
												})
											].filter(n => n)
										}),
										BDFDB.ReactUtils.createElement(class extends LibraryModules.React.Component {
											componentDidMount() {
												start = performance.now();
												progressInterval = BDFDB.TimeUtils.interval(_ => {
													if (!paused) BDFDB.ReactUtils.forceUpdate(this);
												}, 10);
											}
											componentWillUnmount() {
												BDFDB.TimeUtils.clear(progressInterval);
											}
											render() {
												progress = performance.now() - start;
												return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Animations.animated.div, {
													className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.toastbar, barColor && BDFDB.disCN.toastcustombar),
													style: {
														backgroundColor: barColor,
														right: `${100 - progress * 100 / timeout}%`
													}
												})
											}
										})
									]
								});
							}
						}, {children: data.children}), data.toast);
						
						ToastQueues[position].full = (BDFDB.ArrayUtils.sum(Array.from(toasts.childNodes).map(c => {
							let height = BDFDB.DOMUtils.getRects(c).height;
							return height > 50 ? height : 50;
						})) - 100) > BDFDB.DOMUtils.getRects(app).height;
						
						if (typeof data.config.onShow == "function") data.config.onShow();
					};
					
					let toast = BDFDB.DOMUtils.create(`<div class="${BDFDB.disCNS.toast + BDFDB.disCN.toastopening}"></div>`);
					toast.update = _ => {};
					ToastQueues[position].queue.push({children, config, toast});
					runQueue();
					return toast;
				};
				BDFDB.NotificationUtils.desktop = function (content, config = {}) {
					if (!content) return;
					
					const queue = _ => {
						DesktopNotificationQueue.queue.push({content, config});
						runQueue();
					};
					const runQueue = _ => {
						if (DesktopNotificationQueue.running) return;
						let data = DesktopNotificationQueue.queue.shift();
						if (!data) return;
						
						DesktopNotificationQueue.running = true;
						let muted = data.config.silent;
						data.config.silent = data.config.silent || data.config.sound ? true : false;
						let audio = new Audio();
						if (!muted && data.config.sound) {
							audio.src = data.config.sound;
							audio.play();
						}
						let notification = new Notification(data.content, data.config);
						
						let disableInteractions = data.config.disableInteractions && typeof data.config.onClick != "function";
						if (disableInteractions) notification.onclick = _ => {};
						else notification.onclick = _ => {
							if (typeof data.config.onClick == "function") data.config.onClick();
							notification.close();
						};
						
						notification.onclose = _ => {
							audio.pause();
							DesktopNotificationQueue.running = false;
							BDFDB.TimeUtils.timeout(runQueue, 1000);
						}
					};
					
					if (!("Notification" in window)) {}
					else if (Notification.permission === "granted") queue();
					else if (Notification.permission !== "denied") Notification.requestPermission(function (response) {if (response === "granted") queue();});
				};
				BDFDB.NotificationUtils.notice = function (text, config = {}) {
					if (!text) return;
					let layers = document.querySelector(BDFDB.dotCN.layers) || document.querySelector(BDFDB.dotCN.appmount);
					if (!layers) return;
					let id = BDFDB.NumberUtils.generateId(NotificationBars);
					let notice = BDFDB.DOMUtils.create(`<div class="${BDFDB.disCNS.notice + BDFDB.disCN.noticewrapper}" notice-id="${id}"><div class="${BDFDB.disCN.noticedismiss}"${config.forceStyle ? ` style="width: 36px !important; height: 36px !important; position: absolute !important; top: 0 !important; right: 0 !important; left: unset !important;"` : ""}></div><div class="${BDFDB.disCN.noticetext}"></div></div>`);
					layers.parentElement.insertBefore(notice, layers);
					let noticeText = notice.querySelector(BDFDB.dotCN.noticetext);
					if (config.platform) for (let platform of config.platform.split(" ")) if (DiscordClasses["noticeicon" + platform]) {
						let icon = BDFDB.DOMUtils.create(`<i class="${BDFDB.disCN["noticeicon" + platform]}"></i>`);
						BDFDB.DOMUtils.addClass(icon, BDFDB.disCN.noticeplatformicon);
						BDFDB.DOMUtils.removeClass(icon, BDFDB.disCN.noticeicon);
						notice.insertBefore(icon, noticeText);
					}
					if (config.customIcon) {
						let icon = document.createElement("i"), iconInner = BDFDB.DOMUtils.create(config.customIcon);
						if (iconInner.nodeType == Node.TEXT_NODE) icon.style.setProperty("background", `url(${config.customIcon}) center/cover no-repeat`);
						else {
							icon = iconInner;
							if ((icon.tagName || "").toUpperCase() == "SVG") {
								icon.removeAttribute("width");
								icon.setAttribute("height", "100%");
							}
						}
						BDFDB.DOMUtils.addClass(icon, BDFDB.disCN.noticeplatformicon);
						BDFDB.DOMUtils.removeClass(icon, BDFDB.disCN.noticeicon);
						notice.insertBefore(icon, noticeText);
					}
					if (BDFDB.ArrayUtils.is(config.buttons)) for (let data of config.buttons) {
						let contents = typeof data.contents == "string" && data.contents;
						if (contents) {
							let button = BDFDB.DOMUtils.create(`<button class="${BDFDB.DOMUtils.formatClassName(BDFDB.disCN.noticebutton, data.className)}">${contents}</button>`);
							button.addEventListener("click", event => {
								if (data.close) notice.close();
								if (typeof data.onClick == "function") data.onClick(event, notice);
							});
							if (typeof data.onMouseEnter == "function") button.addEventListener("mouseenter", event => data.onMouseEnter(event, notice));
							if (typeof data.onMouseLeave == "function") button.addEventListener("mouseleave", event => data.onMouseLeave(event, notice));
							notice.appendChild(button);
						}
					}
					if (config.id) notice.id = config.id.split(" ").join("");
					if (config.className) BDFDB.DOMUtils.addClass(notice, config.className);
					if (config.textClassName) BDFDB.DOMUtils.addClass(noticeText, config.textClassName);
					if (config.css) BDFDB.DOMUtils.appendLocalStyle("BDFDBcustomNotificationBar" + id, config.css);
					if (config.style) notice.style = config.style;
					if (config.html) noticeText.innerHTML = text;
					else {
						let link = document.createElement("a");
						let newText = [];
						for (let word of text.split(" ")) {
							let encodedWord = BDFDB.StringUtils.htmlEscape(word);
							link.href = word;
							newText.push(link.host && link.host !== window.location.host ? `<label class="${BDFDB.disCN.noticetextlink}">${encodedWord}</label>` : encodedWord);
						}
						noticeText.innerHTML = newText.join(" ");
					}
					let type = null;
					if (config.type && !document.querySelector(BDFDB.dotCNS.chatbase + BDFDB.dotCN.noticestreamer)) {
						if (type = BDFDB.disCN["notice" + config.type]) BDFDB.DOMUtils.addClass(notice, type);
						if (config.type == "premium") {
							let noticeButton = notice.querySelector(BDFDB.dotCN.noticebutton);
							if (noticeButton) BDFDB.DOMUtils.addClass(noticeButton, BDFDB.disCN.noticepremiumaction);
							BDFDB.DOMUtils.addClass(noticeText, BDFDB.disCN.noticepremiumtext);
							notice.insertBefore(BDFDB.DOMUtils.create(`<i class="${BDFDB.disCN.noticepremiumlogo}"></i>`), noticeText);
						}
					}
					if (!type) {
						let comp = BDFDB.ColorUtils.convert(config.color, "RGBCOMP");
						if (comp) {
							let fontColor = comp[0] > 180 && comp[1] > 180 && comp[2] > 180 ? "#000" : "#FFF";
							let backgroundColor = BDFDB.ColorUtils.convert(comp, "HEX");
							let filter = comp[0] > 180 && comp[1] > 180 && comp[2] > 180 ? "brightness(0%)" : "brightness(100%)";
							BDFDB.DOMUtils.appendLocalStyle("BDFDBcustomNotificationBarColorCorrection" + id, `${BDFDB.dotCN.noticewrapper}[notice-id="${id}"]{background-color: ${backgroundColor} !important;}${BDFDB.dotCN.noticewrapper}[notice-id="${id}"] ${BDFDB.dotCN.noticetext} {color: ${fontColor} !important;}${BDFDB.dotCN.noticewrapper}[notice-id="${id}"] ${BDFDB.dotCN.noticebutton} {color: ${fontColor} !important;border-color: ${BDFDB.ColorUtils.setAlpha(fontColor, 0.25, "RGBA")} !important;}${BDFDB.dotCN.noticewrapper}[notice-id="${id}"] ${BDFDB.dotCN.noticebutton}:hover {color: ${backgroundColor} !important;background-color: ${fontColor} !important;}${BDFDB.dotCN.noticewrapper}[notice-id="${id}"] ${BDFDB.dotCN.noticedismiss} {filter: ${filter} !important;}`);
							BDFDB.DOMUtils.addClass(notice, BDFDB.disCN.noticecustom);
						}
						else BDFDB.DOMUtils.addClass(notice, BDFDB.disCN.noticedefault);
					}
					if (config.forceStyle) {
						notice.style.setProperty("display", "flex", "important");
						notice.style.setProperty("height", "36px", "important");
						notice.style.setProperty("min-width", "70vw", "important");
						notice.style.setProperty("left", "unset", "important");
						notice.style.setProperty("right", "unset", "important");
						let sideMargin = ((BDFDB.DOMUtils.getWidth(document.body.firstElementChild) - BDFDB.DOMUtils.getWidth(notice))/2);
						notice.style.setProperty("left", `${sideMargin}px`, "important");
						notice.style.setProperty("right", `${sideMargin}px`, "important");
						notice.style.setProperty("min-width", "unset", "important");
						notice.style.setProperty("width", "unset", "important");
						notice.style.setProperty("max-width", `calc(100vw - ${sideMargin*2}px)`, "important");
					}
					notice.close = _ => {
						BDFDB.DOMUtils.addClass(notice, BDFDB.disCN.noticeclosing);
						if (config.forceStyle) {
							notice.style.setProperty("overflow", "hidden", "important");
							notice.style.setProperty("height", "0px", "important");
						}
						if (notice.tooltip && typeof notice.tooltip.removeTooltip == "function") notice.tooltip.removeTooltip();
						BDFDB.TimeUtils.timeout(_ => {
							if (typeof config.onClose == "function") config.onClose();
							BDFDB.ArrayUtils.remove(NotificationBars, id);
							BDFDB.DOMUtils.removeLocalStyle("BDFDBcustomNotificationBar" + id);
							BDFDB.DOMUtils.removeLocalStyle("BDFDBcustomNotificationBarColorCorrection" + id);
							BDFDB.DOMUtils.remove(notice);
						}, 500);
					};
					notice.querySelector(BDFDB.dotCN.noticedismiss).addEventListener("click", notice.close);
					return notice;
				};
				BDFDB.NotificationUtils.alert = function (header, body) {
					if (typeof header == "string" && typeof header == "string" && BdApi && typeof BdApi.alert == "function") BdApi.alert(header, body);
				};

				var Tooltips = [];
				BDFDB.TooltipUtils = {};
				BDFDB.TooltipUtils.create = function (anker, text, config = {}) {
					if (!text && !config.guild) return null;
					const itemLayerContainer = document.querySelector(BDFDB.dotCN.appmount +  " > " + BDFDB.dotCN.itemlayercontainer);
					if (!itemLayerContainer || !Node.prototype.isPrototypeOf(anker) || !document.contains(anker)) return null;
					const id = BDFDB.NumberUtils.generateId(Tooltips);
					const itemLayer = BDFDB.DOMUtils.create(`<div class="${BDFDB.disCNS.itemlayer + BDFDB.disCN.itemlayerdisabledpointerevents}"><div class="${BDFDB.disCN.tooltip}" tooltip-id="${id}"><div class="${BDFDB.disCN.tooltippointer}"></div><div class="${BDFDB.disCN.tooltipcontent}"></div></div></div>`);
					itemLayerContainer.appendChild(itemLayer);
					
					const tooltip = itemLayer.firstElementChild;
					const tooltipContent = itemLayer.querySelector(BDFDB.dotCN.tooltipcontent);
					const tooltipPointer = itemLayer.querySelector(BDFDB.dotCN.tooltippointer);
					
					if (config.id) tooltip.id = config.id.split(" ").join("");
					
					if (typeof config.type != "string" || !BDFDB.disCN["tooltip" + config.type.toLowerCase()]) config.type = "top";
					let type = config.type.toLowerCase();
					BDFDB.DOMUtils.addClass(tooltip, BDFDB.disCN["tooltip" + type], config.className);
					
					let fontColorIsGradient = false, customBackgroundColor = false, style = "";
					if (config.style) style += config.style;
					if (config.fontColor) {
						fontColorIsGradient = BDFDB.ObjectUtils.is(config.fontColor);
						if (!fontColorIsGradient) style = (style ? (style + " ") : "") + `color: ${BDFDB.ColorUtils.convert(config.fontColor, "RGBA")} !important;`
					}
					if (config.backgroundColor) {
						customBackgroundColor = true;
						let backgroundColorIsGradient = BDFDB.ObjectUtils.is(config.backgroundColor);
						let backgroundColor = !backgroundColorIsGradient ? BDFDB.ColorUtils.convert(config.backgroundColor, "RGBA") : BDFDB.ColorUtils.createGradient(config.backgroundColor);
						style = (style ? (style + " ") : "") + `background: ${backgroundColor} !important; border-color: ${backgroundColorIsGradient ? BDFDB.ColorUtils.convert(config.backgroundColor[type == "left" ? 100 : 0], "RGBA") : backgroundColor} !important;`;
					}
					if (style) tooltip.style = style;
					const zIndexed = config.zIndex && typeof config.zIndex == "number";
					if (zIndexed) {
						itemLayer.style.setProperty("z-index", config.zIndex, "important");
						tooltip.style.setProperty("z-index", config.zIndex, "important");
						tooltipContent.style.setProperty("z-index", config.zIndex, "important");
						BDFDB.DOMUtils.addClass(itemLayerContainer, BDFDB.disCN.itemlayercontainerzindexdisabled);
					}
					if (typeof config.width == "number" && config.width > 196) {
						tooltip.style.setProperty("width", `${config.width}px`, "important");
						tooltip.style.setProperty("max-width", `${config.width}px`, "important");
					}
					if (typeof config.maxWidth == "number" && config.maxWidth > 196) {
						tooltip.style.setProperty("max-width", `${config.maxWidth}px`, "important");
					}
					if (customBackgroundColor) BDFDB.DOMUtils.addClass(tooltip, BDFDB.disCN.tooltipcustom);
					else if (config.color && BDFDB.disCN["tooltip" + config.color.toLowerCase()]) BDFDB.DOMUtils.addClass(tooltip, BDFDB.disCN["tooltip" + config.color.toLowerCase()]);
					else BDFDB.DOMUtils.addClass(tooltip, BDFDB.disCN.tooltipprimary);
					
					if (config.list || BDFDB.ObjectUtils.is(config.guild)) BDFDB.DOMUtils.addClass(tooltip, BDFDB.disCN.tooltiplistitem);
					
					const removeTooltip = _ => {
						document.removeEventListener("wheel", wheel);
						document.removeEventListener("mousemove", mouseMove);
						document.removeEventListener("mouseleave", mouseLeave);
						BDFDB.DOMUtils.remove(itemLayer);
						BDFDB.ArrayUtils.remove(Tooltips, id);
						observer.disconnect();
						if (zIndexed) BDFDB.DOMUtils.removeClass(itemLayerContainer, BDFDB.disCN.itemlayercontainerzindexdisabled);
						if (typeof config.onHide == "function") config.onHide(itemLayer, anker);
					};
					const setText = newText => {
						if (BDFDB.ObjectUtils.is(config.guild)) {
							let channels = LibraryModules.GuildChannelStore.getChannels(config.guild.id);
							let voiceChannels = (channels[LibraryModules.GuildChannelKeys.GUILD_VOCAL_CHANNELS_KEY] || []).filter(c => c.channel.type == BDFDB.DiscordConstants.ChannelTypes.GUILD_VOICE).map(c => c.channel.id);
							let stageChannels = (channels[LibraryModules.GuildChannelKeys.GUILD_VOCAL_CHANNELS_KEY] || []).filter(c => c.channel.type == BDFDB.DiscordConstants.ChannelTypes.GUILD_STAGE_VOICE && LibraryModules.StageChannelStore.getStageInstanceByChannel(c.channel.id)).map(c => c.channel.id);
							let streamOwnerIds = LibraryModules.StreamUtils.getAllApplicationStreams().filter(app => app.guildId === config.guild.id).map(app => app.ownerId) || [];
							let streamOwners = streamOwnerIds.map(ownerId => LibraryModules.UserStore.getUser(ownerId)).filter(n => n);
							let connectedVoiceUsers = BDFDB.ObjectUtils.toArray(LibraryModules.VoiceUtils.getVoiceStates(config.guild.id)).map(state => voiceChannels.includes(state.channelId) && state.channelId != config.guild.afkChannelId && !streamOwnerIds.includes(state.userId) && LibraryModules.UserStore.getUser(state.userId)).filter(n => n);
							let connectedStageUsers = BDFDB.ObjectUtils.toArray(LibraryModules.VoiceUtils.getVoiceStates(config.guild.id)).map(state => stageChannels.includes(state.channelId) && state.channelId != config.guild.afkChannelId && !streamOwnerIds.includes(state.userId) && LibraryModules.UserStore.getUser(state.userId)).filter(n => n);
							
							let isMuted = LibraryModules.MutedUtils.isMuted(config.guild.id);
							let muteConfig = LibraryModules.MutedUtils.getMuteConfig(config.guild.id);
							
							let hasExtraRow = connectedStageUsers.length || connectedVoiceUsers.length || streamOwners.length;
							let children = [typeof newText == "function" ? newText() : newText].flat(10).filter(n => typeof n == "string" || BDFDB.ReactUtils.isValidElement(n));
							
							BDFDB.ReactUtils.render(BDFDB.ReactUtils.createElement(BDFDB.ReactUtils.Fragment, {
								children: [
									BDFDB.ReactUtils.createElement("div", {
										className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.tooltiprow, BDFDB.disCN.tooltiprowguildname),
										children: [
											BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.GuildComponents.Badge, {
												guild: config.guild,
												size: LibraryModules.StringUtils.cssValueToNumber(DiscordClassModules.TooltipGuild.iconSize),
												className: BDFDB.disCN.tooltiprowicon
											}),
											BDFDB.ReactUtils.createElement("span", {
												className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.tooltipguildnametext, hasExtraRow && BDFDB.disCN.tooltipguildnametextlimitedsize),
												children: fontColorIsGradient ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TextGradientElement, {
													gradient: BDFDB.ColorUtils.createGradient(config.fontColor),
													children: config.guild.toString()
												}) : config.guild.toString()
											}),
										]
									}),
									children.length && BDFDB.ReactUtils.createElement("div", {
										className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.tooltiprow, BDFDB.disCN.tooltiprowextra),
										children: children
									}),
									config.note && BDFDB.ReactUtils.createElement("div", {
										className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.tooltiprow, BDFDB.disCN.tooltiprowextra, BDFDB.disCN.tooltipnote),
										children: config.note
									}),
									connectedStageUsers.length && BDFDB.ReactUtils.createElement("div", {
										className: BDFDB.disCN.tooltiprow,
										children: [
											BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SvgIcon, {
												name: InternalComponents.LibraryComponents.SvgIcon.Names.PODIUM,
												className: BDFDB.disCN.tooltipactivityicon
											}),
											BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.UserSummaryItem, {
												users: connectedStageUsers,
												max: 6
											})
										]
									}),
									connectedVoiceUsers.length && BDFDB.ReactUtils.createElement("div", {
										className: BDFDB.disCN.tooltiprow,
										children: [
											BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SvgIcon, {
												name: InternalComponents.LibraryComponents.SvgIcon.Names.SPEAKER,
												className: BDFDB.disCN.tooltipactivityicon
											}),
											BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.UserSummaryItem, {
												users: connectedVoiceUsers,
												max: 6
											})
										]
									}),
									streamOwners.length && BDFDB.ReactUtils.createElement("div", {
										className: BDFDB.disCN.tooltiprow,
										children: [
											BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SvgIcon, {
												name: InternalComponents.LibraryComponents.SvgIcon.Names.STREAM,
												className: BDFDB.disCN.tooltipactivityicon
											}),
											BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.UserSummaryItem, {
												users: streamOwners,
												max: 6
											})
										]
									}),
									isMuted && muteConfig && (muteConfig.end_time == null ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TextElement, {
										className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.tooltipmutetext, hasExtraRow && BDFDB.disCN.tooltipmutetextwithactivity),
										size: InternalComponents.LibraryComponents.TextElement.Sizes.SIZE_12,
										color: InternalComponents.LibraryComponents.TextElement.Colors.MUTED,
										children: BDFDB.LanguageUtils.LanguageStrings.VOICE_CHANNEL_MUTED
									}) : BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.GuildComponents.MutedText, {
										className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.tooltipmutetext, hasExtraRow && BDFDB.disCN.tooltipmutetextwithactivity),
										muteConfig: muteConfig
									}))
								].filter(n => n)
							}), tooltipContent);
						}
						else {
							let children = [typeof newText == "function" ? newText() : newText].flat(10).filter(n => typeof n == "string" || BDFDB.ReactUtils.isValidElement(n));
							children.length && BDFDB.ReactUtils.render(BDFDB.ReactUtils.createElement(BDFDB.ReactUtils.Fragment, {
								children: [
									fontColorIsGradient ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TextGradientElement, {
										gradient: BDFDB.ColorUtils.createGradient(config.fontColor),
										children: children
									}) : children,
									config.note && BDFDB.ReactUtils.createElement("div", {
										className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.tooltiprow, BDFDB.disCN.tooltiprowextra, BDFDB.disCN.tooltipnote),
										children: config.note
									})
								]
							}), tooltipContent);
						}
					};
					const update = newText => {
						if (newText) setText(newText);
						let left, top;
						const tRects = BDFDB.DOMUtils.getRects(anker);
						const iRects = BDFDB.DOMUtils.getRects(itemLayer);
						const aRects = BDFDB.DOMUtils.getRects(document.querySelector(BDFDB.dotCN.appmount));
						const positionOffsets = {height: 10, width: 10};
						const offset = typeof config.offset == "number" ? config.offset : 0;
						switch (type) {
							case "top":
								top = tRects.top - iRects.height - positionOffsets.height + 2 - offset;
								left = tRects.left + (tRects.width - iRects.width) / 2;
								break;
							case "bottom":
								top = tRects.top + tRects.height + positionOffsets.height - 2 + offset;
								left = tRects.left + (tRects.width - iRects.width) / 2;
								break;
							case "left":
								top = tRects.top + (tRects.height - iRects.height) / 2;
								left = tRects.left - iRects.width - positionOffsets.width + 2 - offset;
								break;
							case "right":
								top = tRects.top + (tRects.height - iRects.height) / 2;
								left = tRects.left + tRects.width + positionOffsets.width - 2 + offset;
								break;
							}
							
						itemLayer.style.setProperty("top", `${top}px`, "important");
						itemLayer.style.setProperty("left", `${left}px`, "important");
						
						tooltipPointer.style.removeProperty("margin-left");
						tooltipPointer.style.removeProperty("margin-top");
						if (type == "top" || type == "bottom") {
							if (left < 0) {
								itemLayer.style.setProperty("left", "5px", "important");
								tooltipPointer.style.setProperty("margin-left", `${left - 10}px`, "important");
							}
							else {
								const rightMargin = aRects.width - (left + iRects.width);
								if (rightMargin < 0) {
									itemLayer.style.setProperty("left", `${aRects.width - iRects.width - 5}px`, "important");
									tooltipPointer.style.setProperty("margin-left", `${-1*rightMargin}px`, "important");
								}
							}
						}
						else if (type == "left" || type == "right") {
							if (top < 0) {
								const bRects = BDFDB.DOMUtils.getRects(document.querySelector(BDFDB.dotCN.titlebar));
								const barCorrection = (bRects.width || 0) >= Math.round(75 * window.outerWidth / aRects.width) ? (bRects.height + 5) : 0;
								itemLayer.style.setProperty("top", `${5 + barCorrection}px`, "important");
								tooltipPointer.style.setProperty("margin-top", `${top - 10 - barCorrection}px`, "important");
							}
							else {
								const bottomMargin = aRects.height - (top + iRects.height);
								if (bottomMargin < 0) {
									itemLayer.style.setProperty("top", `${aRects.height - iRects.height - 5}px`, "important");
									tooltipPointer.style.setProperty("margin-top", `${-1*bottomMargin}px`, "important");
								}
							}
						}
					};

					const wheel = e => {
						const tRects1 = BDFDB.DOMUtils.getRects(anker);
						BDFDB.TimeUtils.clear(wheel.timeout);
						wheel.timeout = BDFDB.TimeUtils.timeout(_ => {
							const tRects2 = BDFDB.DOMUtils.getRects(anker);
							if (tRects1.x != tRects2.x || tRects1.y != tRects2.y) removeTooltip();
						}, 500);
					};
					const mouseMove = e => {
						const parent = e.target.parentElement.querySelector(":hover");
						if (parent && anker != parent && !anker.contains(parent)) removeTooltip();
					};
					const mouseLeave = e => removeTooltip();
					if (!config.perssist) {
						document.addEventListener("wheel", wheel);
						document.addEventListener("mousemove", mouseMove);
						document.addEventListener("mouseleave", mouseLeave);
					}
					
					const observer = new MutationObserver(changes => changes.forEach(change => {
						const nodes = Array.from(change.removedNodes);
						if (nodes.indexOf(itemLayer) > -1 || nodes.indexOf(anker) > -1 || nodes.some(n => n.contains(anker))) removeTooltip();
					}));
					observer.observe(document.body, {subtree: true, childList: true});
					
					tooltip.removeTooltip = itemLayer.removeTooltip = removeTooltip;
					tooltip.setText = itemLayer.setText = setText;
					tooltip.update = itemLayer.update = update;
					setText(text);
					update();
					
					if (config.delay) {
						BDFDB.DOMUtils.toggle(itemLayer);
						BDFDB.TimeUtils.timeout(_ => {
							BDFDB.DOMUtils.toggle(itemLayer);
							if (typeof config.onShow == "function") config.onShow(itemLayer, anker);
						}, config.delay);
					}
					else {
						if (typeof config.onShow == "function") config.onShow(itemLayer, anker);
					}
					return itemLayer;
				};
				
				InternalBDFDB.findModule = function (type, cacheString, filter, getExport) {
					if (!BDFDB.ObjectUtils.is(Cache.modules[type])) Cache.modules[type] = {module: {}, export: {}};
					if (getExport && Cache.modules[type].export[cacheString]) return Cache.modules[type].export[cacheString];
					else if (!getExport && Cache.modules[type].module[cacheString]) return Cache.modules[type].module[cacheString];
					else {
						let m = BDFDB.ModuleUtils.find(filter, getExport);
						if (m) {
							if (getExport) Cache.modules[type].export[cacheString] = m;
							else Cache.modules[type].module[cacheString] = m;
							return m;
						}
						else BDFDB.LogUtils.warn(`${cacheString} [${type}] not found in WebModules`);
					}
				};
				InternalBDFDB.getWebModuleReq = function () {
					if (!InternalBDFDB.getWebModuleReq.req) {
						const id = "BDFDB-WebModules";
						const req = window.webpackJsonp.push([[], {[id]: (module, exports, req) => module.exports = req}, [[id]]]);
						delete req.m[id];
						delete req.c[id];
						InternalBDFDB.getWebModuleReq.req = req;
					}
					return InternalBDFDB.getWebModuleReq.req;
				};
				BDFDB.ModuleUtils = {};
				BDFDB.ModuleUtils.find = function (filter, getExport) {
					getExport = typeof getExport != "boolean" ? true : getExport;
					let req = InternalBDFDB.getWebModuleReq();
					for (let i in req.c) if (req.c.hasOwnProperty(i)) {
						let m = req.c[i].exports;
						if (m && (typeof m == "object" || typeof m == "function") && filter(m)) return getExport ? m : req.c[i];
						if (m && m.__esModule) {
							for (let j in m) if (m[j] && (typeof m[j] == "object" || typeof m[j] == "function") && filter(m[j])) return getExport ? m[j] : req.c[i];
							if (m.default && (typeof m.default == "object" || typeof m.default == "function")) for (let j in m.default) if (m.default[j] && (typeof m.default[j] == "object" || typeof m.default[j] == "function") && filter(m.default[j])) return getExport ? m.default[j] : req.c[i];
						}
					}
					for (let i in req.m) if (req.m.hasOwnProperty(i)) {
						let m = req.m[i];
						if (m && typeof m == "function" && filter(m)) {
							if (req.c[i]) return getExport ? req.c[i].exports : req.c[i];
							else {
								let resolved = {}, resolved2 = {};
								m(resolved, resolved2, req);
								let trueResolved = resolved2 && BDFDB.ObjectUtils.isEmpty(resolved2) ? resolved : resolved2;
								return getExport ? trueResolved.exports : trueResolved;
							}
						}
					}
				};
				BDFDB.ModuleUtils.findByProperties = function (...properties) {
					properties = properties.flat(10);
					let getExport = properties.pop();
					if (typeof getExport != "boolean") {
						properties.push(getExport);
						getExport = true;
					}
					return InternalBDFDB.findModule("prop", JSON.stringify(properties), m => properties.every(prop => m[prop] !== undefined), getExport);
				};
				BDFDB.ModuleUtils.findByName = function (name, getExport) {
					return InternalBDFDB.findModule("name", JSON.stringify(name), m => m.displayName === name || m.render && m.render.displayName === name, typeof getExport != "boolean" ? true : getExport);
				};
				BDFDB.ModuleUtils.findByString = function (...strings) {
					strings = strings.flat(10);
					let getExport = strings.pop();
					if (typeof getExport != "boolean") {
						strings.push(getExport);
						getExport = true;
					}
					return InternalBDFDB.findModule("string", JSON.stringify(strings), m => strings.every(string => typeof m == "function" && (m.toString().indexOf(string) > -1 || typeof m.__originalMethod == "function" && m.__originalMethod.toString().indexOf(string) > -1 || typeof m.__originalFunction == "function" && m.__originalFunction.toString().indexOf(string) > -1) || BDFDB.ObjectUtils.is(m) && typeof m.type == "function" && m.type.toString().indexOf(string) > -1), getExport);
				};
				BDFDB.ModuleUtils.findByPrototypes = function (...protoProps) {
					protoProps = protoProps.flat(10);
					let getExport = protoProps.pop();
					if (typeof getExport != "boolean") {
						protoProps.push(getExport);
						getExport = true;
					}
					return InternalBDFDB.findModule("proto", JSON.stringify(protoProps), m => m.prototype && protoProps.every(prop => m.prototype[prop] !== undefined), getExport);
				};
				
				InternalBDFDB.forceInitiateProcess = function (pluginDataObjs, instance, type) {
					pluginDataObjs = [pluginDataObjs].flat(10).filter(n => n);
					if (pluginDataObjs.length && instance && type) {
						let forceRender = false;
						for (let pluginData of pluginDataObjs) {
							let plugin = pluginData.plugin == BDFDB && InternalBDFDB || pluginData.plugin, methodNames = [];
							for (let patchType in plugin.patchedModules) {
								if (plugin.patchedModules[patchType][type]) methodNames.push(plugin.patchedModules[patchType][type]);
							}
							methodNames = BDFDB.ArrayUtils.removeCopies(methodNames).flat(10).filter(n => n);
							if (methodNames.includes("componentDidMount")) InternalBDFDB.initiateProcess(plugin, type, {
								instance: instance,
								methodname: "componentDidMount",
								patchtypes: pluginData.patchTypes[type]
							});
							if (methodNames.includes("render")) forceRender = true;
							else if (!forceRender && methodNames.includes("componentDidUpdate")) InternalBDFDB.initiateProcess(plugin, type, {
								instance: instance,
								methodname: "componentDidUpdate",
								patchtypes: pluginData.patchTypes[type]
							});
						}
						if (forceRender) BDFDB.ReactUtils.forceUpdate(instance);
					}
				};
				InternalBDFDB.initiateProcess = function (plugin, type, e) {
					plugin = plugin == BDFDB && InternalBDFDB || plugin;
					if (BDFDB.ObjectUtils.is(plugin) && !plugin.stopping && e.instance) {
						type = LibraryModules.StringUtils.upperCaseFirstChar(type.split(" _ _ ")[1] || type).replace(/[^A-z0-9]|_/g, "");
						if (typeof plugin[`process${type}`] == "function") {
							if (typeof e.methodname == "string" && (e.methodname.indexOf("componentDid") == 0 || e.methodname.indexOf("componentWill") == 0)) {
								e.node = BDFDB.ReactUtils.findDOMNode(e.instance);
								if (e.node) return plugin[`process${type}`](e);
								else BDFDB.TimeUtils.timeout(_ => {
									e.node = BDFDB.ReactUtils.findDOMNode(e.instance);
									if (e.node) return plugin[`process${type}`](e);
								});
							}
							else if (e.returnvalue || e.patchtypes.includes("before")) return plugin[`process${type}`](e);
						}
					}
				};
				InternalBDFDB.patchObserverData = {observer: null, data: {}};
				InternalBDFDB.patchPlugin = function (plugin) {
					plugin = plugin == BDFDB && InternalBDFDB || plugin;
					if (!BDFDB.ObjectUtils.is(plugin) || !BDFDB.ObjectUtils.is(plugin.patchedModules)) return;
					BDFDB.PatchUtils.unpatch(plugin);
					let patchedModules = {};
					for (let patchType in plugin.patchedModules) for (let type in plugin.patchedModules[patchType]) {
						if (!patchedModules[type]) patchedModules[type] = {};
						patchedModules[type][patchType] = plugin.patchedModules[patchType][type];
					}
					for (let type in patchedModules) {
						let pluginData = {plugin: plugin, patchTypes: patchedModules[type]};
						let unmappedType = type.split(" _ _ ")[1] || type;
						
						let config = {
							classNames: [InternalData.ModuleUtilsConfig.Finder[unmappedType] && InternalData.ModuleUtilsConfig.Finder[unmappedType].class].flat(10).filter(n => DiscordClasses[n]),
							stringFind: InternalData.ModuleUtilsConfig.Finder[unmappedType] && InternalData.ModuleUtilsConfig.Finder[unmappedType].strings,
							propertyFind: InternalData.ModuleUtilsConfig.Finder[unmappedType] && InternalData.ModuleUtilsConfig.Finder[unmappedType].props,
							specialFilter: InternalData.ModuleUtilsConfig.Finder[unmappedType] && InternalData.ModuleUtilsConfig.Finder[unmappedType].special && InternalBDFDB.createFilter(InternalData.ModuleUtilsConfig.Finder[unmappedType].special),
							forceObserve: InternalData.ModuleUtilsConfig.ForceObserve.includes(unmappedType),
							exported: InternalData.ModuleUtilsConfig.Finder[unmappedType] && InternalData.ModuleUtilsConfig.Finder[unmappedType].exported || false,
							mapped: InternalData.ModuleUtilsConfig.PatchMap[type]
						};
						config.nonRender = config.specialFilter || BDFDB.ObjectUtils.toArray(pluginData.patchTypes).flat(10).filter(n => n && !InternalData.ModuleUtilsConfig.InstanceFunctions.includes(n)).length > 0;
						config.nonPrototype = !!(config.codeFind || config.propertyFind || config.nonRender);
						
						let component = InternalData.ModuleUtilsConfig.LoadedInComponents[type] && BDFDB.ObjectUtils.get(InternalComponents, InternalData.ModuleUtilsConfig.LoadedInComponents[type]);
						if (component) InternalBDFDB.patchComponent(pluginData, config.nonRender ? (BDFDB.ModuleUtils.find(m => m == component, config.exported) || {}).exports : component, type, config);
						else {
							let mappedType = config.mapped ? config.mapped + " _ _ " + type : type;
							let name = mappedType.split(" _ _ ")[0];
							if (config.mapped) {
								for (let patchType in plugin.patchedModules) if (plugin.patchedModules[patchType][type]) {
									plugin.patchedModules[patchType][mappedType] = plugin.patchedModules[patchType][type];
									delete plugin.patchedModules[patchType][type];
								}
							}
							
							let patchSpecial = (func, argument) => {
								let module = BDFDB.ModuleUtils[func](argument, config.exported);
								let exports = module && !config.exported && module.exports || module;
								exports && InternalBDFDB.patchComponent(pluginData, InternalBDFDB.isMemo(exports) ? exports.default : exports, mappedType, config);
							};
							if (config.classNames.length) InternalBDFDB.checkForInstance(pluginData, mappedType, config);
							else if (config.stringFind) patchSpecial("findByString", config.stringFind);
							else if (config.propertyFind) patchSpecial("findByProperties", config.propertyFind);
							else if (config.nonRender) patchSpecial("findByName", name);
							else InternalBDFDB.patchComponent(pluginData, BDFDB.ModuleUtils.findByName(name), mappedType, config);
						}
					}
				};
				InternalBDFDB.patchComponent = function (pluginDataObjs, instance, type, config) {
					pluginDataObjs = [pluginDataObjs].flat(10).filter(n => n);
					if (pluginDataObjs.length && instance) {
						let name = type.split(" _ _ ")[0];
						instance = instance[BDFDB.ReactUtils.instanceKey] && instance[BDFDB.ReactUtils.instanceKey].type ? instance[BDFDB.ReactUtils.instanceKey].type : instance;
						instance = config.nonPrototype || BDFDB.ReactUtils.isCorrectInstance(instance, name) || InternalData.ModuleUtilsConfig.LoadedInComponents[type] ? instance : (BDFDB.ReactUtils.findConstructor(instance, name) || BDFDB.ReactUtils.findConstructor(instance, name, {up: true}));
						if (instance) {
							instance = instance[BDFDB.ReactUtils.instanceKey] && instance[BDFDB.ReactUtils.instanceKey].type ? instance[BDFDB.ReactUtils.instanceKey].type : instance;
							let toBePatched = config.nonPrototype || !instance.prototype ? instance : instance.prototype;
							toBePatched = toBePatched && toBePatched.type && typeof toBePatched.type.render == "function" ? toBePatched.type : toBePatched;
							for (let pluginData of pluginDataObjs) for (let patchType in pluginData.patchTypes) {
								let patchMethods = {};
								patchMethods[patchType] = e => {
									return InternalBDFDB.initiateProcess(pluginData.plugin, type, {
										instance: e.thisObject,
										returnvalue: e.returnValue,
										methodname: e.originalMethodName,
										patchtypes: [patchType]
									});
								};
								BDFDB.PatchUtils.patch(pluginData.plugin, toBePatched, pluginData.patchTypes[patchType], patchMethods, {name});
							}
						}
					}
				};
				InternalBDFDB.createFilter = function (config) {
					return ins => ins && config.every(prop => {
						let value = BDFDB.ObjectUtils.get(ins, prop.path);
						return value && (!prop.value || [prop.value].flat(10).filter(n => typeof n == "string").some(n => value.toUpperCase().indexOf(n.toUpperCase()) == 0));
					}) && ins.return.type;
				};
				InternalBDFDB.isMemo = function (exports) {
					return exports && exports.default && typeof exports.default.$$typeof == "symbol" && (exports.default.$$typeof.toString() || "").indexOf("memo") > -1
				};
				InternalBDFDB.checkEle = function (pluginDataObjs, ele, type, config) {
					pluginDataObjs = [pluginDataObjs].flat(10).filter(n => n);
					let unmappedType = type.split(" _ _ ")[1] || type;
					let ins = BDFDB.ReactUtils.getInstance(ele);
					if (typeof config.specialFilter == "function") {
						let component = config.specialFilter(ins);
						if (component) {
							if (config.nonRender) {
								let exports = (BDFDB.ModuleUtils.find(m => m == component, false) || {}).exports;
								InternalBDFDB.patchComponent(pluginDataObjs, InternalBDFDB.isMemo(exports) ? exports.default : exports, type, config);
							}
							else InternalBDFDB.patchComponent(pluginDataObjs, component, type, config);
							BDFDB.PatchUtils.forceAllUpdates(pluginDataObjs.map(n => n.plugin), type);
							return true;
						}
					}
					else if (InternalBDFDB.isCorrectPatchInstance(ins, type)) {
						InternalBDFDB.patchComponent(pluginDataObjs, ins, type, config);
						BDFDB.PatchUtils.forceAllUpdates(pluginDataObjs.map(n => n.plugin), type);
						return true;
					}
					return false;
				};
				InternalBDFDB.checkForInstance = function (pluginData, type, config) {
					const app = document.querySelector(BDFDB.dotCN.app), bdSettings = document.querySelector("#bd-settingspane-container .scroller");
					let instanceFound = false;
					if (!config.forceObserve) {
						if (app) {
							let appIns = BDFDB.ReactUtils.findConstructor(app, type, {unlimited: true}) || BDFDB.ReactUtils.findConstructor(app, type, {unlimited: true, up: true});
							if (appIns && (instanceFound = true)) InternalBDFDB.patchComponent(pluginData, appIns, type, config);
						}
						if (!instanceFound && bdSettings) {
							let bdSettingsIns = BDFDB.ReactUtils.findConstructor(bdSettings, type, {unlimited: true});
							if (bdSettingsIns && (instanceFound = true)) InternalBDFDB.patchComponent(pluginData, bdSettingsIns, type, config);
						}
					}
					if (!instanceFound) {
						let elementFound = false, classes = config.classNames.map(n => BDFDB.disCN[n]), selector = config.classNames.map(n => BDFDB.dotCN[n]).join(", ");
						for (let ele of document.querySelectorAll(selector)) {
							elementFound = InternalBDFDB.checkEle(pluginData, ele, type, config);
							if (elementFound) break;
						}
						if (!elementFound) {
							if (!InternalBDFDB.patchObserverData.observer) {
								let appMount = document.querySelector(BDFDB.dotCN.appmount);
								if (appMount) {
									InternalBDFDB.patchObserverData.observer = new MutationObserver(cs => {cs.forEach(c => {c.addedNodes.forEach(n => {
										if (!n || !n.tagName) return;
										for (let type in InternalBDFDB.patchObserverData.data) if (!InternalBDFDB.patchObserverData.data[type].found) {
											let ele = null;
											if ((ele = BDFDB.DOMUtils.containsClass(n, ...InternalBDFDB.patchObserverData.data[type].classes) ? n : n.querySelector(InternalBDFDB.patchObserverData.data[type].selector)) != null) {
												InternalBDFDB.patchObserverData.data[type].found = InternalBDFDB.checkEle(InternalBDFDB.patchObserverData.data[type].plugins, ele, type, InternalBDFDB.patchObserverData.data[type].config);
												if (InternalBDFDB.patchObserverData.data[type].found) {
													delete InternalBDFDB.patchObserverData.data[type];
													if (BDFDB.ObjectUtils.isEmpty(InternalBDFDB.patchObserverData.data)) {
														InternalBDFDB.patchObserverData.observer.disconnect();
														InternalBDFDB.patchObserverData.observer = null;
													}
												}
											}
										}
									});});});
									InternalBDFDB.patchObserverData.observer.observe(appMount, {childList: true, subtree: true});
								}
							}
							if (!InternalBDFDB.patchObserverData.data[type]) InternalBDFDB.patchObserverData.data[type] = {selector, classes, found: false, config, plugins: []};
							InternalBDFDB.patchObserverData.data[type].plugins.push(pluginData);
						}
					}
				};
				
				InternalBDFDB.isCorrectPatchInstance = function (instance, name) {
					if (!instance) return false;
					instance = instance[BDFDB.ReactUtils.instanceKey] && instance[BDFDB.ReactUtils.instanceKey].type ? instance[BDFDB.ReactUtils.instanceKey].type : instance;
					instance = BDFDB.ReactUtils.isCorrectInstance(instance, name) ? instance : (BDFDB.ReactUtils.findConstructor(instance, name) || BDFDB.ReactUtils.findConstructor(instance, name, {up: true}));
					return !!instance;
				};
				
				BDFDB.PatchUtils = {};
				BDFDB.PatchUtils.isPatched = function (plugin, module, methodName) {
					plugin = plugin == BDFDB && InternalBDFDB || plugin;
					if (!plugin || !BDFDB.ObjectUtils.is(module) || !module.BDFDB_patches || !methodName) return false;
					const pluginId = (typeof plugin === "string" ? plugin : plugin.name).toLowerCase();
					return pluginId && module[methodName] && module[methodName].__is_BDFDB_patched && module.BDFDB_patches[methodName] && BDFDB.ObjectUtils.toArray(module.BDFDB_patches[methodName]).some(patchObj => BDFDB.ObjectUtils.toArray(patchObj).some(priorityObj => Object.keys(priorityObj).includes(pluginId)));
				};
				BDFDB.PatchUtils.patch = function (plugin, module, methodNames, patchMethods, config = {}) {
					plugin = plugin == BDFDB && InternalBDFDB || plugin;
					if (!plugin || !BDFDB.ObjectUtils.is(module) || !methodNames || !BDFDB.ObjectUtils.is(patchMethods)) return null;
					patchMethods = BDFDB.ObjectUtils.filter(patchMethods, type => InternalData.ModuleUtilsConfig.PatchTypes.includes(type), true);
					if (BDFDB.ObjectUtils.isEmpty(patchMethods)) return null;
					const pluginName = (typeof plugin === "string" ? plugin : plugin.name) || "";
					const pluginVersion = typeof plugin === "string" ? "" : plugin.version;
					const pluginId = pluginName.toLowerCase();
					let patchPriority = !isNaN(config.priority) ? config.priority : (BDFDB.ObjectUtils.is(plugin) && !isNaN(plugin.patchPriority) ? plugin.patchPriority : 5);
					patchPriority = patchPriority < 1 ? (plugin == InternalBDFDB ? 0 : 1) : (patchPriority > 9 ? (plugin == InternalBDFDB ? 10 : 9) : Math.round(patchPriority));
					if (!BDFDB.ObjectUtils.is(module.BDFDB_patches)) module.BDFDB_patches = {};
					methodNames = [methodNames].flat(10).filter(n => n);
					let cancel = _ => {BDFDB.PatchUtils.unpatch(plugin, module, methodNames);};
					for (let methodName of methodNames) if (module[methodName] == null || typeof module[methodName] == "function") {
						if (!module.BDFDB_patches[methodName] || config.force && (!module[methodName] || !module[methodName].__is_BDFDB_patched)) {
							if (!module.BDFDB_patches[methodName]) {
								module.BDFDB_patches[methodName] = {};
								for (let type of InternalData.ModuleUtilsConfig.PatchTypes) module.BDFDB_patches[methodName][type] = {};
							}
							if (!module[methodName]) module[methodName] = (_ => {});
							const name = config.name || (module.constructor ? (module.constructor.displayName || module.constructor.name) : "module");
							const originalMethod = module[methodName];
							module.BDFDB_patches[methodName].originalMethod = originalMethod;
							module[methodName] = function () {
								let callInstead = false, stopCall = false;
								const data = {
									thisObject: this && this !== window ? this : {props: arguments[0]},
									methodArguments: arguments,
									originalMethod: originalMethod,
									originalMethodName: methodName,
									callOriginalMethod: _ => {if (!stopCall) data.returnValue = data.originalMethod.apply(data.thisObject, data.methodArguments)},
									callOriginalMethodAfterwards: _ => {callInstead = true;},
									stopOriginalMethodCall: _ => {stopCall = true;}
								};
								if (module.BDFDB_patches && module.BDFDB_patches[methodName]) {
									for (let priority in module.BDFDB_patches[methodName].before) for (let id in BDFDB.ObjectUtils.sort(module.BDFDB_patches[methodName].before[priority])) {
										BDFDB.TimeUtils.suppress(module.BDFDB_patches[methodName].before[priority][id], `"before" callback of ${methodName} in ${name}`, {name: module.BDFDB_patches[methodName].before[priority][id].pluginName, version: module.BDFDB_patches[methodName].before[priority][id].pluginVersion})(data);
									}
									
									if (!module.BDFDB_patches || !module.BDFDB_patches[methodName]) return (methodName == "render" || methodName == "default") && data.returnValue === undefined ? null : data.returnValue;
									let hasInsteadPatches = BDFDB.ObjectUtils.toArray(module.BDFDB_patches[methodName].instead).some(priorityObj => !BDFDB.ObjectUtils.isEmpty(priorityObj));
									if (hasInsteadPatches) for (let priority in module.BDFDB_patches[methodName].instead) for (let id in BDFDB.ObjectUtils.sort(module.BDFDB_patches[methodName].instead[priority])) if (module.BDFDB_patches) {
										let tempReturn = BDFDB.TimeUtils.suppress(module.BDFDB_patches[methodName].instead[priority][id], `"instead" callback of ${methodName} in ${name}`, {name: module.BDFDB_patches[methodName].instead[priority][id].pluginName, version: module.BDFDB_patches[methodName].instead[priority][id].pluginVersion})(data);
										if (tempReturn !== undefined) data.returnValue = tempReturn;
									}
									if ((!hasInsteadPatches || callInstead) && !stopCall) BDFDB.TimeUtils.suppress(data.callOriginalMethod, `originalMethod of ${methodName} in ${name}`, {name: "Discord"})();
									
									if (!module.BDFDB_patches || !module.BDFDB_patches[methodName]) return methodName == "render" && data.returnValue === undefined ? null : data.returnValue;
									for (let priority in module.BDFDB_patches[methodName].after) for (let id in BDFDB.ObjectUtils.sort(module.BDFDB_patches[methodName].after[priority])) if (module.BDFDB_patches) {
										let tempReturn = BDFDB.TimeUtils.suppress(module.BDFDB_patches[methodName].after[priority][id], `"after" callback of ${methodName} in ${name}`, {name: module.BDFDB_patches[methodName].after[priority][id].pluginName, version: module.BDFDB_patches[methodName].after[priority][id].pluginVersion})(data);
										if (tempReturn !== undefined) data.returnValue = tempReturn;
									}
								}
								else BDFDB.TimeUtils.suppress(data.callOriginalMethod, `originalMethod of ${methodName} in ${name}`)();
								callInstead = false, stopCall = false;
								return (methodName == "render" || methodName == "default") && data.returnValue === undefined ? null : data.returnValue;
							};
							for (let key of Object.keys(originalMethod)) module[methodName][key] = originalMethod[key];
							if (!module[methodName].__originalFunction) {
								let realOriginalMethod = originalMethod.__originalMethod || originalMethod.__originalFunction || originalMethod;
								if (typeof realOriginalMethod == "function") {
									module[methodName].__originalFunction = realOriginalMethod;
									module[methodName].toString = _ => realOriginalMethod.toString();
								}
							}
							module[methodName].__is_BDFDB_patched = true;
						}
						for (let type in patchMethods) if (typeof patchMethods[type] == "function") {
							if (!BDFDB.ObjectUtils.is(module.BDFDB_patches[methodName][type][patchPriority])) module.BDFDB_patches[methodName][type][patchPriority] = {};
							module.BDFDB_patches[methodName][type][patchPriority][pluginId] = (...args) => {
								if (config.once || !plugin.started) cancel();
								return patchMethods[type](...args);
							};
							module.BDFDB_patches[methodName][type][patchPriority][pluginId].pluginName = pluginName;
							module.BDFDB_patches[methodName][type][patchPriority][pluginId].pluginVersion = pluginVersion;
						}
					}
					if (BDFDB.ObjectUtils.is(plugin) && !config.once && !config.noCache) {
						if (!BDFDB.ArrayUtils.is(plugin.patchCancels)) plugin.patchCancels = [];
						plugin.patchCancels.push(cancel);
					}
					return cancel;
				};
				BDFDB.PatchUtils.unpatch = function (plugin, module, methodNames) {
					plugin = plugin == BDFDB && InternalBDFDB || plugin;
					if (!module && !methodNames) {
						if (BDFDB.ObjectUtils.is(plugin) && BDFDB.ArrayUtils.is(plugin.patchCancels)) while (plugin.patchCancels.length) (plugin.patchCancels.pop())();
					}
					else {
						if (!BDFDB.ObjectUtils.is(module) || !module.BDFDB_patches) return;
						const pluginId = !plugin ? null : (typeof plugin === "string" ? plugin : plugin.name).toLowerCase();
						if (methodNames) {
							for (let methodName of [methodNames].flat(10).filter(n => n)) if (module[methodName] && module.BDFDB_patches[methodName]) unpatch(methodName, pluginId);
						}
						else for (let patchedMethod of module.BDFDB_patches) unpatch(patchedMethod, pluginId);
					}
					function unpatch (funcName, pluginId) {
						for (let type of InternalData.ModuleUtilsConfig.PatchTypes) {
							if (pluginId) for (let priority in module.BDFDB_patches[funcName][type]) {
								delete module.BDFDB_patches[funcName][type][priority][pluginId];
								if (BDFDB.ObjectUtils.isEmpty(module.BDFDB_patches[funcName][type][priority])) delete module.BDFDB_patches[funcName][type][priority];
							}
							else delete module.BDFDB_patches[funcName][type];
						}
						if (BDFDB.ObjectUtils.isEmpty(BDFDB.ObjectUtils.filter(module.BDFDB_patches[funcName], key => InternalData.ModuleUtilsConfig.PatchTypes.includes(key) && !BDFDB.ObjectUtils.isEmpty(module.BDFDB_patches[funcName][key]), true))) {
							module[funcName] = module.BDFDB_patches[funcName].originalMethod;
							delete module.BDFDB_patches[funcName];
							if (BDFDB.ObjectUtils.isEmpty(module.BDFDB_patches)) delete module.BDFDB_patches;
						}
					}
				};
				BDFDB.PatchUtils.forceAllUpdates = function (plugins, selectedTypes) {
					plugins = [plugins].flat(10).map(n => n == BDFDB && InternalBDFDB || n).filter(n => BDFDB.ObjectUtils.is(n.patchedModules));
					if (plugins.length) {
						const app = document.querySelector(BDFDB.dotCN.app);
						const bdSettings = document.querySelector("#bd-settingspane-container > *");
						if (app) {
							selectedTypes = [selectedTypes].flat(10).filter(n => n).map(type => type && InternalData.ModuleUtilsConfig.PatchMap[type] ? InternalData.ModuleUtilsConfig.PatchMap[type] + " _ _ " + type : type);
							let updateData = {};
							for (let plugin of plugins) {
								updateData[plugin.name] = {
									filteredModules: [],
									specialModules: [],
									specialModuleTypes: [],
									patchTypes: {}
								};
								for (let patchType in plugin.patchedModules) for (let type in plugin.patchedModules[patchType]) {
									let methodNames = [plugin.patchedModules[patchType][type]].flat(10).filter(n => n);
									if (BDFDB.ArrayUtils.includes(methodNames, "componentDidMount", "componentDidUpdate", "render", false) && (!selectedTypes.length || selectedTypes.includes(type))) {
										let unmappedType = type.split(" _ _ ")[1] || type;
										let selector = [InternalData.ModuleUtilsConfig.Finder[unmappedType]].flat(10).filter(n => DiscordClasses[n]).map(n => BDFDB.dotCN[n]).join(", ");
										let specialFilter = InternalData.ModuleUtilsConfig.Finder[unmappedType] && InternalData.ModuleUtilsConfig.Finder[unmappedType].special && InternalBDFDB.createFilter(InternalData.ModuleUtilsConfig.Finder[unmappedType].special);
										if (selector && typeof specialFilter == "function") {
											for (let ele of document.querySelectorAll(selector)) {
												let constro = specialFilter(BDFDB.ReactUtils.getInstance(ele));
												if (constro) {
													updateData[plugin.name].specialModules.push([type, constro]);
													updateData[plugin.name].specialModuleTypes.push(type);
													break;
												}
											}
										}
										else updateData[plugin.name].filteredModules.push(type);
										let name = type.split(" _ _ ")[0];
										if (!updateData[plugin.name].patchTypes[name]) updateData[plugin.name].patchTypes[name] = [];
										updateData[plugin.name].patchTypes[name].push(patchType);
									}
								}
							}
							let updateDataArray = BDFDB.ObjectUtils.toArray(updateData);
							if (BDFDB.ArrayUtils.sum(updateDataArray.map(n => n.filteredModules.length + n.specialModules.length))) {
								try {
									let filteredModules = BDFDB.ArrayUtils.removeCopies(updateDataArray.map(n => n.filteredModules).flat(10));
									let specialModules = BDFDB.ArrayUtils.removeCopies(updateDataArray.map(n => n.specialModules).flat(10));
									const appInsDown = BDFDB.ReactUtils.findOwner(app, {name: filteredModules, type: specialModules, all: true, unlimited: true, group: true});
									const appInsUp = BDFDB.ReactUtils.findOwner(app, {name: filteredModules, type: specialModules, all: true, unlimited: true, group: true, up: true});
									for (let type in appInsDown) {
										let filteredPlugins = plugins.filter(n => updateData[n.name].filteredModules.includes(type) || updateData[n.name].specialModuleTypes.includes(type)).map(n => ({plugin: n, patchTypes: updateData[n.name].patchTypes}));
										for (let ins of appInsDown[type]) InternalBDFDB.forceInitiateProcess(filteredPlugins, ins, type);
									}
									for (let type in appInsUp) {
										let filteredPlugins = plugins.filter(n => updateData[n.name].filteredModules.includes(type) || updateData[n.name].specialModuleTypes.includes(type)).map(n => ({plugin: n, patchTypes: updateData[n.name].patchTypes}));
										for (let ins of appInsUp[type]) InternalBDFDB.forceInitiateProcess(filteredPlugins, ins, type);
									}
									if (bdSettings) {
										const bdSettingsIns = BDFDB.ReactUtils.findOwner(bdSettings, {name: filteredModules, type: specialModules, all: true, unlimited: true});
										if (bdSettingsIns.length) {
											const bdSettingsWrap = BDFDB.ReactUtils.findOwner(BDFDB.ReactUtils.getInstance(document.querySelector("#bd-settingspane-container > *")), {props: "onChange", up: true});
											if (bdSettingsWrap && bdSettingsWrap.props && typeof bdSettingsWrap.props.onChange == "function") bdSettingsWrap.props.onChange(bdSettingsWrap.props.type);
										}
									}
								}
								catch (err) {for (let plugin of plugins) BDFDB.LogUtils.error(["Could not force update Components!", err], plugin);}
							}
						}
					}
				};

				BDFDB.DiscordConstants = BDFDB.ModuleUtils.findByProperties("Permissions", "ActivityTypes");
			
				for (let name in InternalData.DiscordObjects) {
					if (InternalData.DiscordObjects[name].props) DiscordObjects[name] = BDFDB.ModuleUtils.findByPrototypes(InternalData.DiscordObjects[name].props);
					else if (InternalData.DiscordObjects[name].protos) DiscordObjects[name] = BDFDB.ModuleUtils.find(m => m.prototype && InternalData.DiscordObjects[name].protos.every(proto => m.prototype[proto] && (!InternalData.DiscordObjects[name].array || Array.isArray(m.prototype[proto]))));
				}
				BDFDB.DiscordObjects = Object.assign({}, DiscordObjects);
				
				for (let name of InternalData.LibraryRequires) {
					try {LibraryRequires[name] = require(name);} catch (err) {}
				}
				BDFDB.LibraryRequires = Object.assign({}, LibraryRequires);
				
				for (let name in InternalData.LibraryModules) {
					if (InternalData.LibraryModules[name].props) {
						if (InternalData.LibraryModules[name].nonProps) LibraryModules[name] = BDFDB.ModuleUtils.find(m => InternalData.LibraryModules[name].props.every(prop => typeof m[prop] == "function") && InternalData.LibraryModules[name].nonProps.every(prop => typeof m[prop] != "function"));
						else LibraryModules[name] = BDFDB.ModuleUtils.findByProperties(InternalData.LibraryModules[name].props);
					}
					else if (InternalData.LibraryModules[name].strings) LibraryModules[name] = BDFDB.ModuleUtils.findByString(InternalData.LibraryModules[name].strings);
					if (InternalData.LibraryModules[name].value) LibraryModules[name] = (LibraryModules[name] || {})[InternalData.LibraryModules[name].value];
				}
				if (LibraryModules.KeyCodeUtils) LibraryModules.KeyCodeUtils.getString = function (keyArray) {
					return LibraryModules.KeyCodeUtils.toString([keyArray].flat(10).filter(n => n).map(keyCode => [BDFDB.DiscordConstants.KeyboardDeviceTypes.KEYBOARD_KEY, LibraryModules.KeyCodeUtils.keyToCode((Object.entries(LibraryModules.KeyEvents.codes).find(n => n[1] == keyCode && LibraryModules.KeyCodeUtils.keyToCode(n[0], null)) || [])[0], null) || keyCode]), true);
				};
				BDFDB.LibraryModules = Object.assign({}, LibraryModules);
				
				LibraryModules.React = BDFDB.ModuleUtils.findByProperties("createElement", "cloneElement");
				LibraryModules.ReactDOM = BDFDB.ModuleUtils.findByProperties("render", "findDOMNode");
				
				BDFDB.ReactUtils = Object.assign({}, LibraryModules.React, LibraryModules.ReactDOM);
				BDFDB.ReactUtils.childrenToArray = function (parent) {
					if (parent && parent.props && parent.props.children && !BDFDB.ArrayUtils.is(parent.props.children)) {
						var child = parent.props.children;
						parent.props.children = [];
						parent.props.children.push(child);
					}
					return parent.props.children;
				}
				BDFDB.ReactUtils.createElement = function (component, props = {}, errorWrap = false) {
					if (component && component.defaultProps) for (let key in component.defaultProps) if (props[key] == null) props[key] = component.defaultProps[key];
					try {
						let child = LibraryModules.React.createElement(component || "div", props) || null;
						if (errorWrap) return LibraryModules.React.createElement(InternalComponents.ErrorBoundary, {}, child) || null;
						else return child;
					}
					catch (err) {BDFDB.LogUtils.error(["Could not create React Element!", err]);}
					return null;
				};
				BDFDB.ReactUtils.objectToReact = function (obj) {
					if (!obj) return null;
					else if (typeof obj == "string") return obj;
					else if (BDFDB.ObjectUtils.is(obj)) return BDFDB.ReactUtils.createElement(obj.type || obj.props && obj.props.href && "a" || "div", !obj.props ?  {} : Object.assign({}, obj.props, {
						children: obj.props.children ? BDFDB.ReactUtils.objectToReact(obj.props.children) : null
					}));
					else if (BDFDB.ArrayUtils.is(obj)) return obj.map(n => BDFDB.ReactUtils.objectToReact(n));
					else return null;
				};
				BDFDB.ReactUtils.markdownParse = function (str) {
					if (!BDFDB.ReactUtils.markdownParse.parser || !BDFDB.ReactUtils.markdownParse.render) {
						BDFDB.ReactUtils.markdownParse.parser = LibraryModules.SimpleMarkdownParser.parserFor(LibraryModules.SimpleMarkdownParser.defaultRules);
						BDFDB.ReactUtils.markdownParse.render = LibraryModules.SimpleMarkdownParser.reactFor(LibraryModules.SimpleMarkdownParser.ruleOutput(LibraryModules.SimpleMarkdownParser.defaultRules, "react"));
					}
					return BDFDB.ReactUtils.markdownParse.render(BDFDB.ReactUtils.markdownParse.parser(str, {inline: true}));
				};
				BDFDB.ReactUtils.elementToReact = function (node, ref) {
					if (BDFDB.ReactUtils.isValidElement(node)) return node;
					else if (!Node.prototype.isPrototypeOf(node)) return null;
					else if (node.nodeType == Node.TEXT_NODE) return node.nodeValue;
					let attributes = {}, importantStyles = [];
					if (typeof ref == "function") attributes.ref = ref;
					for (let attr of node.attributes) attributes[attr.name] = attr.value;
					if (node.attributes.style) attributes.style = BDFDB.ObjectUtils.filter(node.style, n => node.style[n] && isNaN(parseInt(n)), true);
					attributes.children = [];
					if (node.style && node.style.cssText) for (let propStr of node.style.cssText.split(";")) if (propStr.endsWith("!important")) {
						let key = propStr.split(":")[0];
						let camelprop = key.replace(/-([a-z]?)/g, (m, g) => g.toUpperCase());
						if (attributes.style[camelprop] != null) importantStyles.push(key);
					}
					for (let child of node.childNodes) attributes.children.push(BDFDB.ReactUtils.elementToReact(child));
					attributes.className = BDFDB.DOMUtils.formatClassName(attributes.className, attributes.class);
					delete attributes.class;
					return BDFDB.ReactUtils.forceStyle(BDFDB.ReactUtils.createElement(node.tagName, attributes), importantStyles);
				};
				BDFDB.ReactUtils.forceStyle = function (reactEle, styles) {
					if (!BDFDB.ReactUtils.isValidElement(reactEle)) return null;
					if (!BDFDB.ObjectUtils.is(reactEle.props.style) || !BDFDB.ArrayUtils.is(styles) || !styles.length) return reactEle;
					let ref = reactEle.ref;
					reactEle.ref = instance => {
						if (typeof ref == "function") ref(instance);
						let node = BDFDB.ReactUtils.findDOMNode(instance);
						if (Node.prototype.isPrototypeOf(node)) for (let key of styles) {
							let propValue = reactEle.props.style[key.replace(/-([a-z]?)/g, (m, g) => g.toUpperCase())];
							if (propValue != null) node.style.setProperty(key, propValue, "important");
						}
					};
					return reactEle;
				};
				BDFDB.ReactUtils.findChild = function (nodeOrInstance, config) {
					if (!nodeOrInstance || !BDFDB.ObjectUtils.is(config) || !config.name && !config.key && !config.props && !config.filter) return config.all ? [] : null;
					let instance = Node.prototype.isPrototypeOf(nodeOrInstance) ? BDFDB.ReactUtils.getInstance(nodeOrInstance) : nodeOrInstance;
					if (!BDFDB.ObjectUtils.is(instance) && !BDFDB.ArrayUtils.is(instance)) return null;
					config.name = config.name && [config.name].flat().filter(n => n);
					config.key = config.key && [config.key].flat().filter(n => n);
					config.props = config.props && [config.props].flat().filter(n => n);
					config.filter = typeof config.filter == "function" && config.filter;
					let depth = -1;
					let start = performance.now();
					let maxDepth = config.unlimited ? 999999999 : (config.depth === undefined ? 30 : config.depth);
					let maxTime = config.unlimited ? 999999999 : (config.time === undefined ? 150 : config.time);
					
					let foundChildren = [];
					let singleChild = getChild(instance);
					if (config.all) {
						for (let i in foundChildren) delete foundChildren[i].BDFDBreactSearch;
						return foundChildren;
					}
					else return singleChild;
					
					function getChild (children) {
						let result = null;
						if (!children || depth >= maxDepth || performance.now() - start >= maxTime) return result;
						if (!BDFDB.ArrayUtils.is(children)) {
							if (check(children)) {
								if (config.all === undefined || !config.all) result = children;
								else if (config.all) {
									if (!children.BDFDBreactSearch) {
										children.BDFDBreactSearch = true;
										foundChildren.push(children);
									}
								}
							}
							else if (children.props && children.props.children) {
								depth++;
								result = getChild(children.props.children);
								depth--;
							}
						}
						else {
							for (let child of children) if (child) {
								if (BDFDB.ArrayUtils.is(child)) result = getChild(child);
								else if (check(child)) {
									if (config.all === undefined || !config.all) result = child;
									else if (config.all) {
										if (!child.BDFDBreactSearch) {
											child.BDFDBreactSearch = true;
											foundChildren.push(child);
										}
									}
								}
								else if (child.props && child.props.children) {
									depth++;
									result = getChild(child.props.children);
									depth--;
								}
								if (result) break;
							}
						}
						return result;
					}
					function check (instance) {
						if (!instance) return false;
						let props = instance.stateNode ? instance.stateNode.props : instance.props;
						return instance.type && config.name && config.name.some(name => BDFDB.ReactUtils.isCorrectInstance(instance, name)) || config.key && config.key.some(key => instance.key == key) || props && config.props && config.props[config.someProps ? "some" : "every"](prop => BDFDB.ArrayUtils.is(prop) ? (BDFDB.ArrayUtils.is(prop[1]) ? prop[1].some(checkValue => propCheck(props, prop[0], checkValue)) : propCheck(props, prop[0], prop[1])) : props[prop] !== undefined) || config.filter && config.filter(instance);
					}
					function propCheck (props, key, value) {
						return key != null && props[key] != null && value != null && (key == "className" ? (" " + props[key] + " ").indexOf(" " + value + " ") > -1 : BDFDB.equals(props[key], value));
					}
				};
				BDFDB.ReactUtils.setChild = function (parent, stringOrChild) {
					if (!BDFDB.ReactUtils.isValidElement(parent) || (!BDFDB.ReactUtils.isValidElement(stringOrChild) && typeof stringOrChild != "string" && !BDFDB.ArrayUtils.is(stringOrChild))) return;
					let set = false;
					checkParent(parent);
					function checkParent(child) {
						if (set) return;
						if (!BDFDB.ArrayUtils.is(child)) checkChild(child);
						else for (let subChild of child) checkChild(subChild);
					}
					function checkChild(child) {
						if (!BDFDB.ReactUtils.isValidElement(child)) return;
						if (BDFDB.ReactUtils.isValidElement(child.props.children)) checkParent(child.props.children);
						else if (BDFDB.ArrayUtils.is(child.props.children)) {
							if (child.props.children.every(c => !c || typeof c == "string")) {
								set = true;
								child.props.children = [stringOrChild].flat(10);
							}
							else checkParent(child.props.children);
						}
						else {
							set = true;
							child.props.children = stringOrChild;
						}
					}
				};
				BDFDB.ReactUtils.findConstructor = function (nodeOrInstance, types, config = {}) {
					if (!BDFDB.ObjectUtils.is(config)) return null;
					if (!nodeOrInstance || !types) return config.all ? (config.group ? {} : []) : null;
					let instance = Node.prototype.isPrototypeOf(nodeOrInstance) ? BDFDB.ReactUtils.getInstance(nodeOrInstance) : nodeOrInstance;
					if (!BDFDB.ObjectUtils.is(instance)) return config.all ? (config.group ? {} : []) : null;
					types = types && [types].flat(10).filter(n => typeof n == "string");
					if (!types.length) return config.all ? (config.group ? {} : []) : null;;
					let depth = -1;
					let start = performance.now();
					let maxDepth = config.unlimited ? 999999999 : (config.depth === undefined ? 30 : config.depth);
					let maxTime = config.unlimited ? 999999999 : (config.time === undefined ? 150 : config.time);
					let whitelist = config.up ? {
						return: true,
						sibling: true,
						default: true
					} : {
						child: true,
						sibling: true,
						default: true
					};
					whitelist[BDFDB.ReactUtils.instanceKey] = true;
					
					let foundConstructors = config.group ? {} : [];
					let singleConstructor = getConstructor(instance);
					if (config.all) {
						for (let i in foundConstructors) {
							if (config.group) for (let j in foundConstructors[i]) delete foundConstructors[i][j].BDFDBreactSearch;
							else delete foundConstructors[i].BDFDBreactSearch;
						}
						return foundConstructors;
					}
					else return singleConstructor;

					function getConstructor (instance) {
						depth++;
						let result = undefined;
						if (instance && !Node.prototype.isPrototypeOf(instance) && !BDFDB.ReactUtils.getInstance(instance) && depth < maxDepth && performance.now() - start < maxTime) {
							if (instance.type && types.some(name => BDFDB.ReactUtils.isCorrectInstance(instance, name.split(" _ _ ")[0]))) {
								if (config.all === undefined || !config.all) result = instance.type;
								else if (config.all) {
									if (!instance.type.BDFDBreactSearch) {
										instance.type.BDFDBreactSearch = true;
										if (config.group) {
											if (instance.type && (instance.type.render && instance.type.render.displayName || instance.type.displayName || instance.type.name)) {
												let group = config.name.find(name => (instance.type.render && instance.type.render.displayName || instance.type.displayName || instance.type.name || instance.type) == name.split(" _ _ ")[0]) || "Default";
												if (!BDFDB.ArrayUtils.is(foundConstructors[group])) foundConstructors[group] = [];
												foundConstructors[group].push(instance.stateNode);
											}
										}
										else foundConstructors.push(instance.type);
									}
								}
							}
							if (result === undefined) {
								let keys = Object.getOwnPropertyNames(instance);
								for (let i = 0; result === undefined && i < keys.length; i++) {
									let key = keys[i];
									if (key && whitelist[key] && (typeof instance[key] === "object" || typeof instance[key] == "function")) result = getConstructor(instance[key]);
								}
							}
						}
						depth--;
						return result;
					}
				};
				BDFDB.ReactUtils.findDOMNode = function (instance) {
					if (Node.prototype.isPrototypeOf(instance)) return instance;
					if (!instance || !instance.updater || typeof instance.updater.isMounted !== "function" || !instance.updater.isMounted(instance)) return null;
					let node = LibraryModules.ReactDOM.findDOMNode(instance) || BDFDB.ObjectUtils.get(instance, "child.stateNode");
					return Node.prototype.isPrototypeOf(node) ? node : null;
				};
				BDFDB.ReactUtils.findOwner = function (nodeOrInstance, config) {
					if (!BDFDB.ObjectUtils.is(config)) return null;
					if (!nodeOrInstance || !config.name && !config.type && !config.key && !config.props && !config.filter) return config.all ? (config.group ? {} : []) : null;
					let instance = Node.prototype.isPrototypeOf(nodeOrInstance) ? BDFDB.ReactUtils.getInstance(nodeOrInstance) : nodeOrInstance;
					if (!BDFDB.ObjectUtils.is(instance)) return config.all ? (config.group ? {} : []) : null;
					config.name = config.name && [config.name].flat().filter(n => n);
					config.type = config.type && [config.type].flat().filter(n => n);
					config.key = config.key && [config.key].flat().filter(n => n);
					config.props = config.props && [config.props].flat().filter(n => n);
					config.filter = typeof config.filter == "function" && config.filter;
					let depth = -1;
					let start = performance.now();
					let maxDepth = config.unlimited ? 999999999 : (config.depth === undefined ? 30 : config.depth);
					let maxTime = config.unlimited ? 999999999 : (config.time === undefined ? 150 : config.time);
					let whitelist = config.up ? {
						return: true,
						sibling: true,
						default: true
					} : {
						child: true,
						sibling: true,
						default: true
					};
					whitelist[BDFDB.ReactUtils.instanceKey] = true;
					
					let foundInstances = config.group ? {} : [];
					let singleInstance = getOwner(instance);
					if (config.all) {
						for (let i in foundInstances) {
							if (config.group) for (let j in foundInstances[i]) delete foundInstances[i][j].BDFDBreactSearch;
							else delete foundInstances[i].BDFDBreactSearch;
						}
						return foundInstances;
					}
					else return singleInstance;

					function getOwner (instance) {
						depth++;
						let result = undefined;
						if (instance && !Node.prototype.isPrototypeOf(instance) && !BDFDB.ReactUtils.getInstance(instance) && depth < maxDepth && performance.now() - start < maxTime) {
							let props = instance.stateNode ? instance.stateNode.props : instance.props;
							if (instance.stateNode && !Node.prototype.isPrototypeOf(instance.stateNode) && (instance.type && config.name && config.name.some(name => BDFDB.ReactUtils.isCorrectInstance(instance, name.split(" _ _ ")[0])) || instance.type && config.type && config.type.some(type => BDFDB.ArrayUtils.is(type) ? instance.type === type[1] : instance.type === type) || instance.key && config.key && config.key.some(key => instance.key == key) || props && config.props && config.props.every(prop => BDFDB.ArrayUtils.is(prop) ? (BDFDB.ArrayUtils.is(prop[1]) ? prop[1].some(checkValue => BDFDB.equals(props[prop[0]], checkValue)) : BDFDB.equals(props[prop[0]], prop[1])) : props[prop] !== undefined)) || config.filter && config.filter(instance)) {
								if (config.all === undefined || !config.all) result = instance.stateNode;
								else if (config.all) {
									if (!instance.stateNode.BDFDBreactSearch) {
										instance.stateNode.BDFDBreactSearch = true;
										if (config.group) {
											if (config.name && instance.type && (instance.type.render && instance.type.render.displayName || instance.type.displayName || instance.type.name || instance.type)) {
												let group = config.name.find(name => (instance.type.render && instance.type.render.displayName || instance.type.displayName || instance.type.name || instance.type) == name.split(" _ _ ")[0]) || "Default";
												if (!BDFDB.ArrayUtils.is(foundInstances[group])) foundInstances[group] = [];
												foundInstances[group].push(instance.stateNode);
											}
											else if (config.type && instance.type) {
												let group = [config.type.find(t => BDFDB.ArrayUtils.is(t) && instance.type === t[1])].flat(10)[0] || "Default";
												if (!BDFDB.ArrayUtils.is(foundInstances[group])) foundInstances[group] = [];
												foundInstances[group].push(instance.stateNode);
											}
										}
										else foundInstances.push(instance.stateNode);
									}
								}
							}
							if (result === undefined) {
								let keys = Object.getOwnPropertyNames(instance);
								for (let i = 0; result === undefined && i < keys.length; i++) {
									let key = keys[i];
									if (key && whitelist[key] && (typeof instance[key] === "object" || typeof instance[key] == "function")) result = getOwner(instance[key]);
								}
							}
						}
						depth--;
						return result;
					}
				};
				BDFDB.ReactUtils.findParent = function (nodeOrInstance, config) {
					if (!nodeOrInstance || !BDFDB.ObjectUtils.is(config) || !config.name && !config.key && !config.props && !config.filter) return [null, -1];
					let instance = Node.prototype.isPrototypeOf(nodeOrInstance) ? BDFDB.ReactUtils.getInstance(nodeOrInstance) : nodeOrInstance;
					if (!BDFDB.ObjectUtils.is(instance) && !BDFDB.ArrayUtils.is(instance) || instance.props && typeof instance.props.children == "function") return [null, -1];
					config.name = config.name && [config.name].flat().filter(n => n);
					config.key = config.key && [config.key].flat().filter(n => n);
					config.props = config.props && [config.props].flat().filter(n => n);
					config.filter = typeof config.filter == "function" && config.filter;
					let parent = firstArray = instance;
					while (!BDFDB.ArrayUtils.is(firstArray) && firstArray.props && firstArray.props.children) firstArray = firstArray.props.children;
					if (!BDFDB.ArrayUtils.is(firstArray)) {
						if (parent && parent.props) {
							parent.props.children = [parent.props.children];
							firstArray = parent.props.children;
						}
						else firstArray = [];
					}
					return getParent(instance);
					function getParent (children) {
						let result = [firstArray, -1];
						if (!children) return result;
						if (!BDFDB.ArrayUtils.is(children)) {
							if (check(children)) result = found(children);
							else if (children.props && children.props.children) {
								parent = children;
								result = getParent(children.props.children);
							}
						}
						else {
							for (let i = 0; result[1] == -1 && i < children.length; i++) if (children[i]) {
								if (BDFDB.ArrayUtils.is(children[i])) {
									parent = children;
									result = getParent(children[i]);
								}
								else if (check(children[i])) {
									parent = children;
									result = found(children[i]);
								}
								else if (children[i].props && children[i].props.children) {
									parent = children[i];
									result = getParent(children[i].props.children);
								}
							}
						}
						return result;
					}
					function found (child) {
						if (BDFDB.ArrayUtils.is(parent)) return [parent, parent.indexOf(child)];
						else {
							parent.props.children = [];
							parent.props.children.push(child);
							return [parent.props.children, 0];
						}
					}
					function check (instance) {
						if (!instance) return false;
						let props = instance.stateNode ? instance.stateNode.props : instance.props;
						return instance.type && config.name && config.name.some(name => BDFDB.ReactUtils.isCorrectInstance(instance, name)) || config.key && config.key.some(key => instance.key == key) || props && config.props && config.props[config.someProps ? "some" : "every"](prop => BDFDB.ArrayUtils.is(prop) ? (BDFDB.ArrayUtils.is(prop[1]) ? prop[1].some(checkValue => propCheck(props, prop[0], checkValue)) : propCheck(props, prop[0], prop[1])) : props[prop] !== undefined) || config.filter && config.filter(instance);
					}
					function propCheck (props, key, value) {
						return key != null && props[key] != null && value != null && (key == "className" ? (" " + props[key] + " ").indexOf(" " + value + " ") > -1 : BDFDB.equals(props[key], value));
					}
				};
				BDFDB.ReactUtils.findProps = function (nodeOrInstance, config) {
					if (!BDFDB.ObjectUtils.is(config)) return null;
					if (!nodeOrInstance || !config.name && !config.key) return null;
					let instance = Node.prototype.isPrototypeOf(nodeOrInstance) ? BDFDB.ReactUtils.getInstance(nodeOrInstance) : nodeOrInstance;
					if (!BDFDB.ObjectUtils.is(instance)) return null;
					config.name = config.name && [config.name].flat().filter(n => n);
					config.key = config.key && [config.key].flat().filter(n => n);
					let depth = -1;
					let start = performance.now();
					let maxDepth = config.unlimited ? 999999999 : (config.depth === undefined ? 30 : config.depth);
					let maxTime = config.unlimited ? 999999999 : (config.time === undefined ? 150 : config.time);
					let whitelist = config.up ? {
						return: true,
						sibling: true,
						default: true
					} : {
						child: true,
						sibling: true,
						default: true
					};
					whitelist[BDFDB.ReactUtils.instanceKey] = true;
					return findProps(instance);

					function findProps (instance) {
						depth++;
						let result = undefined;
						if (instance && !Node.prototype.isPrototypeOf(instance) && !BDFDB.ReactUtils.getInstance(instance) && depth < maxDepth && performance.now() - start < maxTime) {
							if (instance.memoizedProps && (instance.type && config.name && config.name.some(name => BDFDB.ReactUtils.isCorrectInstance(instance, name.split(" _ _ ")[0])) || config.key && config.key.some(key => instance.key == key))) result = instance.memoizedProps;
							if (result === undefined) {
								let keys = Object.getOwnPropertyNames(instance);
								for (let i = 0; result === undefined && i < keys.length; i++) {
									let key = keys[i];
									if (key && whitelist[key] && (typeof instance[key] === "object" || typeof instance[key] == "function")) result = findProps(instance[key]);
								}
							}
						}
						depth--;
						return result;
					}
				};
				BDFDB.ReactUtils.findValue = function (nodeOrInstance, searchKey, config = {}) {
					if (!BDFDB.ObjectUtils.is(config)) return null;
					if (!nodeOrInstance || typeof searchKey != "string") return config.all ? [] : null;
					let instance = Node.prototype.isPrototypeOf(nodeOrInstance) ? BDFDB.ReactUtils.getInstance(nodeOrInstance) : nodeOrInstance;
					if (!BDFDB.ObjectUtils.is(instance)) return config.all ? [] : null;
					instance = instance[BDFDB.ReactUtils.instanceKey] || instance;
					let depth = -1;
					let start = performance.now();
					let maxDepth = config.unlimited ? 999999999 : (config.depth === undefined ? 30 : config.depth);
					let maxTime = config.unlimited ? 999999999 : (config.time === undefined ? 150 : config.time);
					let whitelist = {
						props: true,
						state: true,
						stateNode: true,
						updater: true,
						prototype: true,
						type: true,
						children: config.up ? false : true,
						memoizedProps: true,
						memoizedState: true,
						child: config.up ? false : true,
						return: config.up ? true : false,
						sibling: config.up ? false : true
					};
					let blacklist = {
						contextSection: true
					};
					if (BDFDB.ObjectUtils.is(config.whitelist)) Object.assign(whitelist, config.whiteList);
					if (BDFDB.ObjectUtils.is(config.blacklist)) Object.assign(blacklist, config.blacklist);
					let foundKeys = [];
					let singleKey = getKey(instance);
					if (config.all) return foundKeys;
					else return singleKey;
					function getKey(instance) {
						depth++;
						let result = undefined;
						if (instance && !Node.prototype.isPrototypeOf(instance) && !BDFDB.ReactUtils.getInstance(instance) && depth < maxDepth && performance.now() - start < maxTime) {
							let keys = Object.getOwnPropertyNames(instance);
							for (let i = 0; result === undefined && i < keys.length; i++) {
								let key = keys[i];
								if (key && !blacklist[key]) {
									let value = instance[key];
									if (searchKey === key && (config.value === undefined || BDFDB.equals(config.value, value))) {
										if (config.all === undefined || !config.all) result = value;
										else if (config.all) {
											if (config.noCopies === undefined || !config.noCopies) foundKeys.push(value);
											else if (config.noCopies) {
												let copy = false;
												for (let foundKey of foundKeys) if (BDFDB.equals(value, foundKey)) {
													copy = true;
													break;
												}
												if (!copy) foundKeys.push(value);
											}
										}
									}
									else if ((typeof value === "object" || typeof value == "function") && (whitelist[key] || key[0] == "." || !isNaN(key[0]))) result = getKey(value);
								}
							}
						}
						depth--;
						return result;
					}
				};
				BDFDB.ReactUtils.forceUpdate = function (...instances) {
					for (let ins of instances.flat(10).filter(n => n)) if (ins.updater && typeof ins.updater.isMounted == "function" && ins.updater.isMounted(ins)) ins.forceUpdate();
				};
				BDFDB.ReactUtils.getInstance = function (node) {
					if (!BDFDB.ObjectUtils.is(node)) return null;
					return node[Object.keys(node).find(key => key.startsWith("__reactInternalInstance") || key.startsWith("__reactFiber"))];
				};
				BDFDB.ReactUtils.isCorrectInstance = function (instance, name) {
					return instance && ((instance.type && (instance.type.render && instance.type.render.displayName === name || instance.type.displayName === name || instance.type.name === name || instance.type === name)) || instance.render && (instance.render.displayName === name || instance.render.name === name) || instance.displayName == name || instance.name === name);
				};
				BDFDB.ReactUtils.render = function (component, node) {
					if (!BDFDB.ReactUtils.isValidElement(component) || !Node.prototype.isPrototypeOf(node)) return;
					try {
						LibraryModules.ReactDOM.render(component, node);
						let observer = new MutationObserver(changes => changes.forEach(change => {
							let nodes = Array.from(change.removedNodes);
							if (nodes.indexOf(node) > -1 || nodes.some(n => n.contains(node))) {
								observer.disconnect();
								BDFDB.ReactUtils.unmountComponentAtNode(node);
							}
						}));
						observer.observe(document.body, {subtree: true, childList: true});
					}
					catch (err) {BDFDB.LogUtils.error(["Could not render React Element!", err]);}
				};

				BDFDB.MessageUtils = {};
				BDFDB.MessageUtils.rerenderAll = function (instant) {
					BDFDB.TimeUtils.clear(BDFDB.MessageUtils.rerenderAll.timeout);
					BDFDB.MessageUtils.rerenderAll.timeout = BDFDB.TimeUtils.timeout(_ => {
						let channel = LibraryModules.ChannelStore.getChannel(LibraryModules.LastChannelStore.getChannelId());
						if (channel) {
							if (BDFDB.DMUtils.isDMChannel(channel)) BDFDB.DMUtils.markAsRead(channel);
							else BDFDB.ChannelUtils.markAsRead(channel);
						}
						let LayerProviderIns = BDFDB.ReactUtils.findOwner(document.querySelector(BDFDB.dotCN.messageswrapper), {name: "LayerProvider", unlimited: true, up: true});
						let LayerProviderPrototype = BDFDB.ObjectUtils.get(LayerProviderIns, `${BDFDB.ReactUtils.instanceKey}.type.prototype`);
						if (LayerProviderIns && LayerProviderPrototype) {
							BDFDB.PatchUtils.patch({name: "BDFDB MessageUtils"}, LayerProviderPrototype, "render", {after: e => {
								e.returnValue.props.children = typeof e.returnValue.props.children == "function" ? (_ => {return null;}) : [];
								BDFDB.ReactUtils.forceUpdate(LayerProviderIns);
							}}, {once: true});
							BDFDB.ReactUtils.forceUpdate(LayerProviderIns);
						}
					}, instant ? 0 : 1000);
				};
				BDFDB.MessageUtils.openMenu = function (message, e = mousePosition, slim = false) {
					if (!message) return;
					let channel = LibraryModules.ChannelStore.getChannel(message.channel_id);
					if (channel) LibraryModules.ContextMenuUtils.openContextMenu(e, function (e) {
						return BDFDB.ReactUtils.createElement((BDFDB.ModuleUtils.findByName(slim ? "MessageSearchResultContextMenu" : "MessageContextMenu", false) || {exports: {}}).exports.default, Object.assign({}, e, {
							message: message,
							channel: channel
						}));
					});
				};
					
				BDFDB.UserUtils = {};
				BDFDB.UserUtils.is = function (user) {
					return user && user instanceof BDFDB.DiscordObjects.User;
				};
				var myDataUser = LibraryModules.UserStore && LibraryModules.UserStore.getCurrentUser();
				BDFDB.UserUtils.me = new Proxy(myDataUser || {}, {
					get: function (list, item) {
						return (myDataUser = LibraryModules.UserStore.getCurrentUser()) && myDataUser[item];
					}
				});
				BDFDB.UserUtils.getStatus = function (id = BDFDB.UserUtils.me.id) {
					id = typeof id == "number" ? id.toFixed() : id;
					let activity = BDFDB.UserUtils.getActivity(id);
					return activity && activity.type == BDFDB.DiscordConstants.ActivityTypes.STREAMING ? "streaming" : LibraryModules.StatusMetaUtils.getStatus(id);
				};
				BDFDB.UserUtils.getStatusColor = function (status, useColor) {
					status = typeof status == "string" ? status.toLowerCase() : null;
					switch (status) {
						case "online": return useColor ? BDFDB.DiscordConstants.Colors.STATUS_GREEN_600 : "var(--bdfdb-green)";
						case "idle": return useColor ? BDFDB.DiscordConstants.Colors.STATUS_YELLOW : "var(--bdfdb-yellow)";
						case "dnd": return useColor ? BDFDB.DiscordConstants.Colors.STATUS_RED : "var(--bdfdb-red)";
						case "playing": return useColor ? BDFDB.DiscordConstants.Colors.BRAND : "var(--bdfdb-blurple)";
						case "listening": return BDFDB.DiscordConstants.Colors.SPOTIFY;
						case "streaming": return BDFDB.DiscordConstants.Colors.TWITCH;
						default: return BDFDB.DiscordConstants.Colors.STATUS_GREY;
					}
				};
				BDFDB.UserUtils.getActivity = function (id = BDFDB.UserUtils.me.id) {
					for (let activity of LibraryModules.StatusMetaUtils.getActivities(id)) if (activity.type != BDFDB.DiscordConstants.ActivityTypes.CUSTOM_STATUS) return activity;
					return null;
				};
				BDFDB.UserUtils.getCustomStatus = function (id = BDFDB.UserUtils.me.id) {
					for (let activity of LibraryModules.StatusMetaUtils.getActivities(id)) if (activity.type == BDFDB.DiscordConstants.ActivityTypes.CUSTOM_STATUS) return activity;
					return null;
				};
				BDFDB.UserUtils.getAvatar = function (id = BDFDB.UserUtils.me.id) {
					let user = LibraryModules.UserStore.getUser(id);
					if (!user) return window.location.origin + "/assets/1f0bfc0865d324c2587920a7d80c609b.png";
					else return ((user.avatar ? "" : window.location.origin) + LibraryModules.IconUtils.getUserAvatarURL(user)).split("?")[0];
				};
				BDFDB.UserUtils.can = function (permission, id = BDFDB.UserUtils.me.id, channelId = LibraryModules.LastChannelStore.getChannelId()) {
					if (!BDFDB.DiscordConstants.Permissions[permission]) BDFDB.LogUtils.warn([permission, "not found in Permissions"]);
					else {
						let channel = LibraryModules.ChannelStore.getChannel(channelId);
						if (channel) return LibraryModules.PermissionRoleUtils.can(BDFDB.DiscordConstants.Permissions[permission], id, channel);
					}
					return false;
				};
				BDFDB.UserUtils.openMenu = function (user, guildId, e = mousePosition) {
					if (user && guildId) LibraryModules.ContextMenuUtils.openContextMenu(e, function (e) {
						return BDFDB.ReactUtils.createElement((BDFDB.ModuleUtils.findByName("GuildChannelUserContextMenu", false) || {exports: {}}).exports.default, Object.assign({}, e, {
							user: user,
							guildId: guildId
						}));
					});
				};

				BDFDB.GuildUtils = {};
				BDFDB.GuildUtils.is = function (guild) {
					if (!BDFDB.ObjectUtils.is(guild)) return false;
					let keys = Object.keys(guild);
					return guild instanceof BDFDB.DiscordObjects.Guild || Object.keys(new BDFDB.DiscordObjects.Guild({})).every(key => keys.indexOf(key) > -1);
				};
				BDFDB.GuildUtils.getIcon = function (id) {
					let guild = LibraryModules.GuildStore.getGuild(id);
					if (!guild || !guild.icon) return "";
					return LibraryModules.IconUtils.getGuildIconURL(guild).split("?")[0];
				};
				BDFDB.GuildUtils.getBanner = function (id) {
					let guild = LibraryModules.GuildStore.getGuild(id);
					if (!guild || !guild.banner) return "";
					return LibraryModules.IconUtils.getGuildBannerURL(guild).split("?")[0];
				};
				BDFDB.GuildUtils.getFolder = function (id) {
					return LibraryModules.FolderStore.guildFolders.filter(n => n.folderId).find(n => n.guildIds.includes(id));
				};
				BDFDB.GuildUtils.openMenu = function (guild, e = mousePosition) {
					if (guild) LibraryModules.ContextMenuUtils.openContextMenu(e, function (e) {
						return BDFDB.ReactUtils.createElement((BDFDB.ModuleUtils.findByName("GuildContextMenu", false) || {exports: {}}).exports.default, Object.assign({}, e, {
							guild: guild
						}));
					});
				};
				BDFDB.GuildUtils.markAsRead = function (guildIds) {
					let channels = [guildIds].flat(10).filter(id => id && typeof id == "string" && LibraryModules.GuildStore.getGuild(id)).map(id => BDFDB.ObjectUtils.toArray(LibraryModules.GuildChannelStore.getChannels(id)).flat(10).filter(n => BDFDB.ObjectUtils.is(n)).map(n => n.channel && n.channel.id)).flat().filter(n => n);
					if (channels.length) BDFDB.ChannelUtils.markAsRead(channels);
				};
				BDFDB.GuildUtils.rerenderAll = function (instant) {
					BDFDB.TimeUtils.clear(BDFDB.GuildUtils.rerenderAll.timeout);
					BDFDB.GuildUtils.rerenderAll.timeout = BDFDB.TimeUtils.timeout(_ => {
						let GuildsIns = BDFDB.ReactUtils.findOwner(document.querySelector(BDFDB.dotCN.app), {name: "Guilds", unlimited: true});
						let GuildsPrototype = BDFDB.ObjectUtils.get(GuildsIns, `${BDFDB.ReactUtils.instanceKey}.type.prototype`);
						if (GuildsIns && GuildsPrototype) {
							let injectPlaceholder = returnValue => {
								let [children, index] = BDFDB.ReactUtils.findParent(returnValue, {name: "ConnectedUnreadDMs"});
								if (index > -1) children.splice(index + 1, 0, BDFDB.ReactUtils.createElement("div", {}));
								BDFDB.ReactUtils.forceUpdate(GuildsIns);
							};
							BDFDB.PatchUtils.patch({name: "BDFDB GuildUtils"}, GuildsPrototype, "render", {after: e => {
								if (typeof e.returnValue.props.children == "function") {
									let childrenRender = e.returnValue.props.children;
									e.returnValue.props.children = (...args) => {
										let children = childrenRender(...args);
										injectPlaceholder(children);
										return children;
									};
								}
								else injectPlaceholder(e.returnValue);
							}}, {once: true});
							BDFDB.ReactUtils.forceUpdate(GuildsIns);
						}
					}, instant ? 0 : 1000);
				};

				BDFDB.FolderUtils = {};
				BDFDB.FolderUtils.getId = function (div) {
					if (!Node.prototype.isPrototypeOf(div) || !BDFDB.ReactUtils.getInstance(div)) return;
					div = BDFDB.DOMUtils.getParent(BDFDB.dotCN.guildfolderwrapper, div);
					if (!div) return;
					return BDFDB.ReactUtils.findValue(div, "folderId", {up: true});
				};
				BDFDB.FolderUtils.getDefaultName = function (folderId) {
					let folder = LibraryModules.FolderStore.getGuildFolderById(folderId);
					if (!folder) return "";
					let rest = 2 * BDFDB.DiscordConstants.MAX_GUILD_FOLDER_NAME_LENGTH;
					let names = [], allNames = folder.guildIds.map(guildId => (LibraryModules.GuildStore.getGuild(guildId) || {}).name).filter(n => n);
					for (let name of allNames) if (name.length < rest || names.length === 0) {
						names.push(name);
						rest -= name.length;
					}
					return names.join(", ") + (names.length < allNames.length ? ", ..." : "");
				};

				BDFDB.ChannelUtils = {};
				BDFDB.ChannelUtils.is = function (channel) {
					if (!BDFDB.ObjectUtils.is(channel)) return false;
					let keys = Object.keys(channel);
					return channel instanceof BDFDB.DiscordObjects.Channel || Object.keys(new BDFDB.DiscordObjects.Channel({})).every(key => keys.indexOf(key) > -1);
				};
				BDFDB.ChannelUtils.isTextChannel = function (channelOrId) {
					let channel = typeof channelOrId == "string" ? LibraryModules.ChannelStore.getChannel(channelOrId) : channelOrId;
					return BDFDB.ObjectUtils.is(channel) && (channel.type == BDFDB.DiscordConstants.ChannelTypes.GUILD_TEXT || channel.type == BDFDB.DiscordConstants.ChannelTypes.GUILD_STORE || channel.type == BDFDB.DiscordConstants.ChannelTypes.GUILD_ANNOUNCEMENT);
				};
				BDFDB.ChannelUtils.markAsRead = function (channelIds) {
					let unreadChannels = [channelIds].flat(10).filter(id => id && typeof id == "string" && BDFDB.ChannelUtils.isTextChannel(id) && (LibraryModules.UnreadChannelUtils.hasUnread(id) || LibraryModules.UnreadChannelUtils.getMentionCount(id) > 0)).map(id => ({
						channelId: id,
						messageId: LibraryModules.UnreadChannelUtils.lastMessageId(id)
					}));
					if (unreadChannels.length) LibraryModules.AckUtils.bulkAck(unreadChannels);
				};
				BDFDB.ChannelUtils.rerenderAll = function (instant) {
					BDFDB.TimeUtils.clear(BDFDB.ChannelUtils.rerenderAll.timeout);
					BDFDB.ChannelUtils.rerenderAll.timeout = BDFDB.TimeUtils.timeout(_ => {
						let ChannelsIns = BDFDB.ReactUtils.findOwner(document.querySelector(BDFDB.dotCN.guildchannels), {name: "Channels", unlimited: true});
						let ChannelsPrototype = BDFDB.ObjectUtils.get(ChannelsIns, `${BDFDB.ReactUtils.instanceKey}.type.prototype`);
						if (ChannelsIns && ChannelsPrototype) {
							BDFDB.PatchUtils.patch({name: "BDFDB ChannelUtils"}, ChannelsPrototype, "render", {after: e => {
								e.returnValue.props.children = typeof e.returnValue.props.children == "function" ? (_ => {return null;}) : [];
								BDFDB.ReactUtils.forceUpdate(ChannelsIns);
							}}, {once: true});
							BDFDB.ReactUtils.forceUpdate(ChannelsIns);
						}
					}, instant ? 0 : 1000);
				};
				
				BDFDB.DMUtils = {};
				BDFDB.DMUtils.isDMChannel = function (id) {
					let channel = LibraryModules.ChannelStore.getChannel(id);
					return BDFDB.ObjectUtils.is(channel) && (channel.isDM() || channel.isGroupDM());
				};
				BDFDB.DMUtils.getIcon = function (id) {
					let channel = LibraryModules.ChannelStore.getChannel(id);
					if (!channel) return "";
					if (!channel.icon) return channel.isDM() ? BDFDB.UserUtils.getAvatar(channel.recipients[0]) : (channel.isGroupDM() ? window.location.origin + LibraryModules.IconUtils.getChannelIconURL(channel).split("?")[0] : null);
					return LibraryModules.IconUtils.getChannelIconURL(channel).split("?")[0];
				};
				BDFDB.DMUtils.openMenu = function (channel, e = mousePosition) {
					if (channel) {
						if (channel.isGroupDM()) LibraryModules.ContextMenuUtils.openContextMenu(e, function (e) {
							return BDFDB.ReactUtils.createElement((BDFDB.ModuleUtils.findByName("GroupDMContextMenu", false) || {exports: {}}).exports.default, Object.assign({}, e, {
								channel: channel,
								selected: channel.id == LibraryModules.LastChannelStore.getChannelId()
							}));
						});
						else LibraryModules.ContextMenuUtils.openContextMenu(e, function (e) {
							return BDFDB.ReactUtils.createElement((BDFDB.ModuleUtils.findByName("DMUserContextMenu", false) || {exports: {}}).exports.default, Object.assign({}, e, {
								user: LibraryModules.UserStore.getUser(channel.recipients[0]),
								channel: channel,
								selected: channel.id == LibraryModules.LastChannelStore.getChannelId()
							}));
						});
					}
				};
				BDFDB.DMUtils.markAsRead = function (dmIds) {
					let unreadDMs = [dmIds].flat(10).filter(id => id && typeof id == "string" && BDFDB.DMUtils.isDMChannel(id) && (LibraryModules.UnreadChannelUtils.hasUnread(id) || LibraryModules.UnreadChannelUtils.getMentionCount(id) > 0));
					if (unreadDMs.length) for (let i in unreadDMs) BDFDB.TimeUtils.timeout(_ => LibraryModules.AckUtils.ack(unreadDMs[i]), i * 1000);
				};

				InternalBDFDB.writeConfig = function (path, config) {
					try {LibraryRequires.fs.writeFileSync(path, JSON.stringify(config, null, "	"));}
					catch (err) {}
				};
				InternalBDFDB.readConfig = function (path) {
					try {return JSON.parse(LibraryRequires.fs.readFileSync(path));}
					catch (err) {return {};}
				};
				
				BDFDB.DataUtils = {};
				BDFDB.DataUtils.save = function (data, plugin, key, id) {
					plugin = plugin == BDFDB && InternalBDFDB || plugin;
					let pluginName = typeof plugin === "string" ? plugin : plugin.name;
					let fileName = pluginName == "BDFDB" ? "0BDFDB" : pluginName;
					let configPath = LibraryRequires.path.join(BDFDB.BDUtils.getPluginsFolder(), fileName + ".config.json");
					
					let config = Cache.data[pluginName] !== undefined ? Cache.data[pluginName] : (InternalBDFDB.readConfig(configPath) || {});
					
					if (key === undefined) config = BDFDB.ObjectUtils.is(data) ? BDFDB.ObjectUtils.sort(data) : data;
					else {
						if (id === undefined) config[key] = BDFDB.ObjectUtils.is(data) ? BDFDB.ObjectUtils.sort(data) : data;
						else {
							if (!BDFDB.ObjectUtils.is(config[key])) config[key] = {};
							config[key][id] = BDFDB.ObjectUtils.is(data) ? BDFDB.ObjectUtils.sort(data) : data;
						}
					}
					
					let configIsObject = BDFDB.ObjectUtils.is(config);
					if (key !== undefined && configIsObject && BDFDB.ObjectUtils.is(config[key]) && BDFDB.ObjectUtils.isEmpty(config[key])) delete config[key];
					if (BDFDB.ObjectUtils.isEmpty(config)) {
						delete Cache.data[pluginName];
						if (LibraryRequires.fs.existsSync(configPath)) LibraryRequires.fs.unlinkSync(configPath);
					}
					else {
						if (configIsObject) config = BDFDB.ObjectUtils.sort(config);
						Cache.data[pluginName] = configIsObject ? BDFDB.ObjectUtils.deepAssign({}, config) : config;
						InternalBDFDB.writeConfig(configPath, config);
					}
				};

				BDFDB.DataUtils.load = function (plugin, key, id) {
					plugin = plugin == BDFDB && InternalBDFDB || plugin;
					let pluginName = typeof plugin === "string" ? plugin : plugin.name;
					let fileName = pluginName == "BDFDB" ? "0BDFDB" : pluginName;
					let configPath = LibraryRequires.path.join(BDFDB.BDUtils.getPluginsFolder(), fileName + ".config.json");
					
					let config = Cache.data[pluginName] !== undefined ? Cache.data[pluginName] : (InternalBDFDB.readConfig(configPath) || {});
					let configIsObject = BDFDB.ObjectUtils.is(config);
					Cache.data[pluginName] = configIsObject ? BDFDB.ObjectUtils.deepAssign({}, config) : config;
					
					if (key === undefined) return config;
					else {
						let keyData = configIsObject ? (BDFDB.ObjectUtils.is(config[key]) || config[key] === undefined ? BDFDB.ObjectUtils.deepAssign({}, config[key]) : config[key]) : null;
						if (id === undefined) return keyData;
						else return !BDFDB.ObjectUtils.is(keyData) || keyData[id] === undefined ? null : keyData[id];
					}
				};
				BDFDB.DataUtils.remove = function (plugin, key, id) {
					plugin = plugin == BDFDB && InternalBDFDB || plugin;
					let pluginName = typeof plugin === "string" ? plugin : plugin.name;
					let fileName = pluginName == "BDFDB" ? "0BDFDB" : pluginName;
					let configPath = LibraryRequires.path.join(BDFDB.BDUtils.getPluginsFolder(), fileName + ".config.json");
					
					let config = Cache.data[pluginName] !== undefined ? Cache.data[pluginName] : (InternalBDFDB.readConfig(configPath) || {});
					let configIsObject = BDFDB.ObjectUtils.is(config);
					
					if (key === undefined || !configIsObject) config = {};
					else {
						if (id === undefined) delete config[key];
						else if (BDFDB.ObjectUtils.is(config[key])) delete config[key][id];
					}
					
					if (BDFDB.ObjectUtils.is(config[key]) && BDFDB.ObjectUtils.isEmpty(config[key])) delete config[key];
					if (BDFDB.ObjectUtils.isEmpty(config)) {
						delete Cache.data[pluginName];
						if (LibraryRequires.fs.existsSync(configPath)) LibraryRequires.fs.unlinkSync(configPath);
					}
					else {
						if (configIsObject) config = BDFDB.ObjectUtils.sort(config);
						Cache.data[pluginName] = configIsObject ? BDFDB.ObjectUtils.deepAssign({}, config) : config;
						InternalBDFDB.writeConfig(configPath, config);
					}
				};
				BDFDB.DataUtils.get = function (plugin, key, id) {
					plugin = plugin == BDFDB && InternalBDFDB || plugin;
					plugin = typeof plugin == "string" ? BDFDB.BDUtils.getPlugin(plugin) : plugin;
					const defaults = plugin && plugin.defaults;
					if (!BDFDB.ObjectUtils.is(defaults) || key && !BDFDB.ObjectUtils.is(defaults[key])) return id === undefined ? {} : null;
					let oldC = BDFDB.DataUtils.load(plugin), newC = {}, update = false;
					const checkLayer = (i, j) => {
						let isObj = BDFDB.ObjectUtils.is(defaults[i][j].value);
						if (!newC[i]) newC[i] = {};
						if (oldC[i] == null || oldC[i][j] == null || isObj && (!BDFDB.ObjectUtils.is(oldC[i][j]) || Object.keys(defaults[i][j].value).some(n => defaults[i][j].value[n] != null && !BDFDB.sameProto(defaults[i][j].value[n], oldC[i][j][n])))) {
							newC[i][j] = isObj ? BDFDB.ObjectUtils.deepAssign({}, defaults[i][j].value) : defaults[i][j].value;
							update = true;
						}
						else newC[i][j] = oldC[i][j];
					};
					if (key) {for (let j in defaults[key]) checkLayer(key, j);}
					else {for (let i in defaults) if (BDFDB.ObjectUtils.is(defaults[i])) for (let j in defaults[i]) checkLayer(i, j);}
					if (update) BDFDB.DataUtils.save(Object.assign({}, oldC, newC), plugin);
					
					if (key === undefined) return newC;
					else if (id === undefined) return newC[key] === undefined ? {} : newC[key];
					else return newC[key] === undefined || newC[key][id] === undefined ? null : newC[key][id];
				};
				
				BDFDB.ColorUtils = {};
				BDFDB.ColorUtils.convert = function (color, conv, type) {
					if (BDFDB.ObjectUtils.is(color)) {
						var newColor = {};
						for (let pos in color) newColor[pos] = BDFDB.ColorUtils.convert(color[pos], conv, type);
						return newColor;
					}
					else {
						conv = conv === undefined || !conv ? conv = "RGBCOMP" : conv.toUpperCase();
						type = type === undefined || !type || !["RGB", "RGBA", "RGBCOMP", "HSL", "HSLA", "HSLCOMP", "HEX", "HEXA", "INT"].includes(type.toUpperCase()) ? BDFDB.ColorUtils.getType(color) : type.toUpperCase();
						if (conv == "RGBCOMP") {
							switch (type) {
								case "RGBCOMP":
									var rgbComp = [].concat(color);
									if (rgbComp.length == 3) return processRGB(rgbComp);
									else if (rgbComp.length == 4) {
										let a = processA(rgbComp.pop());
										return processRGB(rgbComp).concat(a);
									}
									break;
								case "RGB":
									return processRGB(color.replace(/\s/g, "").slice(4, -1).split(","));
								case "RGBA":
									var rgbComp = color.replace(/\s/g, "").slice(5, -1).split(",");
									var a = processA(rgbComp.pop());
									return processRGB(rgbComp).concat(a);
								case "HSLCOMP":
									var hslComp = [].concat(color);
									if (hslComp.length == 3) return BDFDB.ColorUtils.convert(`hsl(${processHSL(hslComp).join(",")})`, "RGBCOMP");
									else if (hslComp.length == 4) {
										let a = processA(hslComp.pop());
										return BDFDB.ColorUtils.convert(`hsl(${processHSL(hslComp).join(",")})`, "RGBCOMP").concat(a);
									}
									break;
								case "HSL":
									var hslComp = processHSL(color.replace(/\s/g, "").slice(4, -1).split(","));
									var r, g, b, m, c, x, p, q;
									var h = hslComp[0] / 360, l = parseInt(hslComp[1]) / 100, s = parseInt(hslComp[2]) / 100; m = Math.floor(h * 6); c = h * 6 - m; x = s * (1 - l); p = s * (1 - c * l); q = s * (1 - (1 - c) * l);
									switch (m % 6) {
										case 0: r = s, g = q, b = x; break;
										case 1: r = p, g = s, b = x; break;
										case 2: r = x, g = s, b = q; break;
										case 3: r = x, g = p, b = s; break;
										case 4: r = q, g = x, b = s; break;
										case 5: r = s, g = x, b = p; break;
									}
									return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
								case "HSLA":
									var hslComp = color.replace(/\s/g, "").slice(5, -1).split(",");
									return BDFDB.ColorUtils.convert(`hsl(${hslComp.slice(0, 3).join(",")})`, "RGBCOMP").concat(processA(hslComp.pop()));
								case "HEX":
									var hex = /^#([a-f\d]{1})([a-f\d]{1})([a-f\d]{1})$|^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(color);
									return [parseInt(hex[1] + hex[1] || hex[4], 16), parseInt(hex[2] + hex[2] || hex[5], 16), parseInt(hex[3] + hex[3] || hex[6], 16)];
								case "HEXA":
									var hex = /^#([a-f\d]{1})([a-f\d]{1})([a-f\d]{1})([a-f\d]{1})$|^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(color);
									return [parseInt(hex[1] + hex[1] || hex[5], 16), parseInt(hex[2] + hex[2] || hex[6], 16), parseInt(hex[3] + hex[3] || hex[7], 16), Math.floor(BDFDB.NumberUtils.mapRange([0, 255], [0, 100], parseInt(hex[4] + hex[4] || hex[8], 16)))/100];
								case "INT":
									color = processINT(color);
									return [parseInt(color >> 16 & 255), parseInt(color >> 8 & 255), parseInt(color & 255)];
								default:
									return null;
							}
						}
						else {
							if (conv && type && conv.indexOf("HSL") == 0 && type.indexOf("HSL") == 0) {
								if (type == "HSLCOMP") {
									let hslComp = [].concat(color);
									switch (conv) {
										case "HSLCOMP":
											if (hslComp.length == 3) return processHSL(hslComp);
											else if (hslComp.length == 4) {
												var a = processA(hslComp.pop());
												return processHSL(hslComp).concat(a);
											}
											break;
										case "HSL":
											return `hsl(${processHSL(hslComp.slice(0, 3)).join(",")})`;
										case "HSLA":
											hslComp = hslComp.slice(0, 4);
											var a = hslComp.length == 4 ? processA(hslComp.pop()) : 1;
											return `hsla(${processHSL(hslComp).concat(a).join(",")})`;
									}
								}
								return BDFDB.ColorUtils.convert(color.replace(/\s/g, "").slice(color.toUpperCase().indexOf("HSLA") == 0 ? 5 : 4, -1).split(","), conv, "HSLCOMP");
							}
							else {
								let rgbComp = type == "RGBCOMP" ? [].concat(color) : BDFDB.ColorUtils.convert(color, "RGBCOMP", type);
								if (rgbComp) switch (conv) {
									case "RGB":
										return `rgb(${processRGB(rgbComp.slice(0, 3)).join(",")})`;
									case "RGBA":
										rgbComp = rgbComp.slice(0, 4);
										var a = rgbComp.length == 4 ? processA(rgbComp.pop()) : 1;
										return `rgba(${processRGB(rgbComp).concat(a).join(",")})`;
									case "HSLCOMP":
										var a = rgbComp.length == 4 ? processA(rgbComp.pop()) : null;
										var hslComp = processHSL(BDFDB.ColorUtils.convert(rgbComp, "HSL").replace(/\s/g, "").split(","));
										return a != null ? hslComp.concat(a) : hslComp;
									case "HSL":
										var r = processC(rgbComp[0]), g = processC(rgbComp[1]), b = processC(rgbComp[2]);
										var max = Math.max(r, g, b), min = Math.min(r, g, b), dif = max - min, h, l = max === 0 ? 0 : dif / max, s = max / 255;
										switch (max) {
											case min: h = 0; break;
											case r: h = g - b + dif * (g < b ? 6 : 0); h /= 6 * dif; break;
											case g: h = b - r + dif * 2; h /= 6 * dif; break;
											case b: h = r - g + dif * 4; h /= 6 * dif; break;
										}
										return `hsl(${processHSL([Math.round(h * 360), l * 100, s * 100]).join(",")})`;
									case "HSLA":
										var a = rgbComp.length == 4 ? processA(rgbComp.pop()) : 1;
										return `hsla(${BDFDB.ColorUtils.convert(rgbComp, "HSL").slice(4, -1).split(",").concat(a).join(",")})`;
									case "HEX":
										return ("#" + (0x1000000 + (rgbComp[2] | rgbComp[1] << 8 | rgbComp[0] << 16)).toString(16).slice(1)).toUpperCase();
									case "HEXA":
										return ("#" + (0x1000000 + (rgbComp[2] | rgbComp[1] << 8 | rgbComp[0] << 16)).toString(16).slice(1) + (0x100 + Math.round(BDFDB.NumberUtils.mapRange([0, 100], [0, 255], processA(rgbComp[3]) * 100))).toString(16).slice(1)).toUpperCase();
									case "INT":
										return processINT(rgbComp[2] | rgbComp[1] << 8 | rgbComp[0] << 16);
									default:
										return null;
								}
							}
						}
					}
					return null;
					function processC(c) {if (c == null) {return 255;} else {c = parseInt(c.toString().replace(/[^0-9\-]/g, ""));return isNaN(c) || c > 255 ? 255 : c < 0 ? 0 : c;}};
					function processRGB(comp) {return [].concat(comp).map(c => {return processC(c);});};
					function processA(a) {if (a == null) {return 1;} else {a = a.toString();a = (a.indexOf("%") > -1 ? 0.01 : 1) * parseFloat(a.replace(/[^0-9\.\-]/g, ""));return isNaN(a) || a > 1 ? 1 : a < 0 ? 0 : a;}};
					function processSL(sl) {if (sl == null) {return "100%";} else {sl = parseFloat(sl.toString().replace(/[^0-9\.\-]/g, ""));return (isNaN(sl) || sl > 100 ? 100 : sl < 0 ? 0 : sl) + "%";}};
					function processHSL(comp) {comp = [].concat(comp);let h = parseFloat(comp.shift().toString().replace(/[^0-9\.\-]/g, ""));h = isNaN(h) || h > 360 ? 360 : h < 0 ? 0 : h;return [h].concat(comp.map(sl => {return processSL(sl);}));};
					function processINT(c) {if (c == null) {return 16777215;} else {c = parseInt(c.toString().replace(/[^0-9]/g, ""));return isNaN(c) || c > 16777215 ? 16777215 : c < 0 ? 0 : c;}};
				};
				BDFDB.ColorUtils.setAlpha = function (color, a, conv) {
					if (BDFDB.ObjectUtils.is(color)) {
						let newcolor = {};
						for (let pos in color) newcolor[pos] = BDFDB.ColorUtils.setAlpha(color[pos], a, conv);
						return newcolor;
					}
					else {
						let rgbComp = BDFDB.ColorUtils.convert(color, "RGBCOMP");
						if (rgbComp) {
							a = a.toString();
							a = (a.indexOf("%") > -1 ? 0.01 : 1) * parseFloat(a.replace(/[^0-9\.\-]/g, ""));
							a = isNaN(a) || a > 1 ? 1 : a < 0 ? 0 : a;
							rgbComp[3] = a;
							conv = (conv || BDFDB.ColorUtils.getType(color)).toUpperCase();
							conv = conv == "RGB" || conv == "HSL" || conv == "HEX" ? conv + "A" : conv;
							return BDFDB.ColorUtils.convert(rgbComp, conv);
						}
					}
					return null;
				};
				BDFDB.ColorUtils.getAlpha = function (color) {
					let rgbComp = BDFDB.ColorUtils.convert(color, "RGBCOMP");
					if (rgbComp) {
						if (rgbComp.length == 3) return 1;
						else if (rgbComp.length == 4) {
							let a = rgbComp[3].toString();
							a = (a.indexOf("%") > -1 ? 0.01 : 1) * parseFloat(a.replace(/[^0-9\.\-]/g, ""));
							return isNaN(a) || a > 1 ? 1 : a < 0 ? 0 : a;
						}
					}
					return null;
				};
				BDFDB.ColorUtils.change = function (color, value, conv) {
					value = parseFloat(value);
					if (color != null && typeof value == "number" && !isNaN(value)) {
						if (BDFDB.ObjectUtils.is(color)) {
							let newColor = {};
							for (let pos in color) newColor[pos] = BDFDB.ColorUtils.change(color[pos], value, conv);
							return newColor;
						}
						else {
							let rgbComp = BDFDB.ColorUtils.convert(color, "RGBCOMP");
							if (rgbComp) {
								let a = BDFDB.ColorUtils.getAlpha(rgbComp);
								if (parseInt(value) !== value) {
									value = value.toString();
									value = (value.indexOf("%") > -1 ? 0.01 : 1) * parseFloat(value.replace(/[^0-9\.\-]/g, ""));
									value = isNaN(value) ? 0 : value;
									return BDFDB.ColorUtils.convert([].concat(rgbComp).slice(0, 3).map(c => {
										c = Math.round(c * (1 + value));
										return c > 255 ? 255 : c < 0 ? 0 : c;
									}).concat(a), conv || BDFDB.ColorUtils.getType(color));
								}
								else return BDFDB.ColorUtils.convert([].concat(rgbComp).slice(0, 3).map(c => {
									c = Math.round(c + value);
									return c > 255 ? 255 : c < 0 ? 0 : c;
								}).concat(a), conv || BDFDB.ColorUtils.getType(color));
							}
						}
					}
					return null;
				};
				BDFDB.ColorUtils.invert = function (color, conv) {
					if (BDFDB.ObjectUtils.is(color)) {
						let newColor = {};
						for (let pos in color) newColor[pos] = BDFDB.ColorUtils.invert(color[pos], conv);
						return newColor;
					}
					else {
						let comp = BDFDB.ColorUtils.convert(color, "RGBCOMP");
						if (comp) return BDFDB.ColorUtils.convert([255 - comp[0], 255 - comp[1], 255 - comp[2]], conv || BDFDB.ColorUtils.getType(color));
					}
					return null;
				};
				BDFDB.ColorUtils.compare = function (color1, color2) {
					if (color1 && color2) {
						color1 = BDFDB.ColorUtils.convert(color1, "RGBA");
						color2 = BDFDB.ColorUtils.convert(color2, "RGBA");
						if (color1 && color2) return BDFDB.equals(color1, color2);
					}
					return null;
				};
				BDFDB.ColorUtils.isBright = function (color, compare = 160) {
					if (!BDFDB.ColorUtils.getType(color)) return false;
					color = BDFDB.ColorUtils.convert(color, "RGBCOMP");
					if (!color) return false;
					return parseInt(compare) < Math.sqrt(0.299 * color[0]**2 + 0.587 * color[1]**2 + 0.144 * color[2]**2);
				};
				BDFDB.ColorUtils.getType = function (color) {
					if (color != null) {
						if (typeof color === "object" && (color.length == 3 || color.length == 4)) {
							if (isRGB(color)) return "RGBCOMP";
							else if (isHSL(color)) return "HSLCOMP";
						}
						else if (typeof color === "string") {
							if (/^#[a-f\d]{3}$|^#[a-f\d]{6}$/i.test(color)) return "HEX";
							else if (/^#[a-f\d]{4}$|^#[a-f\d]{8}$/i.test(color)) return "HEXA";
							else {
								color = color.toUpperCase();
								let comp = color.replace(/[^0-9\.\-\,\%]/g, "").split(",");
								if (color.indexOf("RGB(") == 0 && comp.length == 3 && isRGB(comp)) return "RGB";
								else if (color.indexOf("RGBA(") == 0 && comp.length == 4 && isRGB(comp)) return "RGBA";
								else if (color.indexOf("HSL(") == 0 && comp.length == 3 && isHSL(comp)) return "HSL";
								else if (color.indexOf("HSLA(") == 0 && comp.length == 4 && isHSL(comp)) return "HSLA";
							}
						}
						else if (typeof color === "number" && parseInt(color) == color && color > -1 && color < 16777216) return "INT";
					}
					return null;
					function isRGB(comp) {return comp.slice(0, 3).every(rgb => rgb.toString().indexOf("%") == -1 && parseFloat(rgb) == parseInt(rgb));};
					function isHSL(comp) {return comp.slice(1, 3).every(hsl => hsl.toString().indexOf("%") == hsl.length - 1);};
				};
				BDFDB.ColorUtils.createGradient = function (colorObj, direction = "to right") {
					let gradientString = "linear-gradient(" + direction;
					for (let pos of Object.keys(colorObj).sort()) {
						let color = BDFDB.ColorUtils.convert(colorObj[pos], "RGBA");
						gradientString += color ? `, ${color} ${pos*100}%` : ''
					}
					return gradientString += ")";
				};

				BDFDB.DOMUtils = {};
				BDFDB.DOMUtils.getSelection = function () {
					let selection = document.getSelection();
					return selection && selection.anchorNode ? selection.getRangeAt(0).toString() : "";
				};
				BDFDB.DOMUtils.addClass = function (eles, ...classes) {
					if (!eles || !classes) return;
					for (let ele of [eles].map(n => NodeList.prototype.isPrototypeOf(n) ? Array.from(n) : n).flat(10).filter(n => n)) {
						if (Node.prototype.isPrototypeOf(ele)) add(ele);
						else if (NodeList.prototype.isPrototypeOf(ele)) for (let e of ele) add(e);
						else if (typeof ele == "string") for (let e of ele.split(",")) if (e && (e = e.trim())) for (let n of document.querySelectorAll(e)) add(n);
					}
					function add(node) {
						if (node && node.classList) for (let cla of classes) for (let cl of [cla].flat(10).filter(n => n)) if (typeof cl == "string") for (let c of cl.split(" ")) if (c) node.classList.add(c);
					}
				};
				BDFDB.DOMUtils.removeClass = function (eles, ...classes) {
					if (!eles || !classes) return;
					for (let ele of [eles].map(n => NodeList.prototype.isPrototypeOf(n) ? Array.from(n) : n).flat(10).filter(n => n)) {
						if (Node.prototype.isPrototypeOf(ele)) remove(ele);
						else if (NodeList.prototype.isPrototypeOf(ele)) for (let e of ele) remove(e);
						else if (typeof ele == "string") for (let e of ele.split(",")) if (e && (e = e.trim())) for (let n of document.querySelectorAll(e)) remove(n);
					}
					function remove(node) {
						if (node && node.classList) for (let cla of classes) for (let cl of [cla].flat(10).filter(n => n)) if (typeof cl == "string") for (let c of cl.split(" ")) if (c) node.classList.remove(c);
					}
				};
				BDFDB.DOMUtils.toggleClass = function (eles, ...classes) {
					if (!eles || !classes) return;
					var force = classes.pop();
					if (typeof force != "boolean") {
						classes.push(force);
						force = undefined;
					}
					if (!classes.length) return;
					for (let ele of [eles].map(n => NodeList.prototype.isPrototypeOf(n) ? Array.from(n) : n).flat(10).filter(n => n)) {
						if (Node.prototype.isPrototypeOf(ele)) toggle(ele);
						else if (NodeList.prototype.isPrototypeOf(ele)) for (let e of ele) toggle(e);
						else if (typeof ele == "string") for (let e of ele.split(",")) if (e && (e = e.trim())) for (let n of document.querySelectorAll(e)) toggle(n);
					}
					function toggle(node) {
						if (node && node.classList) for (let cla of classes) for (let cl of [cla].flat(10).filter(n => n)) if (typeof cl == "string") for (let c of cl.split(" ")) if (c) node.classList.toggle(c, force);
					}
				};
				BDFDB.DOMUtils.containsClass = function (eles, ...classes) {
					if (!eles || !classes) return;
					let all = classes.pop();
					if (typeof all != "boolean") {
						classes.push(all);
						all = true;
					}
					if (!classes.length) return;
					let contained = undefined;
					for (let ele of [eles].map(n => NodeList.prototype.isPrototypeOf(n) ? Array.from(n) : n).flat(10).filter(n => n)) {
						if (Node.prototype.isPrototypeOf(ele)) contains(ele);
						else if (NodeList.prototype.isPrototypeOf(ele)) for (let e of ele) contains(e);
						else if (typeof ele == "string") for (let c of ele.split(",")) if (c && (c = c.trim())) for (let n of document.querySelectorAll(c)) contains(n);
					}
					return contained;
					function contains(node) {
						if (node && node.classList) for (let cla of classes) if (typeof cla == "string") for (let c of cla.split(" ")) if (c) {
							if (contained === undefined) contained = all;
							if (all && !node.classList.contains(c)) contained = false;
							if (!all && node.classList.contains(c)) contained = true;
						}
					}
				};
				BDFDB.DOMUtils.replaceClass = function (eles, oldclass, newclass) {
					if (!eles || typeof oldclass != "string" || typeof newclass != "string") return;
					for (let ele of [eles].map(n => NodeList.prototype.isPrototypeOf(n) ? Array.from(n) : n).flat(10).filter(n => n)) {
						if (Node.prototype.isPrototypeOf(ele)) replace(ele);
						else if (NodeList.prototype.isPrototypeOf(ele)) for (let e of ele) replace(e);
						else if (typeof ele == "string") for (let e of ele.split(",")) if (e && (e = e.trim())) for (let n of document.querySelectorAll(e)) replace(n);
					}
					function replace(node) {
						if (node && node.tagName && node.className) node.className = node.className.replace(new RegExp(oldclass, "g"), newclass).trim();
					}
				};
				BDFDB.DOMUtils.formatClassName = function (...classes) {
					return BDFDB.ArrayUtils.removeCopies(classes.flat(10).filter(n => n).join(" ").split(" ")).join(" ").trim();
				};
				BDFDB.DOMUtils.removeClassFromDOM = function (...classes) {
					for (let c of classes.flat(10).filter(n => n)) if (typeof c == "string") for (let a of c.split(",")) if (a && (a = a.replace(/\.|\s/g, ""))) BDFDB.DOMUtils.removeClass(document.querySelectorAll("." + a), a);
				};
				BDFDB.DOMUtils.show = function (...eles) {
					BDFDB.DOMUtils.toggle(...eles, true);
				};
				BDFDB.DOMUtils.hide = function (...eles) {
					BDFDB.DOMUtils.toggle(...eles, false);
				};
				BDFDB.DOMUtils.toggle = function (...eles) {
					if (!eles) return;
					let force = eles.pop();
					if (typeof force != "boolean") {
						eles.push(force);
						force = undefined;
					}
					if (!eles.length) return;
					for (let ele of eles.flat(10).filter(n => n)) {
						if (Node.prototype.isPrototypeOf(ele)) toggle(ele);
						else if (NodeList.prototype.isPrototypeOf(ele)) for (let node of ele) toggle(node);
						else if (typeof ele == "string") for (let c of ele.split(",")) if (c && (c = c.trim())) for (let node of document.querySelectorAll(c)) toggle(node);
					}
					function toggle(node) {
						if (!node || !Node.prototype.isPrototypeOf(node)) return;
						let hide = force === undefined ? !BDFDB.DOMUtils.isHidden(node) : !force;
						if (hide) {
							let display = node.style.getPropertyValue("display");
							if (display && display != "none") node.BDFDBhideDisplayState = {
								display: display,
								important: (` ${node.style.cssText} `.split(` display: ${display}`)[1] || "").trim().indexOf("!important") == 0
							};
							node.style.setProperty("display", "none", "important");
						}
						else {
							if (node.BDFDBhideDisplayState) {
								node.style.setProperty("display", node.BDFDBhideDisplayState.display, node.BDFDBhideDisplayState.important ? "important" : "");
								delete node.BDFDBhideDisplayState;
							}
							else node.style.removeProperty("display");
						}
					}
				};
				BDFDB.DOMUtils.isHidden = function (node) {
					if (Node.prototype.isPrototypeOf(node) && node.nodeType != Node.TEXT_NODE) return getComputedStyle(node, null).getPropertyValue("display") == "none";
				};
				BDFDB.DOMUtils.remove = function (...eles) {
					for (let ele of eles.flat(10).filter(n => n)) {
						if (Node.prototype.isPrototypeOf(ele)) ele.remove();
						else if (NodeList.prototype.isPrototypeOf(ele)) {
							let nodes = Array.from(ele);
							while (nodes.length) nodes.shift().remove();
						}
						else if (typeof ele == "string") for (let c of ele.split(",")) if (c && (c = c.trim())) {
							let nodes = Array.from(document.querySelectorAll(c));
							while (nodes.length) nodes.shift().remove();
						}
					}
				};
				BDFDB.DOMUtils.create = function (html) {
					if (typeof html != "string" || !html.trim()) return null;
					let template = document.createElement("template");
					try {template.innerHTML = html.replace(/(?<!pre)>[\t\r\n]+<(?!pre)/g, "><");}
					catch (err) {template.innerHTML = html.replace(/>[\t\r\n]+<(?!pre)/g, "><");}
					if (template.content.childNodes.length == 1) return template.content.firstElementChild || template.content.firstChild;
					else {
						let wrapper = document.createElement("span");
						let nodes = Array.from(template.content.childNodes);
						while (nodes.length) wrapper.appendChild(nodes.shift());
						return wrapper;
					}
				};
				BDFDB.DOMUtils.getParent = function (listOrSelector, node) {
					let parent = null;
					if (Node.prototype.isPrototypeOf(node) && listOrSelector) {
						let list = NodeList.prototype.isPrototypeOf(listOrSelector) ? listOrSelector : typeof listOrSelector == "string" ? document.querySelectorAll(listOrSelector) : null;
						if (list) for (let listNode of list) if (listNode.contains(node)) {
							parent = listNode;
							break;
						}
					}
					return parent;
				};
				BDFDB.DOMUtils.setText = function (node, stringOrNode) {
					if (!node || !Node.prototype.isPrototypeOf(node)) return;
					let textnode = node.nodeType == Node.TEXT_NODE ? node : null;
					if (!textnode) for (let child of node.childNodes) if (child.nodeType == Node.TEXT_NODE || BDFDB.DOMUtils.containsClass(child, "BDFDB-textnode")) {
						textnode = child;
						break;
					}
					if (textnode) {
						if (Node.prototype.isPrototypeOf(stringOrNode) && stringOrNode.nodeType != Node.TEXT_NODE) {
							BDFDB.DOMUtils.addClass(stringOrNode, "BDFDB-textnode");
							node.replaceChild(stringOrNode, textnode);
						}
						else if (Node.prototype.isPrototypeOf(textnode) && textnode.nodeType != Node.TEXT_NODE) node.replaceChild(document.createTextNode(stringOrNode), textnode);
						else textnode.textContent = stringOrNode;
					}
					else node.appendChild(Node.prototype.isPrototypeOf(stringOrNode) ? stringOrNode : document.createTextNode(stringOrNode));
				};
				BDFDB.DOMUtils.getText = function (node) {
					if (!node || !Node.prototype.isPrototypeOf(node)) return;
					for (let child of node.childNodes) if (child.nodeType == Node.TEXT_NODE) return child.textContent;
				};
				BDFDB.DOMUtils.getRects = function (node) {
					let rects = {};
					if (Node.prototype.isPrototypeOf(node) && node.nodeType != Node.TEXT_NODE) {
						let hideNode = node;
						while (hideNode) {
							let hidden = BDFDB.DOMUtils.isHidden(hideNode);
							if (hidden) {
								BDFDB.DOMUtils.toggle(hideNode, true);
								hideNode.BDFDBgetRectsHidden = true;
							}
							hideNode = hideNode.parentElement;
						}
						rects = node.getBoundingClientRect();
						hideNode = node;
						while (hideNode) {
							if (hideNode.BDFDBgetRectsHidden) {
								BDFDB.DOMUtils.toggle(hideNode, false);
								delete hideNode.BDFDBgetRectsHidden;
							}
							hideNode = hideNode.parentElement;
						}
					}
					return rects;
				};
				BDFDB.DOMUtils.getHeight = function (node) {
					if (Node.prototype.isPrototypeOf(node) && node.nodeType != Node.TEXT_NODE) {
						let rects = BDFDB.DOMUtils.getRects(node);
						let style = getComputedStyle(node);
						return rects.height + parseInt(style.marginTop) + parseInt(style.marginBottom);
					}
					return 0;
				};
				BDFDB.DOMUtils.getInnerHeight = function (node) {
					if (Node.prototype.isPrototypeOf(node) && node.nodeType != Node.TEXT_NODE) {
						let rects = BDFDB.DOMUtils.getRects(node);
						let style = getComputedStyle(node);
						return rects.height - parseInt(style.paddingTop) - parseInt(style.paddingBottom);
					}
					return 0;
				};
				BDFDB.DOMUtils.getWidth = function (node) {
					if (Node.prototype.isPrototypeOf(node) && node.nodeType != Node.TEXT_NODE) {
						let rects = BDFDB.DOMUtils.getRects(node);
						let style = getComputedStyle(node);
						return rects.width + parseInt(style.marginLeft) + parseInt(style.marginRight);
					}
					return 0;
				};
				BDFDB.DOMUtils.getInnerWidth = function (node) {
					if (Node.prototype.isPrototypeOf(node) && node.nodeType != Node.TEXT_NODE) {
						let rects = BDFDB.DOMUtils.getRects(node);
						let style = getComputedStyle(node);
						return rects.width - parseInt(style.paddingLeft) - parseInt(style.paddingRight);
					}
					return 0;
				};
				BDFDB.DOMUtils.appendWebScript = function (url, container) {
					if (typeof url != "string") return;
					if (!container && !document.head.querySelector("bd-head bd-scripts")) document.head.appendChild(BDFDB.DOMUtils.create(`<bd-head><bd-scripts></bd-scripts></bd-head>`));
					container = container || document.head.querySelector("bd-head bd-scripts") || document.head;
					container = Node.prototype.isPrototypeOf(container) ? container : document.head;
					BDFDB.DOMUtils.removeWebScript(url, container);
					let script = document.createElement("script");
					script.src = url;
					container.appendChild(script);
				};
				BDFDB.DOMUtils.removeWebScript = function (url, container) {
					if (typeof url != "string") return;
					container = container || document.head.querySelector("bd-head bd-scripts") || document.head;
					container = Node.prototype.isPrototypeOf(container) ? container : document.head;
					BDFDB.DOMUtils.remove(container.querySelectorAll(`script[src="${url}"]`));
				};
				BDFDB.DOMUtils.appendWebStyle = function (url, container) {
					if (typeof url != "string") return;
					if (!container && !document.head.querySelector("bd-head bd-styles")) document.head.appendChild(BDFDB.DOMUtils.create(`<bd-head><bd-styles></bd-styles></bd-head>`));
					container = container || document.head.querySelector("bd-head bd-styles") || document.head;
					container = Node.prototype.isPrototypeOf(container) ? container : document.head;
					BDFDB.DOMUtils.removeWebStyle(url, container);
					container.appendChild(BDFDB.DOMUtils.create(`<link type="text/css" rel="stylesheet" href="${url}"></link>`));
				};
				BDFDB.DOMUtils.removeWebStyle = function (url, container) {
					if (typeof url != "string") return;
					container = container || document.head.querySelector("bd-head bd-styles") || document.head;
					container = Node.prototype.isPrototypeOf(container) ? container : document.head;
					BDFDB.DOMUtils.remove(container.querySelectorAll(`link[href="${url}"]`));
				};
				BDFDB.DOMUtils.appendLocalStyle = function (id, css, container) {
					if (typeof id != "string" || typeof css != "string") return;
					if (!container && !document.head.querySelector("bd-head bd-styles")) document.head.appendChild(BDFDB.DOMUtils.create(`<bd-head><bd-styles></bd-styles></bd-head>`));
					container = container || document.head.querySelector("bd-head bd-styles") || document.head;
					container = Node.prototype.isPrototypeOf(container) ? container : document.head;
					BDFDB.DOMUtils.removeLocalStyle(id, container);
					container.appendChild(BDFDB.DOMUtils.create(`<style id="${id}CSS">${css.replace(/\t|\r|\n/g,"")}</style>`));
				};
				BDFDB.DOMUtils.removeLocalStyle = function (id, container) {
					if (typeof id != "string") return;
					container = container || document.head.querySelector("bd-head bd-styles") || document.head;
					container = Node.prototype.isPrototypeOf(container) ? container : document.head;
					BDFDB.DOMUtils.remove(container.querySelectorAll(`style[id="${id}CSS"]`));
				};
				
				BDFDB.ModalUtils = {};
				BDFDB.ModalUtils.open = function (plugin, config) {
					if (!BDFDB.ObjectUtils.is(plugin) || !BDFDB.ObjectUtils.is(config)) return;
					let modalInstance, modalProps, cancels = [], closeModal = _ => {
						if (BDFDB.ObjectUtils.is(modalProps) && typeof modalProps.onClose == "function") modalProps.onClose();
					};
					
					let titleChildren = [], headerChildren = [], contentChildren = [], footerChildren = [];
					
					if (typeof config.text == "string") {
						config.contentClassName = BDFDB.DOMUtils.formatClassName(config.contentClassName, BDFDB.disCN.modaltextcontent);
						contentChildren.push(BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TextElement, {
							children: config.text
						}));
					}
					
					if (config.children) {
						let tabBarItems = [], tabIns = {};
						for (let child of [config.children].flat(10).filter(n => n)) if (LibraryModules.React.isValidElement(child)) {
							if (child.type == InternalComponents.LibraryComponents.ModalComponents.ModalTabContent) {
								if (!tabBarItems.length) child.props.open = true;
								else delete child.props.open;
								let ref = typeof child.ref == "function" ? child.ref : (_ => {});
								child.ref = instance => {
									ref(instance);
									if (instance) tabIns[child.props.tab] = instance;
								};
								tabBarItems.push({value: child.props.tab});
							}
							contentChildren.push(child);
						}
						if (tabBarItems.length) headerChildren.push(BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex, {
							className: BDFDB.disCN.tabbarcontainer,
							align: InternalComponents.LibraryComponents.Flex.Align.CENTER,
							children: [
								BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TabBar, {
									className: BDFDB.disCN.tabbar,
									itemClassName: BDFDB.disCN.tabbaritem,
									type: InternalComponents.LibraryComponents.TabBar.Types.TOP,
									items: tabBarItems,
									onItemSelect: value => {
										for (let key in tabIns) {
											if (key == value) tabIns[key].props.open = true;
											else delete tabIns[key].props.open;
										}
										BDFDB.ReactUtils.forceUpdate(BDFDB.ObjectUtils.toArray(tabIns));
									}
								}),
								config.tabBarChildren
							].flat(10).filter(n => n)
						}));
					}
					
					if (BDFDB.ArrayUtils.is(config.buttons)) for (let button of config.buttons) {
						let contents = typeof button.contents == "string" && button.contents;
						if (contents) {
							let color = typeof button.color == "string" && InternalComponents.LibraryComponents.Button.Colors[button.color.toUpperCase()];
							let look = typeof button.look == "string" && InternalComponents.LibraryComponents.Button.Looks[button.look.toUpperCase()];
							let click = typeof button.click == "function" ? button.click : (typeof button.onClick == "function" ? button.onClick : _ => {});
							
							if (button.cancel) cancels.push(click);
							
							footerChildren.push(BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Button, BDFDB.ObjectUtils.exclude(Object.assign({}, button, {
								look: look || (color ? InternalComponents.LibraryComponents.Button.Looks.FILLED : InternalComponents.LibraryComponents.Button.Looks.LINK),
								color: color || InternalComponents.LibraryComponents.Button.Colors.PRIMARY,
								onClick: _ => {
									if (button.close) closeModal();
									if (!(button.close && button.cancel)) click(modalInstance);
								},
								children: contents
							}), "click", "close", "cancel", "contents")));
						}
					}
					
					contentChildren = contentChildren.concat(config.contentChildren).filter(n => n && (typeof n == "string" || BDFDB.ReactUtils.isValidElement(n)));
					titleChildren = titleChildren.concat(config.titleChildren).filter(n => n && (typeof n == "string" || BDFDB.ReactUtils.isValidElement(n)));
					headerChildren = headerChildren.concat(config.headerChildren).filter(n => n && (typeof n == "string" || BDFDB.ReactUtils.isValidElement(n)));
					footerChildren = footerChildren.concat(config.footerChildren).filter(n => n && (typeof n == "string" || BDFDB.ReactUtils.isValidElement(n)));
					
					if (contentChildren.length) {
						if (typeof config.onClose != "function") config.onClose = _ => {};
						if (typeof config.onOpen != "function") config.onOpen = _ => {};
						
						let name = plugin.name || (typeof plugin.getName == "function" ? plugin.getName() : null);
						name = typeof name == "string" ? name : null;
						let oldTransitionState = 0;
						LibraryModules.ModalUtils.openModal(props => {
							modalProps = props;
							return BDFDB.ReactUtils.createElement(class BDFDB_Modal extends LibraryModules.React.Component {
								render() {
									return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.ModalComponents.ModalRoot, {
										className: BDFDB.DOMUtils.formatClassName(name && `${name}-modal`, BDFDB.disCN.modalwrapper, config.className),
										size: typeof config.size == "string" && InternalComponents.LibraryComponents.ModalComponents.ModalSize[config.size.toUpperCase()] || InternalComponents.LibraryComponents.ModalComponents.ModalSize.SMALL,
										transitionState: props.transitionState,
										children: [
											BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.ModalComponents.ModalHeader, {
												className: BDFDB.DOMUtils.formatClassName(config.headerClassName, config.shade && BDFDB.disCN.modalheadershade, headerChildren.length && BDFDB.disCN.modalheaderhassibling),
												separator: config.headerSeparator || false,
												children: [
													BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex.Child, {
														children: [
															BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.FormComponents.FormTitle, {
																tag: InternalComponents.LibraryComponents.FormComponents.FormTitle.Tags.H4,
																children: config.header
															}),
															BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TextElement, {
																size: InternalComponents.LibraryComponents.TextElement.Sizes.SIZE_12,
																children: typeof config.subHeader == "string" || BDFDB.ReactUtils.isValidElement(config.subHeader) ? config.subHeader : (name || "")
															})
														]
													}),
													titleChildren,
													BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.ModalComponents.ModalCloseButton, {
														onClick: closeModal
													})
												].flat(10).filter(n => n)
											}),
											headerChildren.length ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex, {
												grow: 0,
												shrink: 0,
												children: headerChildren
											}) : null,
											BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.ModalComponents.ModalContent, {
												className: config.contentClassName,
												scroller: config.scroller,
												direction: config.direction,
												content: config.content,
												children: contentChildren
											}),
											footerChildren.length ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.ModalComponents.ModalFooter, {
												className: config.footerClassName,
												direction: config.footerDirection,
												children: footerChildren
											}) : null
										]
									});
								}
								componentDidMount() {
									modalInstance = this;
									if (props.transitionState == 1 && props.transitionState > oldTransitionState) config.onOpen(modalInstance);
									oldTransitionState = props.transitionState;
								}
								componentWillUnmount() {
									if (props.transitionState == 3) {
										for (let cancel of cancels) cancel(modalInstance);
										config.onClose(modalInstance);
									}
								}
							}, props, true);
						}, {
							onCloseRequest: closeModal
						});
					}
				};
				BDFDB.ModalUtils.confirm = function (plugin, text, callback) {
					if (!BDFDB.ObjectUtils.is(plugin) || typeof text != "string") return;
					BDFDB.ModalUtils.open(plugin, {
						text: text,
						header: BDFDB.LanguageUtils.LibraryStrings.confirm,
						className: BDFDB.disCN.modalconfirmmodal,
						scroller: false,
						buttons: [
							{contents: BDFDB.LanguageUtils.LanguageStrings.OKAY, close: true, color: "RED", onClick: callback},
							{contents: BDFDB.LanguageUtils.LanguageStrings.CANCEL, close: true}
						]
					});
				};
			
				const RealMenuItems = BDFDB.ModuleUtils.findByProperties("MenuItem", "MenuGroup");
				BDFDB.ContextMenuUtils = {};
				BDFDB.ContextMenuUtils.open = function (plugin, e, children) {
					LibraryModules.ContextMenuUtils.openContextMenu(e, function (e) {
						return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Menu, {
							navId: "bdfdb-context",
							onClose: LibraryModules.ContextMenuUtils.closeContextMenu,
							children: children
						}, true);
					});
				};
				BDFDB.ContextMenuUtils.close = function (nodeOrInstance) {
					if (!BDFDB.ObjectUtils.is(nodeOrInstance)) return;
					let instance = BDFDB.ReactUtils.findOwner(nodeOrInstance, {props: "closeContextMenu", up: true});
					if (BDFDB.ObjectUtils.is(instance) && instance.props && typeof instance.props.closeContextMenu == "function") instance.props.closeContextMenu();
					else LibraryModules.ContextMenuUtils.closeContextMenu();
				};
				BDFDB.ContextMenuUtils.createItem = function (component, props = {}) {
					if (!component) return null;
					else {
						if (props.render || props.persisting || BDFDB.ObjectUtils.is(props.popoutProps) || (typeof props.color == "string" && !DiscordClasses[`menu${props.color.toLowerCase()}`])) component = InternalComponents.MenuItem;
						if (BDFDB.ObjectUtils.toArray(RealMenuItems).some(c => c == component)) return BDFDB.ReactUtils.createElement(component, props);
						else return BDFDB.ReactUtils.createElement(RealMenuItems.MenuItem, {
							id: props.id,
							disabled: props.disabled,
							customItem: true,
							render: menuItemProps => {
								if (!props.state) props.state = BDFDB.ObjectUtils.extract(props, "checked", "value");
								return BDFDB.ReactUtils.createElement(InternalComponents.CustomMenuItemWrapper, {
									disabled: props.disabled,
									childProps: Object.assign({}, props, menuItemProps, {color: props.color}),
									children: component
								}, true);
							}
						});
					}
				};
				BDFDB.ContextMenuUtils.createItemId = function (...strings) {
					return strings.map(s => typeof s == "number" ? s.toString() : s).filter(s => typeof s == "string").map(s => s.toLowerCase().replace(/\s/, "-")).join("-");
				};
				BDFDB.ContextMenuUtils.findItem = function (returnvalue, config) {
					if (!returnvalue || !BDFDB.ObjectUtils.is(config) || !config.label && !config.id) return [null, -1];
					config.label = config.label && [config.label].flat().filter(n => n);
					config.id = config.id && [config.id].flat().filter(n => n);
					let contextMenu = BDFDB.ReactUtils.findChild(returnvalue, {props: "navId"});
					if (contextMenu) {
						for (let i in contextMenu.props.children) {
							if (contextMenu.props.children[i] && contextMenu.props.children[i].type == RealMenuItems.MenuGroup) {
								if (BDFDB.ArrayUtils.is(contextMenu.props.children[i].props.children)) {
									for (let j in contextMenu.props.children[i].props.children) if (check(contextMenu.props.children[i].props.children[j])) {
										if (config.group) return [contextMenu.props.children, parseInt(i)];
										else return [contextMenu.props.children[i].props.children, parseInt(j)];
									}
								}
								else if (contextMenu.props.children[i] && contextMenu.props.children[i].props) {
									if (check(contextMenu.props.children[i].props.children)) {
										if (config.group) return [contextMenu.props.children, parseInt(i)];
										else {
											contextMenu.props.children[i].props.children = [contextMenu.props.children[i].props.children];
											return [contextMenu.props.children[i].props.children, 0];
										}
									}
									else if (contextMenu.props.children[i].props.children && contextMenu.props.children[i].props.children.props && BDFDB.ArrayUtils.is(contextMenu.props.children[i].props.children.props.children)) {
										for (let j in contextMenu.props.children[i].props.children.props.children) if (check(contextMenu.props.children[i].props.children.props.children[j])) {
											if (config.group) return [contextMenu.props.children, parseInt(i)];
											else return [contextMenu.props.children[i].props.children.props.children, parseInt(j)];
										}
									}
								}
							}
							else if (check(contextMenu.props.children[i])) return [contextMenu.props.children, parseInt(i)];
						}
						return [contextMenu.props.children, -1];
					}
					return [null, -1];
					function check (child) {
						if (!child) return false;
						let props = child.stateNode ? child.stateNode.props : child.props;
						if (!props) return false;
						return config.id && config.id.some(key => props.id == key) || config.label && config.label.some(key => props.label == key);
					}
				};

				BDFDB.StringUtils = {};
				BDFDB.StringUtils.htmlEscape = function (string) {
					let ele = document.createElement("div");
					ele.innerText = string;
					return ele.innerHTML;
				};
				BDFDB.StringUtils.regEscape = function (string) {
					return typeof string == "string" && string.replace(/([\-\/\\\^\$\*\+\?\.\(\)\|\[\]\{\}])/g, "\\$1");
				};
				BDFDB.StringUtils.insertNRST = function (string) {
					return typeof string == "string" && string.replace(/\\r/g, "\r").replace(/\\n/g, "\n").replace(/\\t/g, "\t").replace(/\\s/g, " ");
				};
				BDFDB.StringUtils.highlight = function (string, searchstring, prefix = `<span class="${BDFDB.disCN.highlight}">`, suffix = `</span>`) {
					if (typeof string != "string" || !searchstring || searchstring.length < 1) return string;
					let offset = 0, original = string;
					BDFDB.ArrayUtils.getAllIndexes(string.toUpperCase(), searchstring.toUpperCase()).forEach(index => {
						let d1 = offset * (prefix.length + suffix.length);
						index = index + d1;
						let d2 = index + searchstring.length;
						let d3 = [-1].concat(BDFDB.ArrayUtils.getAllIndexes(string.substring(0, index), "<"));
						let d4 = [-1].concat(BDFDB.ArrayUtils.getAllIndexes(string.substring(0, index), ">"));
						if (d3[d3.length - 1] > d4[d4.length - 1]) return;
						string = string.substring(0, index) + prefix + string.substring(index, d2) + suffix + string.substring(d2);
						offset++;
					});
					return string || original;
				};
				BDFDB.StringUtils.findMatchCaseless = function (match, string, any) {
					if (typeof match != "string" || typeof string != "string" || !match || !string) return "";
					match = BDFDB.StringUtils.regEscape(match);
					let exec = (new RegExp(any ? `([\\n\\r\\s]+${match})|(^${match})` : `([\\n\\r\\s]+${match}[\\n\\r\\s]+)|([\\n\\r\\s]+${match}$)|(^${match}[\\n\\r\\s]+)|(^${match}$)`, "i")).exec(string);
					return exec && typeof exec[0] == "string" && exec[0].replace(/[\n\r\s]/g, "") || "";
				};
				BDFDB.StringUtils.equalCase = function (match, string) {
					if (typeof match != "string" || typeof string != "string") return "";
					let first = match.charAt(0);
					return first != first.toUpperCase() ? (string.charAt(0).toLowerCase() + string.slice(1)) : first != first.toLowerCase() ? (string.charAt(0).toUpperCase() + string.slice(1)) : string;
				};
				BDFDB.StringUtils.extractSelection = function (original, selection) {
					if (typeof original != "string") return "";
					if (typeof selection != "string") return original;
					let s = [], f = [], wrong = 0, canceled = false, done = false;
					for (let i of BDFDB.ArrayUtils.getAllIndexes(original, selection[0])) if (!done) {
						while (i <= original.length && !done) {
							let subSelection = selection.slice(s.filter(n => n != undefined).length);
							if (!subSelection && s.length - 20 <= selection.length) done = true;
							else for (let j in subSelection) if (!done && !canceled) {
								if (original[i] == subSelection[j]) {
									s[i] = subSelection[j];
									f[i] = subSelection[j];
									wrong = 0;
									if (i == original.length) done = true;
								}
								else {
									s[i] = null;
									f[i] = original[i];
									wrong++;
									if (wrong > 4) {
										s = [], f = [], wrong = 0, canceled = true;
										break;
									}
								}
								break;
							}
							canceled = false;
							i++;
						}
					}
					if (s.filter(n => n).length) {
						let reverseS = [].concat(s).reverse(), i = 0, j = 0;
						for (let k in s) {
							if (s[k] == null) i = parseInt(k) + 1;
							else break;
						}
						for (let k in reverseS) {
							if (reverseS[k] == null) j = parseInt(k) + 1;
							else break;
						}
						return f.slice(i, f.length - j).join("");
					}
					else return original;
				};
				
				BDFDB.SlateUtils = {};
				BDFDB.SlateUtils.isRichValue = function (richValue) {
					return BDFDB.ObjectUtils.is(richValue) && LibraryModules.SlateUtils.deserialize("").constructor.prototype.isPrototypeOf(richValue);
				};
				BDFDB.SlateUtils.copyRichValue = function (string, richValue) {
					let newRichValue = LibraryModules.SlateUtils.deserialize(string);
					if (BDFDB.SlateUtils.isRichValue(richValue) && richValue._map && richValue._map._root && BDFDB.ArrayUtils.is(richValue._map._root.entries)) {
						for (let i in richValue._map._root.entries) if (richValue._map._root.entries[i][0] == "selection") {
							newRichValue._map._root.entries[i] = richValue._map._root.entries[i];
							break;
						}
					}
					return newRichValue;
				};
				
				BDFDB.NumberUtils = {};
				BDFDB.NumberUtils.formatBytes = function (bytes, sigDigits) {
					bytes = parseInt(bytes);
					if (isNaN(bytes) || bytes < 0) return "0 Bytes";
					if (bytes == 1) return "1 Byte";
					let size = Math.floor(Math.log(bytes) / Math.log(1024));
					return parseFloat((bytes / Math.pow(1024, size)).toFixed(sigDigits < 1 ? 0 : sigDigits > 20 ? 20 : sigDigits || 2)) + " " + ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"][size];
				};
				BDFDB.NumberUtils.mapRange = function (from, to, value) {
					if (parseFloat(value) < parseFloat(from[0])) return parseFloat(to[0]);
					else if (parseFloat(value) > parseFloat(from[1])) return parseFloat(to[1]);
					else return parseFloat(to[0]) + (parseFloat(value) - parseFloat(from[0])) * (parseFloat(to[1]) - parseFloat(to[0])) / (parseFloat(from[1]) - parseFloat(from[0]));
				};
				BDFDB.NumberUtils.generateId = function (array) {
					array = BDFDB.ArrayUtils.is(array) ? array : [];
					let id = Math.floor(Math.random() * 10000000000000000);
					if (array.includes(id)) return BDFDB.NumberUtils.generateId(array);
					else {
						array.push(id);
						return id;
					}
				};
				BDFDB.NumberUtils.compareVersions = function (newV, oldV) {
					if (!newV || !oldV) return true;
					newV = newV.toString().replace(/["'`]/g, "").split(/,|\./g).map(n => parseInt(n)).filter(n => (n || n == 0) && !isNaN(n));
					oldV = oldV.toString().replace(/["'`]/g, "").split(/,|\./g).map(n => parseInt(n)).filter(n => (n || n == 0) && !isNaN(n));
					let length = Math.max(newV.length, oldV.length);
					if (!length) return true;
					if (newV.length > oldV.length) {
						let tempArray = new Array(newV.length - oldV.length);
						for (let i = 0; i < tempArray.length; i++) tempArray[i] = 0;
						oldV = tempArray.concat(oldV);
					}
					else if (newV.length < oldV.length) {
						let tempArray = new Array(oldV.length - newV.length);
						for (let i = 0; i < tempArray.length; i++) tempArray[i] = 0;
						newV = tempArray.concat(newV);
					}
					for (let i = 0; i < length; i++) for (let iOutdated = false, j = 0; j <= i; j++) {
						if (j == i && newV[j] < oldV[j]) return false;
						if (j < i) iOutdated = newV[j] == oldV[j];
						if ((j == 0 || iOutdated) && j == i && newV[j] > oldV[j]) return true;
					}
					return false;
				};
				BDFDB.NumberUtils.getVersionDifference = function (newV, oldV) {
					if (!newV || !oldV) return false;
					newV = newV.toString().replace(/["'`]/g, "").split(/,|\./g).map(n => parseInt(n)).filter(n => (n || n == 0) && !isNaN(n));
					oldV = oldV.toString().replace(/["'`]/g, "").split(/,|\./g).map(n => parseInt(n)).filter(n => (n || n == 0) && !isNaN(n));
					let length = Math.max(newV.length, oldV.length);
					if (!length) return false;
					if (newV.length > oldV.length) {
						let tempArray = new Array(newV.length - oldV.length);
						for (let i = 0; i < tempArray.length; i++) tempArray[i] = 0;
						oldV = tempArray.concat(oldV);
					}
					else if (newV.length < oldV.length) {
						let tempArray = new Array(oldV.length - newV.length);
						for (let i = 0; i < tempArray.length; i++) tempArray[i] = 0;
						newV = tempArray.concat(newV);
					}
					let oldValue = 0, newValue = 0;
					for (let i in oldV.reverse()) oldValue += (oldV[i] * (10 ** i));
					for (let i in newV.reverse()) newValue += (newV[i] * (10 ** i));
					return (newValue - oldValue) / (10 ** (length-1));
				};

				BDFDB.DiscordUtils = {};
				BDFDB.DiscordUtils.openLink = function (url, config = {}) {
					if ((config.inBuilt || config.inBuilt === undefined && InternalBDFDB.settings.general.useChromium) && LibraryRequires.electron && LibraryRequires.electron.remote) {
						let browserWindow = new LibraryRequires.electron.remote.BrowserWindow({
							frame: true,
							resizeable: true,
							show: true,
							darkTheme: BDFDB.DiscordUtils.getTheme() == BDFDB.disCN.themedark,
							webPreferences: {
								nodeIntegration: false,
								nodeIntegrationInWorker: false
							}
						});
						browserWindow.setMenu(null);
						browserWindow.loadURL(url);
						if (config.minimized) browserWindow.minimize(null);
					}
					else window.open(url, "_blank");
				};
				window.DiscordNative && window.DiscordNative.app && window.DiscordNative.app.getPath("appData").then(path => {BDFDB.DiscordUtils.getFolder.base = path;});
				BDFDB.DiscordUtils.getFolder = function () {
					if (!BDFDB.DiscordUtils.getFolder.base) return "";
					else if (BDFDB.DiscordUtils.getFolder.folder) return BDFDB.DiscordUtils.getFolder.folder;
					else {
						let folder;
						try {
							let build = BDFDB.DiscordUtils.getBuild();
							build = "discord" + (build == "stable" ? "" : build);
							folder = LibraryRequires.path.resolve(BDFDB.DiscordUtils.getFolder.base, build, BDFDB.DiscordUtils.getVersion());
						} 
						catch (err) {folder = BDFDB.DiscordUtils.getFolder.base;}
						return BDFDB.DiscordUtils.getFolder.folder = folder;
					}
				};
				BDFDB.DiscordUtils.getBuild = function () {
					if (BDFDB.DiscordUtils.getBuild.build) return BDFDB.DiscordUtils.getBuild.build;
					else {
						let build;
						try {build = window.DiscordNative.app.getReleaseChannel();} 
						catch (err) {
							let version = BDFDB.DiscordUtils.getVersion();
							if (version) {
								version = version.split(".");
								if (version.length == 3 && !isNaN(version = parseInt(version[2]))) build = version > 300 ? "stable" : version > 200 ? "canary" : "ptb";
								else build = "stable";
							}
							else build = "stable";
						}
						return BDFDB.DiscordUtils.getBuild.build = build;
					}
				};
				BDFDB.DiscordUtils.getVersion = function () {
					if (BDFDB.DiscordUtils.getVersion.version) return BDFDB.DiscordUtils.getVersion.version;
					else {
						let version;
						try {version = window.DiscordNative.app.getVersion();}
						catch (err) {version = "999.999.9999";}
						return BDFDB.DiscordUtils.getVersion.version = version;
					}
				};
				BDFDB.DiscordUtils.isDevModeEnabled = function () {
					return LibraryModules.SettingsStore.developerMode;
				};
				BDFDB.DiscordUtils.getTheme = function () {
					return LibraryModules.SettingsStore.theme != "dark" ? BDFDB.disCN.themelight : BDFDB.disCN.themedark;
				};
				BDFDB.DiscordUtils.getMode = function () {
					return LibraryModules.SettingsStore.messageDisplayCompact ? "compact" : "cozy";
				};
				BDFDB.DiscordUtils.getZoomFactor = function () {
					let aRects = BDFDB.DOMUtils.getRects(document.querySelector(BDFDB.dotCN.appmount));
					let widthZoom = Math.round(100 * window.outerWidth / aRects.width);
					let heightZoom = Math.round(100 * window.outerHeight / aRects.height);
					return widthZoom < heightZoom ? widthZoom : heightZoom;
				};
				BDFDB.DiscordUtils.getFontScale = function () {
					return parseInt(document.firstElementChild.style.fontSize.replace("%", ""));
				};
				BDFDB.DiscordUtils.shake = function () {
					BDFDB.ReactUtils.findOwner(document.querySelector(BDFDB.dotCN.appcontainer), {name: "Shakeable", unlimited: true, up: true}).shake();
				};
				BDFDB.DiscordUtils.rerenderAll = function (instant) {
					BDFDB.TimeUtils.clear(BDFDB.DiscordUtils.rerenderAll.timeout);
					BDFDB.DiscordUtils.rerenderAll.timeout = BDFDB.TimeUtils.timeout(_ => {
						let ShakeableIns = BDFDB.ReactUtils.findOwner(document.querySelector(BDFDB.dotCN.appcontainer), {name: "Shakeable", unlimited: true, up: true});
						let ShakeablePrototype = BDFDB.ObjectUtils.get(ShakeableIns, `${BDFDB.ReactUtils.instanceKey}.type.prototype`);
						if (ShakeableIns && ShakeablePrototype) {
							BDFDB.PatchUtils.patch({name: "BDFDB DiscordUtils"}, ShakeablePrototype, "render", {after: e => {
								e.returnValue.props.children = typeof e.returnValue.props.children == "function" ? (_ => {return null;}) : [];
								BDFDB.ReactUtils.forceUpdate(ShakeableIns);
							}}, {once: true});
							BDFDB.ReactUtils.forceUpdate(ShakeableIns);
						}
					}, instant ? 0 : 1000);
				};

				BDFDB.WindowUtils = {};
				BDFDB.WindowUtils.open = function (plugin, url, config = {}) {
					plugin = plugin == BDFDB && InternalBDFDB || plugin;
					if (!BDFDB.ObjectUtils.is(plugin) || !url || !LibraryRequires.electron || !LibraryRequires.electron.remote) return;
					if (!BDFDB.ArrayUtils.is(plugin.browserWindows)) plugin.browserWindows = [];
					config = Object.assign({
						show: false,
						webPreferences: {
							nodeIntegration: true,
							nodeIntegrationInWorker: true
						}
					}, config);
					let browserWindow = new LibraryRequires.electron.remote.BrowserWindow(BDFDB.ObjectUtils.exclude(config, "showOnReady", "onLoad"));
					
					if (!config.show && config.showOnReady) browserWindow.once("ready-to-show", browserWindow.show);
					if (config.devTools) browserWindow.openDevTools();
					if (typeof config.onLoad == "function") browserWindow.webContents.on("did-finish-load", (...args) => {config.onLoad(...args);});
					if (typeof config.onClose == "function") browserWindow.once("closed", (...args) => {config.onClose(...args);});
					
					if (typeof browserWindow.removeMenu == "function") browserWindow.removeMenu();
					else browserWindow.setMenu(null);
					browserWindow.loadURL(url);
					browserWindow.executeJavaScriptSafe = js => {if (!browserWindow.isDestroyed()) browserWindow.webContents.executeJavaScript(`(_ => {${js}})();`);};
					plugin.browserWindows.push(browserWindow);
					return browserWindow;
				};
				BDFDB.WindowUtils.close = function (browserWindow) {
					if (BDFDB.ObjectUtils.is(browserWindow) && !browserWindow.isDestroyed() && browserWindow.isClosable()) browserWindow.close();
				};
				BDFDB.WindowUtils.closeAll = function (plugin) {
					plugin = plugin == BDFDB && InternalBDFDB || plugin;
					if (!BDFDB.ObjectUtils.is(plugin) || !BDFDB.ArrayUtils.is(plugin.browserWindows)) return;
					while (plugin.browserWindows.length) BDFDB.WindowUtils.close(plugin.browserWindows.pop());
				};
				BDFDB.WindowUtils.addListener = function (plugin, actions, callback) {
					plugin = plugin == BDFDB && InternalBDFDB || plugin;
					if (!BDFDB.ObjectUtils.is(plugin) || !actions || typeof callback != "function") return;
					BDFDB.WindowUtils.removeListener(plugin, actions);
					for (let action of actions.split(" ")) {
						action = action.split(".");
						let eventName = action.shift();
						if (!eventName) return;
						let namespace = (action.join(".") || "") + plugin.name;
						if (!BDFDB.ArrayUtils.is(plugin.ipcListeners)) plugin.ipcListeners = [];

						plugin.ipcListeners.push({eventName, namespace, callback});
						LibraryRequires.electron.ipcRenderer.on(eventName, callback);
					}
				};
				BDFDB.WindowUtils.removeListener = function (plugin, actions = "") {
					plugin = plugin == BDFDB && InternalBDFDB || plugin;
					if (!BDFDB.ObjectUtils.is(plugin) || !BDFDB.ArrayUtils.is(plugin.ipcListeners)) return;
					if (actions) {
						for (let action of actions.split(" ")) {
							action = action.split(".");
							let eventName = action.shift();
							let namespace = (action.join(".") || "") + plugin.name;
							for (let listener of plugin.ipcListeners) {
								let removedListeners = [];
								if (listener.eventName == eventName && listener.namespace == namespace) {
									LibraryRequires.electron.ipcRenderer.off(listener.eventName, listener.callback);
									removedListeners.push(listener);
								}
								if (removedListeners.length) plugin.ipcListeners = plugin.ipcListeners.filter(listener => {return removedListeners.indexOf(listener) < 0;});
							}
						}
					}
					else {
						for (let listener of plugin.ipcListeners) LibraryRequires.electron.ipcRenderer.off(listener.eventName, listener.callback);
						plugin.ipcListeners = [];
					}
				};
				
				const DiscordClassModules = Object.assign({}, InternalData.CustomClassModules);
				for (let name in InternalData.DiscordClassModules) {
					if (InternalData.DiscordClassModules[name].length) DiscordClassModules[name] = BDFDB.ModuleUtils.find(m => InternalData.DiscordClassModules[name].props.every(prop => typeof m[prop] == "string") && (InternalData.DiscordClassModules[name].smaller ? Object.keys(m).length < InternalData.DiscordClassModules[name].length : Object.keys(m).length == InternalData.DiscordClassModules[name].length));
					else DiscordClassModules[name] = BDFDB.ModuleUtils.findByProperties(InternalData.DiscordClassModules[name].props);
				}
				BDFDB.DiscordClassModules = Object.assign({}, DiscordClassModules);
				
				const DiscordClasses = Object.assign({}, InternalData.DiscordClasses);
				BDFDB.DiscordClasses = Object.assign({}, DiscordClasses);
				InternalBDFDB.getDiscordClass = function (item, selector) {
					let className = fallbackClassName = DiscordClassModules.BDFDB.BDFDBundefined + "-" + InternalBDFDB.generateClassId();
					if (DiscordClasses[item] === undefined) {
						BDFDB.LogUtils.warn([item, "not found in DiscordClasses"]);
						return className;
					} 
					else if (!BDFDB.ArrayUtils.is(DiscordClasses[item]) || DiscordClasses[item].length != 2) {
						BDFDB.LogUtils.warn([item, "is not an Array of Length 2 in DiscordClasses"]);
						return className;
					}
					else if (DiscordClassModules[DiscordClasses[item][0]] === undefined) {
						BDFDB.LogUtils.warn([DiscordClasses[item][0], "not found in DiscordClassModules"]);
						return className;
					}
					else if ([DiscordClasses[item][1]].flat().every(prop => DiscordClassModules[DiscordClasses[item][0]][prop] === undefined)) {
						BDFDB.LogUtils.warn([DiscordClasses[item][1], "not found in", DiscordClasses[item][0], "in DiscordClassModules"]);
						return className;
					}
					else {
						for (let prop of [DiscordClasses[item][1]].flat()) {
							className = DiscordClassModules[DiscordClasses[item][0]][prop];
							if (className) break;
							else className = fallbackClassName;
						}
						if (selector) {
							className = className.split(" ").filter(n => n.indexOf("da-") != 0).join(selector ? "." : " ");
							className = className || fallbackClassName;
						}
						return BDFDB.ArrayUtils.removeCopies(className.split(" ")).join(" ") || fallbackClassName;
					}
				};
				const generationChars = "0123456789ABCDEFGHIJKMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("");
				InternalBDFDB.generateClassId = function () {
					let id = "";
					while (id.length < 6) id += generationChars[Math.floor(Math.random() * generationChars.length)];
					return id;
				};
				BDFDB.disCN = new Proxy(DiscordClasses, {
					get: function (list, item) {
						return InternalBDFDB.getDiscordClass(item, false).replace("#", "");
					}
				});
				BDFDB.disCNS = new Proxy(DiscordClasses, {
					get: function (list, item) {
						return InternalBDFDB.getDiscordClass(item, false).replace("#", "") + " ";
					}
				});
				BDFDB.disCNC = new Proxy(DiscordClasses, {
					get: function (list, item) {
						return InternalBDFDB.getDiscordClass(item, false).replace("#", "") + ",";
					}
				});
				BDFDB.dotCN = new Proxy(DiscordClasses, {
					get: function (list, item) {
						let className = InternalBDFDB.getDiscordClass(item, true);
						return (className.indexOf("#") == 0 ? "" : ".") + className;
					}
				});
				BDFDB.dotCNS = new Proxy(DiscordClasses, {
					get: function (list, item) {
						let className = InternalBDFDB.getDiscordClass(item, true);
						return (className.indexOf("#") == 0 ? "" : ".") + className + " ";
					}
				});
				BDFDB.dotCNC = new Proxy(DiscordClasses, {
					get: function (list, item) {
						let className = InternalBDFDB.getDiscordClass(item, true);
						return (className.indexOf("#") == 0 ? "" : ".") + className + ",";
					}
				});
				BDFDB.notCN = new Proxy(DiscordClasses, {
					get: function (list, item) {
						return `:not(.${InternalBDFDB.getDiscordClass(item, true).split(".")[0]})`;
					}
				});
				BDFDB.notCNS = new Proxy(DiscordClasses, {
					get: function (list, item) {
						return `:not(.${InternalBDFDB.getDiscordClass(item, true).split(".")[0]}) `;
					}
				});
				BDFDB.notCNC = new Proxy(DiscordClasses, {
					get: function (list, item) {
						return `:not(.${InternalBDFDB.getDiscordClass(item, true).split(".")[0]}),`;
					}
				});
			
				const LanguageStrings = LibraryModules.LanguageStore && LibraryModules.LanguageStore._proxyContext ? Object.assign({}, LibraryModules.LanguageStore._proxyContext.defaultMessages) : {};
				const LibraryStrings = Object.assign({}, InternalData.LibraryStrings);
				BDFDB.LanguageUtils = {};
				BDFDB.LanguageUtils.languages = Object.assign({}, InternalData.Languages);
				BDFDB.LanguageUtils.getLanguage = function () {
					let lang = LibraryModules.LanguageStore.chosenLocale || LibraryModules.SettingsStore.locale || "en";
					if (lang == "en-GB" || lang == "en-US") lang = "en";
					let langIds = lang.split("-");
					let langId = langIds[0];
					let langId2 = langIds[1] || "";
					lang = langId2 && langId.toUpperCase() !== langId2.toUpperCase() ? langId + "-" + langId2 : langId;
					return BDFDB.LanguageUtils.languages[lang] || BDFDB.LanguageUtils.languages[langId] || BDFDB.LanguageUtils.languages.en;
				};
				BDFDB.LanguageUtils.getName = function (language) {
					if (!language || typeof language.name != "string") return "";
					if (language.name.startsWith("Discord")) return language.name.slice(0, -1) + (language.ownlang && (BDFDB.LanguageUtils.languages[language.id] || {}).name != language.ownlang ? ` / ${language.ownlang}` : "") + ")";
					else return language.name + (language.ownlang && language.name != language.ownlang ? ` / ${language.ownlang}` : "");
				};
				BDFDB.LanguageUtils.LanguageStrings = new Proxy(LanguageStrings, {
					get: function (list, item) {
						let stringObj = LibraryModules.LanguageStore.Messages[item];
						if (!stringObj) BDFDB.LogUtils.warn([item, "not found in BDFDB.LanguageUtils.LanguageStrings"]);
						else {
							if (stringObj && typeof stringObj == "object" && typeof stringObj.format == "function") return BDFDB.LanguageUtils.LanguageStringsFormat(item);
							else return stringObj;
						}
						return "";
					}
				});
				BDFDB.LanguageUtils.LanguageStringsCheck = new Proxy(LanguageStrings, {
					get: function (list, item) {
						return !!LibraryModules.LanguageStore.Messages[item];
					}
				});
				let parseLanguageStringObj = obj => {
					let string = "";
					if (typeof obj == "string") string += obj;
					else if (BDFDB.ObjectUtils.is(obj)) {
						if (obj.props) string += parseLanguageStringObj(obj.props);
						else if (obj.type) {
							let text = obj.content || obj.children && obj.children[0] && obj.children[0].toString() || "";
							if (text) {
								if (obj.type == "text" || obj.content) string = parseLanguageStringObj(text);
								else string += `<${obj.type}>${parseLanguageStringObj(text)}</${obj.type}>`;
							}
						}
					}
					else if (BDFDB.ArrayUtils.is(obj)) for (let ele of obj) string += parseLanguageStringObj(ele);
					return string;
				};
				BDFDB.LanguageUtils.LanguageStringsFormat = function (item, ...values) {
					if (item) {
						let stringObj = LibraryModules.LanguageStore.Messages[item];
						if (stringObj && typeof stringObj == "object" && typeof stringObj.format == "function") {
							let i = 0, returnvalue, formatVars = {};
							while (!returnvalue && i < 10) {
								i++;
								try {returnvalue = stringObj.format(formatVars, false);}
								catch (err) {
									returnvalue = null;
									let value = values.shift();
									formatVars[err.toString().split("for: ")[1]] = value != null ? (value === 0 ? "0" : value) : "undefined";
								}
							}
							if (returnvalue) return parseLanguageStringObj(returnvalue);
							else {
								BDFDB.LogUtils.warn([item, "failed to format string in BDFDB.LanguageUtils.LanguageStrings"]);
								return "";
							}
						}
						else return BDFDB.LanguageUtils.LanguageStrings[item];
					}
					else BDFDB.LogUtils.warn([item, "enter a valid key to format the string in BDFDB.LanguageUtils.LanguageStrings"]);
					return "";
				};
				BDFDB.LanguageUtils.LibraryStrings = new Proxy(LibraryStrings.default || {}, {
					get: function (list, item) {
						let languageId = BDFDB.LanguageUtils.getLanguage().id;
						if (LibraryStrings[languageId] && LibraryStrings[languageId][item]) return LibraryStrings[languageId][item];
						else if (LibraryStrings.default[item]) return LibraryStrings.default[item];
						else BDFDB.LogUtils.warn([item, "not found in BDFDB.LanguageUtils.LibraryStrings"]);
						return "";
					}
				});
				BDFDB.LanguageUtils.LibraryStringsCheck = new Proxy(LanguageStrings, {
					get: function (list, item) {
						return !!LibraryStrings.default[item];
					}
				});
				BDFDB.LanguageUtils.LibraryStringsFormat = function (item, ...values) {
					if (item) {
						let languageId = BDFDB.LanguageUtils.getLanguage().id, string = null;
						if (LibraryStrings[languageId] && LibraryStrings[languageId][item]) string = LibraryStrings[languageId][item];
						else if (LibraryStrings.default[item]) string = LibraryStrings.default[item];
						if (string) {
							for (let i = 0; i < values.length; i++) if (typeof values[i] == "string" || typeof values[i] == "number") string = string.replace(new RegExp(`{{var${i}}}`, "g"), values[i]);
							return string;
						}
						else BDFDB.LogUtils.warn([item, "not found in BDFDB.LanguageUtils.LibraryStrings"]);
					}
					else BDFDB.LogUtils.warn([item, "enter a valid key to format the string in BDFDB.LanguageUtils.LibraryStrings"]);
					return "";
				};
				BDFDB.TimeUtils.interval(interval => {
					if (LibraryModules.LanguageStore.chosenLocale) {
						BDFDB.TimeUtils.clear(interval);
						let language = BDFDB.LanguageUtils.getLanguage();
						if (language) BDFDB.LanguageUtils.languages.$discord = Object.assign({}, language, {name: `Discord (${language.name})`});
					}
				}, 100);
				for (let key in BDFDB.LanguageUtils.languages) try {
					if (new Date(0).toLocaleString(key, {second: 'numeric'}) != "0") {
						BDFDB.LanguageUtils.languages[key].numberMap = {};
						for (let i = 0; i < 10; i++) BDFDB.LanguageUtils.languages[key].numberMap[i] = new Date(i*1000).toLocaleString(key, {second: 'numeric'});
					}
				}
				catch (err) {}
				
				const reactInitialized = LibraryModules.React && LibraryModules.React.Component;
				InternalBDFDB.setDefaultProps = function (component, defaultProps) {
					if (BDFDB.ObjectUtils.is(component)) component.defaultProps = Object.assign({}, component.defaultProps, defaultProps);
				};
				let openedItem;
				InternalComponents.MenuItem = reactInitialized && class BDFDB_MenuItem extends LibraryModules.React.Component {
					constructor(props) {
						super(props);
						this.state = {hovered: false};
					}
					componentWillUnmount() {
						if (openedItem == this.props.id) openedItem = null;
					}
					render() {
						let color = (typeof this.props.color == "string" ? this.props.color : InternalComponents.LibraryComponents.MenuItems.Colors.DEFAULT).toLowerCase();
						let isCustomColor = false;
						if (color) {
							if (DiscordClasses[`menu${color}`]) color = color;
							else if (BDFDB.ColorUtils.getType(color)) {
								isCustomColor = true;
								color = BDFDB.ColorUtils.convert(color, "RGBA");
							}
							else color = (InternalComponents.LibraryComponents.MenuItems.Colors.DEFAULT || "").toLowerCase();
						}
						let renderPopout, onClose, hasPopout = BDFDB.ObjectUtils.is(this.props.popoutProps);
						if (hasPopout) {
							renderPopout = instance => {
								openedItem = this.props.id;
								return typeof this.props.popoutProps.renderPopout == "function" && this.props.popoutProps.renderPopout(instance);
							};
							onClose = instance => {
								openedItem = null;
								typeof this.props.popoutProps.onClose == "function" && this.props.popoutProps.onClose(instance);
							};
						}
						let focused = !openedItem ? this.props.isFocused : openedItem == this.props.id;
						let themeDark = BDFDB.DiscordUtils.getTheme() == BDFDB.disCN.themedark;
						let item = BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Clickable, Object.assign({
							className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.menuitem, (this.props.label || this.props.subtext) && BDFDB.disCN.menulabelcontainer, color && (isCustomColor ? BDFDB.disCN.menucolorcustom : BDFDB.disCN[`menu${color}`]), this.props.disabled && BDFDB.disCN.menudisabled, focused && BDFDB.disCN.menufocused),
							style: {
								color: isCustomColor ? ((focused || this.state.hovered) ? (BDFDB.ColorUtils.isBright(color) ? "#000000" : "#ffffff") : color) : (this.state.hovered ? "#ffffff" : null),
								background: isCustomColor && (focused || this.state.hovered) && color
							},
							onClick: this.props.disabled ? null : e => {
								if (!this.props.action) return false;
								!this.props.persisting && !hasPopout && this.props.onClose();
								this.props.action(e, this);
							},
							onMouseEnter: this.props.disabled ? null : e => {
								if (typeof this.props.onMouseEnter == "function") this.props.onMouseEnter(e, this);
								this.setState({hovered: true});
							},
							onMouseLeave: this.props.disabled ? null : e => {
								if (typeof this.props.onMouseLeave == "function") this.props.onMouseLeave(e, this);
								this.setState({hovered: false});
							},
							"aria-disabled": this.props.disabled,
							children: [
								typeof this.props.render == "function" ? this.props.render(this) : this.props.render,
								(this.props.label || this.props.subtext) && BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN.menulabel,
									children: [
										typeof this.props.label == "function" ? this.props.label(this) : this.props.label,
										this.props.subtext && BDFDB.ReactUtils.createElement("div", {
											className: BDFDB.disCN.menusubtext,
											children: typeof this.props.subtext == "function" ? this.props.subtext(this) : this.props.subtext
										})
									].filter(n => n)
								}),
								this.props.hint && BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN.menuhintcontainer,
									children: typeof this.props.hint == "function" ? this.props.hint(this) : this.props.hint
								}),
								this.props.icon && BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN.menuiconcontainer,
									children: BDFDB.ReactUtils.createElement(this.props.icon, {
										className: BDFDB.disCN.menuicon
									})
								}),
								this.props.imageUrl && BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN.menuimagecontainer,
									children: BDFDB.ReactUtils.createElement("img", {
										className: BDFDB.disCN.menuimage,
										src: typeof this.props.imageUrl == "function" ? this.props.imageUrl(this) : this.props.imageUrl,
										alt: ""
									})
								})
							].filter(n => n)
						}, this.props.menuItemProps, {isFocused: focused}));
						return hasPopout ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.PopoutContainer, Object.assign({}, this.props.popoutProps, {
							children: item,
							renderPopout: renderPopout,
							onClose: onClose
						})) : item;
					}
				};
				InternalComponents.CustomMenuItemWrapper = reactInitialized && class BDFDB_CustomMenuItemWrapper extends LibraryModules.React.Component {
					constructor(props) {
						super(props);
						this.state = {hovered: false};
					}
					render() {
						let isItem = this.props.children == InternalComponents.MenuItem;
						let item = BDFDB.ReactUtils.createElement(this.props.children, Object.assign({}, this.props.childProps, {
							onMouseEnter: isItem ? e => {
								if (this.props.childProps && typeof this.props.childProps.onMouseEnter == "function") this.props.childProps.onMouseEnter(e, this);
								this.setState({hovered: true});
							} : this.props.childProps && this.props.childProps.onMouseEnter,
							onMouseLeave: isItem ? e => {
								if (this.props.childProps && typeof this.props.childProps.onMouseLeave == "function") this.props.childProps.onMouseLeave(e, this);
								this.setState({hovered: false});
							} : this.props.childProps && this.props.childProps.onMouseLeave,
							isFocused: this.state.hovered && !this.props.disabled
						}));
						return isItem ? item : BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Clickable, {
							onMouseEnter: e => {
								this.setState({hovered: true});
							},
							onMouseLeave: e => {
								this.setState({hovered: false});
							},
							children: item
						});
					}
				};
				InternalComponents.ErrorBoundary = reactInitialized && class BDFDB_ErrorBoundary extends LibraryModules.React.PureComponent {
					constructor(props) {
						super(props);
						this.state = {hasError: false};
					}
					static getDerivedStateFromError(err) {
						return {hasError: true};
					}
					componentDidCatch(err, info) {
						BDFDB.LogUtils.error(["Could not create React Element!", err]);
					}
					render() {
						if (this.state.hasError) return LibraryModules.React.createElement("span", {
							style: {
								background: BDFDB.DiscordConstants && BDFDB.DiscordConstants.Colors && BDFDB.DiscordConstants.Colors.PRIMARY_DARK,
								borderRadius: 5,
								color: BDFDB.DiscordConstants && BDFDB.DiscordConstants.Colors && BDFDB.DiscordConstants.Colors.STATUS_RED,
								fontSize: 12,
								fontWeight: 600,
								padding: 6,
								textAlign: "center",
								verticalAlign: "center"
							},
							children: "React Component Error"
						});
						return this.props.children;
					}
				};
				
				for (let name in InternalData.NativeSubComponents) {
					if (InternalData.NativeSubComponents[name].name) {
						if (InternalData.NativeSubComponents[name].protos) InternalComponents.NativeSubComponents[name] = BDFDB.ModuleUtils.find(m => m && m.displayName == InternalData.NativeSubComponents[name].name && m.prototype && InternalData.NativeSubComponents[name].protos.every(proto => m.prototype[proto]));
						else InternalComponents.NativeSubComponents[name] = BDFDB.ModuleUtils.findByName(InternalData.NativeSubComponents[name].name);
					}
					else if (InternalData.NativeSubComponents[name].props) InternalComponents.NativeSubComponents[name] = BDFDB.ModuleUtils.findByProperties(InternalData.NativeSubComponents[name].props);
				}
				
				for (let name in InternalData.LibraryComponents) {
					let module;
					if (InternalData.LibraryComponents[name].name) module = BDFDB.ModuleUtils.findByName(InternalData.LibraryComponents[name].name);
					else if (InternalData.LibraryComponents[name].strings) module = BDFDB.ModuleUtils.findByString(InternalData.LibraryComponents[name].strings);
					else if (InternalData.LibraryComponents[name].props) module = BDFDB.ModuleUtils.findByProperties(InternalData.LibraryComponents[name].props);
					let child = name, parent = child.split(" "), components = InternalComponents.LibraryComponents;
					if (parent.length > 1) {
						child = parent[1], parent = parent[0];
						if (!InternalComponents.LibraryComponents[parent]) InternalComponents.LibraryComponents[parent] = {};
						components = InternalComponents.LibraryComponents[parent];
					}
					if (InternalData.LibraryComponents[name].value) module = (module || {})[InternalData.LibraryComponents[name].value];
					if (InternalData.LibraryComponents[name].assign) components[child] = Object.assign({}, module);
					else components[child] = module;
				}
				
				InternalComponents.LibraryComponents.AutoFocusCatcher = reactInitialized && class BDFDB_AutoFocusCatcher extends LibraryModules.React.Component {
					render() {
						const style = {padding: 0, margin: 0, border: "none", width: 0, maxWidth: 0, height: 0, maxHeight: 0, visibility: "hidden"};
						return BDFDB.ReactUtils.forceStyle(BDFDB.ReactUtils.createElement("input", {style}), Object.keys(style));
					}
				};
				
				InternalComponents.LibraryComponents.BadgeAnimationContainer = reactInitialized && class BDFDB_BadgeAnimationContainer extends LibraryModules.React.Component {
					componentDidMount() {BDFDB.ReactUtils.forceUpdate(this);}
					componentWillAppear(e) {if (typeof e == "function") e();}
					componentWillEnter(e) {if (typeof e == "function") e();}
					componentWillLeave(e) {if (typeof e == "function") this.timeoutId = setTimeout(e, 300);}
					componentWillUnmount() {BDFDB.TimeUtils.clear(this.timeoutId)}
					render() {
						return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Animations.animated.div, {
							className: this.props.className,
							style: this.props.animatedStyle,
							children: this.props.children
						});
					}
				};
				
				InternalComponents.LibraryComponents.Badges = Object.assign({}, BDFDB.ModuleUtils.findByProperties("IconBadge", "NumberBadge"));
				InternalComponents.LibraryComponents.Badges.getBadgePaddingForValue = function (count) {
					switch (count) {
						case 1:
						case 4:
						case 6:
							return 1;
						default:
							return 0;
					}
				};
				InternalComponents.LibraryComponents.Badges.IconBadge = reactInitialized && class BDFDB_IconBadge extends LibraryModules.React.Component {
					render() {
						return BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.DOMUtils.formatClassName(this.props.className, BDFDB.disCN.badgeiconbadge, this.props.shape && InternalComponents.LibraryComponents.Badges.BadgeShapes[this.props.shape] || InternalComponents.LibraryComponents.Badges.BadgeShapes.ROUND),
							style: Object.assign({
								backgroundColor: this.props.disableColor ? null : (this.props.color || BDFDB.DiscordConstants.Colors.STATUS_RED)
							}, this.props.style),
							children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SvgIcon, {
								className: BDFDB.disCN.badgeicon,
								name: this.props.icon
							})
						});
					}
				};
				InternalComponents.LibraryComponents.Badges.NumberBadge = reactInitialized && class BDFDB_IconBadge extends LibraryModules.React.Component {
					handleClick(e) {if (typeof this.props.onClick == "function") this.props.onClick(e, this);}
					handleContextMenu(e) {if (typeof this.props.onContextMenu == "function") this.props.onContextMenu(e, this);}
					handleMouseEnter(e) {if (typeof this.props.onMouseEnter == "function") this.props.onMouseEnter(e, this);}
					handleMouseLeave(e) {if (typeof this.props.onMouseLeave == "function") this.props.onMouseLeave(e, this);}
					render() {
						return BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.DOMUtils.formatClassName(this.props.className, BDFDB.disCN.badgenumberbadge, this.props.shape && InternalComponents.LibraryComponents.Badges.BadgeShapes[this.props.shape] || InternalComponents.LibraryComponents.Badges.BadgeShapes.ROUND),
							style: Object.assign({
								backgroundColor: !this.props.disableColor && (this.props.color || BDFDB.DiscordConstants.Colors.STATUS_RED),
								width: InternalComponents.LibraryComponents.Badges.getBadgeWidthForValue(this.props.count),
								paddingRight: InternalComponents.LibraryComponents.Badges.getBadgePaddingForValue(this.props.count)
							}, this.props.style),
							onClick: this.handleClick.bind(this),
							onContextMenu: this.handleContextMenu.bind(this),
							onMouseEnter: this.handleMouseEnter.bind(this),
							onMouseLeave: this.handleMouseLeave.bind(this),
							children: InternalComponents.LibraryComponents.Badges.getBadgeCountString(this.props.count)
						});
					}
				};
				
				InternalComponents.LibraryComponents.BotTag = reactInitialized && class BDFDB_BotTag extends LibraryModules.React.Component {
					handleClick(e) {if (typeof this.props.onClick == "function") this.props.onClick(e, this);}
					handleContextMenu(e) {if (typeof this.props.onContextMenu == "function") this.props.onContextMenu(e, this);}
					handleMouseEnter(e) {if (typeof this.props.onMouseEnter == "function") this.props.onMouseEnter(e, this);}
					handleMouseLeave(e) {if (typeof this.props.onMouseLeave == "function") this.props.onMouseLeave(e, this);}
					render() {
						return BDFDB.ReactUtils.createElement("span", {
							className: BDFDB.DOMUtils.formatClassName(this.props.className, this.props.invertColor ? BDFDB.disCN.bottaginvert : BDFDB.disCN.bottagregular, this.props.useRemSizes ? BDFDB.disCN.bottagrem : BDFDB.disCN.bottagpx),
							style: this.props.style,
							onClick: this.handleClick.bind(this),
							onContextMenu: this.handleContextMenu.bind(this),
							onMouseEnter: this.handleMouseEnter.bind(this),
							onMouseLeave: this.handleMouseLeave.bind(this),
							children: BDFDB.ReactUtils.createElement("span", {
								className: BDFDB.disCN.bottagtext,
								children: this.props.tag || BDFDB.LanguageUtils.LanguageStrings.BOT_TAG_BOT
							})
						});
					}
				};
				
				InternalComponents.LibraryComponents.Button = reactInitialized && class BDFDB_Button extends LibraryModules.React.Component {
					handleClick(e) {if (typeof this.props.onClick == "function") this.props.onClick(e, this);}
					handleContextMenu(e) {if (typeof this.props.onContextMenu == "function") this.props.onContextMenu(e, this);}
					handleMouseDown(e) {if (typeof this.props.onMouseDown == "function") this.props.onMouseDown(e, this);}
					handleMouseUp(e) {if (typeof this.props.onMouseUp == "function") this.props.onMouseUp(e, this);}
					handleMouseEnter(e) {if (typeof this.props.onMouseEnter == "function") this.props.onMouseEnter(e, this);}
					handleMouseLeave(e) {if (typeof this.props.onMouseLeave == "function") this.props.onMouseLeave(e, this);}
					render() {
						let processingAndListening = (this.props.disabled || this.props.submitting) && (null != this.props.onMouseEnter || null != this.props.onMouseLeave);
						let props = BDFDB.ObjectUtils.exclude(this.props, "look", "color", "hover", "size", "fullWidth", "grow", "disabled", "submitting", "type", "style", "wrapperClassName", "className", "innerClassName", "onClick", "onContextMenu", "onMouseDown", "onMouseUp", "onMouseEnter", "onMouseLeave", "children", "rel");
						let button = BDFDB.ReactUtils.createElement("button", Object.assign({}, !this.props.disabled && !this.props.submitting && props, {
							className: BDFDB.DOMUtils.formatClassName(this.props.className, BDFDB.disCN.button, this.props.look != null ? this.props.look : InternalComponents.LibraryComponents.Button.Looks.FILLED, this.props.color != null ? this.props.color : InternalComponents.LibraryComponents.Button.Colors.BRAND, this.props.hover, this.props.size != null ? this.props.size : InternalComponents.LibraryComponents.Button.Sizes.MEDIUM, processingAndListening && this.props.wrapperClassName, this.props.fullWidth && BDFDB.disCN.buttonfullwidth, (this.props.grow === undefined || this.props.grow) && BDFDB.disCN.buttongrow, this.props.hover && this.props.hover !== InternalComponents.LibraryComponents.Button.Hovers.DEFAULT && BDFDB.disCN.buttonhashover, this.props.submitting && BDFDB.disCN.buttonsubmitting),
							onClick: (this.props.disabled || this.props.submitting) ? e => {return e.preventDefault();} : this.handleClick.bind(this),
							onContextMenu: (this.props.disabled || this.props.submitting) ? e => {return e.preventDefault();} : this.handleContextMenu.bind(this),
							onMouseUp: !this.props.disabled && this.handleMouseDown.bind(this),
							onMouseDown: !this.props.disabled && this.handleMouseUp.bind(this),
							onMouseEnter: this.handleMouseEnter.bind(this),
							onMouseLeave: this.handleMouseLeave.bind(this),
							type: !this.props.type ? "button" : this.props.type,
							disabled: this.props.disabled,
							style: this.props.style,
							rel: this.props.rel,
							children: [
								this.props.submitting && !this.props.disabled ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Spinner, {
									type: InternalComponents.LibraryComponents.Spinner.Type.PULSING_ELLIPSIS,
									className: BDFDB.disCN.buttonspinner,
									itemClassName: BDFDB.disCN.buttonspinneritem
								}) : null,
								BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.buttoncontents, this.props.innerClassName),
									children: this.props.children
								})
							]
						}));
						return !processingAndListening ? button : BDFDB.ReactUtils.createElement("span", {
							className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.buttondisabledwrapper, this.props.wrapperClassName, this.props.size != null ? this.props.size : InternalComponents.LibraryComponents.Button.Sizes.MEDIUM, this.props.fullWidth && BDFDB.disCN.buttonfullwidth, (this.props.grow === undefined || this.props.grow) && BDFDB.disCN.buttongrow),
							children: [
								button,
								BDFDB.ReactUtils.createElement("span", {
									onMouseEnter: this.handleMouseEnter.bind(this),
									onMouseLeave: this.handleMouseLeave.bind(this),
									className: BDFDB.disCN.buttondisabledoverlay
								})
							]
						});
					}
				};
				
				InternalComponents.LibraryComponents.Card = reactInitialized && class BDFDB_Card extends LibraryModules.React.Component {
					render() {
						return BDFDB.ReactUtils.createElement("div", BDFDB.ObjectUtils.exclude(Object.assign({}, this.props, {
							className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.hovercardwrapper, this.props.horizontal && BDFDB.disCN.hovercardhorizontal, this.props.backdrop && BDFDB.disCN.hovercard, this.props.className),
							onMouseEnter: e => {if (typeof this.props.onMouseEnter == "function") this.props.onMouseEnter(e, this);},
							onMouseLeave: e => {if (typeof this.props.onMouseLeave == "function") this.props.onMouseLeave(e, this);},
							onClick: e => {if (typeof this.props.onClick == "function") this.props.onClick(e, this);},
							onContextMenu: e => {if (typeof this.props.onContextMenu == "function") this.props.onContextMenu(e, this);},
							children: [
								!this.props.noRemove ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.CardRemoveButton, {
									onClick: e => {
										if (typeof this.props.onRemove == "function") this.props.onRemove(e, this);
										BDFDB.ListenerUtils.stopEvent(e);
									}
								}) : null,
								typeof this.props.children == "string" ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TextElement, {
									className: BDFDB.disCN.hovercardinner,
									children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TextScroller, {children: this.props.children})
								}) : this.props.children
							].flat(10).filter(n => n)
						}), "backdrop", "horizontal", "noRemove"));
					}
				};
				InternalBDFDB.setDefaultProps(InternalComponents.LibraryComponents.Card, {backdrop: true, noRemove: false});
				
				InternalComponents.LibraryComponents.ChannelTextAreaButton = reactInitialized && class BDFDB_ChannelTextAreaButton extends LibraryModules.React.Component {
					render() {
						return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Button, {
							look: InternalComponents.LibraryComponents.Button.Looks.BLANK,
							size: InternalComponents.LibraryComponents.Button.Sizes.NONE,
							"aria-label": this.props.label,
							tabIndex: this.props.tabIndex,
							className: BDFDB.DOMUtils.formatClassName(this.props.isActive && BDFDB.disCN.textareabuttonactive),
							innerClassName: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.textareabutton, this.props.className, this.props.pulse && BDFDB.disCN.textareaattachbuttonplus),
							onClick: this.props.onClick,
							onContextMenu: this.props.onContextMenu,
							onMouseEnter: this.props.onMouseEnter,
							onMouseLeave: this.props.onMouseLeave,
							children: BDFDB.ReactUtils.createElement("div", {
								className: BDFDB.disCN.textareabuttonwrapper,
								children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SvgIcon, {
									name: this.props.iconName,
									iconSVG: this.props.iconSVG,
									className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.textareaicon, this.props.iconClassName, this.props.pulse && BDFDB.disCN.textareaiconpulse),
									nativeClass: this.props.nativeClass
								})
							})
						});
					}
				};
				InternalBDFDB.setDefaultProps(InternalComponents.LibraryComponents.ChannelTextAreaButton, {tabIndex: 0});
				
				InternalComponents.LibraryComponents.CharCounter = reactInitialized && class BDFDB_CharCounter extends LibraryModules.React.Component {
					getCounterString() {
						let input = this.refElement || {}, string = "";
						if (BDFDB.DOMUtils.containsClass(this.refElement, BDFDB.disCN.textarea)) {
							let instance = BDFDB.ReactUtils.findOwner(input, {name: "ChannelEditorContainer", up: true});
							if (instance) string = instance.props.textValue;
							else string = input.value || input.textContent || "";
						}
						else string = input.value || input.textContent || "";
						let start = input.selectionStart || 0, end = input.selectionEnd || 0, selectlength = end - start, selection = BDFDB.DOMUtils.getSelection();
						let select = !selectlength && !selection ? 0 : (selectlength || selection.length);
						select = !select ? 0 : (select > string.length ? (end || start ? string.length - (string.length - end - start) : string.length) : select);
						let children = [
							typeof this.props.renderPrefix == "function" && this.props.renderPrefix(string.length),
							`${string.length}${!this.props.max ? "" : "/" + this.props.max}${!select ? "" : " (" + select + ")"}`,
							typeof this.props.renderSuffix == "function" && this.props.renderSuffix(string.length)
						].filter(n => n);
						if (typeof this.props.onChange == "function") this.props.onChange(this);
						return children.length == 1 ? children[0] : BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex, {
							align: InternalComponents.LibraryComponents.Flex.Align.CENTER,
							children: children
						});
					}
					updateCounter() {
						if (!this.refElement) return;
						BDFDB.TimeUtils.clear(this.updateTimeout);
						this.updateTimeout = BDFDB.TimeUtils.timeout(this.forceUpdateCounter.bind(this), 100);
					}
					forceUpdateCounter() {
						if (!this.refElement) return;
						this.props.children = this.getCounterString();
						BDFDB.ReactUtils.forceUpdate(this);
					}
					handleSelection() {
						if (!this.refElement) return;
						let mouseMove = _ => {
							BDFDB.TimeUtils.timeout(this.forceUpdateCounter.bind(this), 10);
						};
						let mouseUp = _ => {
							document.removeEventListener("mousemove", mouseMove);
							document.removeEventListener("mouseup", mouseUp);
							if (this.refElement.selectionEnd - this.refElement.selectionStart) BDFDB.TimeUtils.timeout(_ => {
								document.addEventListener("click", click);
							});
						};
						let click = _ => {
							BDFDB.TimeUtils.timeout(this.forceUpdateCounter.bind(this), 100);
							document.removeEventListener("mousemove", mouseMove);
							document.removeEventListener("mouseup", mouseUp);
							document.removeEventListener("click", click);
						};
						document.addEventListener("mousemove", mouseMove);
						document.addEventListener("mouseup", mouseUp);
					}
					componentDidMount() {
						if (this.props.refClass) {
							let node = BDFDB.ReactUtils.findDOMNode(this);
							if (node && node.parentElement) {
								this.refElement = node.parentElement.querySelector(this.props.refClass);
								if (this.refElement) {
									if (!this._updateCounter) this._updateCounter = _ => {
										if (!document.contains(node)) BDFDB.ListenerUtils.multiRemove(this.refElement, "keydown click change", this._updateCounter);
										else this.updateCounter();
									};
									if (!this._handleSelection) this._handleSelection = _ => {
										if (!document.contains(node)) BDFDB.ListenerUtils.multiRemove(this.refElement, "mousedown", this._handleSelection);
										else this.handleSelection();
									};
									BDFDB.ListenerUtils.multiRemove(this.refElement, "mousedown", this._handleSelection);
									BDFDB.ListenerUtils.multiAdd(this.refElement, "mousedown", this._handleSelection);
									if (this.refElement.tagName == "INPUT" || this.refElement.tagName == "TEXTAREA") {
										BDFDB.ListenerUtils.multiRemove(this.refElement, "keydown click change", this._updateCounter);
										BDFDB.ListenerUtils.multiAdd(this.refElement, "keydown click change", this._updateCounter);
									}
									else {
										if (!this._mutationObserver) this._mutationObserver = new MutationObserver(changes => {
											if (!document.contains(node)) this._mutationObserver.disconnect();
											else this.updateCounter();
										});
										else this._mutationObserver.disconnect();
										this._mutationObserver.observe(this.refElement, {childList: true, subtree: true});
									}
									this.updateCounter();
								}
								else BDFDB.LogUtils.warn(["could not find referenceElement for BDFDB_CharCounter"]);
							}
						}
						else BDFDB.LogUtils.warn(["refClass can not be undefined for BDFDB_CharCounter"]);
					}
					render() {
						let string = this.getCounterString();
						BDFDB.TimeUtils.timeout(_ => {if (string != this.getCounterString()) BDFDB.ReactUtils.forceUpdate(this);});
						return BDFDB.ReactUtils.createElement("div", BDFDB.ObjectUtils.exclude(Object.assign({}, this.props, {
							className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.charcounter, this.props.className),
							children: string
						}), "parsing", "max", "refClass", "renderPrefix", "renderSuffix"));
					}
				};
				
				InternalComponents.LibraryComponents.Checkbox = reactInitialized && class BDFDB_Checkbox extends LibraryModules.React.Component {
					handleClick(e) {if (typeof this.props.onClick == "function") this.props.onClick(e, this);}
					handleContextMenu(e) {if (typeof this.props.onContextMenu == "function") this.props.onContextMenu(e, this);}
					handleMouseDown(e) {if (typeof this.props.onMouseDown == "function") this.props.onMouseDown(e, this);}
					handleMouseUp(e) {if (typeof this.props.onMouseUp == "function") this.props.onMouseUp(e, this);}
					handleMouseEnter(e) {if (typeof this.props.onMouseEnter == "function") this.props.onMouseEnter(e, this);}
					handleMouseLeave(e) {if (typeof this.props.onMouseLeave == "function") this.props.onMouseLeave(e, this);}
					getInputMode() {
						return this.props.disabled ? "disabled" : this.props.readOnly ? "readonly" : "default";
					}
					getStyle() {
						let style = this.props.style || {};
						if (!this.props.value) return style;
						style = Object.assign({}, style);
						this.props.color = typeof this.props.getColor == "function" ? this.props.getColor(this.props.value) : this.props.color;
						switch (this.props.type) {
							case InternalComponents.NativeSubComponents.Checkbox.Types.DEFAULT:
								style.borderColor = this.props.color;
								break;
							case InternalComponents.NativeSubComponents.Checkbox.Types.GHOST:
								let color = BDFDB.ColorUtils.setAlpha(this.props.color, 0.15, "RGB");
								style.borderColor = color;
								style.backgroundColor = color;
								break;
							case InternalComponents.NativeSubComponents.Checkbox.Types.INVERTED:
								style.backgroundColor = this.props.color;
								style.borderColor = this.props.color;
						}
						return style;
					}
					getColor() {
						return this.props.value ? (this.props.type === InternalComponents.NativeSubComponents.Checkbox.Types.INVERTED ? BDFDB.DiscordConstants.Colors.WHITE : this.props.color) : "transparent";
					}
					handleChange(e) {
						this.props.value = typeof this.props.getValue == "function" ? this.props.getValue(this.props.value, e) : !this.props.value;
						if (typeof this.props.onChange == "function") this.props.onChange(this.props.value, this);
						BDFDB.ReactUtils.forceUpdate(this);
					}
					render() {
						let label = this.props.children ? BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.checkboxlabel, this.props.disabled ? BDFDB.disCN.checkboxlabeldisabled : BDFDB.disCN.checkboxlabelclickable, this.props.reverse ? BDFDB.disCN.checkboxlabelreversed : BDFDB.disCN.checkboxlabelforward),
							style: {
								lineHeight: this.props.size + "px"
							},
							children: this.props.children
						}) : null;
						return BDFDB.ReactUtils.createElement("label", {
							className: BDFDB.DOMUtils.formatClassName(this.props.disabled ? BDFDB.disCN.checkboxwrapperdisabled : BDFDB.disCN.checkboxwrapper, this.props.align, this.props.className),
							children: [
								this.props.reverse && label,
								!this.props.displayOnly && BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.FocusRingScope, {
									children: BDFDB.ReactUtils.createElement("input", {
										className: BDFDB.disCN["checkboxinput" + this.getInputMode()],
										type: "checkbox",
										onClick: this.props.disabled || this.props.readOnly ? (_ => {}) : this.handleChange.bind(this),
										onContextMenu: this.props.disabled || this.props.readOnly ? (_ => {}) : this.handleChange.bind(this),
										checked: this.props.value,
										style: {
											width: this.props.size,
											height: this.props.size
										}
									})
								}),
								BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.checkbox, this.props.shape, this.props.value && BDFDB.disCN.checkboxchecked),
									style: Object.assign({
										width: this.props.size,
										height: this.props.size,
										borderColor: this.props.checkboxColor
									}, this.getStyle()),
									children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Checkmark, {
										width: 18,
										height: 18,
										color: this.getColor(),
										"aria-hidden": true
									})
								}),
								!this.props.reverse && label
							].filter(n => n)
						});
					}
				};
				
				InternalComponents.LibraryComponents.Clickable = reactInitialized && class BDFDB_Clickable extends LibraryModules.React.Component {
					handleClick(e) {if (typeof this.props.onClick == "function") this.props.onClick(e, this);}
					handleContextMenu(e) {if (typeof this.props.onContextMenu == "function") this.props.onContextMenu(e, this);}
					handleMouseDown(e) {if (typeof this.props.onMouseDown == "function") this.props.onMouseDown(e, this);}
					handleMouseUp(e) {if (typeof this.props.onMouseUp == "function") this.props.onMouseUp(e, this);}
					handleMouseEnter(e) {if (typeof this.props.onMouseEnter == "function") this.props.onMouseEnter(e, this);}
					handleMouseLeave(e) {if (typeof this.props.onMouseLeave == "function") this.props.onMouseLeave(e, this);}
					render() {
						return BDFDB.ReactUtils.createElement(InternalComponents.NativeSubComponents.Clickable, Object.assign({}, this.props, {
							className: BDFDB.DOMUtils.formatClassName(this.props.className, (this.props.className || "").toLowerCase().indexOf("disabled") == -1 && BDFDB.disCN.cursorpointer),
							onClick: this.handleClick.bind(this),
							onContextMenu: this.handleContextMenu.bind(this),
							onMouseUp: this.handleMouseDown.bind(this),
							onMouseDown: !this.props.disabled && this.handleMouseUp.bind(this),
							onMouseEnter: this.handleMouseEnter.bind(this),
							onMouseLeave: this.handleMouseLeave.bind(this)
						}));
					}
				};
				
				InternalComponents.LibraryComponents.CollapseContainer = reactInitialized && class BDFDB_CollapseContainer extends LibraryModules.React.Component {
					render() {
						if (!BDFDB.ObjectUtils.is(this.props.collapseStates)) this.props.collapseStates = {};
						this.props.collapsed = this.props.collapsed && (this.props.collapseStates[this.props.title] || this.props.collapseStates[this.props.title] === undefined);
						this.props.collapseStates[this.props.title] = this.props.collapsed;
						return BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.DOMUtils.formatClassName(this.props.collapsed && BDFDB.disCN.collapsecontainercollapsed, this.props.mini ? BDFDB.disCN.collapsecontainermini : BDFDB.disCN.collapsecontainer, this.props.className),
							id: this.props.id,
							children: [
								BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex, {
									className: BDFDB.disCN.collapsecontainerheader,
									align: InternalComponents.LibraryComponents.Flex.Align.CENTER,
									onClick: e => {
										this.props.collapsed = !this.props.collapsed;
										this.props.collapseStates[this.props.title] = this.props.collapsed;
										if (typeof this.props.onClick == "function") this.props.onClick(this.props.collapsed, this);
										BDFDB.ReactUtils.forceUpdate(this);
									},
									children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.FormComponents.FormTitle, {
										tag: InternalComponents.LibraryComponents.FormComponents.FormTitle.Tags.H5,
										className: BDFDB.disCN.collapsecontainertitle,
										children: this.props.title
									})
								}),
								!this.props.collapsed ? BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN.collapsecontainerinner,
									children: this.props.children
								}) : null
							]
						});
					}
				};
				InternalBDFDB.setDefaultProps(InternalComponents.LibraryComponents.CollapseContainer, {collapsed: true, mini: true});
				
				InternalComponents.LibraryComponents.ColorPicker = reactInitialized && class BDFDB_ColorPicker extends LibraryModules.React.Component {
					constructor(props) {
						super(props);
						if (!this.state) this.state = {};
						this.state.isGradient = props.gradient && props.color && BDFDB.ObjectUtils.is(props.color);
						this.state.gradientBarEnabled = this.state.isGradient;
						this.state.draggingAlphaCursor = false;
						this.state.draggingGradientCursor = false;
						this.state.selectedGradientCursor = 0;
					}
					handleColorChange(color) {
						let changed = false;
						if (color != null) {
							changed = !BDFDB.equals(this.state.isGradient ? this.props.color[this.state.selectedGradientCursor] : this.props.color, color);
							if (this.state.isGradient) this.props.color[this.state.selectedGradientCursor] = color;
							else this.props.color = color;
						}
						else changed = true;
						if (changed) {
							if (typeof this.props.onColorChange == "function") this.props.onColorChange(BDFDB.ColorUtils.convert(this.props.color, "RGBCOMP"));
							BDFDB.ReactUtils.forceUpdate(this);
						}
					}
					componentDidMount() {
						this.domElementRef = {current: BDFDB.DOMUtils.getParent(BDFDB.dotCN.itemlayer, BDFDB.ReactUtils.findDOMNode(this))};
						let popoutContainerInstance = BDFDB.ReactUtils.findOwner(this.domElementRef.current, {name: "BDFDB_PopoutContainer", unlimited: true, up: true});
						if (popoutContainerInstance) {
							let mouseDown = event => {
								if (!this.domElementRef.current || !document.contains(this.domElementRef.current)) document.removeEventListener("mousedown", mouseDown);
								else if (!this.domElementRef.current.contains(event.target)) {
									let mouseUp = event => {
										if (!this.domElementRef.current || !document.contains(this.domElementRef.current)) {
											document.removeEventListener("mousedown", mouseDown);
											document.removeEventListener("mouseup", mouseUp);
										}
										else if (!this.domElementRef.current.contains(event.target)) {
											document.removeEventListener("mousedown", mouseDown);
											document.removeEventListener("mouseup", mouseUp);
											popoutContainerInstance.handleClick(event);
										}
									};
									document.addEventListener("mouseup", mouseUp);
								}
							};
							document.addEventListener("mousedown", mouseDown);
						}
					}
					render() {
						if (this.state.isGradient) this.props.color = Object.assign({}, this.props.color);
						
						let hslFormat = this.props.alpha ? "HSLA" : "HSL";
						let hexRegex = this.props.alpha ? /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i : /^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
						
						let selectedColor = BDFDB.ColorUtils.convert(this.state.isGradient ? this.props.color[this.state.selectedGradientCursor] : this.props.color, hslFormat) || BDFDB.ColorUtils.convert("#000000FF", hslFormat);
						let currentGradient = (this.state.isGradient ? Object.entries(this.props.color, hslFormat) : [[0, selectedColor], [1, selectedColor]]);
						
						let [h, s, l] = BDFDB.ColorUtils.convert(selectedColor, "HSLCOMP");
						let a = BDFDB.ColorUtils.getAlpha(selectedColor);
						a = a == null ? 1 : a;
						
						let hexColor = BDFDB.ColorUtils.convert(selectedColor, this.props.alpha ? "HEXA" : "HEX");
						let hexLength = hexColor.length;
						
						return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.PopoutFocusLock, {
							className: BDFDB.disCNS.colorpickerwrapper + BDFDB.disCN.colorpicker,
							children: [
								BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN.colorpickerinner,
									children: [
										BDFDB.ReactUtils.createElement("div", {
											className: BDFDB.disCN.colorpickersaturation,
											children: BDFDB.ReactUtils.createElement("div", {
												className: BDFDB.disCN.colorpickersaturationcolor,
												style: {position: "absolute", top: 0, right: 0, bottom: 0, left: 0, cursor: "crosshair", backgroundColor: BDFDB.ColorUtils.convert([h, "100%", "100%"], "RGB")},
												onClick: event => {
													let rects = BDFDB.DOMUtils.getRects(BDFDB.DOMUtils.getParent(BDFDB.dotCN.colorpickersaturationcolor, event.target));
													this.handleColorChange(BDFDB.ColorUtils.convert([h, BDFDB.NumberUtils.mapRange([rects.left, rects.left + rects.width], [0, 100], event.clientX) + "%", BDFDB.NumberUtils.mapRange([rects.top, rects.top + rects.height], [100, 0], event.clientY) + "%", a], hslFormat));
												},
												onMouseDown: event => {
													let rects = BDFDB.DOMUtils.getRects(BDFDB.DOMUtils.getParent(BDFDB.dotCN.colorpickersaturationcolor, event.target));
													let mouseUp = _ => {
														document.removeEventListener("mouseup", mouseUp);
														document.removeEventListener("mousemove", mouseMove);
													};
													let mouseMove = event2 => {
														this.handleColorChange(BDFDB.ColorUtils.convert([h, BDFDB.NumberUtils.mapRange([rects.left, rects.left + rects.width], [0, 100], event2.clientX) + "%", BDFDB.NumberUtils.mapRange([rects.top, rects.top + rects.height], [100, 0], event2.clientY) + "%", a], hslFormat));
													};
													document.addEventListener("mouseup", mouseUp);
													document.addEventListener("mousemove", mouseMove);
												},
												children: [
													BDFDB.ReactUtils.createElement("style", {
														children: `${BDFDB.dotCN.colorpickersaturationwhite} {background: -webkit-linear-gradient(to right, #fff, rgba(255,255,255,0));background: linear-gradient(to right, #fff, rgba(255,255,255,0));}${BDFDB.dotCN.colorpickersaturationblack} {background: -webkit-linear-gradient(to top, #000, rgba(0,0,0,0));background: linear-gradient(to top, #000, rgba(0,0,0,0));}`
													}),
													BDFDB.ReactUtils.createElement("div", {
														className: BDFDB.disCN.colorpickersaturationwhite,
														style: {position: "absolute", top: 0, right: 0, bottom: 0, left: 0},
														children: [
															BDFDB.ReactUtils.createElement("div", {
																className: BDFDB.disCN.colorpickersaturationblack,
																style: {position: "absolute", top: 0, right: 0, bottom: 0, left: 0}
															}),
															BDFDB.ReactUtils.createElement("div", {
																className: BDFDB.disCN.colorpickersaturationcursor,
																style: {position: "absolute", cursor: "crosshair", left: s, top: `${BDFDB.NumberUtils.mapRange([0, 100], [100, 0], parseFloat(l))}%`},
																children: BDFDB.ReactUtils.createElement("div", {
																	style: {width: 4, height: 4, boxShadow: "rgb(255, 255, 255) 0px 0px 0px 1.5px, rgba(0, 0, 0, 0.3) 0px 0px 1px 1px inset, rgba(0, 0, 0, 0.4) 0px 0px 1px 2px", borderRadius: "50%", transform: "translate(-2px, -2px)"}
																})
															})
														]
													})
												]
											})
										}),
										BDFDB.ReactUtils.createElement("div", {
											className: BDFDB.disCN.colorpickerhue,
											children: BDFDB.ReactUtils.createElement("div", {
												style: {position: "absolute", top: 0, right: 0, bottom: 0, left: 0},
												children: BDFDB.ReactUtils.createElement("div", {
													className: BDFDB.disCN.colorpickerhuehorizontal,
													style: {padding: "0px 2px", position: "relative", height: "100%"},
													onClick: event => {
														let rects = BDFDB.DOMUtils.getRects(BDFDB.DOMUtils.getParent(BDFDB.dotCN.colorpickerhuehorizontal, event.target));
														this.handleColorChange(BDFDB.ColorUtils.convert([BDFDB.NumberUtils.mapRange([rects.left, rects.left + rects.width], [0, 360], event.clientX), s, l, a], hslFormat));
													},
													onMouseDown: event => {
														let rects = BDFDB.DOMUtils.getRects(BDFDB.DOMUtils.getParent(BDFDB.dotCN.colorpickerhuehorizontal, event.target));
														let mouseUp = _ => {
															document.removeEventListener("mouseup", mouseUp);
															document.removeEventListener("mousemove", mouseMove);
														};
														let mouseMove = event2 => {
															this.handleColorChange(BDFDB.ColorUtils.convert([BDFDB.NumberUtils.mapRange([rects.left, rects.left + rects.width], [0, 360], event2.clientX), s, l, a], hslFormat));
														};
														document.addEventListener("mouseup", mouseUp);
														document.addEventListener("mousemove", mouseMove);
													},
													children: [
														BDFDB.ReactUtils.createElement("style", {
															children: `${BDFDB.dotCN.colorpickerhuehorizontal} {background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);background: -webkit-linear-gradient(to right, #f00 0%, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);}${BDFDB.dotCN.colorpickerhuevertical} {background: linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);background: -webkit-linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);}`
														}),
														BDFDB.ReactUtils.createElement("div", {
															className: BDFDB.disCN.colorpickerhuecursor,
															style: {position: "absolute", cursor: "ew-resize", left: `${BDFDB.NumberUtils.mapRange([0, 360], [0, 100], h)}%`},
															children: BDFDB.ReactUtils.createElement("div", {
																style: {marginTop: 1, width: 4, borderRadius: 1, height: 8, boxShadow: "rgba(0, 0, 0, 0.6) 0px 0px 2px", background: "rgb(255, 255, 255)", transform: "translateX(-2px)"}
															})
														})
													]
												})
											})
										}),
										this.props.alpha && BDFDB.ReactUtils.createElement("div", {
											className: BDFDB.disCN.colorpickeralpha,
											children: [
												BDFDB.ReactUtils.createElement("div", {
													style: {position: "absolute", top: 0, right: 0, bottom: 0, left: 0},
													children: BDFDB.ReactUtils.createElement("div", {
														className: BDFDB.disCN.colorpickeralphacheckered,
														style: {padding: "0px 2px", position: "relative", height: "100%"}
													})
												}),
												BDFDB.ReactUtils.createElement("div", {
													style: {position: "absolute", top: 0, right: 0, bottom: 0, left: 0},
													children: BDFDB.ReactUtils.createElement("div", {
														className: BDFDB.disCN.colorpickeralphahorizontal,
														style: {padding: "0px 2px", position: "relative", height: "100%", background: `linear-gradient(to right, ${BDFDB.ColorUtils.setAlpha([h, s, l], 0, "RGBA")}, ${BDFDB.ColorUtils.setAlpha([h, s, l], 1, "RGBA")}`},
														onClick: event => {
															let rects = BDFDB.DOMUtils.getRects(BDFDB.DOMUtils.getParent(BDFDB.dotCN.colorpickeralphahorizontal, event.target));
															this.handleColorChange(BDFDB.ColorUtils.setAlpha([h, s, l], BDFDB.NumberUtils.mapRange([rects.left, rects.left + rects.width], [0, 1], event.clientX), hslFormat));
														},
														onMouseDown: event => {
															let rects = BDFDB.DOMUtils.getRects(BDFDB.DOMUtils.getParent(BDFDB.dotCN.colorpickeralphahorizontal, event.target));
															let mouseUp = _ => {
																document.removeEventListener("mouseup", mouseUp);
																document.removeEventListener("mousemove", mouseMove);
																this.state.draggingAlphaCursor = false;
																BDFDB.ReactUtils.forceUpdate(this);
															};
															let mouseMove = event2 => {
																this.state.draggingAlphaCursor = true;
																this.handleColorChange(BDFDB.ColorUtils.setAlpha([h, s, l], BDFDB.NumberUtils.mapRange([rects.left, rects.left + rects.width], [0, 1], event2.clientX), hslFormat));
															};
															document.addEventListener("mouseup", mouseUp);
															document.addEventListener("mousemove", mouseMove);
														},
														children: BDFDB.ReactUtils.createElement("div", {
															className: BDFDB.disCN.colorpickeralphacursor,
															style: {position: "absolute", cursor: "ew-resize", left: `${a * 100}%`},
															children: [
																BDFDB.ReactUtils.createElement("div", {
																	style: {marginTop: 1, width: 4, borderRadius: 1, height: 8, boxShadow: "rgba(0, 0, 0, 0.6) 0px 0px 2px", background: "rgb(255, 255, 255)", transform: "translateX(-2px)"}
																}),
																this.state.draggingAlphaCursor && BDFDB.ReactUtils.createElement("span", {
																	className: BDFDB.disCN.sliderbubble,
																	style: {opacity: 1, visibility: "visible", left: 2},
																	children: `${Math.floor(a * 100)}%`
																})
															].filter(n => n)
														})
													})
												})
											]
										}),
										this.state.gradientBarEnabled && BDFDB.ReactUtils.createElement("div", {
											className: BDFDB.disCN.colorpickergradient,
											children: [
												BDFDB.ReactUtils.createElement("div", {
													style: {position: "absolute", top: 0, right: 0, bottom: 0, left: 0},
													children: BDFDB.ReactUtils.createElement("div", {
														className: BDFDB.disCN.colorpickergradientcheckered,
														style: {padding: "0px 2px", position: "relative", height: "100%"}
													})
												}),
												BDFDB.ReactUtils.createElement("div", {
													style: {position: "absolute", top: 0, right: 0, bottom: 0, left: 0},
													children: BDFDB.ReactUtils.createElement("div", {
														className: BDFDB.disCN.colorpickergradienthorizontal,
														style: {padding: "0px 2px", position: "relative", cursor: "copy", height: "100%", background: BDFDB.ColorUtils.createGradient(currentGradient.reduce((colorObj, posAndColor) => (colorObj[posAndColor[0]] = posAndColor[1], colorObj), {}))},
														onClick: event => {
															let rects = BDFDB.DOMUtils.getRects(event.target);
															let pos = BDFDB.NumberUtils.mapRange([rects.left, rects.left + rects.width], [0.01, 0.99], event.clientX);
															if (Object.keys(this.props.color).indexOf(pos) == -1) {
																this.props.color[pos] = BDFDB.ColorUtils.convert("#000000FF", hslFormat);
																this.state.selectedGradientCursor = pos;
																this.handleColorChange();
															}
														},
														children: currentGradient.map(posAndColor => BDFDB.ReactUtils.createElement("div", {
															className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.colorpickergradientcursor, (posAndColor[0] == 0 || posAndColor[0] == 1) && BDFDB.disCN.colorpickergradientcursoredge, this.state.selectedGradientCursor == posAndColor[0] && BDFDB.disCN.colorpickergradientcursorselected),
															style: {position: "absolute", cursor: "pointer", left: `${posAndColor[0] * 100}%`},
															onMouseDown: posAndColor[0] == 0 || posAndColor[0] == 1 ? _ => {} : event => {
																event = event.nativeEvent || event;
																let mouseMove = event2 => {
																	if (Math.sqrt((event.pageX - event2.pageX)**2) > 10) {
																		document.removeEventListener("mousemove", mouseMove);
																		document.removeEventListener("mouseup", mouseUp);
																		
																		this.state.draggingGradientCursor = true;
																		let cursor = BDFDB.DOMUtils.getParent(BDFDB.dotCN.colorpickergradientcursor, event.target);
																		let rects = BDFDB.DOMUtils.getRects(cursor.parentElement);
																		
																		let releasing = _ => {
																			document.removeEventListener("mousemove", dragging);
																			document.removeEventListener("mouseup", releasing);
																			BDFDB.TimeUtils.timeout(_ => {this.state.draggingGradientCursor = false;});
																		};
																		let dragging = event3 => {
																			let pos = BDFDB.NumberUtils.mapRange([rects.left, rects.left + rects.width], [0.01, 0.99], event3.clientX);
																			if (Object.keys(this.props.color).indexOf(pos) == -1) {
																				delete this.props.color[posAndColor[0]];
																				posAndColor[0] = pos;
																				this.props.color[pos] = posAndColor[1];
																				this.state.selectedGradientCursor = pos;
																				this.handleColorChange();
																			}
																		};
																		document.addEventListener("mousemove", dragging);
																		document.addEventListener("mouseup", releasing);
																	}
																};
																let mouseUp = _ => {
																	document.removeEventListener("mousemove", mouseMove);
																	document.removeEventListener("mouseup", mouseUp);
																};
																document.addEventListener("mousemove", mouseMove);
																document.addEventListener("mouseup", mouseUp);
															},
															onClick: event => {
																BDFDB.ListenerUtils.stopEvent(event);
																if (!this.state.draggingGradientCursor) {
																	this.state.selectedGradientCursor = posAndColor[0];
																	BDFDB.ReactUtils.forceUpdate(this);
																}
															},
															onContextMenu: posAndColor[0] == 0 || posAndColor[0] == 1 ? _ => {} : event => {
																BDFDB.ListenerUtils.stopEvent(event);
																delete this.props.color[posAndColor[0]];
																this.state.selectedGradientCursor = 0;
																this.handleColorChange();
															},
															children: BDFDB.ReactUtils.createElement("div", {
																style: {background: BDFDB.ColorUtils.convert(posAndColor[1], "RGBA")}
															})
														}))
													})
												})
											]
										})
									].filter(n => n)
								}),
								BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TextInput, {
									className: BDFDB.disCNS.colorpickerhexinput + BDFDB.disCN.margintop8,
									maxLength: this.props.alpha ? 9 : 7,
									valuePrefix: "#",
									value: hexColor,
									autoFocus: true,
									onChange: value => {
										const oldLength = hexLength;
										hexLength = (value || "").length;
										if (this.props.alpha && (oldLength > 8 || oldLength < 6) && hexLength == 7) value += "FF";
										if (hexRegex.test(value)) this.handleColorChange(value);
									},
									inputChildren: this.props.gradient && BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TooltipContainer, {
										text: BDFDB.LanguageUtils.LibraryStrings.gradient,
										children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Clickable, {
											className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.colorpickergradientbutton, this.state.gradientBarEnabled && BDFDB.disCN.colorpickergradientbuttonenabled),
											children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SvgIcon, {
												nativeClass: true,
												width: 28,
												height: 28,
												name: InternalComponents.LibraryComponents.SvgIcon.Names.GRADIENT
											}),
											onClick: _ => {
												this.state.gradientBarEnabled = !this.state.gradientBarEnabled;
												if (this.state.gradientBarEnabled && !this.state.isGradient) this.props.color = {0: selectedColor, 1: selectedColor};
												else if (!this.state.gradientBarEnabled && this.state.isGradient) this.props.color = selectedColor;
												this.state.isGradient = this.props.color && BDFDB.ObjectUtils.is(this.props.color);
												this.handleColorChange();
											}
										})
									})
								}),
								BDFDB.ReactUtils.createElement("div", {
									className: "move-corners",
									children: [{top: 0, left: 0}, {top: 0, right: 0}, {bottom: 0, right: 0}, {bottom: 0, left: 0}].map(pos => BDFDB.ReactUtils.createElement("div", {
										className: "move-corner",
										onMouseDown: e => {
											if (!this.domElementRef.current) return;
											let rects = BDFDB.DOMUtils.getRects(this.domElementRef.current);
											let left = rects.left, top = rects.top;
											let oldX = e.pageX, oldY = e.pageY;
											let mouseUp = _ => {
												document.removeEventListener("mouseup", mouseUp);
												document.removeEventListener("mousemove", mouseMove);
											};
											let mouseMove = e2 => {
												left = left - (oldX - e2.pageX), top = top - (oldY - e2.pageY);
												oldX = e2.pageX, oldY = e2.pageY;
												this.domElementRef.current.style.setProperty("left", `${left}px`, "important");
												this.domElementRef.current.style.setProperty("top", `${top}px`, "important");
											};
											document.addEventListener("mouseup", mouseUp);
											document.addEventListener("mousemove", mouseMove);
										},
										style: Object.assign({}, pos, {width: 10, height: 10, cursor: "move", position: "absolute"})
									}))
								})
							]
						});
					}
				};
				
				InternalComponents.LibraryComponents.ColorSwatches = reactInitialized && class BDFDB_ColorSwatches extends LibraryModules.React.Component {
					ColorSwatch(props) {
						const swatches = props.swatches;
						let useWhite = !BDFDB.ColorUtils.isBright(props.color);
						let swatch = BDFDB.ReactUtils.createElement("button", {
							type: "button",
							className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.colorpickerswatch, props.isSingle && BDFDB.disCN.colorpickerswatchsingle, props.isDisabled && BDFDB.disCN.colorpickerswatchdisabled, props.isSelected && BDFDB.disCN.colorpickerswatchselected, props.isCustom && BDFDB.disCN.colorpickerswatchcustom, props.color == null && BDFDB.disCN.colorpickerswatchnocolor),
							number: props.number,
							disabled: props.isDisabled,
							onClick: _ => {
								if (!props.isSelected) {
									let color = props.isCustom && props.color == null ? (swatches.props.color || swatches.props.defaultCustomColor || "rgba(0, 0, 0, 1)") : props.color;
									if (typeof swatches.props.onColorChange == "function") swatches.props.onColorChange(BDFDB.ColorUtils.convert(color, "RGBCOMP"));
									swatches.props.color = color;
									swatches.props.customColor = props.isCustom ? color : swatches.props.customColor;
									swatches.props.customSelected = props.isCustom;
									BDFDB.ReactUtils.forceUpdate(swatches);
								}
							},
							style: Object.assign({}, props.style, {
								background: BDFDB.ObjectUtils.is(props.color) ? BDFDB.ColorUtils.createGradient(props.color) : BDFDB.ColorUtils.convert(props.color, "RGBA")
							}),
							children: [
								props.isCustom || props.isSingle ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SvgIcon, {
									className: BDFDB.disCN.colorpickerswatchdropper,
									foreground: BDFDB.disCN.colorpickerswatchdropperfg,
									name: InternalComponents.LibraryComponents.SvgIcon.Names.DROPPER,
									width: props.isCustom ? 14 : 10,
									height: props.isCustom ? 14 : 10,
									color: useWhite ? BDFDB.DiscordConstants.Colors.WHITE : BDFDB.DiscordConstants.Colors.BLACK
								}) : null,
								props.isSelected && !props.isSingle ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SvgIcon, {
									name: InternalComponents.LibraryComponents.SvgIcon.Names.CHECKMARK,
									width: props.isCustom ? 32 : 16,
									height: props.isCustom ? 24 : 16,
									color: useWhite ? BDFDB.DiscordConstants.Colors.WHITE : BDFDB.DiscordConstants.Colors.BLACK
								}) : null
							]
						});
						if (props.isCustom || props.isSingle || props.color == null) swatch = BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TooltipContainer, {
							text: props.isCustom || props.isSingle ? BDFDB.LanguageUtils.LanguageStrings.CUSTOM_COLOR : BDFDB.LanguageUtils.LanguageStrings.DEFAULT,
							tooltipConfig: {type: props.isSingle ? "top" : "bottom"},
							children: swatch
						});
						if (props.isCustom || props.isSingle) swatch = BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.PopoutContainer, {
							children: swatch,
							wrap: false,
							popoutClassName: BDFDB.disCNS.colorpickerwrapper + BDFDB.disCN.colorpicker,
							animation: InternalComponents.LibraryComponents.PopoutContainer.Animation.TRANSLATE,
							position: InternalComponents.LibraryComponents.PopoutContainer.Positions.BOTTOM,
							align: InternalComponents.LibraryComponents.PopoutContainer.Align.CENTER,
							renderPopout: _ => BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.ColorPicker, Object.assign({}, swatches.props.pickerConfig, {
								color: swatches.props.color,
								onColorChange: color => {
									if (typeof swatches.props.onColorChange == "function") swatches.props.onColorChange(color);
									props.color = color;
									swatches.props.color = color;
									swatches.props.customColor = color;
									swatches.props.customSelected = true;
									BDFDB.ReactUtils.forceUpdate(swatches);
								}
							}), true)
						});
						if (props.isCustom) swatch = BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.disCN.colorpickerswatchcustomcontainer,
							children: swatch
						});
						return swatch;
					}
					render() {
						let i = 0;
						this.props.color = BDFDB.ObjectUtils.is(this.props.color) ? this.props.color : BDFDB.ColorUtils.convert(this.props.color, "RGBA");
						this.props.colors = (BDFDB.ArrayUtils.is(this.props.colors) ? this.props.colors : [null, 5433630, 3066993, 1752220, 3447003, 3429595, 8789737, 10181046, 15277667, 15286558, 15158332, 15105570, 15844367, 13094093, 7372936, 6513507, 16777215, 3910932, 2067276, 1146986, 2123412, 2111892, 7148717, 7419530, 11342935, 11345940, 10038562, 11027200, 12745742, 9936031, 6121581, 2894892]).map(c => BDFDB.ColorUtils.convert(c, "RGBA"));
						this.props.colorRows = this.props.colors.length ? [this.props.colors.slice(0, parseInt(this.props.colors.length/2)), this.props.colors.slice(parseInt(this.props.colors.length/2))] : [];
						this.props.customColor = !this.props.color || !this.props.customSelected && this.props.colors.indexOf(this.props.color) > -1 ? null : this.props.color;
						this.props.defaultCustomColor = BDFDB.ObjectUtils.is(this.props.defaultCustomColor) ? this.props.defaultCustomColor : BDFDB.ColorUtils.convert(this.props.defaultCustomColor, "RGBA");
						this.props.customSelected = !!this.props.customColor;
						this.props.pickerConfig = BDFDB.ObjectUtils.is(this.props.pickerConfig) ? this.props.pickerConfig : {gradient: true, alpha: true};
						
						let customSwatch = BDFDB.ReactUtils.createElement(this.ColorSwatch, {
							swatches: this,
							color: this.props.customColor,
							isSingle: !this.props.colors.length,
							isCustom: this.props.colors.length,
							isSelected: this.props.customSelected,
							isDisabled: this.props.disabled,
							style: {margin: 0}
						});
						return !this.props.colors.length ? BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.disCN.colorpickerswatchsinglewrapper,
							children: customSwatch
						}) : BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex, {
							className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.colorpickerswatches, BDFDB.disCN.colorpickerswatchescontainer, this.props.disabled && BDFDB.disCN.colorpickerswatchesdisabled),
							children: [
								BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex.Child, {
									className: BDFDB.disCN.marginreset,
									shrink: 0,
									grow: 0,
									children: customSwatch
								}),
								BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex, {
									direction: InternalComponents.LibraryComponents.Flex.Direction.VERTICAL,
									className: BDFDB.disCN.flexmarginreset,
									grow: 1,
									children: this.props.colorRows.map(row => BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex, {
										className: BDFDB.disCN.colorpickerrow,
										wrap: InternalComponents.LibraryComponents.Flex.Wrap.WRAP,
										children: row.map(color => BDFDB.ReactUtils.createElement(this.ColorSwatch, {
											swatches: this,
											color: color,
											isCustom: false,
											isSelected: !this.props.customSelected && color == this.props.color,
											isDisabled: this.props.disabled
										}))
									}))
								}) 
							]
						});
					}
				};
		
				InternalComponents.LibraryComponents.DateInput = class BDFDB_DateInput extends LibraryModules.React.Component {
					renderFormatButton(props) {
						const button = BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Clickable, {
							className: BDFDB.disCN.dateinputbutton,
							children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SvgIcon, {
								name: props.svgName,
								width: 20,
								height: 20
							})
						});
						return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.PopoutContainer, {
							width: props.popoutWidth || 350,
							padding: 10,
							animation: InternalComponents.LibraryComponents.PopoutContainer.Animation.SCALE,
							position: InternalComponents.LibraryComponents.PopoutContainer.Positions.TOP,
							align: InternalComponents.LibraryComponents.PopoutContainer.Align.RIGHT,
							onClose: instance => BDFDB.DOMUtils.removeClass(instance.domElementRef.current, BDFDB.disCN.dateinputbuttonselected),
							renderPopout: instance => {
								BDFDB.DOMUtils.addClass(instance.domElementRef.current, BDFDB.disCN.dateinputbuttonselected);
								return props.children || BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex, {
									align: InternalComponents.LibraryComponents.Flex.Align.CENTER,
									children: [
										props.name && BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SettingsLabel, {
											label: props.name
										}),
										BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TextInput, {
											className: BDFDB.disCN.dateinputfield,
											placeholder: props.placeholder,
											value: props.getValue(),
											onChange: typeof props.onChange == "function" ? props.onChange : null
										}),
										props.tooltipText && this.renderInfoButton(props.tooltipText)
									].filter(n => n)
								})
							},
							children: props.name ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TooltipContainer, {
								text: props.name,
								children: button
							}) : button
						});
					}
					renderInfoButton(text, style) {
						return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TooltipContainer, {
							text: [text].flat(10).filter(n => n).map(n => BDFDB.ReactUtils.createElement("div", {children: n})),
							tooltipConfig: {
								type: "bottom",
								zIndex: 1009,
								maxWidth: 560
							},
							children: BDFDB.ReactUtils.createElement("div", {
								className: BDFDB.disCN.dateinputbutton,
								style: Object.assign({}, style),
								children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SvgIcon, {
									name: InternalComponents.LibraryComponents.SvgIcon.Names.QUESTIONMARK,
									width: 24,
									height: 24
								})
							})
						});
					}
					handleChange() {
						if (typeof this.props.onChange == "function") this.props.onChange(BDFDB.ObjectUtils.extract(this.props, "formatString", "dateString", "timeString", "timeOffset", "language"));
					}
					render() {
						let input = this, formatter, preview;
						const defaultOffset = ((new Date()).getTimezoneOffset() * (-1/60));
						return BDFDB.ReactUtils.createElement("div", BDFDB.ObjectUtils.exclude(Object.assign({}, this.props, {
							className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.dateinputwrapper, this.props.className),
							children: [
								BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SettingsLabel, {
									label: this.props.label
								}),
								BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN.dateinputinner,
									children: [
										BDFDB.ReactUtils.createElement("div", {
											className: BDFDB.disCN.dateinputcontrols,
											children: [
												BDFDB.ReactUtils.createElement(class DateInputPreview extends LibraryModules.React.Component {
													componentDidMount() {formatter = this;}
													render() {
														return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TextInput, {
															className: BDFDB.disCN.dateinputfield,
															placeholder: InternalComponents.LibraryComponents.DateInput.getDefaultString(input.props.language),
															value: input.props.formatString,
															onChange: value => {
																input.props.formatString = value;
																input.handleChange.apply(input, []);
																BDFDB.ReactUtils.forceUpdate(formatter, preview);
															}
														});
													}
												}),
												this.renderInfoButton([
													"$date will be replaced with the Date",
													"$time will be replaced with the Time",
													"$time12 will be replaced with the Time (12h Form)",
													"$month will be replaced with the Month Name",
													"$monthS will be replaced with the Month Name (Short Form)",
													"$day will be replaced with the Weekday Name",
													"$dayS will be replaced with the Weekday Name (Short Form)",
													"$agoAmount will be replaced with ('Today', 'Yesterday', 'x days/weeks/months ago')",
													"$agoDays will be replaced with ('Today', 'Yesterday', 'x days ago')",
													"$agoDate will be replaced with ('Today', 'Yesterday', $date)"
												], {marginRight: 6}),
												this.renderFormatButton({
													name: BDFDB.LanguageUtils.LanguageStrings.DATE,
													svgName: InternalComponents.LibraryComponents.SvgIcon.Names.CALENDAR,
													placeholder: this.props.dateString,
													getValue: _ => this.props.dateString,
													tooltipText: [
														"$d will be replaced with the Day",
														"$dd will be replaced with the Day (Forced Zeros)",
														"$m will be replaced with the Month",
														"$mm will be replaced with the Month (Forced Zeros)",
														"$yy will be replaced with the Year (2-Digit)",
														"$yyyy will be replaced with the Year (4-Digit)",
														"$month will be replaced with the Month Name",
														"$monthS will be replaced with the Month Name (Short Form)",
													],
													onChange: value => {
														this.props.dateString = value;
														this.handleChange.apply(this, []);
														BDFDB.ReactUtils.forceUpdate(formatter, preview);
													}
												}),
												this.renderFormatButton({
													name: BDFDB.LanguageUtils.LibraryStrings.time,
													svgName: InternalComponents.LibraryComponents.SvgIcon.Names.CLOCK,
													placeholder: this.props.timeString,
													getValue: _ => this.props.timeString,
													tooltipText: [
														"$h will be replaced with the Hours",
														"$hh will be replaced with the Hours (Forced Zeros)",
														"$m will be replaced with the Minutes",
														"$mm will be replaced with the Minutes (Forced Zeros)",
														"$s will be replaced with the Seconds",
														"$ss will be replaced with the Seconds (Forced Zeros)",
														"$u will be replaced with the Milliseconds",
														"$uu will be replaced with the Milliseconds (Forced Zeros)"
													],
													onChange: value => {
														this.props.timeString = value;
														this.handleChange.apply(this, []);
														BDFDB.ReactUtils.forceUpdate(formatter, preview);
													}
												}),
												this.renderFormatButton({
													name: BDFDB.LanguageUtils.LibraryStrings.location,
													svgName: InternalComponents.LibraryComponents.SvgIcon.Names.GLOBE,
													popoutWidth: 550,
													children: [
														BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.AutoFocusCatcher, {}),
														BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex, {
															className: BDFDB.disCN.marginbottom4,
															align: InternalComponents.LibraryComponents.Flex.Align.CENTER,
															children: [
																BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SettingsLabel, {
																	label: BDFDB.LanguageUtils.LanguageStrings.LANGUAGE
																}),
																BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Select, {
																	className: BDFDB.disCN.dateinputfield,
																	value: this.props.language != null ? this.props.language : "$discord",
																	options: Object.keys(BDFDB.LanguageUtils.languages).map(id => ({
																		value: id,
																		label: BDFDB.LanguageUtils.getName(BDFDB.LanguageUtils.languages[id])
																	})),
																	searchable: true,
																	optionRenderer: lang => lang.label,
																	onChange: value => {
																		this.props.language = value == "$discord" ? undefined : value;
																		this.handleChange.apply(this, []);
																		BDFDB.ReactUtils.forceUpdate(formatter, preview);
																	}
																})
															]
														}),
														BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex, {
															align: InternalComponents.LibraryComponents.Flex.Align.CENTER,
															children: [
																BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SettingsLabel, {
																	label: BDFDB.LanguageUtils.LibraryStrings.timezone
																}),
																BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Select, {
																	className: BDFDB.disCN.dateinputfield,
																	value: this.props.timeOffset != null ? this.props.timeOffset : defaultOffset,
																	options: [-12.0, -11.0, -10.0, -9.5, -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.5, -3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 3.5, 4.0, 4.5, 5.0, 5.5, 5.75, 6.0, 6.5, 7.0, 8.0, 8.75, 9.0, 9.5, 10.0, 10.5, 11.0, 12.0, 12.75, 13.0, 14.0].map(offset => ({label: offset< 0 ? offset : `+${offset}`, value: offset})),
																	searchable: true,
																	onChange: value => {
																		this.props.timeOffset = value == defaultOffset ? undefined : value;
																		this.handleChange.apply(this, []);
																		BDFDB.ReactUtils.forceUpdate(formatter, preview);
																	}
																})
															]
														})
													]
												})
											]
										}),
										BDFDB.ReactUtils.createElement(class DateInputPreview extends LibraryModules.React.Component {
											componentDidMount() {preview = this;}
											render() {
												return !input.props.noPreview && BDFDB.ReactUtils.createElement("div", {
													className: BDFDB.disCN.dateinputpreview,
													children: [
														input.props.prefix && BDFDB.ReactUtils.createElement("div", {
															className: BDFDB.disCN.dateinputpreviewprefix,
															children: typeof input.props.prefix == "function" ? input.props.prefix(input) : input.props.prefix,
														}),
														BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TextScroller, {
															children: InternalComponents.LibraryComponents.DateInput.format(input.props, new Date((new Date()) - (1000*60*60*24*2)))
														}),
														input.props.suffix && BDFDB.ReactUtils.createElement("div", {
															className: BDFDB.disCN.dateinputpreviewsuffix,
															children: typeof input.props.suffix == "function" ? input.props.suffix(input) : input.props.suffix,
														})
													].filter(n => n)
												});
											}
										})
									]
								})
							]
						}), "onChange", "label", "formatString", "dateString", "timeString", "timeOffset", "language", "noPreview", "prefix", "suffix"));
					}
				};
				InternalComponents.LibraryComponents.DateInput.getDefaultString = function (language) {
					language = language || BDFDB.LanguageUtils.getLanguage().id;
					const date = new Date();
					return date.toLocaleString(language).replace(date.toLocaleDateString(language), "$date").replace(date.toLocaleTimeString(language, {hourCycle: "h12"}), "$time12").replace(date.toLocaleTimeString(language, {hourCycle: "h11"}), "$time12").replace(date.toLocaleTimeString(language, {hourCycle: "h24"}), "$time").replace(date.toLocaleTimeString(language, {hourCycle: "h23"}), "$time");
				};
				InternalComponents.LibraryComponents.DateInput.parseDate = function (date, offset) {
					let timeObj = typeof date == "string" || typeof date == "number" ? new Date(date) : date;
					if (timeObj.toString() == "Invalid Date") timeObj = new Date(parseInt(date));
					if (timeObj.toString() == "Invalid Date" || typeof timeObj.toLocaleDateString != "function") timeObj = new Date();
					offset = offset != null && parseFloat(offset);
					if ((offset || offset === 0) && !isNaN(offset)) timeObj = new Date(timeObj.getTime() + ((offset - timeObj.getTimezoneOffset() * (-1/60)) * 60*60*1000));
					return timeObj;
				};
				InternalComponents.LibraryComponents.DateInput.format = function (data, time) {
					if (typeof data == "string") data = {formatString: data};
					if (data && typeof data.formatString != "string") data.formatString = "";
					if (!data || typeof data.formatString != "string" || !time) return "";
					
					const language = data.language || BDFDB.LanguageUtils.getLanguage().id;
					const timeObj = InternalComponents.LibraryComponents.DateInput.parseDate(time, data.timeOffset);
					const now = new Date();
					const daysAgo = Math.round((Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()) - Date.UTC(timeObj.getFullYear(), timeObj.getMonth(), timeObj.getDate()))/(1000*60*60*24));
					const date = data.dateString && typeof data.dateString == "string" ? InternalComponents.LibraryComponents.DateInput.formatDate({dateString: data.dateString, language: language}, timeObj) : timeObj.toLocaleDateString(language);
					
					return (data.formatString || InternalComponents.LibraryComponents.DateInput.getDefaultString(language))
						.replace(/\$date/g, date)
						.replace(/\$time12/g, data.timeString && typeof data.timeString == "string" ? InternalComponents.LibraryComponents.DateInput.formatTime({timeString: data.timeString, language: language}, timeObj, true) : timeObj.toLocaleTimeString(language, {hourCycle: "h12"}))
						.replace(/\$time/g, data.timeString && typeof data.timeString == "string" ? InternalComponents.LibraryComponents.DateInput.formatTime({timeString: data.timeString, language: language}, timeObj) : timeObj.toLocaleTimeString(language, {hourCycle: "h23"}))
						.replace(/\$monthS/g, timeObj.toLocaleDateString(language, {month: "short"}))
						.replace(/\$month/g, timeObj.toLocaleDateString(language, {month: "long"}))
						.replace(/\$dayS/g, timeObj.toLocaleDateString(language, {weekday: "short"}))
						.replace(/\$day/g, timeObj.toLocaleDateString(language, {weekday: "long"}))
						.replace(/\$agoAmount/g, daysAgo > 1 ? BDFDB.LanguageUtils.LanguageStringsFormat(`GAME_LIBRARY_LAST_PLAYED_${daysAgo > 80 ? "MONTHS" : daysAgo > 30 ? "WEEKS" : "DAYS"}`, daysAgo > 80 ? Math.round(daysAgo/30) : daysAgo > 30 ? Math.round(daysAgo/7) : daysAgo) : BDFDB.LanguageUtils.LanguageStrings[`SEARCH_SHORTCUT_${daysAgo == 1 ? "YESTERDAY" : "TODAY"}`])
						.replace(/\$agoDays/g, daysAgo > 1 ? BDFDB.LanguageUtils.LanguageStringsFormat(`GAME_LIBRARY_LAST_PLAYED_DAYS`, daysAgo) : BDFDB.LanguageUtils.LanguageStrings[`SEARCH_SHORTCUT_${daysAgo == 1 ? "YESTERDAY" : "TODAY"}`])
						.replace(/\$agoDate/g, daysAgo > 1 ? date : BDFDB.LanguageUtils.LanguageStrings[`SEARCH_SHORTCUT_${daysAgo == 1 ? "YESTERDAY" : "TODAY"}`]);
				};
				InternalComponents.LibraryComponents.DateInput.formatDate = function (data, time) {
					if (typeof data == "string") data = {dateString: data};
					if (data && typeof data.dateString != "string") return "";
					if (!data || typeof data.dateString != "string" || !data.dateString || !time) return "";
					
					const language = data.language || BDFDB.LanguageUtils.getLanguage().id;
					const timeObj = InternalComponents.LibraryComponents.DateInput.parseDate(time, data.timeOffset);
					
					return data.dateString
						.replace(/\$monthS/g, timeObj.toLocaleDateString(language, {month: "short"}))
						.replace(/\$month/g, timeObj.toLocaleDateString(language, {month: "long"}))
						.replace(/\$dd/g, timeObj.toLocaleDateString(language, {day: "2-digit"}))
						.replace(/\$d/g, timeObj.toLocaleDateString(language, {day: "numeric"}))
						.replace(/\$mm/g, timeObj.toLocaleDateString(language, {month: "2-digit"}))
						.replace(/\$m/g, timeObj.toLocaleDateString(language, {month: "numeric"}))
						.replace(/\$yyyy/g, timeObj.toLocaleDateString(language, {year: "numeric"}))
						.replace(/\$yy/g, timeObj.toLocaleDateString(language, {year: "2-digit"}));
				};
				InternalComponents.LibraryComponents.DateInput.formatTime = function (data, time, hour12) {
					if (typeof data == "string") data = {timeString: data};
					if (data && typeof data.timeString != "string") return "";
					if (!data || typeof data.timeString != "string" || !data.timeString || !time) return "";
					
					const language = data.language || BDFDB.LanguageUtils.getLanguage().id;
					const timeObj = InternalComponents.LibraryComponents.DateInput.parseDate(time, data.timeOffset);
					
					let hours = timeObj.getHours();
					if (hour12) {
						hours = hours == 0 ? 12 : hours;
						if (hours > 12) hours -= 12;
					}
					const minutes = timeObj.getMinutes();
					const seconds = timeObj.getSeconds();
					const milli = timeObj.getMilliseconds();
					
					let string = data.timeString
						.replace(/\$hh/g, hours < 10 ? `0${hours}` : hours)
						.replace(/\$h/g, hours)
						.replace(/\$mm/g, minutes < 10 ? `0${minutes}` : minutes)
						.replace(/\$m/g, minutes)
						.replace(/\$ss/g, seconds < 10 ? `0${seconds}` : seconds)
						.replace(/\$s/g, seconds)
						.replace(/\$uu/g, milli < 10 ? `00${seconds}` : milli < 100 ? `0${milli}` : milli)
						.replace(/\$u/g, milli);

					let digits = "\\d";
					if (BDFDB.LanguageUtils.languages[language] && BDFDB.LanguageUtils.languages[language].numberMap) {
						digits = Object.entries(BDFDB.LanguageUtils.languages[language].numberMap).map(n => n[1]).join("");
						for (let number in BDFDB.LanguageUtils.languages[language].numberMap) string = string.replace(new RegExp(number, "g"), BDFDB.LanguageUtils.languages[language].numberMap[number]);
					}
					return hour12 ? timeObj.toLocaleTimeString(language, {hourCycle: "h12"}).replace(new RegExp(`[${digits}]{1,2}[^${digits}][${digits}]{1,2}[^${digits}][${digits}]{1,2}`, "g"), string) : string;
				};
				
				InternalComponents.LibraryComponents.EmojiPickerButton = reactInitialized && class BDFDB_EmojiPickerButton extends LibraryModules.React.Component {
					handleEmojiChange(emoji) {
						if (emoji != null) {
							this.props.emoji = emoji.id ? {
								id: emoji.id,
								name: emoji.name,
								animated: emoji.animated
							} : {
								id: null,
								name: emoji.optionallyDiverseSequence,
								animated: false
							};
							if (typeof this.props.onSelect == "function") this.props.onSelect(this.props.emoji, this);
							BDFDB.ReactUtils.forceUpdate(this);
						}
					}
					render() {
						return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.PopoutContainer, {
							children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.EmojiButton, {
								className: BDFDB.DOMUtils.formatClassName(this.props.className, BDFDB.disCN.emojiinputbutton),
								renderButtonContents: this.props.emoji ? _ => BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Emoji, {
									className: BDFDB.disCN.emoji,
									emojiId: this.props.emoji.id,
									emojiName: this.props.emoji.name
								}) : null
							}),
							wrap: false,
							animation: InternalComponents.LibraryComponents.PopoutContainer.Animation.NONE,
							position: InternalComponents.LibraryComponents.PopoutContainer.Positions.TOP,
							align: InternalComponents.LibraryComponents.PopoutContainer.Align.LEFT,
							renderPopout: instance => {
								return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.EmojiPicker, {
									closePopout: instance.close,
									onSelectEmoji: this.handleEmojiChange.bind(this),
									allowManagedEmojis: this.props.allowManagedEmojis
								});
							}
						});
					}
				};
				InternalBDFDB.setDefaultProps(InternalComponents.LibraryComponents.EmojiPickerButton, {allowManagedEmojis: false});
				
				InternalComponents.LibraryComponents.FavButton = reactInitialized && class BDFDB_FavButton extends LibraryModules.React.Component {
					handleClick() {
						this.props.isFavorite = !this.props.isFavorite;
						if (typeof this.props.onClick == "function") this.props.onClick(this.props.isFavorite, this);
						BDFDB.ReactUtils.forceUpdate(this);
					}
					render() {
						return BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.favbuttoncontainer, this.props.className),
							children: BDFDB.ReactUtils.createElement(InternalComponents.NativeSubComponents.FavButton, BDFDB.ObjectUtils.exclude(Object.assign({}, this.props, {onClick: this.handleClick.bind(this)}), "className"))
						});
					}
				};
				
				InternalComponents.LibraryComponents.FileButton = reactInitialized && class BDFDB_FileButton extends LibraryModules.React.Component {
					componentDidMount() {
						if (this.props.searchFolders) {
							let node = BDFDB.ReactUtils.findDOMNode(this);
							if (node && (node = node.querySelector("input[type='file']")) != null) {
								node.setAttribute("directory", "");
								node.setAttribute("webkitdirectory", "");
							}
						}
					}
					render() {
						let filter = this.props.filter && [this.props.filter].flat(10).filter(n => typeof n == "string") || [];
						return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Button, BDFDB.ObjectUtils.exclude(Object.assign({}, this.props, {
							onClick: e => {e.currentTarget.querySelector("input").click();},
							children: [
								BDFDB.LanguageUtils.LibraryStrings.file_navigator_text,
								BDFDB.ReactUtils.createElement("input", {
									type: "file",
									accept: filter.length && (filter.join("/*,") + "/*"),
									style: {display: "none"},
									onChange: e => {
										let file = e.currentTarget.files[0];
										if (this.refInput && file && (!filter.length || filter.some(n => file.type.indexOf(n) == 0))) {
											this.refInput.props.value = this.props.searchFolders ? file.path.split(file.name).slice(0, -1).join(file.name) : `${this.props.mode == "url" ? "url('" : ""}${(this.props.useFilePath) ? file.path : `data:${file.type};base64,${BDFDB.LibraryRequires.fs.readFileSync(file.path).toString("base64")}`}${this.props.mode ? "')" : ""}`;
											BDFDB.ReactUtils.forceUpdate(this.refInput);
											this.refInput.handleChange(this.refInput.props.value);
										}
									}
								})
							]
						}), "filter", "mode", "useFilePath", "searchFolders"));
					}
				};
				
				InternalComponents.LibraryComponents.FormComponents.FormItem = reactInitialized && class BDFDB_FormItem extends LibraryModules.React.Component {
					render() {
						return BDFDB.ReactUtils.createElement("div", {
							className: this.props.className,
							style: this.props.style,
							children: [
								BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex, {
									align: InternalComponents.LibraryComponents.Flex.Align.BASELINE,
									children: [
										this.props.title != null || this.props.error != null ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex.Child, {
											wrap: true,
											children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.FormComponents.FormTitle, {
												tag: this.props.tag || InternalComponents.LibraryComponents.FormComponents.FormTitle.Tags.H5,
												disabled: this.props.disabled,
												required: this.props.required,
												error: this.props.error,
												className: this.props.titleClassName,
												children: this.props.title
											})
										}) : null
									].concat([this.props.titleChildren].flat(10)).filter(n => n)
								}),
							].concat(this.props.children)
						});
					}
				};
				
				InternalComponents.LibraryComponents.GuildComponents = Object.assign({}, InternalComponents.LibraryComponents.GuildComponents);
				
				InternalComponents.LibraryComponents.GuildComponents.Guild = reactInitialized && class BDFDB_Guild extends LibraryModules.React.Component {
					constructor(props) {
						super(props);
						this.state = {hovered: false};
					}
					handleMouseEnter(e) {
						if (!this.props.sorting) this.setState({hovered: true});
						if (typeof this.props.onMouseEnter == "function") this.props.onMouseEnter(e, this);
					}
					handleMouseLeave(e) {
						if (!this.props.sorting) this.setState({hovered: false});
						if (typeof this.props.onMouseLeave == "function") this.props.onMouseLeave(e, this);
					}
					handleMouseDown(e) {
						if (!this.props.unavailable && this.props.guild && this.props.selectedChannelId) LibraryModules.DirectMessageUtils.preload(this.props.guild.id, this.props.selectedChannelId);
						if (e.button == 0 && typeof this.props.onMouseDown == "function") this.props.onMouseDown(e, this);
					}
					handleMouseUp(e) {
						if (e.button == 0 && typeof this.props.onMouseUp == "function") this.props.onMouseUp(e, this);
					}
					handleClick(e) {
						if (typeof this.props.onClick == "function") this.props.onClick(e, this);
					}
					handleContextMenu(e) {
						if (this.props.menu) BDFDB.GuildUtils.openMenu(this.props.guild, e);
						if (typeof this.props.onContextMenu == "function") this.props.onContextMenu(e, this);
					}
					setRef(e) {
						if (typeof this.props.setRef == "function") this.props.setRef(this.props.guild.id, e)
					}
					componentDidMount() {
						let node = BDFDB.ReactUtils.findDOMNode(this);
						if (node) for (let child of node.querySelectorAll("a")) child.setAttribute("draggable", false);
					}
					render() {
						if (!this.props.guild) return null;
						
						this.props.guildId = this.props.guild.id;
						this.props.selectedChannelId = LibraryModules.LastChannelStore.getChannelId(this.props.guild.id);
						
						let currentVoiceChannel = LibraryModules.ChannelStore.getChannel(LibraryModules.CurrentVoiceUtils.getChannelId());
						let hasVideo = currentVoiceChannel && LibraryModules.VoiceUtils.hasVideo(currentVoiceChannel);
						
						this.props.selected = this.props.state ? LibraryModules.LastGuildStore.getGuildId() == this.props.guild.id : false;
						this.props.unread = this.props.state ? LibraryModules.UnreadGuildUtils.hasUnread(this.props.guild.id) : false;
						this.props.badge = this.props.state ? LibraryModules.UnreadGuildUtils.getMentionCount(this.props.guild.id) : 0;
						
						this.props.audio = this.props.state ? currentVoiceChannel && currentVoiceChannel.guild_id == this.props.guild.id && !hasVideo : false;
						this.props.video = this.props.state ? currentVoiceChannel && currentVoiceChannel.guild_id == this.props.guild.id && hasVideo : false;
						this.props.screenshare = this.props.state ? !!LibraryModules.StreamUtils.getAllApplicationStreams().filter(stream => stream.guildId == this.props.guild.id)[0] : false;
						this.props.liveStage = this.props.state ? Object.keys(LibraryModules.StageChannelStore.getStageInstancesByGuild(this.props.guild.id)).length > 0 : false;
						this.props.hasLiveVoiceChannel = this.props.state && false ? !LibraryModules.MutedUtils.isMuted(this.props.guild.id) && BDFDB.ObjectUtils.toArray(LibraryModules.VoiceUtils.getVoiceStates(this.props.guild.id)).length > 0 : false;
						this.props.participating = this.props.state ? LibraryModules.CurrentVoiceUtils.getGuildId() == this.props.guild.id : false;
						this.props.participatingInStage = this.props.state ? currentVoiceChannel && currentVoiceChannel.guild_id == this.props.guild.id && currentVoiceChannel.isGuildStageVoice() : false;
						
						this.props.animatable = this.props.state ? LibraryModules.IconUtils.hasAnimatedGuildIcon(this.props.guild) : false;
						this.props.unavailable = this.props.state ? LibraryModules.GuildUnavailableStore.unavailableGuilds.includes(this.props.guild.id) : false;
					
						let isDraggedGuild = this.props.draggingGuildId === this.props.guild.id;
						let guild = isDraggedGuild ? BDFDB.ReactUtils.createElement("div", {
							children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.GuildComponents.Items.DragPlaceholder, {})
						}) : BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.disCN.guildcontainer,
							children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.GuildComponents.BlobMask, {
								selected: this.state.isDropHovering || this.props.selected || this.state.hovered,
								upperBadge: this.props.unavailable ? InternalComponents.LibraryComponents.GuildComponents.Items.renderUnavailableBadge() : InternalComponents.LibraryComponents.GuildComponents.Items.renderIconBadge(BDFDB.ObjectUtils.extract(this.props, "audio", "video", "screenshare", "liveStage", "hasLiveVoiceChannel", "participating", "participatingInStage")),
								lowerBadge: this.props.badge > 0 ? InternalComponents.LibraryComponents.GuildComponents.Items.renderMentionBadge(this.props.badge) : null,
								lowerBadgeWidth: InternalComponents.LibraryComponents.Badges.getBadgeWidthForValue(this.props.badge),
								children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.NavItem, {
									to: {
										pathname: BDFDB.DiscordConstants.Routes.CHANNEL(this.props.guild.id, this.props.selectedChannelId),
										state: {
											analyticsSource: {
												page: BDFDB.DiscordConstants.AnalyticsPages.GUILD_CHANNEL,
												section: BDFDB.DiscordConstants.AnalyticsSections.CHANNEL_LIST,
												object: BDFDB.DiscordConstants.AnalyticsObjects.CHANNEL
											}
										}
									},
									name: this.props.guild.name,
									onMouseEnter: this.handleMouseEnter.bind(this),
									onMouseLeave: this.handleMouseLeave.bind(this),
									onMouseDown: this.handleMouseDown.bind(this),
									onMouseUp: this.handleMouseUp.bind(this),
									onClick: this.handleClick.bind(this),
									onContextMenu: this.handleContextMenu.bind(this),
									icon: this.props.guild.getIconURL(this.state.hovered && this.props.animatable ? "gif" : "png"),
									selected: this.props.selected || this.state.hovered
								})
							})
						});
							
						if (this.props.draggable && typeof this.props.connectDragSource == "function") guild = this.props.connectDragSource(guild);
						
						let children = [
							this.props.list || this.props.pill ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.GuildComponents.Pill, {
								hovered: !isDraggedGuild && this.state.hovered,
								selected: !isDraggedGuild && this.props.selected,
								unread: !isDraggedGuild && this.props.unread,
								className: BDFDB.disCN.guildpill
							}) : null,
							!this.props.tooltip ? guild : BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TooltipContainer, {
								tooltipConfig: Object.assign({type: "right"}, this.props.tooltipConfig, {guild: this.props.list && this.props.guild}),
								children: guild
							})
						].filter(n => n);
						return this.props.list ? BDFDB.ReactUtils.createElement("div", {
							ref: null != this.props.setRef ? this.props.setRef : null,
							className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.guildouter, BDFDB.disCN._bdguild, this.props.unread && BDFDB.disCN._bdguildunread, this.props.selected && BDFDB.disCN._bdguildselected, this.props.unread && BDFDB.disCN._bdguildunread, this.props.audio && BDFDB.disCN._bdguildaudio, this.props.video && BDFDB.disCN._bdguildvideo),
							children: BDFDB.ReactUtils.createElement(BDFDB.ReactUtils.Fragment, {
								children: children
							})
						}) : BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.guild, this.props.className),
							children: children
						});
					}
				};
				InternalBDFDB.setDefaultProps(InternalComponents.LibraryComponents.GuildComponents.Guild, {menu: true, tooltip: true, list: false, state: false, draggable: false, sorting: false});
				
				InternalComponents.LibraryComponents.GuildSummaryItem = reactInitialized && class BDFDB_GuildSummaryItem extends LibraryModules.React.Component {
					defaultRenderGuild(guild, isLast) {
						if (!guild) return BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.disCN.guildsummaryemptyguild
						});
						let icon = BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.GuildComponents.Icon, {
							className: BDFDB.disCN.guildsummaryicon,
							guild: guild,
							showTooltip: this.props.showTooltip,
							tooltipPosition: "top",
							size: InternalComponents.LibraryComponents.GuildComponents.Icon.Sizes.SMALLER
						});
						return this.props.switchOnClick ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Clickable, {
							className: BDFDB.disCN.guildsummaryclickableicon,
							onClick: _ => LibraryModules.HistoryUtils.transitionTo(BDFDB.DiscordConstants.Routes.CHANNEL(guild.id, LibraryModules.LastChannelStore.getChannelId(guild.id))),
							key: guild.id,
							tabIndex: -1,
							children: icon
						}) : icon;
					}
					renderGuilds() {
						let elements = [];
						let renderGuild = typeof this.props.renderGuild != "function" ? this.defaultRenderGuild : this.props.renderGuild;
						let loaded = 0, max = this.props.guilds.length === this.props.max ? this.props.guilds.length : this.props.max - 1;
						while (loaded < max && loaded < this.props.guilds.length) {
							let isLast = loaded === this.props.guilds.length - 1;
							let guild = renderGuild.apply(this, [this.props.guilds[loaded], isLast]);
							elements.push(BDFDB.ReactUtils.createElement("div", {
								className: isLast ? BDFDB.disCN.guildsummaryiconcontainer : BDFDB.disCN.guildsummaryiconcontainermasked,
								children: guild
							}));
							loaded++;
						}
						if (loaded < this.props.guilds.length) {
							let rest = Math.min(this.props.guilds.length - loaded, 99);
							elements.push(BDFDB.ReactUtils.createElement(LibraryModules.React.Fragment, {
								key: "more-guilds",
								children: this.props.renderMoreGuilds("+" + rest, rest, this.props.guilds.slice(loaded), this.props)
							}));
						}
						return elements;
					}
					renderIcon() {
						return this.props.renderIcon ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SvgIcon, {
							name: InternalComponents.LibraryComponents.SvgIcon.Names.WHATISTHIS,
							className: BDFDB.disCN.guildsummarysvgicon
						}) : null;
					}
					render() {
						return BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.DOMUtils.formatClassName(this.props.className, BDFDB.disCN.guildsummarycontainer),
							ref: this.props._ref,
							children: [
								this.renderIcon.apply(this),
								this.renderGuilds.apply(this)
							].flat(10).filter(n => n)
						});
					}
				};
				InternalBDFDB.setDefaultProps(InternalComponents.LibraryComponents.GuildSummaryItem, {max: 10, renderMoreGuilds: (count, amount, restGuilds, props) => {
					let icon = BDFDB.ReactUtils.createElement("div", {className: BDFDB.disCN.guildsummarymoreguilds, children: count});
					return props.showTooltip ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TooltipContainer, {
						text: restGuilds.map(guild => guild.name).join(", "),
						children: icon
					}) : icon;
				}, renderIcon: false});
				
				InternalComponents.LibraryComponents.KeybindRecorder = reactInitialized && class BDFDB_KeybindRecorder extends LibraryModules.React.Component {
					handleChange(arrays) {
						this.props.value = arrays.map(platformKey => LibraryModules.KeyEvents.codes[LibraryModules.KeyCodeUtils.codeToKey(platformKey)] || platformKey[1]);
						if (typeof this.props.onChange == "function") this.props.onChange(this.props.value, this);
					}
					handleReset() {
						this.props.value = [];
						if (this.recorder) this.recorder.setState({codes: []});
						if (typeof this.props.onChange == "function") this.props.onChange([], this);
						if (typeof this.props.onReset == "function") this.props.onReset(this);
					}
					componentDidMount() {
						if (!this.recorder) this.recorder = BDFDB.ReactUtils.findOwner(this, {name: "KeybindRecorder"});
					}
					render() {
						return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex, {
							className: BDFDB.disCN.hotkeywrapper,
							direction: InternalComponents.LibraryComponents.Flex.Direction.HORIZONTAL,
							align: InternalComponents.LibraryComponents.Flex.Align.CENTER,
							children: [
								BDFDB.ReactUtils.createElement(InternalComponents.NativeSubComponents.KeybindRecorder, BDFDB.ObjectUtils.exclude(Object.assign({}, this.props, {
									defaultValue: [this.props.defaultValue || this.props.value].flat(10).filter(n => n).map(keyCode => [BDFDB.DiscordConstants.KeyboardDeviceTypes.KEYBOARD_KEY, LibraryModules.KeyCodeUtils.keyToCode((Object.entries(LibraryModules.KeyEvents.codes).find(n => n[1] == keyCode && LibraryModules.KeyCodeUtils.keyToCode(n[0], null)) || [])[0], null) || keyCode]),
									onChange: this.handleChange.bind(this)
								}), "reset", "onReset")),
								this.props.reset || this.props.onReset ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TooltipContainer, {
									text: BDFDB.LanguageUtils.LanguageStrings.REMOVE_KEYBIND,
									tooltipConfig: {type: "top"},
									children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Clickable, {
										className: BDFDB.disCN.hotkeyresetbutton,
										onClick: this.handleReset.bind(this),
										children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SvgIcon, {
											iconSVG: `<svg height="20" width="20" viewBox="0 0 20 20"><path fill="currentColor" d="M 14.348 14.849 c -0.469 0.469 -1.229 0.469 -1.697 0 l -2.651 -3.030 -2.651 3.029 c -0.469 0.469 -1.229 0.469 -1.697 0 -0.469 -0.469 -0.469 -1.229 0 -1.697l2.758 -3.15 -2.759 -3.152 c -0.469 -0.469 -0.469 -1.228 0 -1.697 s 1.228 -0.469 1.697 0 l 2.652 3.031 2.651 -3.031 c 0.469 -0.469 1.228 -0.469 1.697 0 s 0.469 1.229 0 1.697l -2.758 3.152 2.758 3.15 c 0.469 0.469 0.469 1.229 0 1.698 z"></path></svg>`,
										})
									})
								}) : null
							].filter(n => n)
						});
					}
				};
				
				InternalComponents.LibraryComponents.ListRow = reactInitialized && class BDFDB_ListRow extends LibraryModules.React.Component {
					render() {
						return BDFDB.ReactUtils.createElement("div", BDFDB.ObjectUtils.exclude(Object.assign({}, this.props, {
							className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.listrowwrapper, this.props.className, BDFDB.disCN.listrow),
							children: [
								this.props.prefix,
								BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN.listrowcontent,
									style: {flex: "1 1 auto"},
									children: [
										BDFDB.ReactUtils.createElement("div", {
											className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.listname, this.props.labelClassName),
											style: {flex: "1 1 auto"},
											children: this.props.label
										}),
										typeof this.props.note == "string" ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.FormComponents.FormText, {
											type: InternalComponents.LibraryComponents.FormComponents.FormText.Types.DESCRIPTION,
											children: this.props.note
										}) : null
									].filter(n => n)
								}),
								this.props.suffix
							].filter(n => n)
						}), "label", "note", "suffix", "prefix", "labelClassName"));
					}
				};
				
				InternalComponents.LibraryComponents.MemberRole = reactInitialized && class BDFDB_MemberRole extends LibraryModules.React.Component {
					handleClick(e) {if (typeof this.props.onClick == "function") this.props.onClick(e, this);}
					handleContextMenu(e) {if (typeof this.props.onContextMenu == "function") this.props.onContextMenu(e, this);}
					render() {
						let color = BDFDB.ColorUtils.convert(this.props.role.colorString || BDFDB.DiscordConstants.Colors.PRIMARY_DARK_300, "RGB");
						return BDFDB.ReactUtils.createElement("li", {
							className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.userpopoutrole, this.props.className),
							style: {borderColor: BDFDB.ColorUtils.setAlpha(color, 0.6)},
							onClick: this.handleClick.bind(this),
							onContextMenu: this.handleContextMenu.bind(this),
							children: [
								!this.props.noCircle ? BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN.userpopoutrolecircle,
									style: {backgroundColor: color}
								}) : null,
								BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN.userpopoutrolename,
									children: this.props.role.name
								})
							].filter(n => n)
						});
					}
				};
				
				InternalComponents.LibraryComponents.MenuItems.MenuCheckboxItem = reactInitialized && class BDFDB_MenuCheckboxItem extends LibraryModules.React.Component {
					handleClick() {
						if (this.props.state) {
							this.props.state.checked = !this.props.state.checked;
							if (typeof this.props.action == "function") this.props.action(this.props.state.checked, this);
						}
						BDFDB.ReactUtils.forceUpdate(this);
					}
					render() {
						return BDFDB.ReactUtils.createElement(InternalComponents.NativeSubComponents.MenuCheckboxItem, Object.assign({}, this.props, {
							checked: this.props.state && this.props.state.checked,
							action: this.handleClick.bind(this)
						}));
					}
				};
				
				InternalComponents.LibraryComponents.MenuItems.MenuHint = reactInitialized && class BDFDB_MenuHint extends LibraryModules.React.Component {
					render() {
						return !this.props.hint ? null : BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.disCN.menuhint,
							children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TextScroller, {
								children: this.props.hint
							})
						});
					}
				};
				
				InternalComponents.LibraryComponents.MenuItems.MenuIcon = reactInitialized && class BDFDB_MenuIcon extends LibraryModules.React.Component {
					render() {
						let isString = typeof this.props.icon == "string";
						return !this.props.icon ? null : BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SvgIcon, {
							className: BDFDB.disCN.menuicon,
							nativeClass: true,
							iconSVG: isString ? this.props.icon : null,
							name: !isString ? this.props.icon : null
						});
					}
				};
				
				InternalComponents.LibraryComponents.MenuItems.MenuSliderItem = reactInitialized && class BDFDB_MenuSliderItem extends LibraryModules.React.Component {
					handleValueChange(value) {
						if (this.props.state) {
							this.props.state.value = Math.round(BDFDB.NumberUtils.mapRange([0, 100], [this.props.minValue, this.props.maxValue], value) * Math.pow(10, this.props.digits)) / Math.pow(10, this.props.digits);
							if (typeof this.props.onValueChange == "function") this.props.onValueChange(this.props.state.value, this);
						}
						BDFDB.ReactUtils.forceUpdate(this);
					}
					handleValueRender(value) {
						let newValue = Math.round(BDFDB.NumberUtils.mapRange([0, 100], [this.props.minValue, this.props.maxValue], value) * Math.pow(10, this.props.digits)) / Math.pow(10, this.props.digits);
						if (typeof this.props.onValueRender == "function") {
							let tempReturn = this.props.onValueRender(newValue, this);
							if (tempReturn != undefined) newValue = tempReturn;
						}
						return newValue;
					}
					render() {
						let value = this.props.state && this.props.state.value || 0;
						return BDFDB.ReactUtils.createElement(InternalComponents.NativeSubComponents.MenuControlItem, BDFDB.ObjectUtils.exclude(Object.assign({}, this.props, {
							label: typeof this.props.renderLabel == "function" ? this.props.renderLabel(Math.round(value * Math.pow(10, this.props.digits)) / Math.pow(10, this.props.digits)) : this.props.label,
							control: (menuItemProps, ref) => {
								return BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN.menuslidercontainer,
									children: BDFDB.ReactUtils.createElement(InternalComponents.NativeSubComponents.Slider, Object.assign({}, menuItemProps, {
										ref: ref,
										className: BDFDB.disCN.menuslider,
										mini: true,
										initialValue: Math.round(BDFDB.NumberUtils.mapRange([this.props.minValue, this.props.maxValue], [0, 100], value) * Math.pow(10, this.props.digits)) / Math.pow(10, this.props.digits),
										onValueChange: this.handleValueChange.bind(this),
										onValueRender: this.handleValueRender.bind(this)
									}))
								});
							}
						}), "digits", "renderLabel"));
					}
				};
				InternalBDFDB.setDefaultProps(InternalComponents.LibraryComponents.MenuItems.MenuSliderItem, {minValue: 0, maxValue: 100, digits: 0});
				
				InternalComponents.LibraryComponents.ModalComponents.ModalContent = reactInitialized && class BDFDB_ModalContent extends LibraryModules.React.Component {
					render() {
						return this.props.scroller ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Scrollers.Thin, {
							className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.modalcontent, this.props.className),
							ref: this.props.scrollerRef,
							children: this.props.children
						}) : BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex, {
							className: BDFDB.DOMUtils.formatClassName(this.props.content && BDFDB.disCN.modalcontent, BDFDB.disCN.modalnoscroller, this.props.className),
							direction: this.props.direction || InternalComponents.LibraryComponents.Flex.Direction.VERTICAL,
							align: InternalComponents.LibraryComponents.Flex.Align.STRETCH,
							children: this.props.children
						});
					}
				};
				InternalBDFDB.setDefaultProps(InternalComponents.LibraryComponents.ModalComponents.ModalContent, {scroller: true, content: true});
				
				InternalComponents.LibraryComponents.ModalComponents.ModalTabContent = reactInitialized && class BDFDB_ModalTabContent extends LibraryModules.React.Component {
					render() {
						return !this.props.open ? null : BDFDB.ReactUtils.createElement(this.props.scroller ? InternalComponents.LibraryComponents.Scrollers.Thin : "div", Object.assign(BDFDB.ObjectUtils.exclude(this.props, "scroller", "open"), {
							className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.modaltabcontent, this.props.open && BDFDB.disCN.modaltabcontentopen, this.props.className),
							children: this.props.children
						}));
					}
				};
				InternalBDFDB.setDefaultProps(InternalComponents.LibraryComponents.ModalComponents.ModalTabContent, {tab: "unnamed"});
				
				InternalComponents.LibraryComponents.ModalComponents.ModalFooter = reactInitialized && class BDFDB_ModalFooter extends LibraryModules.React.Component {
					render() {
						return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex, {
							className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.modalfooter, this.props.className),
							direction: this.props.direction || InternalComponents.LibraryComponents.Flex.Direction.HORIZONTAL_REVERSE,
							align: InternalComponents.LibraryComponents.Flex.Align.STRETCH,
							grow: 0,
							shrink: 0,
							children: this.props.children
						});
					}
				};
				
				InternalComponents.LibraryComponents.MultiInput = reactInitialized && class BDFDB_MultiInput extends LibraryModules.React.Component {
					constructor(props) {
						super(props);
						this.state = {focused: false};
					}
					render() {
						if (this.props.children && this.props.children.props) this.props.children.props.className = BDFDB.DOMUtils.formatClassName(this.props.children.props.className, BDFDB.disCN.inputmultifield);
						return BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.DOMUtils.formatClassName(this.props.className, BDFDB.disCN.inputwrapper, BDFDB.disCN.inputmultiwrapper),
							children: BDFDB.ReactUtils.createElement("div", {
								className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.input, BDFDB.disCN.inputmulti, this.state.focused && BDFDB.disCN.inputfocused),
								children: [
									BDFDB.ReactUtils.createElement("div", {
										className: BDFDB.DOMUtils.formatClassName(this.props.innerClassName, BDFDB.disCN.inputwrapper, BDFDB.disCN.inputmultifirst),
										children: this.props.children
									}),
									BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TextInput, BDFDB.ObjectUtils.exclude(Object.assign({}, this.props, {
										className: BDFDB.disCN.inputmultilast,
										inputClassName: BDFDB.disCN.inputmultifield,
										onFocus: e => {this.setState({focused: true})},
										onBlur: e => {this.setState({focused: false})}
									}), "children", "innerClassName"))
								]
							})
						});
					}
				};
				
				InternalComponents.LibraryComponents.ListInput = reactInitialized && class BDFDB_ListInput extends LibraryModules.React.Component {
					handleChange() {
						if (typeof this.props.onChange) this.props.onChange(this.props.items, this);
					}
					render() {
						if (!BDFDB.ArrayUtils.is(this.props.items)) this.props.items = [];
						return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.MultiInput, BDFDB.ObjectUtils.exclude(Object.assign({}, this.props, {
							className: BDFDB.disCN.inputlist,
							innerClassName: BDFDB.disCN.inputlistitems,
							onKeyDown: e => {
								if (e.which == 13 && e.target.value && e.target.value.trim()) {
									let value = e.target.value.trim();
									this.props.value = "";
									if (!this.props.items.includes(value)) {
										this.props.items.push(value);
										BDFDB.ReactUtils.forceUpdate(this);
										this.handleChange.apply(this, []);
									}
								}
							},
							children: this.props.items.map(item => BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Badges.TextBadge, {
								className: BDFDB.disCN.inputlistitem,
								color: "var(--bdfdb-blurple)",
								style: {borderRadius: "3px"},
								text: [
									item,
									BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SvgIcon, {
										className: BDFDB.disCN.inputlistdelete,
										name: InternalComponents.LibraryComponents.SvgIcon.Names.CLOSE,
										onClick: _ => {
											BDFDB.ArrayUtils.remove(this.props.items, item);
											BDFDB.ReactUtils.forceUpdate(this);
											this.handleChange.apply(this, []);
										}
									})
								]
							}))
						}), "items"));
					}
				};
				
				InternalComponents.LibraryComponents.PaginatedList = reactInitialized && class BDFDB_PaginatedList extends LibraryModules.React.Component {
					constructor(props) {
						super(props);
						this.state = {
							offset: props.offset
						};
					}
					handleJump(offset) {
						if (offset > -1 && offset < Math.ceil(this.props.items.length/this.props.amount) && this.state.offset != offset) {
							this.state.offset = offset;
							if (typeof this.props.onJump == "function") this.props.onJump(offset, this);
							BDFDB.ReactUtils.forceUpdate(this);
						}
					}
					renderPagination(bottom) {
						let maxOffset = Math.ceil(this.props.items.length/this.props.amount) - 1;
						return this.props.items.length > this.props.amount && BDFDB.ReactUtils.createElement("nav", {
							className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.pagination, bottom ? BDFDB.disCN.paginationbottom : BDFDB.disCN.paginationtop, this.props.mini && BDFDB.disCN.paginationmini),
							children: [
								BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Paginator, {
									totalCount: this.props.items.length,
									currentPage: this.state.offset + 1,
									pageSize: this.props.amount,
									maxVisiblePages: this.props.maxVisiblePages,
									onPageChange: page => {this.handleJump(isNaN(parseInt(page)) ? -1 : page - 1);}
								}),
								this.props.jump && BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TextInput, {
									type: "number",
									size: InternalComponents.LibraryComponents.TextInput.Sizes.MINI,
									value: this.state.offset + 1,
									min: 1,
									max: maxOffset + 1,
									onKeyDown: (event, instance) => {if (event.which == 13) this.handleJump(isNaN(parseInt(instance.props.value)) ? -1 : instance.props.value - 1);}
								}),
							].filter(n => n)
						});
					}
					render() {
						let items = [], alphabet = {};
						if (BDFDB.ArrayUtils.is(this.props.items) && this.props.items.length) {
							if (!this.props.alphabetKey) items = this.props.items;
							else {
								let unsortedItems = [].concat(this.props.items);
								for (let key of ["0-9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]) {
									let numbers = key == "0-9", alphaItems = [];
									for (let item of unsortedItems) if (item && item[this.props.alphabetKey] && (numbers && !isNaN(parseInt(item[this.props.alphabetKey][0])) || item[this.props.alphabetKey].toUpperCase().indexOf(key) == 0)) alphaItems.push(item);
									for (let sortedItem of alphaItems) BDFDB.ArrayUtils.remove(unsortedItems, sortedItem);
									alphabet[key] = {items: BDFDB.ArrayUtils.keySort(alphaItems, this.props.alphabetKey), disabled: !alphaItems.length};
								}
								alphabet["?!"] = {items: BDFDB.ArrayUtils.keySort(unsortedItems, this.props.alphabetKey), disabled: !unsortedItems.length};
								for (let key in alphabet) items.push(alphabet[key].items);
								items = items.flat(10);
							}
						}
						return typeof this.props.renderItem != "function" || !items.length ? null : BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Scrollers.Thin, {
							className: BDFDB.DOMUtils.formatClassName(this.props.className, BDFDB.disCN.paginationlist, this.props.mini && BDFDB.disCN.paginationlistmini),
							fade: this.props.fade,
							children: [
								this.renderPagination(),
								items.length > this.props.amount && this.props.alphabetKey && BDFDB.ReactUtils.createElement("nav", {
									className: BDFDB.disCN.paginationlistalphabet,
									children: Object.keys(alphabet).map(key => BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Clickable, {
										className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.paginationlistalphabetchar, alphabet[key].disabled &&BDFDB.disCN.paginationlistalphabetchardisabled),
										onClick: _ => {if (!alphabet[key].disabled) this.handleJump(Math.floor(items.indexOf(alphabet[key].items[0])/this.props.amount));},
										children: key
									}))
								}),
								this.props.header,
								BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN.paginationlistcontent,
									children: items.slice(this.state.offset * this.props.amount, (this.state.offset + 1) * this.props.amount).map((data, i) => {return this.props.renderItem(data, i);}).flat(10).filter(n => n)
								}),
								this.props.copyToBottom && this.renderPagination(true)
							].flat(10).filter(n => n)
						});
					}
				};
				InternalBDFDB.setDefaultProps(InternalComponents.LibraryComponents.PaginatedList, {amount: 50, offset: 0, mini: true, jump: true, maxVisiblePages: 7, copyToBottom: false, fade: true});
				
				InternalComponents.LibraryComponents.Popout = reactInitialized && class BDFDB_Popout extends LibraryModules.React.Component {
					componentDidMount() {
						this.props.containerInstance.popout = this;
					}
					componentWillUnmount() {
						delete this.props.containerInstance.popout;
						if (typeof this.props.onClose == "function") this.props.onClose(this.props.containerInstance, this);
					}
					render() {
						if (!this.props.wrap) return this.props.children;
						let pos = typeof this.props.position == "string" ? this.props.position.toLowerCase() : null;
						let positionClass = pos && DiscordClasses["popout" + pos] ? BDFDB.disCN["popout" + pos] : BDFDB.disCN.popouttop;
						let arrowClass = !this.props.arrow ? BDFDB.disCN.popoutnoarrow : (pos && pos.indexOf("top") > -1 && pos != "top" ? BDFDB.disCN.popoutarrowalignmenttop : BDFDB.disCN.popoutarrowalignmentmiddle);
						return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.PopoutFocusLock, {
							className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.popoutwrapper, BDFDB.disCN.popout, positionClass, this.props.invert && pos && pos != "bottom" && BDFDB.disCN.popoutinvert, arrowClass, !this.props.shadow && BDFDB.disCN.popoutnoshadow),
							id: this.props.id,
							onClick: e => {e.stopPropagation();},
							style: Object.assign({}, this.props.style, {
								position: this.props.isChild ? "relative" : "absolute"
							}),
							children: BDFDB.ReactUtils.createElement("div", {
								className: BDFDB.DOMUtils.formatClassName(this.props.className, this.props.themed && BDFDB.disCN.popoutthemedpopout),
								style: BDFDB.ObjectUtils.extract(this.props, "padding", "height", "maxHeight", "minHeight", "width", "maxWidth", "minWidth"),
								children: this.props.children
							})
						});
					}
				};
				InternalBDFDB.setDefaultProps(InternalComponents.LibraryComponents.Popout, {themed: true, wrap: true});
				
				InternalComponents.LibraryComponents.PopoutContainer = reactInitialized && class BDFDB_PopoutContainer extends LibraryModules.React.Component {
					componentDidMount() {
						let basePopout = BDFDB.ReactUtils.findOwner(this, {name: "BasePopout"});
						if (!basePopout || !basePopout.handleClick) return;
						this.handleClick = e => basePopout.handleClick(BDFDB.ObjectUtils.is(e) ? e : (new MouseEvent({})));
						this.close = basePopout.close;
						this.domElementRef = basePopout.domElementRef;
					}
					render() {
						let child = (BDFDB.ArrayUtils.is(this.props.children) ? this.props.children[0] : this.props.children) || BDFDB.ReactUtils.createElement("div", {style: {height: "100%", width: "100%"}});
						child.props.className = BDFDB.DOMUtils.formatClassName(child.props.className, this.props.className);
						let childClick = child.props.onClick, childContextMenu = child.props.onContextMenu;
						child.props.onClick = (e, childThis) => {
							if (!this.domElementRef.current || this.domElementRef.current.contains(e.target)) {
								if ((this.props.openOnClick || this.props.openOnClick === undefined) && typeof this.handleClick == "function") this.handleClick(e);
								if (typeof this.props.onClick == "function") this.props.onClick(e, this);
								if (typeof childClick == "function") childClick(e, childThis);
							}
							else e.stopPropagation();
						};
						child.props.onContextMenu = (e, childThis) => {
							if (!this.domElementRef.current || this.domElementRef.current.contains(e.target)) {
								if (this.props.openOnContextMenu && typeof this.handleClick == "function") this.handleClick(e);
								if (typeof this.props.onContextMenu == "function") this.props.onContextMenu(e, this);
								if (typeof childContextMenu == "function") childContextMenu(e, childThis);
							}
							else e.stopPropagation();
						};
						return BDFDB.ReactUtils.createElement(LibraryModules.React.Fragment, {
							children: BDFDB.ReactUtils.createElement(InternalComponents.NativeSubComponents.PopoutContainer, Object.assign({}, this.props, {
								children: _ => child,
								renderPopout: e => {
									const documentClick = event => {
										let node = BDFDB.ReactUtils.findDOMNode(this.popout);
										if (!node || !document.contains(node) || node != event.target && document.contains(event.target) && !node.contains(event.target)) {
											document.removeEventListener("click", documentClick);
											if (node && typeof this.close == "function") this.close();
										}
									};
									document.addEventListener("click", documentClick);
									return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Popout, BDFDB.ObjectUtils.exclude(Object.assign({}, this.props, {
										className: this.props.popoutClassName,
										containerInstance: this,
										isChild: true,
										position: e.position,
										style: this.props.popoutStyle,
										onClose: typeof this.props.onClose == "function" ? this.props.onClose.bind(this) : _ => {},
										children: typeof this.props.renderPopout == "function" ? this.props.renderPopout(this) : null
									}), "popoutStyle", "popoutClassName"));
								}
							}))
						});
					}
				};
				InternalBDFDB.setDefaultProps(InternalComponents.LibraryComponents.PopoutContainer, {wrap: true});
				
				InternalComponents.LibraryComponents.QuickSelect = reactInitialized && class BDFDB_QuickSelect extends LibraryModules.React.Component {
					handleChange(option) {
						this.props.value = option;
						if (typeof this.props.onChange == "function") this.props.onChange(option.value || option.key, this);
						BDFDB.ReactUtils.forceUpdate(this);
					}
					render() {
						let options = (BDFDB.ArrayUtils.is(this.props.options) ? this.props.options : [{}]).filter(n => n);
						let selectedOption = BDFDB.ObjectUtils.is(this.props.value) ? this.props.value : (options[0] || {});
						return BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.DOMUtils.formatClassName(this.props.className, BDFDB.disCN.quickselectwrapper),
							children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex, {
								className: BDFDB.disCN.quickselect,
								align: InternalComponents.LibraryComponents.Flex.Align.CENTER,
								children: [
									BDFDB.ReactUtils.createElement("div", {
										className: BDFDB.disCN.quickselectlabel,
										children: this.props.label
									}),
									BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex, {
										align: InternalComponents.LibraryComponents.Flex.Align.CENTER,
										className: BDFDB.disCN.quickselectclick,
										onClick: event => {
											LibraryModules.ContextMenuUtils.openContextMenu(event, _ => {
												return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Menu, {
													navId: "bdfdb-quickselect",
													onClose: LibraryModules.ContextMenuUtils.closeContextMenu,
													className: this.props.popoutClassName,
													children: BDFDB.ContextMenuUtils.createItem(InternalComponents.LibraryComponents.MenuItems.MenuGroup, {
														children: options.map((option, i) => {
															let selected = option.value && option.value === selectedOption.value || option.key && option.key === selectedOption.key;
															return BDFDB.ContextMenuUtils.createItem(InternalComponents.LibraryComponents.MenuItems.MenuItem, {
																label: option.label,
																id: BDFDB.ContextMenuUtils.createItemId("option", option.key || option.value || i),
																action: selected ? null : event2 => {
																	this.handleChange.bind(this)(option)
																}
															});
														})
													})
												});
											});
										},
										children: [
											BDFDB.ReactUtils.createElement("div", {
												className: BDFDB.disCN.quickselectvalue,
												children: typeof this.props.renderValue == "function" ? this.props.renderValue(this.props.value) : this.props.value.label
											}),
											BDFDB.ReactUtils.createElement("div", {
												className: BDFDB.disCN.quickselectarrow
											})
										]
									})
								]
							})
						});
					}
				};
				
				InternalComponents.LibraryComponents.RadioGroup = reactInitialized && class BDFDB_RadioGroup extends LibraryModules.React.Component {
					handleChange(value) {
						this.props.value = value.value;
						if (typeof this.props.onChange == "function") this.props.onChange(value, this);
						BDFDB.ReactUtils.forceUpdate(this);
					}
					render() {
						return BDFDB.ReactUtils.createElement(InternalComponents.NativeSubComponents.RadioGroup, Object.assign({}, this.props, {
							onChange: this.handleChange.bind(this)
						}));
					}
				};
				
				InternalComponents.LibraryComponents.SearchBar = reactInitialized && class BDFDB_SearchBar extends LibraryModules.React.Component {
					handleChange(query) {
						this.props.query = query;
						if (typeof this.props.onChange == "function") this.props.onChange(query, this);
						BDFDB.ReactUtils.forceUpdate(this);
					}
					handleClear() {
						this.props.query = "";
						if (this.props.changeOnClear && typeof this.props.onChange == "function") this.props.onChange("", this);
						if (typeof this.props.onClear == "function") this.props.onClear(this);
						BDFDB.ReactUtils.forceUpdate(this);
					}
					render() {
						let props = Object.assign({}, this.props, {
							onChange: this.handleChange.bind(this),
							onClear: this.handleClear.bind(this)
						});
						if (typeof props.query != "string") props.query = "";
						return BDFDB.ReactUtils.createElement(InternalComponents.NativeSubComponents.SearchBar, props);
					}
				};
				
				InternalComponents.LibraryComponents.Select = reactInitialized && class BDFDB_Select extends LibraryModules.React.Component {
					handleChange(value) {
						this.props.value = value.value || value;
						if (typeof this.props.onChange == "function") this.props.onChange(value, this);
						BDFDB.ReactUtils.forceUpdate(this);
					}
					render() {
						return BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.DOMUtils.formatClassName(this.props.className, BDFDB.disCN.selectwrapper),
							children: BDFDB.ReactUtils.createElement(InternalComponents.NativeSubComponents.SearchableSelect, BDFDB.ObjectUtils.exclude(Object.assign({}, this.props, {
								className: this.props.inputClassName,
								autoFocus: this.props.autoFocus ? this.props.autoFocus : false,
								maxVisibleItems: this.props.maxVisibleItems || 7,
								renderOptionLabel: this.props.optionRenderer,
								onChange: this.handleChange.bind(this)
							}), "inputClassName", "optionRenderer"))
						});
					}
				};
				
				InternalComponents.LibraryComponents.SettingsGuildList = reactInitialized && class BDFDB_SettingsGuildList extends LibraryModules.React.Component {
					render() {
						this.props.disabled = BDFDB.ArrayUtils.is(this.props.disabled) ? this.props.disabled : [];
						return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex, {
							className: this.props.className,
							wrap: InternalComponents.LibraryComponents.Flex.Wrap.WRAP,
							children: [this.props.includeDMs && {name: BDFDB.LanguageUtils.LanguageStrings.DIRECT_MESSAGES, acronym: "DMs", id: BDFDB.DiscordConstants.ME, getIconURL: _ => {}}].concat(LibraryModules.FolderStore.getFlattenedGuilds()).filter(n => n).map(guild => BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TooltipContainer, {
								text: guild.name,
								children: BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.DOMUtils.formatClassName(this.props.guildClassName, BDFDB.disCN.settingsguild, this.props.disabled.includes(guild.id) && BDFDB.disCN.settingsguilddisabled),
									children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.GuildComponents.Icon, {
										guild: guild,
										size: this.props.size || InternalComponents.LibraryComponents.GuildComponents.Icon.Sizes.MEDIUM
									}),
									onClick: e => {
										let isDisabled = this.props.disabled.includes(guild.id);
										if (isDisabled) BDFDB.ArrayUtils.remove(this.props.disabled, guild.id, true);
										else this.props.disabled.push(guild.id);
										if (typeof this.props.onClick == "function") this.props.onClick(this.props.disabled, this);
										BDFDB.ReactUtils.forceUpdate(this);
									}
								})
							}))
						});
					}
				};
				
				InternalComponents.LibraryComponents.SettingsPanel = reactInitialized && class BDFDB_SettingsPanel extends LibraryModules.React.Component {
					componentDidMount() {
						this.props._instance = this;
						let node = BDFDB.ReactUtils.findDOMNode(this);
						if (node) this.props._node = node;
					}
					componentWillUnmount() {
						if (BDFDB.ObjectUtils.is(this.props.addon) && typeof this.props.addon.onSettingsClosed == "function") this.props.addon.onSettingsClosed();
					}
					render() {						
						let panelItems = [
							BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.AutoFocusCatcher, {}),
							typeof this.props.children == "function" ? (_ => {
								return this.props.children(this.props.collapseStates);
							})() : this.props.children
						].flat(10).filter(n => n);
						
						return BDFDB.ReactUtils.createElement("div", {
							key: this.props.addon && this.props.addon.name && `${this.props.addon.name}-settingsPanel`,
							id: this.props.addon && this.props.addon.name && `${this.props.addon.name}-settings`,
							className: BDFDB.disCN.settingspanel,
							children: panelItems
						});
					}
				};
				
				InternalComponents.LibraryComponents.SettingsPanelList = InternalComponents.LibraryComponents.SettingsPanelInner = reactInitialized && class BDFDB_SettingsPanelInner extends LibraryModules.React.Component {
					render() {
						return this.props.children ? BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.DOMUtils.formatClassName(this.props.className, BDFDB.disCN.settingspanellistwrapper, this.props.mini && BDFDB.disCN.settingspanellistwrappermini),
							children: [
								this.props.dividerTop ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.FormComponents.FormDivider, {
									className: this.props.mini ? BDFDB.disCN.marginbottom4 : BDFDB.disCN.marginbottom8
								}) : null,
								typeof this.props.title == "string" ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.FormComponents.FormTitle, {
									className: BDFDB.disCN.marginbottom4,
									tag: InternalComponents.LibraryComponents.FormComponents.FormTitle.Tags.H3,
									children: this.props.title
								}) : null,
								BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN.settingspanellist,
									children: this.props.children
								}),
								this.props.dividerBottom ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.FormComponents.FormDivider, {
									className: this.props.mini ? BDFDB.disCN.margintop4 : BDFDB.disCN.margintop8
								}) : null
							]
						}) : null;
					}
				};
				
				InternalComponents.LibraryComponents.SettingsItem = reactInitialized && class BDFDB_SettingsItem extends LibraryModules.React.Component {
					handleChange(value) {
						if (typeof this.props.onChange == "function") this.props.onChange(value, this);
					}
					render() {
						if (typeof this.props.type != "string" || !["BUTTON", "SELECT", "SLIDER", "SWITCH", "TEXTINPUT"].includes(this.props.type.toUpperCase())) return null;
						let childComponent = InternalComponents.LibraryComponents[this.props.type];
						if (!childComponent) return null;
						if (this.props.mini && childComponent.Sizes) this.props.size = childComponent.Sizes.MINI || childComponent.Sizes.MIN;
						let label = this.props.label ? (this.props.tag ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.FormComponents.FormTitle, {
							className: BDFDB.DOMUtils.formatClassName(this.props.labelClassName, BDFDB.disCN.marginreset),
							tag: this.props.tag,
							children: this.props.label
						}) : BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SettingsLabel, {
							className: BDFDB.DOMUtils.formatClassName(this.props.labelClassName),
							mini: this.props.mini,
							label: this.props.label
						})) : null;
						let margin = this.props.margin != null ? this.props.margin : (this.props.mini ? 0 : 8);
						return BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.DOMUtils.formatClassName(this.props.className, BDFDB.disCN.settingsrow, BDFDB.disCN.settingsrowcontainer, this.props.disabled && BDFDB.disCN.settingsrowdisabled, margin != null && (BDFDB.DiscordClasses[`marginbottom${margin}`] && BDFDB.disCN[`marginbottom${margin}`] || margin == 0 && BDFDB.disCN.marginreset)),
							id: this.props.id,
							children: [
								this.props.dividerTop ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.FormComponents.FormDivider, {
									className: this.props.mini ? BDFDB.disCN.marginbottom4 : BDFDB.disCN.marginbottom8
								}) : null,
								BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN.settingsrowlabel,
									children: [
										label && !this.props.basis ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex.Child, {
											grow: 1,
											shrink: 1,
											wrap: true,
											children: label
										}) : label,
										this.props.labelChildren,
										BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex.Child, {
											className: BDFDB.disCNS.settingsrowcontrol + BDFDB.disCN.flexchild,
											grow: 0,
											shrink: this.props.basis ? 0 : 1,
											basis: this.props.basis,
											wrap: true,
											children: BDFDB.ReactUtils.createElement(childComponent, BDFDB.ObjectUtils.exclude(Object.assign(BDFDB.ObjectUtils.exclude(this.props, "className", "id", "type"), this.props.childProps, {
												onChange: this.handleChange.bind(this),
												onValueChange: this.handleChange.bind(this)
											}), "basis", "margin", "dividerBottom", "dividerTop", "label", "labelClassName", "labelChildren", "tag", "mini", "note", "childProps"))
										})
									].flat(10).filter(n => n)
								}),
								typeof this.props.note == "string" ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex.Child, {
									className: BDFDB.disCN.settingsrownote,
									children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.FormComponents.FormText, {
										disabled: this.props.disabled,
										type: InternalComponents.LibraryComponents.FormComponents.FormText.Types.DESCRIPTION,
										children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TextScroller, {speed: 2, children: this.props.note})
									})
								}) : null,
								this.props.dividerBottom ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.FormComponents.FormDivider, {
									className: this.props.mini ? BDFDB.disCN.margintop4 : BDFDB.disCN.margintop8
								}) : null
							]
						});
					}
				};
				
				InternalComponents.LibraryComponents.SettingsLabel = reactInitialized && class BDFDB_SettingsLabel extends LibraryModules.React.Component {
					render() {
						return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TextScroller, {
							className: BDFDB.DOMUtils.formatClassName(this.props.className, BDFDB.disCN.settingsrowtitle, this.props.mini ? BDFDB.disCN.settingsrowtitlemini : BDFDB.disCN.settingsrowtitledefault, BDFDB.disCN.cursordefault),
							speed: 2,
							children: this.props.label
						});
					}	
				};
				
				InternalComponents.LibraryComponents.SettingsList = reactInitialized && class BDFDB_SettingsList extends LibraryModules.React.Component {
					componentDidMount() {
						this.checkList();
					}
					componentDidUpdate() {
						this.checkList();
					}
					checkList() {
						let list = BDFDB.ReactUtils.findDOMNode(this);
						if (list && !this.props.configWidth) {
							let headers = Array.from(list.querySelectorAll(BDFDB.dotCN.settingstableheader));
							headers.shift();
							if (BDFDB.DOMUtils.getRects(headers[0]).width == 0) BDFDB.TimeUtils.timeout(_ => {this.resizeList(headers);});
							else this.resizeList(headers);
						}
					}
					resizeList(headers) {
						let configWidth = 0, biggestWidth = 0;
						if (!configWidth) {
							for (let header of headers) {
								header.style = "";
								let width = BDFDB.DOMUtils.getRects(header).width;
								configWidth = width > configWidth ? width : configWidth;
							}
							configWidth += 4;
							biggestWidth = configWidth;
						}
						if (headers.length * configWidth > 300) {
							this.props.vertical = true;
							configWidth = parseInt(290 / headers.length);
						}
						else if (configWidth < 36) {
							configWidth = 36;
							biggestWidth = configWidth;
						}
						this.props.configWidth = configWidth;
						this.props.biggestWidth = biggestWidth;
						BDFDB.ReactUtils.forceUpdate(this);
					}
					renderHeaderOption(props) {
						return BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.DOMUtils.formatClassName(props.className, BDFDB.disCN.colorbase, BDFDB.disCN.size10, props.clickable && BDFDB.disCN.cursorpointer),
							onClick: _ => {if (typeof this.props.onHeaderClick == "function") this.props.onHeaderClick(props.label, this);},
							onContextMenu: _ => {if (typeof this.props.onHeaderContextMenu == "function") this.props.onHeaderContextMenu(props.label, this);},
							children: BDFDB.ReactUtils.createElement("span", {
								children: props.label
							})
						});
					}
					renderItem(props) {
						return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Card, BDFDB.ObjectUtils.exclude(Object.assign({}, this.props, {
							className: BDFDB.DOMUtils.formatClassName([this.props.cardClassName, props.className].filter(n => n).join(" ").indexOf(BDFDB.disCN.card) == -1 && BDFDB.disCN.cardprimaryoutline, BDFDB.disCN.settingstablecard, this.props.cardClassName, props.className),
							cardId: props.key,
							backdrop: false,
							horizontal: true,
							style: Object.assign({}, this.props.cardStyle, props.style),
							children: [
								BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN.settingstablecardlabel,
									children: this.props.renderLabel(props)
								}),
								BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN.settingstablecardconfigs,
									style: {
										width: props.wrapperWidth || null,
										minWidth: props.wrapperWidth || null,
										maxWidth: props.wrapperWidth || null
									},
									children: this.props.settings.map(setting => BDFDB.ReactUtils.createElement("div", {
										className: BDFDB.disCN.checkboxcontainer,
										children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Checkbox, {
											disabled: props.disabled,
											cardId: props.key,
											settingId: setting,
											shape: InternalComponents.LibraryComponents.Checkbox.Shapes.ROUND,
											type: InternalComponents.LibraryComponents.Checkbox.Types.INVERTED,
											color: this.props.checkboxColor,
											getColor: this.props.getCheckboxColor,
											value: props[setting],
											getValue: this.props.getCheckboxValue,
											onChange: this.props.onCheckboxChange
										})
									})).flat(10).filter(n => n)
								})
							]
						}), "title", "data", "settings", "renderLabel", "cardClassName", "cardStyle", "checkboxColor", "getCheckboxColor",  "getCheckboxValue", "onCheckboxChange", "configWidth", "biggestWidth", "pagination"));
					}
					render() {
						this.props.settings = BDFDB.ArrayUtils.is(this.props.settings) ? this.props.settings : [];
						this.props.renderLabel = typeof this.props.renderLabel == "function" ? this.props.renderLabel : data => data.label;
						this.props.data = (BDFDB.ArrayUtils.is(this.props.data) ? this.props.data : [{}]).filter(n => n);
						
						let wrapperWidth = this.props.configWidth && this.props.configWidth * this.props.settings.length;
						let isHeaderClickable = typeof this.props.onHeaderClick == "function" || typeof this.props.onHeaderContextMenu == "function";
						let usePagination = BDFDB.ObjectUtils.is(this.props.pagination);
						
						let header = BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.disCN.settingstableheaders,
							style: this.props.vertical && this.props.biggestWidth ? {
								marginTop: this.props.biggestWidth - 15 || 0
							} : {},
							children: [
								this.renderHeaderOption({
									className: BDFDB.disCN.settingstableheadername,
									clickable: this.props.title && isHeaderClickable,
									label: this.props.title || ""
								}),
								BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN.settingstableheaderoptions,
									style: {
										width: wrapperWidth || null,
										minWidth: wrapperWidth || null,
										maxWidth: wrapperWidth || null
									},
									children: this.props.settings.map(setting => this.renderHeaderOption({
										className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.settingstableheaderoption, this.props.vertical && BDFDB.disCN.settingstableheadervertical),
										clickable: isHeaderClickable,
										label: setting
									}))
								})
							]
						});
						return !this.props.data.length ? null : BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.settingstablelist, this.props.className),
							children: [
								!usePagination && header,
								!usePagination ? this.props.data.map(data => this.renderItem(Object.assign({}, data, {wrapperWidth}))) : BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.PaginatedList, Object.assign({}, this.props.pagination, {
									header: header,
									items: this.props.data,
									renderItem: data => this.renderItem(Object.assign({}, data, {wrapperWidth})),
									onJump: (offset, instance) => {
										this.props.pagination.offset = offset;
										if (typeof this.props.pagination.onJump == "function") this.props.pagination.onJump(offset, this, instance);
									}
								}))
							].filter(n => n)
						});
					}
				};
				
				InternalComponents.LibraryComponents.SettingsSaveItem = reactInitialized && class BDFDB_SettingsSaveItem extends LibraryModules.React.Component {
					saveSettings(value) {
						if (!BDFDB.ArrayUtils.is(this.props.keys) || !BDFDB.ObjectUtils.is(this.props.plugin)) return;
						let keys = this.props.keys.filter(n => n);
						let option = keys.shift();
						if (BDFDB.ObjectUtils.is(this.props.plugin) && option) {
							let data = BDFDB.DataUtils.load(this.props.plugin, option);
							let newC = "";
							for (let key of keys) newC += `{"${key}":`;
							value = value != null && value.value != null ? value.value : value;
							let isString = typeof value == "string";
							let marker = isString ? `"` : ``;
							newC += (marker + (isString ? value.replace(/\\/g, "\\\\") : value) + marker) + "}".repeat(keys.length);
							newC = JSON.parse(newC);
							newC = BDFDB.ObjectUtils.is(newC) ? BDFDB.ObjectUtils.deepAssign({}, data, newC) : newC;
							BDFDB.DataUtils.save(newC, this.props.plugin, option);
							if (!this.props.plugin.settings) this.props.plugin.settings = {};
							this.props.plugin.settings[option] = newC;
							this.props.plugin.SettingsUpdated = true;
						}
						if (typeof this.props.onChange == "function") this.props.onChange(value, this);
					}
					render() {
						if (typeof this.props.type != "string" || !["SELECT", "SLIDER", "SWITCH", "TEXTINPUT"].includes(this.props.type.toUpperCase())) return null;
						return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SettingsItem, BDFDB.ObjectUtils.exclude(Object.assign({}, this.props, {
							onChange: this.saveSettings.bind(this)
						}), "keys", "key", "plugin"));
					}
				};
				
				InternalComponents.LibraryComponents.SidebarList = reactInitialized && class BDFDB_SidebarList extends LibraryModules.React.Component {
					handleItemSelect(item) {
						this.props.selectedItem = item;
						if (typeof this.props.onItemSelect == "function") this.props.onItemSelect(item, this);
						BDFDB.ReactUtils.forceUpdate(this);
					}
					render() {
						let items = (BDFDB.ArrayUtils.is(this.props.items) ? this.props.items : [{}]).filter(n => n);
						let selectedItem = this.props.selectedItem || (items[0] || {}).value;
						let selectedElements = (items.find(n => n.value == selectedItem) || {}).elements;
						let renderElement = typeof this.props.renderElement == "function" ? this.props.renderElement : (_ => {});
						return BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.DOMUtils.formatClassName(this.props.className, BDFDB.disCN.sidebarlist),
							children: [
								BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Scrollers.Thin, {
									className: BDFDB.DOMUtils.formatClassName(this.props.sidebarClassName, BDFDB.disCN.sidebar),
									fade: true,
									children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TabBar, {
										itemClassName: this.props.itemClassName,
										type: InternalComponents.LibraryComponents.TabBar.Types.SIDE,
										items: items,
										selectedItem: selectedItem,
										renderItem: this.props.renderItem,
										onItemSelect: this.handleItemSelect.bind(this)
									})
								}),
								BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Scrollers.Thin, {
									className: BDFDB.DOMUtils.formatClassName(this.props.contentClassName, BDFDB.disCN.sidebarcontent),
									fade: true,
									children: [selectedElements].flat(10).filter(n => n).map(data => renderElement(data))
								})
							]
						});
					}
				};
				
				InternalComponents.LibraryComponents.Slider = reactInitialized && class BDFDB_Slider extends LibraryModules.React.Component {
					handleMarkerRender(marker) {
						let newMarker = BDFDB.NumberUtils.mapRange([0, 100], this.props.edges, marker);
						if (typeof this.props.digits == "number") newMarker = Math.round(newMarker * Math.pow(10, this.props.digits)) / Math.pow(10, this.props.digits);
						return newMarker;
					}
					handleValueChange(value) {
						let newValue = BDFDB.NumberUtils.mapRange([0, 100], this.props.edges, value);
						if (typeof this.props.digits == "number") newValue = Math.round(newValue * Math.pow(10, this.props.digits)) / Math.pow(10, this.props.digits);
						this.props.defaultValue = this.props.value = newValue;
						if (typeof this.props.onValueChange == "function") this.props.onValueChange(newValue, this);
						BDFDB.ReactUtils.forceUpdate(this);
					}
					handleValueRender(value) {
						let newValue = BDFDB.NumberUtils.mapRange([0, 100], this.props.edges, value);
						if (typeof this.props.digits == "number") newValue = Math.round(newValue * Math.pow(10, this.props.digits)) / Math.pow(10, this.props.digits);
						if (typeof this.props.onValueRender == "function") {
							let tempReturn = this.props.onValueRender(newValue, this);
							if (tempReturn != undefined) newValue = tempReturn;
						}
						return newValue;
					}
					render() {
						let value = this.props.value || this.props.defaultValue || 0;
						if (!BDFDB.ArrayUtils.is(this.props.edges) || this.props.edges.length != 2) this.props.edges = [this.props.min || this.props.minValue || 0, this.props.max || this.props.maxValue || 100];
						this.props.minValue = 0;
						this.props.maxValue = 100;
						let defaultValue = BDFDB.NumberUtils.mapRange(this.props.edges, [0, 100], value);
						if (typeof this.props.digits == "number") defaultValue = Math.round(defaultValue * Math.pow(10, this.props.digits)) / Math.pow(10, this.props.digits);
						return BDFDB.ReactUtils.createElement(InternalComponents.NativeSubComponents.Slider, BDFDB.ObjectUtils.exclude(Object.assign({}, this.props, {
							initialValue: defaultValue,
							markers: typeof this.props.markerAmount == "number" ? Array.from(Array(this.props.markerAmount).keys()).map((_, i) => i * (this.props.maxValue - this.props.minValue)/10) : undefined,
							onMarkerRender: this.handleMarkerRender.bind(this),
							onValueChange: this.handleValueChange.bind(this),
							onValueRender: this.handleValueRender.bind(this)
						}), "digits", "edges", "max", "min", "markerAmount"));
					}
				};
				InternalBDFDB.setDefaultProps(InternalComponents.LibraryComponents.Slider, {hideBubble: false});
				
				InternalComponents.LibraryComponents.SvgIcon = reactInitialized && class BDFDB_Icon extends LibraryModules.React.Component {
					render() {
						if (BDFDB.ObjectUtils.is(this.props.name)) {
							let calcClassName = [];
							if (BDFDB.ObjectUtils.is(this.props.name.getClassName)) for (let path in this.props.name.getClassName) {
								if (!path || BDFDB.ObjectUtils.get(this, path)) calcClassName.push(BDFDB.disCN[this.props.name.getClassName[path]]);
							}
							if (calcClassName.length || this.props.className) this.props.nativeClass = true;
							this.props.iconSVG = this.props.name.icon;
							let props = Object.assign({
								width: 24,
								height: 24,
								color: "currentColor"
							}, this.props.name.defaultProps, this.props, {
								className: BDFDB.DOMUtils.formatClassName(calcClassName, this.props.className)
							});
							for (let key in props) this.props.iconSVG = this.props.iconSVG.replace(new RegExp(`%%${key}`, "g"), props[key]);
						}
						if (this.props.iconSVG) {
							let icon = BDFDB.ReactUtils.elementToReact(BDFDB.DOMUtils.create(this.props.iconSVG));
							if (BDFDB.ReactUtils.isValidElement(icon)) {
								icon.props.className = BDFDB.DOMUtils.formatClassName(!this.props.nativeClass && BDFDB.disCN.svgicon, icon.props.className, this.props.className);
								icon.props.style = Object.assign({}, icon.props.style, this.props.style);
								icon.props = Object.assign({}, BDFDB.ObjectUtils.extract(this.props, "onClick", "onContextMenu", "onMouseDown", "onMouseUp", "onMouseEnter", "onMouseLeave"), icon.props);
								return icon;
							}
						}
						return null;
					}
				};
				InternalComponents.LibraryComponents.SvgIcon.Names = InternalData.SvgIcons || {};
				
				const SwitchIconPaths = {
					a: {
						TOP: "M5.13231 6.72963L6.7233 5.13864L14.855 13.2704L13.264 14.8614L5.13231 6.72963Z",
						BOTTOM: "M13.2704 5.13864L14.8614 6.72963L6.72963 14.8614L5.13864 13.2704L13.2704 5.13864Z"
					},
					b: {
						TOP: "M6.56666 11.0013L6.56666 8.96683L13.5667 8.96683L13.5667 11.0013L6.56666 11.0013Z",
						BOTTOM: "M13.5582 8.96683L13.5582 11.0013L6.56192 11.0013L6.56192 8.96683L13.5582 8.96683Z"
					},
					c: {
						TOP: "M7.89561 14.8538L6.30462 13.2629L14.3099 5.25755L15.9009 6.84854L7.89561 14.8538Z",
						BOTTOM: "M4.08643 11.0903L5.67742 9.49929L9.4485 13.2704L7.85751 14.8614L4.08643 11.0903Z"
					}
				};
				const SwitchInner = function (props) {
					let reducedMotion = BDFDB.ReactUtils.useContext(LibraryModules.PreferencesContext.AccessibilityPreferencesContext).reducedMotion;
					let ref = BDFDB.ReactUtils.useRef(null);
					let state = BDFDB.ReactUtils.useState(false);
					let animation = InternalComponents.LibraryComponents.Animations.useSpring({
						config: {
							mass: 1,
							tension: 250
						},
						opacity: props.disabled ? .3 : 1,
						state: state[0] ? (props.value ? .7 : .3) : (props.value ? 1 : 0)
					});
					let fill = animation.state.to({
						output: [props.uncheckedColor, props.checkedColor]
					});
					let mini = props.size == InternalComponents.LibraryComponents.Switch.Sizes.MINI;
					
					return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Animations.animated.div, {
						className: BDFDB.DOMUtils.formatClassName(props.className, BDFDB.disCN.switch, mini && BDFDB.disCN.switchmini),
						onMouseDown: _ => {
							return !props.disabled && state[1](true);
						},
						onMouseUp: _ => {
							return state[1](false);
						},
						onMouseLeave: _ => {
							return state[1](false);
						},
						style: {
							opacity: animation.opacity,
							backgroundColor: animation.state.to({
								output: [props.uncheckedColor, props.checkedColor]
							})
						},
						tabIndex: -1,
						children: [
							BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Animations.animated.svg, {
								className: BDFDB.disCN.switchslider,
								viewBox: "0 0 28 20",
								preserveAspectRatio: "xMinYMid meet",
								style: {
									left: animation.state.to({
										range: [0, .3, .7, 1],
										output: mini ? [-1, 2, 6, 9] : [-3, 1, 8, 12]
									})
								},
								children: [
									BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Animations.animated.rect, {
										fill: "white",
										x: animation.state.to({
											range: [0, .3, .7, 1],
											output: [4, 0, 0, 4]
										}),
										y: animation.state.to({
											range: [0, .3, .7, 1],
											output: [0, 1, 1, 0]
										}),
										height: animation.state.to({
											range: [0, .3, .7, 1],
											output: [20, 18, 18, 20]
										}),
										width: animation.state.to({
											range: [0, .3, .7, 1],
											output: [20, 28, 28, 20]
										}),
										rx: "10"
									}),
									BDFDB.ReactUtils.createElement("svg", {
										viewBox: "0 0 20 20",
										fill: "none",
										children: [
											BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Animations.animated.path, {
												fill: fill,
												d: animation.state.to({
													range: [0, .3, .7, 1],
													output: reducedMotion.enabled ? [SwitchIconPaths.a.TOP, SwitchIconPaths.a.TOP, SwitchIconPaths.c.TOP, SwitchIconPaths.c.TOP] : [SwitchIconPaths.a.TOP, SwitchIconPaths.b.TOP, SwitchIconPaths.b.TOP, SwitchIconPaths.c.TOP]
												})
											}),
											BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Animations.animated.path, {
												fill: fill,
												d: animation.state.to({
													range: [0, .3, .7, 1],
													output: reducedMotion.enabled ? [SwitchIconPaths.a.BOTTOM, SwitchIconPaths.a.BOTTOM, SwitchIconPaths.c.BOTTOM, SwitchIconPaths.c.BOTTOM] : [SwitchIconPaths.a.BOTTOM, SwitchIconPaths.b.BOTTOM, SwitchIconPaths.b.BOTTOM, SwitchIconPaths.c.BOTTOM]
												})
											})
										]
									})
								]
							}),
							BDFDB.ReactUtils.createElement("input", BDFDB.ObjectUtils.exclude(Object.assign({}, props, {
								id: props.id,
								type: "checkbox",
								ref: ref,
								className: BDFDB.DOMUtils.formatClassName(props.inputClassName, BDFDB.disCN.switchinner),
								tabIndex: props.disabled ? -1 : 0,
								onKeyDown: e => {
									if (!props.disabled && !e.repeat && (e.key == " " || e.key == "Enter")) state[1](true);
								},
								onKeyUp: e => {
									if (!props.disabled && !e.repeat) {
										state[1](false);
										if (e.key == "Enter" && ref.current) ref.current.click();
									}
								},
								onChange: e => {
									state[1](false);
									if (typeof props.onChange == "function") props.onChange(e.currentTarget.checked, e);
								},
								checked: props.value,
								disabled: props.disabled
							}), "uncheckedColor", "checkedColor", "size", "value"))
						]
					});
				};
				InternalComponents.LibraryComponents.Switch = reactInitialized && class BDFDB_Switch extends LibraryModules.React.Component {
					handleChange() {
						this.props.value = !this.props.value;
						if (typeof this.props.onChange == "function") this.props.onChange(this.props.value, this);
						BDFDB.ReactUtils.forceUpdate(this);
					}
					render() {
						return BDFDB.ReactUtils.createElement(SwitchInner, Object.assign({}, this.props, {
							onChange: this.handleChange.bind(this)
						}));
					}
				};
				InternalComponents.LibraryComponents.Switch.Sizes = {
					DEFAULT: "default",
					MINI: "mini",
				};
				InternalBDFDB.setDefaultProps(InternalComponents.LibraryComponents.Switch, {
					size: InternalComponents.LibraryComponents.Switch.Sizes.DEFAULT,
					uncheckedColor: BDFDB.DiscordConstants.Colors.PRIMARY_DARK_400,
					checkedColor: BDFDB.DiscordConstants.Colors.BRAND
				});
				
				InternalComponents.LibraryComponents.TabBar = reactInitialized && class BDFDB_TabBar extends LibraryModules.React.Component {
					handleItemSelect(item) {
						this.props.selectedItem = item;
						if (typeof this.props.onItemSelect == "function") this.props.onItemSelect(item, this);
						BDFDB.ReactUtils.forceUpdate(this);
					}
					render() {
						let items = (BDFDB.ArrayUtils.is(this.props.items) ? this.props.items : [{}]).filter(n => n);
						let selectedItem = this.props.selectedItem || (items[0] || {}).value;
						let renderItem = typeof this.props.renderItem == "function" ? this.props.renderItem : (data => data.label || data.value);
						return BDFDB.ReactUtils.createElement(InternalComponents.NativeSubComponents.TabBar, BDFDB.ObjectUtils.exclude(Object.assign({}, this.props, {
							selectedItem: selectedItem,
							onItemSelect: this.handleItemSelect.bind(this),
							children: items.map(data => BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TabBar.Item, {
								className: BDFDB.DOMUtils.formatClassName(this.props.itemClassName, selectedItem == data.value && this.props.itemSelectedClassName),
								itemType: this.props.type,
								id: data.value,
								children: renderItem(data),
								"aria-label": data.label || data.value
							}))
						}), "itemClassName", "items", "renderItem"));
					}
				};
				
				InternalComponents.LibraryComponents.Table = reactInitialized && class BDFDB_Table extends LibraryModules.React.Component {
					render() {
						return BDFDB.ReactUtils.createElement(InternalComponents.NativeSubComponents.Table, Object.assign({}, this.props, {
							className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.table, this.props.className),
							headerCellClassName: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.tableheadercell, this.props.headerCellClassName),
							sortedHeaderCellClassName: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.tableheadercellsorted, this.props.sortedHeaderCellClassName),
							bodyCellClassName: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.tablebodycell, this.props.bodyCellClassName),
							onSort: (sortKey, sortDirection) => {
								this.props.sortDirection = this.props.sortKey != sortKey && sortDirection == InternalComponents.LibraryComponents.Table.SortDirection.ASCENDING && this.props.columns.filter(n => n.key == sortKey)[0].reverse ? InternalComponents.LibraryComponents.Table.SortDirection.DESCENDING : sortDirection;
								this.props.sortKey = sortKey;
								this.props.data = BDFDB.ArrayUtils.keySort(this.props.data, this.props.sortKey);
								if (this.props.sortDirection == InternalComponents.LibraryComponents.Table.SortDirection.DESCENDING) this.props.data.reverse();
								if (typeof this.props.onSort == "function") this.props.onSort(this.props.sortKey, this.props.sortDirection);
								BDFDB.ReactUtils.forceUpdate(this);
							}
						}));
					}
				};
				
				InternalComponents.LibraryComponents.TextArea = reactInitialized && class BDFDB_TextArea extends LibraryModules.React.Component {
					handleChange(e) {
						this.props.value = e;
						if (typeof this.props.onChange == "function") this.props.onChange(e, this);
						BDFDB.ReactUtils.forceUpdate(this);
					}
					handleBlur(e) {if (typeof this.props.onBlur == "function") this.props.onBlur(e, this);}
					handleFocus(e) {if (typeof this.props.onFocus == "function") this.props.onFocus(e, this);}
					render() {
						return BDFDB.ReactUtils.createElement(InternalComponents.NativeSubComponents.TextArea, Object.assign({}, this.props, {
							onChange: this.handleChange.bind(this),
							onBlur: this.handleBlur.bind(this),
							onFocus: this.handleFocus.bind(this)
						}));
					}
				};
				
				InternalComponents.LibraryComponents.TextGradientElement = reactInitialized && class BDFDB_TextGradientElement extends LibraryModules.React.Component {
					render() {
						if (this.props.gradient && this.props.children) return BDFDB.ReactUtils.createElement("span", {
							children: this.props.children,
							ref: instance => {
								let ele = BDFDB.ReactUtils.findDOMNode(instance);
								if (ele) {
									ele.style.setProperty("background-image", this.props.gradient, "important");
									ele.style.setProperty("color", "transparent", "important");
									ele.style.setProperty("-webkit-background-clip", "text", "important");
								}
							}
						});
						return this.props.children || null;
					}
				};
				
				InternalComponents.LibraryComponents.TextInput = reactInitialized && class BDFDB_TextInput extends LibraryModules.React.Component {
					handleChange(e) {
						let value = e = BDFDB.ObjectUtils.is(e) ? e.currentTarget.value : e;
						this.props.value = this.props.valuePrefix && !value.startsWith(this.props.valuePrefix) ? (this.props.valuePrefix + value) : value;
						if (typeof this.props.onChange == "function") this.props.onChange(this.props.value, this);
						BDFDB.ReactUtils.forceUpdate(this);
					}
					handleInput(e) {if (typeof this.props.onInput == "function") this.props.onInput(BDFDB.ObjectUtils.is(e) ? e.currentTarget.value : e, this);}
					handleKeyDown(e) {if (typeof this.props.onKeyDown == "function") this.props.onKeyDown(e, this);}
					handleBlur(e) {if (typeof this.props.onBlur == "function") this.props.onBlur(e, this);}
					handleFocus(e) {if (typeof this.props.onFocus == "function") this.props.onFocus(e, this);}
					handleMouseEnter(e) {if (typeof this.props.onMouseEnter == "function") this.props.onMouseEnter(e, this);}
					handleMouseLeave(e) {if (typeof this.props.onMouseLeave == "function") this.props.onMouseLeave(e, this);}
					handleNumberButton(ins, value) {
						BDFDB.TimeUtils.clear(ins.pressedTimeout);
						ins.pressedTimeout = BDFDB.TimeUtils.timeout(_ => {
							delete this.props.focused;
							BDFDB.ReactUtils.forceUpdate(this);
						}, 1000);
						this.props.focused = true;
						this.handleChange.bind(this)(value);
						this.handleInput.bind(this)(value);
					}
					componentDidMount() {
						if (this.props.type == "file") {
							let navigatorInstance = BDFDB.ReactUtils.findOwner(this, {name: "BDFDB_FileButton"});
							if (navigatorInstance) navigatorInstance.refInput = this;
						}
						let input = BDFDB.ReactUtils.findDOMNode(this);
						if (!input) return;
						input = input.querySelector("input") || input;
						if (input && !input.patched) {
							input.addEventListener("keydown", e => {
								this.handleKeyDown.bind(this)(e);
								e.stopImmediatePropagation();
							});
							input.patched = true;
						}
					}
					render() {
						let inputChildren = [
							BDFDB.ReactUtils.createElement("input", BDFDB.ObjectUtils.exclude(Object.assign({}, this.props, {
								className: BDFDB.DOMUtils.formatClassName(this.props.size && InternalComponents.LibraryComponents.TextInput.Sizes[this.props.size.toUpperCase()] && BDFDB.disCN["input" + this.props.size.toLowerCase()] || BDFDB.disCN.inputdefault, this.props.inputClassName, this.props.focused && BDFDB.disCN.inputfocused, this.props.error || this.props.errorMessage ? BDFDB.disCN.inputerror : (this.props.success && BDFDB.disCN.inputsuccess), this.props.disabled && BDFDB.disCN.inputdisabled, this.props.editable && BDFDB.disCN.inputeditable),
								type: this.props.type == "color" || this.props.type == "file" ? "text" : this.props.type,
								onChange: this.handleChange.bind(this),
								onInput: this.handleInput.bind(this),
								onKeyDown: this.handleKeyDown.bind(this),
								onBlur: this.handleBlur.bind(this),
								onFocus: this.handleFocus.bind(this),
								onMouseEnter: this.handleMouseEnter.bind(this),
								onMouseLeave: this.handleMouseLeave.bind(this),
								maxLength: this.props.type == "file" ? false : this.props.maxLength,
								style: this.props.width ? {width: `${this.props.width}px`} : {},
								ref: this.props.inputRef
							}), "errorMessage", "focused", "error", "success", "inputClassName", "inputChildren", "valuePrefix", "inputPrefix", "size", "editable", "inputRef", "style", "mode", "noAlpha", "filter", "useFilePath", "searchFolders")),
							this.props.inputChildren,
							this.props.type == "color" ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex.Child, {
								wrap: true,
								children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.ColorSwatches, {
									colors: [],
									color: this.props.value && this.props.mode == "comp" ? BDFDB.ColorUtils.convert(this.props.value.split(","), "RGB") : this.props.value,
									onColorChange: color => this.handleChange(!color ? "" : (this.props.mode == "comp" ? BDFDB.ColorUtils.convert(color, "RGBCOMP").slice(0, 3).join(",") : BDFDB.ColorUtils.convert(color, this.props.noAlpha ? "RGB" : "RGBA"))),
									ref: this.props.controlsRef,
									pickerConfig: {gradient: false, alpha: this.props.mode != "comp" && !this.props.noAlpha}
								})
							}) : null,
							this.props.type == "file" ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.FileButton, {
								filter: this.props.filter,
								mode: this.props.mode,
								useFilePath: this.props.useFilePath,
								searchFolders: this.props.searchFolders,
								ref: this.props.controlsRef
							}) : null
						].flat(10).filter(n => n);
						
						return BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.inputwrapper, this.props.type == "number" && (this.props.size && InternalComponents.LibraryComponents.TextInput.Sizes[this.props.size.toUpperCase()] && BDFDB.disCN["inputnumberwrapper" + this.props.size.toLowerCase()] || BDFDB.disCN.inputnumberwrapperdefault), this.props.className),
							style: this.props.style,
							children: [
								this.props.inputPrefix ? BDFDB.ReactUtils.createElement("span", {
									className: BDFDB.disCN.inputprefix
								}) : null,
								this.props.type == "number" ? BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN.inputnumberbuttons,
									children: [
										BDFDB.ReactUtils.createElement("div", {
											className: BDFDB.disCN.inputnumberbuttonup,
											onClick: e => {
												let min = parseInt(this.props.min);
												let max = parseInt(this.props.max);
												let newV = parseInt(this.props.value) + 1 || min || 0;
												if (isNaN(max) || !isNaN(max) && newV <= max) this.handleNumberButton.bind(this)(e._targetInst, isNaN(min) || !isNaN(min) && newV >= min ? newV : min);
											}
										}),
										BDFDB.ReactUtils.createElement("div", {
											className: BDFDB.disCN.inputnumberbuttondown,
											onClick: e => {
												let min = parseInt(this.props.min);
												let max = parseInt(this.props.max);
												let newV = parseInt(this.props.value) - 1 || min || 0;
												if (isNaN(min) || !isNaN(min) && newV >= min) this.handleNumberButton.bind(this)(e._targetInst, isNaN(max) || !isNaN(max) && newV <= max ? newV : max);
											}
										})
									]
								}) : null,
								inputChildren.length == 1 ? inputChildren[0] : BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex, {
									align: InternalComponents.LibraryComponents.Flex.Align.CENTER,
									children: inputChildren.map((child, i) => i != 0 ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Flex.Child, {
										shrink: 0,
										children: child
									}) : child)
								}),
								this.props.errorMessage ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TextElement, {
									className: BDFDB.disCN.carderror,
									size: InternalComponents.LibraryComponents.TextElement.Sizes.SIZE_12,
									color: InternalComponents.LibraryComponents.TextElement.Colors.STATUS_RED,
									children: this.props.errorMessage
								}) : null
							].filter(n => n)
						});
					}
				};
				
				InternalComponents.LibraryComponents.TextScroller = reactInitialized && class BDFDB_TextScroller extends LibraryModules.React.Component {
					render() {
						let scrolling, scroll = _ => {};
						return BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.textscroller, this.props.className),
							style: Object.assign({}, this.props.style, {
								position: "relative",
								display: "block",
								overflow: "hidden"
							}),
							ref: instance => {
								const ele = BDFDB.ReactUtils.findDOMNode(instance);
								if (ele && ele.parentElement) {
									const maxWidth = BDFDB.DOMUtils.getInnerWidth(ele.parentElement);
									if (maxWidth > 50) ele.style.setProperty("max-width", `${maxWidth}px`);
									if (!this.props.initiated) BDFDB.TimeUtils.timeout(_ => {
										this.props.initiated = true;
										if (document.contains(ele.parentElement)) BDFDB.ReactUtils.forceUpdate(this);
									}, 3000);
									const Animation = new LibraryModules.AnimationUtils.Value(0);
									Animation.interpolate({inputRange: [0, 1], outputRange: [0, (BDFDB.DOMUtils.getRects(ele.firstElementChild).width - BDFDB.DOMUtils.getRects(ele).width) * -1]}).addListener(v => {
										ele.firstElementChild.style.setProperty("display", v.value == 0 ? "inline" : "block", "important");
										ele.firstElementChild.style.setProperty("left", `${v.value}px`, "important");
									});
									scroll = p => {
										const display = ele.firstElementChild.style.getPropertyValue("display", "inline");
										ele.firstElementChild.style.setProperty("display", "inline", "important");
										const innerWidth = BDFDB.DOMUtils.getRects(ele.firstElementChild).width;
										const outerWidth = BDFDB.DOMUtils.getRects(ele).width;
										ele.firstElementChild.style.setProperty("display", display, "important");
										
										let w = p + parseFloat(ele.firstElementChild.style.getPropertyValue("left")) / (innerWidth - outerWidth);
										w = isNaN(w) || !isFinite(w) ? p : w;
										w *= innerWidth / (outerWidth * 2);
										LibraryModules.AnimationUtils.parallel([LibraryModules.AnimationUtils.timing(Animation, {toValue: p, duration: Math.sqrt(w**2) * 4000 / (parseInt(this.props.speed) || 1)})]).start();
									};
								}
							},
							onClick: e => {
								if (typeof this.props.onClick == "function") this.props.onClick(e, this);
							},
							onMouseEnter: e => {
								if (BDFDB.DOMUtils.getRects(e.currentTarget).width < BDFDB.DOMUtils.getRects(e.currentTarget.firstElementChild).width) {
									scrolling = true;
									scroll(1);
								}
							},
							onMouseLeave: e => {
								if (scrolling) {
									scrolling = false;
									scroll(0);
								}
							},
							children: BDFDB.ReactUtils.createElement("div", {
								style: {
									left: "0",
									position: "relative",
									display: "inline",
									whiteSpace: "nowrap"
								},
								children: this.props.children
							})
						});
					}
				};
				InternalComponents.LibraryComponents.TooltipContainer = reactInitialized && class BDFDB_TooltipContainer extends LibraryModules.React.Component {
					updateTooltip(text) {
						if (this.tooltip) this.tooltip.update(text);
					}
					render() {
						let child = (typeof this.props.children == "function" ? this.props.children() : (BDFDB.ArrayUtils.is(this.props.children) ? this.props.children[0] : this.props.children)) || BDFDB.ReactUtils.createElement("div", {});
						child.props.className = BDFDB.DOMUtils.formatClassName(child.props.className, this.props.className);
						let childProps = Object.assign({}, child.props);
						let shown = false;
						child.props.onMouseEnter = (e, childThis) => {
							if (!shown && !e.currentTarget.BDFDBtooltipShown) {
								e.currentTarget.BDFDBtooltipShown = shown = true;
								this.tooltip = BDFDB.TooltipUtils.create(e.currentTarget, typeof this.props.text == "function" ? this.props.text(this) : this.props.text, Object.assign({
									note: this.props.note,
									delay: this.props.delay
								}, this.props.tooltipConfig, {
									onHide: (tooltip, anker) => {
										delete anker.BDFDBtooltipShown;
										shown = false;
										if (this.props.tooltipConfig && typeof this.props.tooltipConfig.onHide == "function") this.props.tooltipConfig.onHide(tooltip, anker);
									}
								}));
								if (typeof this.props.onMouseEnter == "function") this.props.onMouseEnter(e, this);
								if (typeof childProps.onMouseEnter == "function") childProps.onMouseEnter(e, childThis);
							}
						};
						child.props.onMouseLeave = (e, childThis) => {
							if (typeof this.props.onMouseLeave == "function") this.props.onMouseLeave(e, this);
							if (typeof childProps.onMouseLeave == "function") childProps.onMouseLeave(e, childThis);
						};
						child.props.onClick = (e, childThis) => {
							if (typeof this.props.onClick == "function") this.props.onClick(e, this);
							if (typeof childProps.onClick == "function") childProps.onClick(e, childThis);
							if (typeof this.props.text == "function") this.updateTooltip(this.props.text(this));
						};
						child.props.onContextMenu = (e, childThis) => {
							if (typeof this.props.onContextMenu == "function") this.props.onContextMenu(e, this);
							if (typeof childProps.onContextMenu == "function") childProps.onContextMenu(e, childThis);
							if (typeof this.props.text == "function") this.updateTooltip(this.props.text(this));
						};
						return BDFDB.ReactUtils.createElement(LibraryModules.React.Fragment, {
							children: child
						});
					}
				};
				
				InternalComponents.LibraryComponents.UserPopoutContainer = reactInitialized && class BDFDB_UserPopoutContainer extends LibraryModules.React.Component {
					render() {
						return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.PopoutContainer, BDFDB.ObjectUtils.exclude(Object.assign({}, this.props, {
							wrap: false,
							renderPopout: instance => {
								return BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.UserPopout, {
									userId: this.props.userId,
									guildId: this.props.guildId,
									channelId: this.props.channelId
								});
							}
						}), "userId", "guildId", "channelId"));
					}
				};
				
				const VideoInner = function (props) {
					let ref = BDFDB.ReactUtils.useRef(null);
					BDFDB.ReactUtils.useEffect(_ => {
						if (ref.current) props.play ? ref.current.play() : ref.current.pause();
					}, [props.play]);
					return props.naturalWidth <= BDFDB.DiscordConstants.MAX_VIDEO_WIDTH && props.naturalHeight <= BDFDB.DiscordConstants.MAX_VIDEO_HEIGHT || props.naturalWidth <= BDFDB.DiscordConstants.MAX_VIDEO_HEIGHT && props.naturalHeight <= BDFDB.DiscordConstants.MAX_VIDEO_WIDTH ? BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.VideoForwardRef, {
						ref: ref,
						className: props.className,
						poster: props.poster,
						src: props.src,
						width: props.width,
						height: props.height,
						muted: true,
						loop: true,
						autoPlay: props.play,
						preload: "none"
					}) : BDFDB.ReactUtils.createElement("img", {
						alt: "",
						src: props.poster,
						width: props.width,
						height: props.height
					});
				};
				InternalComponents.LibraryComponents.Video = reactInitialized && class BDFDB_Video extends LibraryModules.React.Component {
					render() {
						return BDFDB.ReactUtils.createElement(VideoInner, this.props);
					}
				};
				
				for (let type in InternalComponents.NativeSubComponents) if (InternalComponents.LibraryComponents[type]) for (let key in InternalComponents.NativeSubComponents[type]) if (key != "displayName" && key != "name" && (typeof InternalComponents.NativeSubComponents[type][key] != "function" || key.charAt(0) == key.charAt(0).toUpperCase())) {
					if (key == "defaultProps") InternalComponents.LibraryComponents[type][key] = Object.assign({}, InternalComponents.LibraryComponents[type][key], InternalComponents.NativeSubComponents[type][key]);
					else InternalComponents.LibraryComponents[type][key] = InternalComponents.NativeSubComponents[type][key];
				}
				BDFDB.LibraryComponents = Object.assign({}, InternalComponents.LibraryComponents);
				
				InternalBDFDB.createCustomControl = function (data) {
					let controlButton = BDFDB.DOMUtils.create(`<button class="${BDFDB.DOMUtils.formatClassName(BDFDB.disCN._repobutton, BDFDB.disCN._repocontrolsbutton, BDFDB.disCN._repocontrolscustom)}"></button>`);
					BDFDB.ReactUtils.render(BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SvgIcon, {
						nativeClass: true,
						name: data.svgName,
						width: 20,
						height: 20
					}), controlButton);
					controlButton.addEventListener("click", _ => {if (typeof data.onClick == "function") data.onClick();});
					if (data.tooltipText) controlButton.addEventListener("mouseenter", _ => {BDFDB.TooltipUtils.create(controlButton, data.tooltipText);});
					return controlButton;
				};
				InternalBDFDB.appendCustomControls = function (card) {
					if (!card || card.querySelector(BDFDB.dotCN._repocontrolscustom)) return;
					let checkbox = card.querySelector(BDFDB.dotCN._reposwitch);
					if (!checkbox) return;
					let props = BDFDB.ObjectUtils.get(BDFDB.ReactUtils.getInstance(card), "return.stateNode.props");
					let plugin = props && props.addon && (props.addon.plugin || props.addon.instance);
					if (plugin && (plugin == libraryInstance || plugin.name && plugin.name && PluginStores.loaded[plugin.name] && PluginStores.loaded[plugin.name] == plugin)) {
						let url = InternalBDFDB.getPluginURL(plugin);
						let controls = [];
						let footerControls = card.querySelector(BDFDB.dotCNS._repofooter + BDFDB.dotCN._repocontrols);
						if (plugin.changeLog) controls.push(InternalBDFDB.createCustomControl({
							tooltipText: BDFDB.LanguageUtils.LanguageStrings.CHANGE_LOG,
							svgName: InternalComponents.LibraryComponents.SvgIcon.Names.CHANGELOG,
							onClick: _ => {BDFDB.PluginUtils.openChangeLog(plugin);}
						}));
						if (PluginStores.updateData.plugins[url] && PluginStores.updateData.plugins[url].outdated) controls.push(InternalBDFDB.createCustomControl({
							tooltipText: BDFDB.LanguageUtils.LanguageStrings.UPDATE_MANUALLY,
							svgName: InternalComponents.LibraryComponents.SvgIcon.Names.DOWNLOAD,
							onClick: _ => {BDFDB.PluginUtils.downloadUpdate(plugin.name, url);}
						}));
						if (footerControls) for (let control of controls) footerControls.insertBefore(control, footerControls.firstElementChild);
						else for (let control of controls) checkbox.parentElement.insertBefore(control, checkbox.parentElement.firstElementChild);
					}
				};
				InternalBDFDB.addListObserver = function (layer) {
					if (!layer) return;
					BDFDB.ObserverUtils.connect(BDFDB, layer, {name: "cardObserver", instance: new MutationObserver(changes => {changes.forEach(change => {if (change.addedNodes) {change.addedNodes.forEach(n => {
						if (BDFDB.DOMUtils.containsClass(n, BDFDB.disCN._repocard)) InternalBDFDB.appendCustomControls(n);
						if (n.nodeType != Node.TEXT_NODE) for (let c of n.querySelectorAll(BDFDB.dotCN._repocard)) InternalBDFDB.appendCustomControls(c);
						InternalBDFDB.appendCustomControls(BDFDB.DOMUtils.getParent(BDFDB.dotCN._repocard, n));
					});}});})}, {childList: true, subtree: true});
					for (let c of layer.querySelectorAll(BDFDB.dotCN._repocard)) InternalBDFDB.appendCustomControls(c);
				}

				const keyDownTimeouts = {};
				BDFDB.ListenerUtils.add(BDFDB, document, "keydown.BDFDBPressedKeys", e => {
					if (!pressedKeys.includes(e.which)) {
						BDFDB.TimeUtils.clear(keyDownTimeouts[e.which]);
						pressedKeys.push(e.which);
						keyDownTimeouts[e.which] = BDFDB.TimeUtils.timeout(_ => {
							BDFDB.ArrayUtils.remove(pressedKeys, e.which, true);
						}, 60000);
					}
				});
				BDFDB.ListenerUtils.add(BDFDB, document, "keyup.BDFDBPressedKeys", e => {
					BDFDB.TimeUtils.clear(keyDownTimeouts[e.which]);
					BDFDB.ArrayUtils.remove(pressedKeys, e.which, true);
				});
				BDFDB.ListenerUtils.add(BDFDB, document, "mousedown.BDFDBMousePosition", e => {
					mousePosition = e;
				});
				BDFDB.ListenerUtils.add(BDFDB, window, "focus.BDFDBPressedKeysReset", e => {
					pressedKeys = [];
				});
				
				InternalBDFDB.patchedModules = {
					after: {
						DiscordTag: "default",
						Message: "default",
						MessageHeader: "default",
						MemberListItem: ["componentDidMount", "componentDidUpdate"],
						PrivateChannel: ["componentDidMount", "componentDidUpdate"],
						UserPopout: ["componentDidMount", "componentDidUpdate"],
						UserProfile: ["componentDidMount", "componentDidUpdate"],
						SettingsView: "componentDidMount",
						Shakeable: "render"
					}
				};
				
				
				InternalBDFDB.processSettingsView = function (e) {
					if (e.node && e.node.parentElement && e.node.parentElement.getAttribute("aria-label") == BDFDB.DiscordConstants.Layers.USER_SETTINGS) InternalBDFDB.addListObserver(e.node.parentElement);
				}
			
				let AppViewExport = BDFDB.ModuleUtils.findByName("AppView", false);
				if (AppViewExport) InternalBDFDB.processShakeable = function (e) {
					let [children, index] = BDFDB.ReactUtils.findParent(e.returnvalue, {name: "AppView"});
					if (index > -1) children[index] = BDFDB.ReactUtils.createElement(AppViewExport.exports.default, children[index].props);
				};
				
				InternalBDFDB.processMessage = function (e) {
					if (e.returnvalue && e.returnvalue.props && e.returnvalue.props.children && e.returnvalue.props.children.props) {
						let message;
						for (let key in e.instance.props) {
							if (!message) message = BDFDB.ObjectUtils.get(e.instance.props[key], "props.message");
							else break;
						}
						if (message) e.returnvalue.props.children.props[InternalData.userIdAttribute] = message.author.id;
					}
				};

				const BDFDB_Patrons = Object.assign({}, InternalData.BDFDB_Patrons), BDFDB_Patron_Tiers = Object.assign({}, InternalData.BDFDB_Patron_Tiers);
				InternalBDFDB._processAvatarRender = function (user, avatar) {
					if (BDFDB.ReactUtils.isValidElement(avatar) && BDFDB.ObjectUtils.is(user) && (avatar.props.className || "").indexOf(BDFDB.disCN.bdfdbbadgeavatar) == -1) {
						avatar.props[InternalData.userIdAttribute] = user.id;
						let role = "", note = "", className = BDFDB.DOMUtils.formatClassName((avatar.props.className || "").replace(BDFDB.disCN.avatar, "")), addBadge = InternalBDFDB.settings.general.showSupportBadges;
						if (BDFDB_Patrons[user.id] && BDFDB_Patrons[user.id].active) {
							role = BDFDB_Patrons[user.id].text || (BDFDB_Patron_Tiers[BDFDB_Patrons[user.id].tier] || {}).text;
							note = BDFDB_Patrons[user.id].text && (BDFDB_Patron_Tiers[BDFDB_Patrons[user.id].tier] || {}).text;
							className = BDFDB.DOMUtils.formatClassName(className, addBadge && BDFDB.disCN.bdfdbhasbadge, BDFDB.disCN.bdfdbbadgeavatar, BDFDB.disCN.bdfdbsupporter, BDFDB.disCN[`bdfdbsupporter${BDFDB_Patrons[user.id].tier}`]);
						}
						if (user.id == InternalData.myId) {
							addBadge = true;
							role = `Theme ${BDFDB.LanguageUtils.LibraryStrings.developer}`;
							className = BDFDB.DOMUtils.formatClassName(className, BDFDB.disCN.bdfdbhasbadge, BDFDB.disCN.bdfdbbadgeavatar, BDFDB.disCN.bdfdbdev);
						}
						if (role) {
							delete avatar.props[InternalData.userIdAttribute];
							if (avatar.type == "img") avatar = BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.AvatarComponents.default, Object.assign({}, avatar.props, {
								size: InternalComponents.LibraryComponents.AvatarComponents.Sizes.SIZE_40
							}));
							delete avatar.props.className;
							let newProps = {
								className: className,
								children: [avatar]
							};
							newProps[InternalData.userIdAttribute] = user.id;
							avatar = BDFDB.ReactUtils.createElement("div", newProps);
							if (addBadge) avatar.props.children.push(BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.TooltipContainer, {
								text: role,
								note: note,
								children: BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN.bdfdbbadge
								})
							}));
							return avatar;
						}
					}
				};
				InternalBDFDB._processAvatarMount = function (user, avatar, wrapper) {
					if (!user) return;
					if (wrapper) wrapper.setAttribute(InternalData.userIdAttribute, user.id);
					if (Node.prototype.isPrototypeOf(avatar) && (avatar.className || "").indexOf(BDFDB.disCN.bdfdbbadgeavatar) == -1) {
						avatar.setAttribute(InternalData.userIdAttribute, user.id);
						let role = "", note = "", addBadge = InternalBDFDB.settings.general.showSupportBadges;
						if (BDFDB_Patrons[user.id] && BDFDB_Patrons[user.id].active) {
							role = BDFDB_Patrons[user.id].text || (BDFDB_Patron_Tiers[BDFDB_Patrons[user.id].tier] || {}).text;
							note = BDFDB_Patrons[user.id].text && (BDFDB_Patron_Tiers[BDFDB_Patrons[user.id].tier] || {}).text;
							avatar.className = BDFDB.DOMUtils.formatClassName(avatar.className, addBadge && BDFDB.disCN.bdfdbhasbadge, BDFDB.disCN.bdfdbbadgeavatar, BDFDB.disCN.bdfdbsupporter, BDFDB.disCN[`bdfdbsupporter${BDFDB_Patrons[user.id].tier}`]);
						}
						else if (user.id == InternalData.myId) {
							addBadge = true;
							role = `Theme ${BDFDB.LanguageUtils.LibraryStrings.developer}`;
							avatar.className = BDFDB.DOMUtils.formatClassName(avatar.className, addBadge && BDFDB.disCN.bdfdbhasbadge, BDFDB.disCN.bdfdbbadgeavatar, BDFDB.disCN.bdfdbdev);
						}
						if (addBadge && role && !avatar.querySelector(BDFDB.dotCN.bdfdbbadge)) {
							let badge = document.createElement("div");
							badge.className = BDFDB.disCN.bdfdbbadge;
							badge.addEventListener("mouseenter", _ => BDFDB.TooltipUtils.create(badge, role, {position: "top", note: note}));
							avatar.appendChild(badge);
						}
					}
				};
				InternalBDFDB._processUserInfoNode = function (user, wrapper) {
					if (!user || !wrapper) return;
					if (InternalData.UserBackgrounds[user.id]) for (let property in InternalData.UserBackgrounds[user.id]) wrapper.style.setProperty(property, InternalData.UserBackgrounds[user.id][property], "important");
				};
				InternalBDFDB.processMessageHeader = function (e) {
					if (e.instance.props.message && e.instance.props.message.author) {
						let avatarWrapper = BDFDB.ObjectUtils.get(e, "returnvalue.props.children.0");
						if (avatarWrapper && avatarWrapper.props && typeof avatarWrapper.props.children == "function") {
							let renderChildren = avatarWrapper.props.children;
							avatarWrapper.props.children = (...args) => {
								let renderedChildren = renderChildren(...args);
								return InternalBDFDB._processAvatarRender(e.instance.props.message.author, renderedChildren) || renderedChildren;
							};
						}
						else if (avatarWrapper && avatarWrapper.type == "img") e.returnvalue.props.children[0] = InternalBDFDB._processAvatarRender(e.instance.props.message.author, avatarWrapper) || avatarWrapper;
					}
				};
				InternalBDFDB.processMemberListItem = function (e) {
					InternalBDFDB._processAvatarMount(e.instance.props.user, e.node.querySelector(BDFDB.dotCN.avatarwrapper), e.node);
				};
				InternalBDFDB.processPrivateChannel = function (e) {
					InternalBDFDB._processAvatarMount(e.instance.props.user, e.node.querySelector(BDFDB.dotCN.avatarwrapper), e.node);
				};
				InternalBDFDB.processUserPopout = function (e) {
					InternalBDFDB._processAvatarMount(e.instance.props.user, e.node.querySelector(BDFDB.dotCN.avatarwrapper), e.node);
					InternalBDFDB._processUserInfoNode(e.instance.props.user, e.node);
				};
				InternalBDFDB.processUserProfile = function (e) {
					InternalBDFDB._processAvatarMount(e.instance.props.user, e.node.querySelector(BDFDB.dotCN.avatarwrapper), e.node);
					InternalBDFDB._processUserInfoNode(e.instance.props.user, e.node);
				};
				InternalBDFDB.processDiscordTag = function (e) {
					if (e.instance && e.instance.props && e.returnvalue && e.instance.props.user) e.returnvalue.props.user = e.instance.props.user;
				};
				
				const ContextMenuTypes = ["UserSettingsCog", "UserProfileActions", "User", "Developer", "Slate", "GuildFolder", "GroupDM", "SystemMessage", "Message", "Native", "Role", "Guild", "Channel"];
				const QueuedComponents = BDFDB.ArrayUtils.removeCopies([].concat(ContextMenuTypes.map(n => n + "ContextMenu"), ["GuildHeaderContextMenu", "MessageOptionContextMenu", "MessageOptionToolbar"]));	
				InternalBDFDB.addContextListeners = function (plugin) {
					plugin = plugin == BDFDB && InternalBDFDB || plugin;
					for (let type of QueuedComponents) if (typeof plugin[`on${type}`] == "function") {
						PluginStores.patchQueues[type].query.push(plugin);
						PluginStores.patchQueues[type].query = BDFDB.ArrayUtils.removeCopies(PluginStores.patchQueues[type].query);
						PluginStores.patchQueues[type].query.sort((x, y) => x.name < y.name ? -1 : x.name > y.name ? 1 : 0);
						for (let module of PluginStores.patchQueues[type].modules) InternalBDFDB.patchContextMenuForPlugin(plugin, type, module);
					}
				};
				InternalBDFDB.patchContextMenuForPlugin = function (plugin, type, module) {
					plugin = plugin == BDFDB && InternalBDFDB || plugin;
					if (module && module.exports && module.exports.default) BDFDB.PatchUtils.patch(plugin, module.exports, "default", {after: e => {
						if (e.returnValue && typeof plugin[`on${type}`] == "function") plugin[`on${type}`]({instance: {props: e.methodArguments[0]}, returnvalue: e.returnValue, methodname: "default", type: module.exports.default.displayName});
					}});
				};
				InternalBDFDB.executeExtraPatchedPatches = function (type, e) {
					if (e.returnvalue && BDFDB.ObjectUtils.is(PluginStores.patchQueues[type]) && BDFDB.ArrayUtils.is(PluginStores.patchQueues[type].query)) {
						for (let plugin of PluginStores.patchQueues[type].query) if(typeof plugin[`on${type}`] == "function") plugin[`on${type}`](e);
					}
				};
				
				BDFDB.ReactUtils.instanceKey = Object.keys(document.querySelector(BDFDB.dotCN.app) || {}).some(n => n.startsWith("__reactInternalInstance")) ? "_reactInternalFiber" : "_reactInternals";

				BDFDB.PluginUtils.load(BDFDB);
				InternalBDFDB.settings = BDFDB.DataUtils.get(InternalBDFDB);
				changeLogs = BDFDB.DataUtils.load(BDFDB, "changeLogs");
				BDFDB.PluginUtils.checkChangeLog(BDFDB);
				
				if (window.Lightcord || window.LightCord) BDFDB.ModalUtils.open(BDFDB, {
					header: "Attention!",
					subHeader: "Modified Client detected",
					text: "We detected that you are using LightCord. Unlike other client modificaton (BetterDiscord, PowerCord), LightCord is a completely modified client, which is no longer maintained by Discord but instead by a 3rd party. This will put your account at risk, not only because the 3rd party might use your account credentials as they like, you are also breaking a higher instance of Discord's ToS by using a 3rd party client instead of using a simple client mod which ininjects itself into the original client app. Many Plugins won't flawlessly run on LightCord. We do not support LightCord and as such, we do not provide help or support. You should switch to another modification as soon as possible.",
					buttons: [{color: "RED", contents: BDFDB.LanguageUtils.LanguageStrings.OKAY, close: true}]
				});
				
				InternalBDFDB.patchPlugin(BDFDB);
				
				for (let type of QueuedComponents) if (!PluginStores.patchQueues[type]) PluginStores.patchQueues[type] = {query: [], modules: []};
				BDFDB.PatchUtils.patch(BDFDB, LibraryModules.ContextMenuUtils, "openContextMenu", {before: e => {
					let menu = e.methodArguments[1]();
					if (BDFDB.ObjectUtils.is(menu) && menu.type && menu.type.displayName) {
						for (let type of ContextMenuTypes) if (menu.type.displayName.indexOf(type) > -1) {
							let patchType = type + "ContextMenu";
							let module = BDFDB.ModuleUtils.find(m => m == menu.type, false);
							if (module && module.exports && module.exports.default && PluginStores.patchQueues[patchType]) {
								PluginStores.patchQueues[patchType].modules.push(module);
								PluginStores.patchQueues[patchType].modules = BDFDB.ArrayUtils.removeCopies(PluginStores.patchQueues[patchType].modules);
								for (let plugin of PluginStores.patchQueues[patchType].query) InternalBDFDB.patchContextMenuForPlugin(plugin, patchType, module);
							}
							break;
						}
					}
				}});
				
				BDFDB.PatchUtils.patch(BDFDB, BDFDB.ObjectUtils.get(BDFDB.ModuleUtils.findByString("renderReactions", "canAddNewReactions", "showMoreUtilities", false), "exports.default"), "type", {after: e => {
					if (document.querySelector(BDFDB.dotCN.emojipicker) || !BDFDB.ObjectUtils.toArray(PluginStores.loaded).filter(p => p.started).some(p => p.onMessageOptionContextMenu || p.onMessageOptionToolbar)) return;
					let toolbar = BDFDB.ReactUtils.findChild(e.returnValue, {filter: c => c && c.props && c.props.showMoreUtilities != undefined && c.props.showEmojiPicker != undefined && c.props.setPopout != undefined});
					if (toolbar) BDFDB.PatchUtils.patch(BDFDB, toolbar, "type", {after: e2 => {
						let menu = BDFDB.ReactUtils.findChild(e2.returnValue, {filter: c => c && c.props && typeof c.props.onRequestClose == "function" && c.props.onRequestClose.toString().indexOf("moreUtilities") > -1});
						InternalBDFDB.executeExtraPatchedPatches("MessageOptionToolbar", {instance: {props: e2.methodArguments[0]}, returnvalue: e2.returnValue, methodname: "default"});
						if (menu && typeof menu.props.renderPopout == "function") {
							let renderPopout = menu.props.renderPopout;
							menu.props.renderPopout = (...args) => {
								let renderedPopout = renderPopout(...args);
								BDFDB.PatchUtils.patch(BDFDB, renderedPopout, "type", {after: e3 => {
									InternalBDFDB.executeExtraPatchedPatches("MessageOptionContextMenu", {instance: {props: e3.methodArguments[0]}, returnvalue: e3.returnValue, methodname: "default"});
								}}, {noCache: true});
								return renderedPopout;
							}
						}
					}}, {once: true});
				}});
				
				BDFDB.PatchUtils.patch(BDFDB, BDFDB.ObjectUtils.get(BDFDB.ModuleUtils.findByString("guild-header-popout", false), "exports.default.prototype"), "render", {after: e => {
					BDFDB.PatchUtils.patch(BDFDB, e.returnValue.type, "type", {after: e2 => {
						InternalBDFDB.executeExtraPatchedPatches("GuildHeaderContextMenu", {instance: {props: e2.methodArguments[0]}, returnvalue: e2.returnValue, methodname: "type"});
					}}, {noCache: true});
				}});
				
				BDFDB.PatchUtils.patch(BDFDB, (BDFDB.ModuleUtils.findByName("useCopyIdItem", false) || {}).exports, "default", {after: e => {
					if (!e.returnValue) e.returnValue = false;
				}}, {priority: 10});
				BDFDB.PatchUtils.patch(BDFDB, (BDFDB.ModuleUtils.findByName("DeveloperContextMenu", false) || {}).exports, "default", {after: e => {
					if (!e.returnValue.props.children) LibraryModules.ContextMenuUtils.closeContextMenu();
				}}, {priority: 10});
				
				let languageChangeTimeout, translateAllNew = e => {
					if (e.methodArguments[0] && e.methodArguments[0].locale) {
						BDFDB.TimeUtils.clear(languageChangeTimeout);
						languageChangeTimeout = BDFDB.TimeUtils.timeout(_ => {
							for (let pluginName in PluginStores.loaded) if (PluginStores.loaded[pluginName].started) BDFDB.PluginUtils.translate(PluginStores.loaded[pluginName]);
						}, 10000);
					}
				};
				if (LibraryModules.SettingsUtils) BDFDB.PatchUtils.patch(BDFDB, LibraryModules.SettingsUtils, "updateLocalSettings", {after: translateAllNew});
				
				InternalBDFDB.onSettingsClosed = function () {
					if (InternalBDFDB.SettingsUpdated) {
						delete InternalBDFDB.SettingsUpdated;
						InternalBDFDB.forceUpdateAll();
					}
				};
				
				InternalBDFDB.forceUpdateAll = function () {					
					BDFDB.MessageUtils.rerenderAll();
					BDFDB.PatchUtils.forceAllUpdates(BDFDB);
				};
				
				InternalBDFDB.addSpecialListeners(BDFDB);
				
				if (InternalComponents.LibraryComponents.GuildComponents.BlobMask) {
					let newBadges = ["lowerLeftBadge", "upperLeftBadge"];
					BDFDB.PatchUtils.patch(BDFDB, InternalComponents.LibraryComponents.GuildComponents.BlobMask.prototype, "render", {
						before: e => {
							e.thisObject.props = Object.assign({}, InternalComponents.LibraryComponents.GuildComponents.BlobMask.defaultProps, e.thisObject.props);
							for (let type of newBadges) if (!e.thisObject.state[`${type}Mask`]) e.thisObject.state[`${type}Mask`] = new InternalComponents.LibraryComponents.Animations.Controller({spring: 0});
						},
						after: e => {
							let [children, index] = BDFDB.ReactUtils.findParent(e.returnValue, {name: "TransitionGroup"});
							if (index > -1) {
								children[index].props.children.push(!e.thisObject.props.lowerLeftBadge ? null : BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.BadgeAnimationContainer, {
									className: BDFDB.disCN.guildlowerleftbadge,
									key: "lower-left-badge",
									animatedStyle: e.thisObject.getLowerLeftBadgeStyles(),
									children: e.thisObject.props.lowerLeftBadge
								}));
								children[index].props.children.push(!e.thisObject.props.upperLeftBadge ? null : BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.BadgeAnimationContainer, {
									className: BDFDB.disCN.guildupperleftbadge,
									key: "upper-left-badge",
									animatedStyle: e.thisObject.getUpperLeftBadgeStyles(),
									children: e.thisObject.props.upperLeftBadge
								}));
							}
							[children, index] = BDFDB.ReactUtils.findParent(e.returnValue, {name: "mask"});
							if (index > -1) {
								children[index].props.children.push(BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Animations.animated.rect, {
									x: -4,
									y: -4,
									width: e.thisObject.props.upperLeftBadgeWidth + 8,
									height: 24,
									rx: 12,
									ry: 12,
									transform: e.thisObject.getLeftBadgePositionInterpolation(e.thisObject.state.upperLeftBadgeMask, -1),
									fill: "black"
								}));
								children[index].props.children.push(BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Animations.animated.rect, {
									x: -4,
									y: 28,
									width: e.thisObject.props.lowerLeftBadgeWidth + 8,
									height: 24,
									rx: 12,
									ry: 12,
									transform: e.thisObject.getLeftBadgePositionInterpolation(e.thisObject.state.lowerLeftBadgeMask),
									fill: "black"
								}));
							}
						}
					});
					BDFDB.PatchUtils.patch(BDFDB, InternalComponents.LibraryComponents.GuildComponents.BlobMask.prototype, "componentDidMount", {
						after: e => {
							for (let type of newBadges) e.thisObject.state[`${type}Mask`].update({
								spring: e.thisObject.props[type] != null ? 1 : 0,
								immediate: true
							}).start();
						}
					});
					BDFDB.PatchUtils.patch(BDFDB, InternalComponents.LibraryComponents.GuildComponents.BlobMask.prototype, "componentWillUnmount", {
						after: e => {
							for (let type of newBadges) if (e.thisObject.state[`${type}Mask`]) e.thisObject.state[`${type}Mask`].dispose();
						}
					});
					BDFDB.PatchUtils.patch(BDFDB, InternalComponents.LibraryComponents.GuildComponents.BlobMask.prototype, "componentDidUpdate", {
						after: e => {
							for (let type of newBadges) if (e.thisObject.props[type] != null && e.methodArguments[0][type] == null) {
								e.thisObject.state[`${type}Mask`].update({
									spring: 1,
									immediate: !document.hasFocus(),
									config: {friction: 30, tension: 900, mass: 1}
								}).start();
							}
							else if (e.thisObject.props[type] == null && e.methodArguments[0][type] != null) {
								e.thisObject.state[`${type}Mask`].update({
									spring: 0,
									immediate: !document.hasFocus(),
									config: {duration: 150, friction: 10, tension: 100, mass: 1}
								}).start();
							}
						}
					});
					InternalComponents.LibraryComponents.GuildComponents.BlobMask.prototype.getLeftBadgePositionInterpolation = function (e, t) {
						return void 0 === t && (t = 1), e.springs.spring.to([0, 1], [20, 0]).to(function (e) {
							return "translate(" + e * -1 + " " + e * t + ")";
						});
					};
					InternalComponents.LibraryComponents.GuildComponents.BlobMask.prototype.getLowerLeftBadgeStyles = function () {
						var e = this.state.lowerLeftBadgeMask.springs.spring;
						return {
							opacity: e.to([0, .5, 1], [0, 0, 1]),
							transform: e.to(function (e) {
								return "translate(" + -1 * (16 - 16 * e) + "px, " + (16 - 16 * e) + "px)";
							})
						};
					};
					InternalComponents.LibraryComponents.GuildComponents.BlobMask.prototype.getUpperLeftBadgeStyles = function () {
						var e = this.state.upperLeftBadgeMask.springs.spring;
						return {
							opacity: e.to([0, .5, 1], [0, 0, 1]),
							transform: e.to(function (e) {
								return "translate(" + -1 * (16 - 16 * e) + "px, " + -1 * (16 - 16 * e) + "px)";
							})
						};
					};
					let extraDefaultProps = {};
					for (let type of newBadges) extraDefaultProps[`${type}Width`] = 16;
					InternalBDFDB.setDefaultProps(InternalComponents.LibraryComponents.GuildComponents.BlobMask, extraDefaultProps);
				}
				
				BDFDB.PatchUtils.patch(BDFDB, LibraryModules.GuildStore, "getGuild", {after: e => {
					if (e.returnValue && e.methodArguments[0] == InternalData.myGuildId) e.returnValue.banner = `https://mwittrien.github.io/BetterDiscordAddons/Library/_res/BDFDB.banner.png`;
				}});
				
				BDFDB.PatchUtils.patch(BDFDB, LibraryModules.UserStore, "getUser", {after: e => {
					if (e.returnValue && e.methodArguments[0] == InternalData.myId) e.returnValue.banner = `https://mwittrien.github.io/BetterDiscordAddons/Library/_res/DevilBro.banner.png`;
				}});

				BDFDB.PatchUtils.patch(BDFDB, LibraryModules.IconUtils, "getGuildBannerURL", {instead: e => {
					return e.methodArguments[0].id == InternalData.myGuildId ? e.methodArguments[0].banner : e.callOriginalMethod();
				}});

				BDFDB.PatchUtils.patch(BDFDB, LibraryModules.IconUtils, "getUserBannerURL", {instead: e => {
					return e.methodArguments[0].id == InternalData.myId ? e.methodArguments[0].banner : e.callOriginalMethod();
				}});
				
				InternalBDFDB.forceUpdateAll();
			
				const pluginQueue = window.BDFDB_Global && BDFDB.ArrayUtils.is(window.BDFDB_Global.pluginQueue) ? window.BDFDB_Global.pluginQueue : [];

				if (BDFDB.UserUtils.me.id == InternalData.myId || BDFDB.UserUtils.me.id == "350635509275557888") {
					for (let module in DiscordClassModules) if (!DiscordClassModules[module]) BDFDB.LogUtils.warn([module, "not initialized in DiscordClassModules"]);
					for (let obj in DiscordObjects) if (!DiscordObjects[obj]) BDFDB.LogUtils.warn([obj, "not initialized in DiscordObjects"]);
					for (let require in LibraryRequires) if (!LibraryRequires[require]) BDFDB.LogUtils.warn([require, "not initialized in LibraryRequires"]);
					for (let module in LibraryModules) if (!LibraryModules[module]) BDFDB.LogUtils.warn([module, "not initialized in LibraryModules"]);
					for (let component in InternalComponents.NativeSubComponents) if (!InternalComponents.NativeSubComponents[component]) BDFDB.LogUtils.warn([component, "not initialized in NativeSubComponents"]);
					for (let component in InternalComponents.LibraryComponents) if (!InternalComponents.LibraryComponents[component]) BDFDB.LogUtils.warn([component, "not initialized in LibraryComponents"]);

					BDFDB.DevUtils = {};
					BDFDB.DevUtils.generateClassId = InternalBDFDB.generateClassId;
					BDFDB.DevUtils.findByIndex = function (index) {
						return BDFDB.DevUtils.req.c[index];
					};
					BDFDB.DevUtils.findPropAny = function (...strings) {
						window.t = {"$filter":(prop => [...strings].flat(10).filter(n => typeof n == "string").every(string => prop.toLowerCase().indexOf(string.toLowerCase()) > -1))};
						for (let i in BDFDB.DevUtils.req.c) if (BDFDB.DevUtils.req.c.hasOwnProperty(i)) {
							let m = BDFDB.DevUtils.req.c[i].exports;
							if (m && typeof m == "object") for (let j in m) if (window.t.$filter(j)) window.t[j + "_" + i] = m;
							if (m && typeof m == "object" && typeof m.default == "object") for (let j in m.default) if (window.t.$filter(j)) window.t[j + "_default_" + i] = m.default;
						}
						console.clear();
						console.log(window.t);
					};
					BDFDB.DevUtils.findPropFunc = function (...strings) {
						window.t = {"$filter":(prop => [...strings].flat(10).filter(n => typeof n == "string").every(string => prop.toLowerCase().indexOf(string.toLowerCase()) > -1))};
						for (let i in BDFDB.DevUtils.req.c) if (BDFDB.DevUtils.req.c.hasOwnProperty(i)) {
							let m = BDFDB.DevUtils.req.c[i].exports;
							if (m && typeof m == "object") for (let j in m) if (window.t.$filter(j) && typeof m[j] != "string") window.t[j + "_" + i] = m;
							if (m && typeof m == "object" && typeof m.default == "object") for (let j in m.default) if (window.t.$filter(j) && typeof m.default[j] != "string") window.t[j + "_default_" + i] = m.default;
						}
						console.clear();
						console.log(window.t);
					};
					BDFDB.DevUtils.findPropStringLib = function (...strings) {
						window.t = {"$filter":(prop => [...strings].flat(10).filter(n => typeof n == "string").every(string => prop.toLowerCase().indexOf(string.toLowerCase()) > -1))};
						for (let i in BDFDB.DevUtils.req.c) if (BDFDB.DevUtils.req.c.hasOwnProperty(i)) {
							let m = BDFDB.DevUtils.req.c[i].exports;
							if (m && typeof m == "object") for (let j in m) if (window.t.$filter(j) && typeof m[j] == "string" && /^[A-z0-9]+\-[A-z0-9_-]{6}$/.test(m[j])) window.t[j + "_" + i] = m;
							if (m && typeof m == "object" && typeof m.default == "object") for (let j in m.default) if (window.t.$filter(j) && typeof m.default[j] == "string" && /^[A-z0-9]+\-[A-z0-9_-]{6}$/.test(m.default[j])) window.t[j + "_default_" + i] = m.default;
						}
						console.clear();
						console.log(window.t);
					};
					BDFDB.DevUtils.findNameAny = function (...strings) {
						window.t = {"$filter":(modu => [...strings].flat(10).filter(n => typeof n == "string").some(string => typeof modu.displayName == "string" && modu.displayName.toLowerCase().indexOf(string.toLowerCase()) > -1 || modu.name == "string" && modu.name.toLowerCase().indexOf(string.toLowerCase()) > -1))};
						for (let i in BDFDB.DevUtils.req.c) if (BDFDB.DevUtils.req.c.hasOwnProperty(i)) {
							let m = BDFDB.DevUtils.req.c[i].exports;
							if (m && (typeof m == "object" || typeof m == "function") && window.t.$filter(m)) window.t[(m.displayName || m.name) + "_" + i] = m;
							if (m && (typeof m == "object" || typeof m == "function") && m.default && (typeof m.default == "object" || typeof m.default == "function") && window.t.$filter(m.default)) window.t[(m.default.displayName || m.default.name) + "_" + i] = m.default;
						}
						console.clear();
						console.log(window.t);
					};
					BDFDB.DevUtils.findCodeAny = function (...strings) {
						window.t = {"$filter":(m => [...strings].flat(10).filter(n => typeof n == "string").map(string => string.toLowerCase()).every(string => typeof m == "function" && (m.toString().toLowerCase().indexOf(string) > -1 || typeof m.__originalMethod == "function" && m.__originalMethod.toString().toLowerCase().indexOf(string) > -1 || typeof m.__originalFunction == "function" && m.__originalFunction.toString().toLowerCase().indexOf(string) > -1) || BDFDB.ObjectUtils.is(m) && typeof m.type == "function" && m.type.toString().toLowerCase().indexOf(string) > -1))};
						for (let i in BDFDB.DevUtils.req.c) if (BDFDB.DevUtils.req.c.hasOwnProperty(i)) {
							let m = BDFDB.DevUtils.req.c[i].exports;
							if (m && typeof m == "function" && window.t.$filter(m)) window.t["module_" + i] = {string: m.toString(), func: m};
							if (m && m.__esModule) {
								for (let j in m) if (m[j] && typeof m[j] == "function" && window.t.$filter(m[j])) window.t[j + "_module_" + i] = {string: m[j].toString(), func: m[j], module: m};
								if (m.default && (typeof m.default == "object" || typeof m.default == "function")) for (let j in m.default) if (m.default[j] && typeof m.default[j] == "function" && window.t.$filter(m.default[j])) window.t[j + "_module_" + i + "_default"] = {string: m.default[j].toString(), func: m.default[j], module: m};
							}
						}
						for (let i in BDFDB.DevUtils.req.m) if (typeof BDFDB.DevUtils.req.m[i] == "function" && window.t.$filter(BDFDB.DevUtils.req.m[i])) window.t["function_" + i] = {string: BDFDB.DevUtils.req.m[i].toString(), func: BDFDB.DevUtils.req.m[i]};
						console.clear();
						console.log(window.t);
					};
					BDFDB.DevUtils.getAllModules = function () {
						window.t = {};
						for (let i in BDFDB.DevUtils.req.c) if (BDFDB.DevUtils.req.c.hasOwnProperty(i)) {
							let m = BDFDB.DevUtils.req.c[i].exports;
							if (m && typeof m == "object") window.t[i] = m;
						}
						console.clear();
						console.log(window.t);
					};
					BDFDB.DevUtils.getAllStringLibs = function () {
						window.t = [];
						for (let i in BDFDB.DevUtils.req.c) if (BDFDB.DevUtils.req.c.hasOwnProperty(i)) {
							let m = BDFDB.DevUtils.req.c[i].exports;
							if (m && typeof m == "object" && !BDFDB.ArrayUtils.is(m) && Object.keys(m).length) {
								var string = true, stringlib = false;
								for (let j in m) {
									if (typeof m[j] != "string") string = false;
									if (typeof m[j] == "string" && /^[A-z0-9]+\-[A-z0-9_-]{6}$/.test(m[j])) stringlib = true;
								}
								if (string && stringlib) window.t.push(m);
							}
							if (m && typeof m == "object" && m.default && typeof m.default == "object" && !BDFDB.ArrayUtils.is(m.default) && Object.keys(m.default).length) {
								var string = true, stringlib = false;
								for (let j in m.default) {
									if (typeof m.default[j] != "string") string = false;
									if (typeof m.default[j] == "string" && /^[A-z0-9]+\-[A-z0-9_-]{6}$/.test(m.default[j])) stringlib = true;
								}
								if (string && stringlib) window.t.push(m.default);
							}
						}
						console.clear();
						console.log(window.t);
					};
					BDFDB.DevUtils.listen = function (strings) {
						strings = BDFDB.ArrayUtils.is(strings) ? strings : Array.from(arguments);
						BDFDB.DevUtils.listenStop();
						BDFDB.DevUtils.listen.p = BDFDB.PatchUtils.patch("WebpackSearch", BDFDB.ModuleUtils.findByProperties(strings), strings[0], {after: e => {
							console.log(e);
						}});
					};
					BDFDB.DevUtils.listenStop = function () {
						if (typeof BDFDB.DevUtils.listen.p == "function") BDFDB.DevUtils.listen.p();
					};
					BDFDB.DevUtils.generateLanguageStrings = function (strings, config = {}) {
						const language = config.language || "en";
						const languages = BDFDB.ArrayUtils.removeCopies(BDFDB.ArrayUtils.is(config.languages) ? config.languages : ["en"].concat(Object.keys(BDFDB.ObjectUtils.filter(BDFDB.LanguageUtils.languages, n => n.discord))).filter(n => !n.startsWith("en-") && !n.startsWith("$") && n != language)).sort();
						let translations = {};
						strings = BDFDB.ObjectUtils.sort(strings);
						const stringKeys = Object.keys(strings);
						translations[language] = BDFDB.ObjectUtils.toArray(strings);
						let text = Object.keys(translations[language]).map(k => translations[language][k]).join("\n\n");
						
						let gt = (lang, callback) => {
							let googleTranslateWindow = BDFDB.WindowUtils.open(BDFDB, `https://translate.google.com/#${language}/${{"zh": "zh-CN", "pt-BR": "pt"}[lang] || lang}/${encodeURIComponent(text)}`, {
								onLoad: _ => {
									googleTranslateWindow.executeJavaScriptSafe(`
										let count = 0, interval = setInterval(_ => {
											count++;
											let translation = Array.from(document.querySelectorAll("[data-language-to-translate-into] span:not([class])")).map(n => n.innerText).join("");
											if (translation || count > 50) {
												clearInterval(interval);
												require("electron").ipcRenderer.sendTo(${LibraryRequires.electron.remote.getCurrentWindow().webContents.id}, "BDFDB-translation", [
													translation,
													(document.querySelector("h2 ~ [lang]") || {}).lang
												]);
											}
										}, 100);
									`);
								}
							});
							BDFDB.WindowUtils.addListener(BDFDB, "BDFDB-translation", (event, messageData) => {
								BDFDB.WindowUtils.close(googleTranslateWindow);
								BDFDB.WindowUtils.removeListener(BDFDB, "BDFDB-translation");
								callback(messageData[0]);
							});
						};
						let gt2 = (lang, callback) => {
							BDFDB.LibraryRequires.request(`https://translate.googleapis.com/translate_a/single?client=gtx&sl=${language}&tl=${lang}&dt=t&dj=1&source=input&q=${encodeURIComponent(text)}`, (error, response, result) => {
								if (!error && result && response.statusCode == 200) {
									try {callback(JSON.parse(result).sentences.map(n => n && n.trans).filter(n => n).join(""));}
									catch (err) {callback("");}
								}
								else {
									if (response.statusCode == 429) {
										BDFDB.NotificationUtils.toast("Too many requests, switching to backup", {
											type: "danger"
										});
										config.useBackup = true;
										BDFDB.DevUtils.generateLanguageStrings(strings, config);
									}
									else {
										BDFDB.NotificationUtils.toast("Failed to translate text", {
											type: "danger"
										});
										callback("");
									}
								}
							});
						};
						let fails = 0, next = lang => {
							if (!lang) {
								let formatTranslation = (l, s, i) => {
									l = l == "en" ? "default" : l;
									return config.cached && config.cached[l] && config.cached[l][stringKeys[i]] || (translations[language][i][0] == translations[language][i][0].toUpperCase() ? LibraryModules.StringUtils.upperCaseFirstChar(s) : s);
								};
								let format = config.asObject ? ((l, isNotFirst) => {
									return `${isNotFirst ? "," : ""}\n\t\t"${l == "en" ? "default" : l}": {${translations[l].map((s, i) => `\n\t\t\t"${stringKeys[i]}": "${formatTranslation(l, s, i)}"`).join(",")}\n\t\t}`;
								}) : ((l, isNotFirst) => {
									return `\n\t\t\t\t\t${l == "en" ? "default" : `case "${l}"`}:${l.length > 2 ? "\t" : "\t\t"}// ${BDFDB.LanguageUtils.languages[l].name}\n\t\t\t\t\t\treturn {${translations[l].map((s, i) => `\n\t\t\t\t\t\t\t${stringKeys[i]}:${"\t".repeat(10 - ((stringKeys[i].length + 2) / 4))}"${formatTranslation(l, s, i)}"`).join(",")}\n\t\t\t\t\t\t};`;
								});
								let result = Object.keys(translations).filter(n => n != "en").sort().map((l, i) => format(l, i)).join("");
								if (translations.en) result += format("en", result ? 1 : 0);
								BDFDB.NotificationUtils.toast("Translation copied to clipboard", {
									type: "success"
								});
								BDFDB.LibraryRequires.electron.clipboard.write({text: result});
							}
							else (config.useBackup ? gt : gt2)(lang, translation => {
								BDFDB.LogUtils.log(lang);
								if (!translation) {
									console.warn("no translation");
									fails++;
									if (fails > 10) console.error("skipped language");
									else languages.unshift(lang);
								}
								else {
									fails = 0;
									translations[lang] = translation.split("\n\n");
								}
								next(languages.shift());
							});
						};
						next(languages.shift());
					};
					BDFDB.DevUtils.req = InternalBDFDB.getWebModuleReq();
					
					window.BDFDB = BDFDB;
				}
				
				for (let obj in DiscordObjects) if (!DiscordObjects[obj]) {
					DiscordObjects[obj] = function () {};
					BDFDB.DiscordObjects[obj] = function () {};
				}
				for (let component in InternalComponents.NativeSubComponents) if (!InternalComponents.NativeSubComponents[component]) InternalComponents.NativeSubComponents[component] = "div";
				for (let component in InternalComponents.LibraryComponents) if (!InternalComponents.LibraryComponents[component]) {
					InternalComponents.LibraryComponents[component] = "div";
					BDFDB.LibraryComponents[component] = "div";
				}
				
				if (!document.querySelector("head #bd-stylesheet")) BDFDB.DOMUtils.appendWebStyle("https://rauenzi.github.io/BetterDiscordApp/src/styles/index.css");
				if (css) BDFDB.DOMUtils.appendLocalStyle("BDFDB", css.replace(/[\n\t\r]/g, "").replace(/\[REPLACE_CLASS_([A-z0-9_]+?)\]/g, function(a, b) {return BDFDB.dotCN[b];}));
			
				BDFDB.LogUtils.log("Finished loading Library");
				
				window.BDFDB_Global = Object.assign({
					started: true,
					loaded: true,
					PluginUtils: {
						buildPlugin: BDFDB.PluginUtils.buildPlugin,
						cleanUp: BDFDB.PluginUtils.cleanUp
					}
				}, config);
				
				while (PluginStores.delayed.loads.length) PluginStores.delayed.loads.shift().load();
				while (PluginStores.delayed.starts.length) PluginStores.delayed.starts.shift().start();
				while (pluginQueue.length) {
					let pluginName = pluginQueue.shift();
					if (pluginName) BDFDB.TimeUtils.timeout(_ => BDFDB.BDUtils.reloadPlugin(pluginName));
				}
			}, "Could not initiate Library!"));
		});
	};
	loadLibrary(true);
	
	return class BDFDB_Frame {
		getName () {return config.info.name;}
		getAuthor () {return config.info.author;}
		getVersion () {return config.info.version;}
		getDescription () {return config.info.description;}
		
		load () {
			this.loaded = true;
			libraryInstance = this;
			Object.assign(this, config.info, BDFDB.ObjectUtils.exclude(config, "info"));
			if (!BDFDB.BDUtils.isPluginEnabled(config.info.name)) BDFDB.BDUtils.enablePlugin(config.info.name);
		}
		start () {
			if (!this.loaded) this.load();
		}
		stop () {
			if (!BDFDB.BDUtils.isPluginEnabled(config.info.name)) BDFDB.BDUtils.enablePlugin(config.info.name);
		}
		
		getSettingsPanel (collapseStates = {}) {
			let settingsPanel;
			let getString = (type, key, property) => {
				return BDFDB.LanguageUtils.LibraryStringsCheck[`settings_${key}_${property}`] ? BDFDB.LanguageUtils.LibraryStringsFormat(`settings_${key}_${property}`, BDFDB.BDUtils.getSettingsProperty("name", BDFDB.BDUtils.settingsIds[key]) || LibraryModules.StringUtils.upperCaseFirstChar(key.replace(/([A-Z])/g, " $1"))) : InternalBDFDB.defaults[type][key][property];
			};
			return settingsPanel = BDFDB.PluginUtils.createSettingsPanel(BDFDB, {
				collapseStates: collapseStates,
				children: _ => {
					let settingsItems = [];
					
					for (let key in InternalBDFDB.settings.choices) settingsItems.push(BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SettingsSaveItem, {
						type: "Select",
						plugin: InternalBDFDB,
						keys: ["choices", key],
						label: getString("choices", key, "description"),
						note: getString("choices", key, "note"),
						basis: "50%",
						value: InternalBDFDB.settings.choices[key],
						options: Object.keys(LibraryConstants[InternalBDFDB.defaults.choices[key].items] || {}).map(p => ({
							value: p,
							label: BDFDB.LanguageUtils.LibraryStrings[p] || p
						})),
						searchable: true
					}));
					for (let key in InternalBDFDB.settings.general) {
						let nativeSetting = BDFDB.BDUtils.settingsIds[key] && BDFDB.BDUtils.getSettings(BDFDB.BDUtils.settingsIds[key]);
						let disabled = typeof InternalBDFDB.defaults.general[key].isDisabled == "function" && InternalBDFDB.defaults.general[key].isDisabled({
							value: InternalBDFDB.settings.general[key],
							nativeValue: nativeSetting
						});
						let hidden = typeof InternalBDFDB.defaults.general[key].isHidden == "function" && InternalBDFDB.defaults.general[key].isHidden({
							value: InternalBDFDB.settings.general[key],
							nativeValue: nativeSetting
						});
						if (!hidden) settingsItems.push(BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SettingsSaveItem, {
							type: "Switch",
							plugin: InternalBDFDB,
							disabled: disabled,
							keys: ["general", key],
							label: getString("general", key, "description"),
							note: (typeof InternalBDFDB.defaults.general[key].hasNote == "function" ? InternalBDFDB.defaults.general[key].hasNote({
								value: InternalBDFDB.settings.general[key],
								nativeValue: nativeSetting,
								disabled: disabled
							}) : InternalBDFDB.defaults.general[key].hasNote) && getString("general", key, "note"),
							value: (typeof InternalBDFDB.defaults.general[key].getValue == "function" ? InternalBDFDB.defaults.general[key].getValue({
								value: InternalBDFDB.settings.general[key],
								nativeValue: nativeSetting,
								disabled: disabled
							}) : true) && (InternalBDFDB.settings.general[key] || nativeSetting)
						}));
					}
					settingsItems.push(BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SettingsItem, {
						type: "Button",
						label: BDFDB.LanguageUtils.LibraryStrings.update_check_info,
						dividerTop: true,
						basis: "20%",
						children: BDFDB.LanguageUtils.LibraryStrings.check_for_updates,
						labelChildren: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.Clickable, {
							children: BDFDB.ReactUtils.createElement(InternalComponents.LibraryComponents.SvgIcon, {
								name: InternalComponents.LibraryComponents.SvgIcon.Names.QUESTIONMARK,
								width: 20,
								height: 20,
								onClick: _ => BDFDB.ModalUtils.open(InternalBDFDB, {
									header: "Plugins",
									subHeader: "",
									contentClassName: BDFDB.disCN.marginbottom20,
									text: BDFDB.ObjectUtils.toArray(Object.assign({}, window.PluginUpdates && window.PluginUpdates.plugins, PluginStores.updateData.plugins)).map(p => p.name).filter(n => n).sort().join(", ")
								})
							})
						}),
						onClick: _ => {
							let loadingString = `${BDFDB.LanguageUtils.LanguageStrings.CHECKING_FOR_UPDATES} - ${BDFDB.LanguageUtils.LibraryStrings.please_wait}`;
							let currentLoadingString = loadingString;
							let toastInterval, toast = BDFDB.NotificationUtils.toast(loadingString, {
								type: "info",
								timeout: 0,
								onClose: _ => {BDFDB.TimeUtils.clear(toastInterval);}
							});
							toastInterval = BDFDB.TimeUtils.interval(_ => {
								currentLoadingString = currentLoadingString.endsWith(".....") ? loadingString : currentLoadingString + ".";
								toast.update(currentLoadingString);
							}, 500);
							BDFDB.PluginUtils.checkAllUpdates().then(outdated => {
								toast.close();
								if (outdated > 0) BDFDB.NotificationUtils.toast(BDFDB.LanguageUtils.LibraryStringsFormat("update_check_complete_outdated", outdated), {
									type: "danger"
								});
								else BDFDB.NotificationUtils.toast(BDFDB.LanguageUtils.LibraryStrings.update_check_complete, {
									type: "success"
								});
							});
						}
					}));
					
					return settingsItems;
				}
			});
		}
	}
})();
{
	"PluginNameMap": {
		"OwnerTag": "StaffTag"
	},
	"LibraryRequires": ["child_process", "electron", "fs", "path", "process", "request"],
	"DiscordObjects": {
		"Channel": {"props": ["getRecipientId", "isManaged", "getGuildId"]},
		"Guild": {"props": ["getIconURL", "getMaxEmojiSlots", "getRole"]},
		"Invite": {"props": ["getExpiresAt", "isExpired"]},
		"Message": {"props": ["getReaction", "isEdited", "getChannelId"]},
		"Messages": {"props": ["jumpToMessage", "hasAfterCached", "forEach"]},
		"Relationship": {"protos": ["comparator"], "array": true},
		"Timestamp": {"props": ["add", "dayOfYear", "hasAlignedHourOffset"]},
		"User": {"props": ["hasFlag", "isLocalBot", "isClaimed"]}
	},
	"LibraryModules": {
		"AckUtils": {"props": ["localAck", "bulkAck"]},
		"ActivityUtils": {"props": ["sendActivityInvite", "updateActivity"]},
		"APIEncodeUtils": {"props": ["stringify", "parse", "encode"]},
		"APIUtils": {"props": ["getAPIBaseURL"]},
		"AnalyticsUtils": {"props": ["isThrottled", "track"]},
		"AnimationUtils": {"props": ["spring", "decay"]},
		"ArrayUtils": {"props": ["isArrayLike", "zipObject"]},
		"AssetUtils": {"props": ["getAssetImage", "getAssetIds"]},
		"AutocompleteOptions": {"props": ["AUTOCOMPLETE_OPTIONS"]},
		"AutocompleteSentinels": {"props": ["CHANNEL_SENTINEL", "COMMAND_SENTINEL"]},
		"BadgeUtils": {"props": ["getBadgeCountString", "getBadgeWidthForValue"]},
		"CallUtils": {"props": ["getCalls", "isCallActive"]},
		"CategoryCollapseStore": {"props": ["getCollapsedCategories", "isCollapsed"]},
		"CategoryCollapseUtils": {"props": ["categoryCollapse", "categoryCollapseAll"]},
		"ChannelIconUtils": {"props": ["getChannelIconComponent", "getChannelIconTooltipText"]},
		"ChannelUtils": {"props": ["selectChannel", "selectPrivateChannel"]},
		"ChannelStore": {"props": ["getChannel", "getDMFromUserId"]},
		"ColorUtils": {"props": ["hex2int", "hex2rgb"]},
		"ConnectionStore": {"props": ["getAccounts", "getLocalAccounts"]},
		"ConnectionUtils": {"props": ["setShowActivity", "setVisibility"]},
		"ContextMenuUtils": {"props": ["closeContextMenu", "openContextMenu"]},
		"CopyLinkUtils": {"props": ["SUPPORTS_COPY", "copy"]},
		"CurrentUserStore": {"props": ["getCurrentUser"]},
		"CurrentVoiceUtils": {"props": ["getAveragePing", "isConnected"]},
		"CustomStatusConstants": {"props": ["ClearAfterValues", "STATUS_MAX_LENGTH"]},
		"DesktopNotificationUtils": {"props": ["showNotification", "requestPermission"]},
		"DirectMessageStore": {"props": ["getPrivateChannelIds"]},
		"DirectMessageUnreadStore": {"props": ["getUnreadPrivateChannelIds"]},
		"DispatchApiUtils": {"props": ["dirtyDispatch", "isDispatching"]},
		"DispatchUtils": {"props": ["ComponentDispatch"]},
		"DirectMessageUtils": {"props": ["addRecipient", "openPrivateChannel"]},
		"EmojiUtils": {"props": ["translateInlineEmojiToSurrogates", "translateSurrogatesToInlineEmoji"]},
		"EmojiStateUtils": {"props": ["getURL", "isEmojiDisabled"]},
		"FriendUtils": {"props": ["getFriendIDs", "getRelationships"]},
		"FolderStore": {"props": ["getGuildFolderById", "getFlattenedGuilds"]},
		"FolderUtils": {"props": ["isFolderExpanded", "getExpandedFolders"]},
		"GuildBoostUtils": {"props": ["getTierName", "getUserLevel"]},
		"GuildChannelKeys": {"props": ["GUILD_SELECTABLE_CHANNELS_KEY", "GUILD_VOCAL_CHANNELS_KEY"]},
		"GuildChannelStore": {"props": ["getChannels", "getDefaultChannel"]},
		"GuildEmojiStore": {"props": ["getGuildEmoji", "getDisambiguatedEmojiContext"]},
		"GuildNotificationsUtils": {"props": ["updateChannelOverrideSettings", "updateGuildNotificationSettings"]},
		"GuildSettingsSectionUtils": {"props": ["getGuildSettingsSections"]},
		"GuildSettingsUtils": {"props": ["open", "updateGuild"]},
		"GuildStore": {"props": ["getGuild", "getGuilds"]},
		"GuildUnavailableStore": {"props": ["isUnavailable", "totalUnavailableGuilds"]},
		"GuildUtils": {"props": ["selectGuild", "transitionToGuildSync"]},
		"GuildWelcomeStore": {"props": ["hasSeen", "get"]},
		"GuildWelcomeUtils": {"props": ["welcomeScreenViewed", "resetWelcomeScreen"]},
		"HistoryUtils": {"props": ["transitionTo", "replaceWith", "getHistory"]},
		"IconUtils": {"props": ["getGuildIconURL", "getGuildBannerURL"]},
		"ImageEditUtils": {"props": ["getPrimaryColorForAvatar", "getRatio"]},
		"InviteUtils": {"props": ["acceptInvite", "createInvite"]},
		"KeyCodeUtils": {"props": ["toCombo", "keyToCode"], "assign": true},
		"KeyEvents": {"props": ["aliases", "code", "codes"]},
		"LanguageStore": {"props": ["getLanguages", "Messages"]},
		"LastChannelStore": {"props": ["getLastSelectedChannelId"]},
		"LastGuildStore": {"props": ["getLastSelectedGuildId"]},
		"LinkUtils": {"props": ["handleClick", "isLinkTrusted"]},
		"LocalSettingsStore": {"props": ["darkSidebar", "keyboardModeEnabled"]},
		"LoginUtils": {"props": ["login", "logout"]},
		"MediaDeviceUtils": {"props": ["getOutputDevices", "getInputDevices"]},
		"MediaDeviceSetUtils": {"props": ["setOutputDevice", "setInputDevice"]},
		"MemberCountUtils": {"props": ["getMemberCount", "getMemberCounts"]},
		"MemberStore": {"props": ["getMember", "getMembers"]},
		"MentionUtils": {"props": ["isRawMessageMentioned", "isMentioned"]},
		"MessageAuthorUtils": {"props": ["getMessageAuthor", "useNullableMessageAuthor"]},
		"MessageManageUtils": {"props": ["copyLink", "replyToMessage"]},
		"MessagePinUtils": {"props": ["pinMessage", "unpinMessage"]},
		"MessageReplyStore": {"props": ["getPendingReply"]},
		"MessageReplyUtils": {"props": ["createPendingReply", "deletePendingReply"]},
		"MessageStore": {"props": ["getMessage", "getMessages"]},
		"MessageUtils": {"props": ["receiveMessage", "editMessage"]},
		"ModalUtils": {"props": ["openModal", "hasModalOpen"]},
		"MutedUtils": {"props": ["isGuildOrCategoryOrChannelMuted"]},
		"NoteStore": {"props": ["getNote"]},
		"NotificationSettingsStore": {"props": ["getDesktopType", "getTTSType"]},
		"NotificationSettingsUtils": {"props": ["setDesktopType", "setTTSType"]},
		"NotificationUtils": {"props": ["makeTextChatNotification", "shouldNotify"]},
		"PlatformUtils": {"props": ["isWindows", "isLinux"]},
		"PermissionUtils": {"props": ["getChannelPermissions", "can"]},
		"PermissionRoleUtils": {"props": ["canEveryone", "can"]},
		"PreferencesContext": {"props": ["AccessibilityPreferencesContext"]},
		"QueryUtils": {"props": ["AutocompleterQuerySymbols", "AutocompleterResultTypes"]},
		"ReactionEmojiUtils": {"props": ["getReactionEmojiName", "getReactionEmojiName"]},
		"ReactionUtils": {"props": ["addReaction", "removeReaction"]},
		"RecentMentionUtils": {"props": ["deleteRecentMention", "fetchRecentMentions"]},
		"RelationshipStore": {"props": ["getFriendIDs", "getRelationships"]},
		"RelationshipUtils": {"props": ["addRelationship", "removeRelationship"]},
		"SearchPageUtils": {"props": ["searchNextPage", "searchPreviousPage"]},
		"SettingsStore": {"props": ["guildPositions", "theme"]},
		"SettingsUtils": {"props": ["updateRemoteSettings", "updateLocalSettings"]},
		"SimpleMarkdownParser": {"props": ["parseBlock", "parseInline", "defaultOutput"]},
		"SlateUtils": {"props": ["serialize", "deserialize"], "notProps": ["getFlag"]},
		"SlateSelectionUtils": {"props": ["serialize", "serializeSelection"]},
		"SlowmodeUtils": {"props": ["getSlowmodeCooldownGuess"]},
		"SoundStateUtils": {"props": ["isSoundDisabled", "getDisabledSounds"]},
		"SoundUtils": {"props": ["playSound", "createSound"]},
		"SpellCheckStore": {"strings": ["SPELLCHECK_LEARN_WORD", "isEnabled"], "value": "default"},
		"SpellCheckUtils": {"props": ["learnWord", "toggleSpellcheck"]},
		"SpotifyTrackUtils": {"props": ["hasConnectedAccount", "getLastPlayedTrackId"]},
		"SpotifyUtils": {"props": ["setActiveDevice", "pause"]},
		"StageChannelLiveStore": {"props": ["getAllLiveStageChannels", "useAllLiveStageChannels"]},
		"StageChannelStore": {"props": ["getStageInstanceByChannel", "getAllStageInstances"]},
		"StateStoreUtils": {"props": ["useStateFromStores", "useStateFromStoresArray"]},
		"StatusMetaUtils": {"props": ["getApplicationActivity", "getStatus"]},
		"StoreChangeUtils": {"props": ["get", "set", "clear", "remove"]},
		"StreamerModeStore": {"props": ["disableSounds", "hidePersonalInformation"]},
		"StreamUtils": {"props": ["getActiveStreamForUser", "getAllApplicationStreams"]},
		"StringUtils": {"props": ["cssValueToNumber", "upperCaseFirstChar"]},
		"TimestampUtils": {"props": ["fromTimestamp", "extractTimestamp"]},
		"TimeUtils": {"props": ["calendarFormat", "dateFormat"]},
		"UnreadGuildUtils": {"props": ["hasUnread", "getUnreadGuilds"]},
		"UnreadChannelUtils": {"props": ["getUnreadCount", "getOldestUnreadMessageId"]},
		"UploadUtils": {"props": ["upload", "instantBatchUpload"]},
		"URLParser": {"props": ["parse", "resolveObject"]},
		"UserFetchUtils": {"props": ["fetchCurrentUser", "getUser"]},
		"UserNameUtils": {"props": ["getName", "getNickname"]},
		"UserProfileUtils": {"props": ["open", "fetchProfile"]},
		"UserSettingsUtils": {"props": ["open", "updateAccount"]},
		"UserStore": {"props": ["getUser", "getUsers"]},
		"Utilities": {"props": ["flatMap", "cloneDeep"]},
		"VoiceChannelUtils": {"props": ["isFullscreenInContext", "getParticipants"]},
		"VoiceUtils": {"props": ["getAllVoiceStates", "getVoiceStatesForChannel"]},
		"WindowUtils": {"props": ["minimize", "maximize", "close"]},
		"ZoomUtils": {"props": ["setZoom", "setFontSize"]}
	},
	"ModuleUtilsConfig": {
		"PatchTypes": [
			"before",
			"instead",
			"after"
		],
		"InstanceFunctions": [
			"render",
			"componentDidMount",
			"componentDidUpdate",
			"componentWillUnmount"
		],
		"PatchMap": {
			"AuditLogs": "GuildSettingsAuditLog",
			"BannedCard": "BannedUser",
			"ChannelWindow": "Channel",
			"InvitationCard": "InviteRow",
			"InviteCard": "InviteRow",
			"MemberCard": "Member",
			"PopoutContainer": "Popout",
			"QuickSwitchResult": "Result",
			"UserProfile": "UserProfileBody"
		},
		"ForceObserve": [
			"DirectMessage",
			"GuildIcon"
		],
		"MemoComponent": [],
		"SubRender": [],
		"NonPrototype": [],
		"Finder": {
			"Account": {"class": "accountinfo"},
			"App": {"class": "app"},
			"AppSkeleton": {"class": "app"},
			"AuditLogs": {"class": "auditlog"},
			"AuthWrapper": {"class": "loginscreen"},
			"Avatar": {"props": ["AnimatedAvatar"]},
			"BannedCard": {"class": "guildsettingsbannedcard"},
			"Category": {"class": "categorycontainerdefault"},
			"ChannelCall": {"class": "callcurrentcontainer"},
			"ChannelCategoryItem": {"strings": ["muted", "channel", "collapsed"], "exported": true},
			"ChannelMember": {"class": "member"},
			"ChannelMembers": {"class": "members"},
			"Channels": {"class": "guildchannels"},
			"ChannelTextAreaForm": {"class": "chatform"},
			"ChannelWindow": {"class": "chatcontent"},
			"ChatMessage": {"strings": ["childrenMessageContent", "childrenRepliedMessage", "message.id"]},
			"CustomStatusModal": {"class": "customstatusmodal"},
			"DirectMessage": {"class": "guildouter"},
			"EmojiPicker": {"strings": ["EMOJI_PICKER_TAB_PANEL_ID", "diversitySelector"]},
			"FocusRing": {"props": ["FocusRingScope"]},
			"GuestHomeButton": {"props": ["GuestHomeButton"]},
			"Guild": {"class": "guildouter"},
			"GuildFolder": {"class": "guildfolderwrapper", "special": [{"path": "return.memoizedProps.folderId"}, {"path": "return.memoizedProps.guildIds"}]},
			"GuildIcon": {"class": "avataricon"},
			"GuildRoleSettings": {"class": "settingswindowcontentregion"},
			"Guilds": {"class": "guildswrapper"},
			"GuildSettings": {"class": "layer"},
			"GuildSettingsBans": {"class": "guildsettingsbannedcard"},
			"GuildSettingsEmoji": {"class": "guildsettingsemojicard"},
			"GuildSettingsMembers": {"class": "guildsettingsmembercard"},
			"GuildSidebar": {"class": "guildchannels"},
			"I18nLoaderWrapper": {"class": "app"},
			"InstantInviteModal": {"class": "invitemodalwrapper"},
			"InvitationCard": {"class": "invitemodalinviterow"},
			"InviteGuildName": {"props": ["GuildName", "GuildTemplateName"]},
			"InviteCard": {"class": "guildsettingsinvitecard"},
			"MemberCard": {"class": "guildsettingsmembercard"},
			"MemberRoles": {"props": ["MemberRole"]},
			"Message": {"strings": ["childrenMessageContent", "childrenRepliedMessage", "zalgo"]},
			"MessageHeader": {"strings": ["ANIMATE_CHAT_AVATAR", "showUsernamePopout"]},
			"Messages": {"strings": ["group-spacing-", "canManageMessages"]},
			"MessageUsername": {"strings": ["default.username", "colorString", "compact"]},
			"ModalLayer": {"class": "layermodal"},
			"MutualGuilds": {"class": "userprofilebody"},
			"MutualFriends": {"class": "userprofilebody"},
			"Note": {"class": "usernotetextarea"},
			"PopoutContainer": {"class": "popout"},
			"Popouts": {"class": "popouts"},
			"PrivateChannelCall": {"class": "callcurrentcontainer"},
			"PrivateChannelCallParticipants": {"class": "callcurrentcontainer"},
			"PrivateChannelRecipientsInvitePopout": {"class": "searchpopoutdmaddpopout"},
			"PrivateChannelsList": {"class": "dmchannelsscroller"},
			"QuickSwitchChannelResult": {"class": "quickswitchresult"},
			"QuickSwitchGuildResult": {"class": "quickswitchresult"},
			"QuickSwitchResult": {"class": "quickswitchresult"},
			"Reaction": {"class": "messagereactionme"},
			"Reactor": {"class": "messagereactionsmodalreactor"},
			"ReactorsComponent": {"class": "messagereactionsmodalreactor"},
			"RichChannelMention": {"props": ["ChannelMention"]},
			"RichUserMention": {"props": ["UserMention"]},
			"RTCConnection": {"class": "voicedetails"},
			"SearchResults": {"class": "searchresultswrap"},
			"SearchResultsInner": {"strings": ["SEARCH_HIDE_BLOCKED_MESSAGES", "totalResults", "SEARCH_PAGE_SIZE"]},
			"StandardSidebarView": {"class": "settingswindowstandardsidebarview"},
			"TypingUsers": {"class": "typing"},
			"UnavailableGuildsButton": {"props": ["UnavailableGuildsButton"]},
			"UnreadDMs": {"class": "guildsscroller"},
			"Upload": {"class": "uploadmodal"},
			"UserHook": {"class": "auditloguserhook"},
			"UserPopout": {"class": "userpopout"},
			"UserProfile": {"class": "userprofile"},
			"UserSettingsAppearance": {"class": "usersettingsappearancepreview"},
			"V2C_ContentColumn": {"class": "settingswindowcontentcolumn", "special": [{"path": "return.stateNode.props.title", "value": ["PLUGINS", "THEMES"]}]}
		},
		"LoadedInComponents": {
			"AutocompleteChannelResult": "LibraryComponents.AutocompleteItems.Channel",
			"AutocompleteUserResult": "LibraryComponents.AutocompleteItems.User",
			"QuickSwitchChannelResult": "LibraryComponents.QuickSwitchItems.Channel",
			"QuickSwitchGroupDMResult": "LibraryComponents.QuickSwitchItems.GroupDM",
			"QuickSwitchGuildResult": "LibraryComponents.QuickSwitchItems.Guild",
			"QuickSwitchUserResult": "LibraryComponents.QuickSwitchItems.User"
		}
	},
	"NativeSubComponents": {
		"Button": {"props": ["Colors", "Hovers", "Looks"]},
		"Checkbox": {"name": "Checkbox"},
		"Clickable": {"name": "Clickable"},
		"FavButton": {"name": "GIFFavButton"},
		"KeybindRecorder": {"name": "KeybindRecorder"},
		"MenuCheckboxItem": {"name": "MenuCheckboxItem"},
		"MenuControlItem": {"name": "MenuControlItem"},
		"MenuItem": {"name": "MenuItem"},
		"PopoutContainer": {"name": "Popout"},
		"QuickSelect": {"name": "QuickSelectWrapper"},
		"RadioGroup": {"name": "RadioGroup"},
		"SearchBar": {"name": "SearchBar", "protos": ["focus"]},
		"SearchableSelect": {"name": "SearchableSelect"},
		"Select": {"name": "SelectTempWrapper"},
		"Slider": {"name": "Slider"},
		"Switch": {"name": "Switch"},
		"TabBar": {"name": "TabBar"},
		"Table": {"name": "Table"},
		"TextArea": {"name": "TextArea"},
		"TextInput": {"name": "TextInput"},
		"TooltipContainer": {"name": "Tooltip"}
	},
	"LibraryComponents": {
		"Anchor": {"name": "Anchor"},
		"Animations": {"props": ["Controller", "Spring"], "assign": true},
		"AutocompleteItems": {"props": ["Generic", "User", "Command"]},
		"AutocompleteMenu": {"name": "Autocomplete"},
		"AvatarComponents": {"props": ["AnimatedAvatar"]},
		"Badges": {"props": ["IconBadge", "NumberBadge"], "assign": true},
		"CardRemoveButton": {"name": "RemoveButton"},
		"Checkmark": {"name": "Checkmark"},
		"Connectors": {"props": ["Router", "Link"], "assign": true},
		"DiscordTag": {"name": "DiscordTag"},
		"Emoji": {"strings": ["emojiName", "shouldAnimate", "jumboable"], "value": "default"},
		"EmojiButton": {"name": "EmojiButton"},
		"EmojiPicker": {"strings": ["EMOJI_PICKER_TAB_PANEL_ID", "diversitySelector"]},
		"Flex": {"props": ["Wrap", "Direction", "Child"]},
		"FlowerStarIcon": {"name": "FlowerStarIcon"},
		"FocusRingScope": {"props": ["FocusRingScope"], "value": "default"},
		"FormComponents": {"props": ["FormSection", "FormText"], "assign": true},
		"GuildComponents Badge": {"name": "GuildBadge"},
		"GuildComponents BlobMask": {"name": "BlobMask"},
		"GuildComponents Icon": {"name": "GuildIconWrapper"},
		"GuildComponents Items": {"props": ["Separator", "DragPlaceholder"]},
		"GuildComponents MutedText": {"props": ["useMutedUntilText"], "value": "default"},
		"GuildComponents Pill": {"strings": ["opacity:1,height:", "20:8", "default.item"]},
		"HeaderBarComponents": {"name": "HeaderBarContainer"},
		"Image": {"props": ["ImageReadyStates"]},
		"ImageModal": {"name": "ImageModal"},
		"LazyImage": {"name": "LazyImage"},
		"ListHeader": {"name": "ListSectionItem"},
		"Mask": {"name": "Mask"},
		"Menu": {"name": "Menu"},
		"MenuItems": {"props": ["MenuItem", "MenuGroup"], "assign": true},
		"MenuItems Colors": {"props": ["MenuItemColor"], "value": "MenuItemColor"},
		"MessageGroup": {"name": "ChannelMessage"},
		"MessagesPopoutComponents": {"props": ["Header", "EmptyStateBottom"]},
		"ModalComponents": {"props": ["ModalContent", "ModalFooter"], "assign": true},
		"NavItem": {"name": "NavItem"},
		"Paginator": {"name": "Paginator"},
		"PanelButton": {"name": "PanelButton"},
		"PopoutCSSAnimator": {"name": "PopoutCSSAnimator"},
		"PopoutFocusLock": {"strings": ["useFocusLock", "useImperativeHandle"]},
		"PrivateChannelItems": {"props": ["DirectMessage", "GroupDM"]},
		"QuickSwitchItems": {"props": ["Channel", "GroupDM", "Header"]},
		"QuickSwitchMenu": {"name": "QuickSwitcher"},
		"Scrollers Auto": {"props": ["AdvancedScrollerThin", "AdvancedScrollerAuto"], "value": "AdvancedScrollerAuto"},
		"Scrollers None": {"props": ["AdvancedScrollerThin", "AdvancedScrollerAuto"], "value": "AdvancedScrollerNone"},
		"Scrollers Thin": {"props": ["AdvancedScrollerThin", "AdvancedScrollerAuto"], "value": "AdvancedScrollerThin"},
		"Spinner": {"name": "Spinner"},
		"Status": {"name": "Status"},
		"StatusPickerPopout": {"strings": ["\"StatusPickerPopout\""], "value": "default"},
		"TextElement": {"name": "Text"},
		"UserBadges": {"props": ["BadgeSizes"]},
		"UserBadgesKeys": {"props": ["BadgeKeys"], "value": "BadgeKeys"},
		"UserPopout": {"name": "ConnectedUserPopout"},
		"UserSummaryItem": {"name": "UserSummaryItem"},
		"VideoForwardRef": {"strings": ["displayName=\"Video\"", "\"video\"", "HTMLImageElement"], "value": "default"}
	},
	"SvgIcons": {
		"ACTIVITY": {
			"defaultProps": {
				"width": 16,
				"height": 16
			},
			"icon": "<svg name='Activity' width='%%width' height='%%height' viewBox='0 0 16 16'><path fill='%%color' d='M6,7 L2,7 L2,6 L6,6 L6,7 Z M8,5 L2,5 L2,4 L8,4 L8,5 Z M8,3 L2,3 L2,2 L8,2 L8,3 Z M8.88888889,0 L1.11111111,0 C0.494444444,0 0,0.494444444 0,1.11111111 L0,8.88888889 C0,9.50253861 0.497461389,10 1.11111111,10 L8.88888889,10 C9.50253861,10 10,9.50253861 10,8.88888889 L10,1.11111111 C10,0.494444444 9.5,0 8.88888889,0 Z' transform='translate(3 3)'/></svg>"
		},
		"ACTIVITY_DISABLED": {
			"defaultProps": {
				"width": 16,
				"height": 16,
				"foreground": 16
			},
			"icon": "<svg name='ActivityDisabled' aria-hidden='false' width='%%width' height='%%height' viewBox='0 0 16 16'><path fill='%%color' d='M 4.1113281 3 C 3.4946615 3 3 3.4946615 3 4.1113281 L 3 10.46875 L 5.484375 8 L 5 8 L 5 7 L 6.4902344 7 L 7.4980469 6 L 5 6 L 5 5 L 8.5039062 5 L 10.517578 3 L 4.1113281 3 z M 13 5.5390625 L 11 7.5390625 L 11 8 L 10.539062 8 L 9 9.5390625 L 9 10 L 8.5390625 10 L 8.5117188 10.027344 L 5.5195312 13 L 11.888672 13 C 12.502322 13 13 12.502322 13 11.888672 L 13 5.5390625 z'/><path d='M 14,2.8466665 13.153333,1.9999998 2,13.153333 2.846666,14 5.64,11.213333 6.46,10.386667 7.566666,9.2799998 9.993333,6.8533328 Z' class='%%foreground' fill='currentColor'/></svg>"
		},
		"ARROW_DOWN": {
			"defaultProps": {
				"width": 18,
				"height": 18
			},
			"icon": "<svg name='ArrowDown' width='%%width' height='%%height' viewBox='0 0 18 18'><path fill='%%color' d='M4 7l5 5 5-5H4z'/></svg>"
		},
		"ARROW_UP": {
			"defaultProps": {
				"width": 18,
				"height": 18
			},
			"icon": "<svg name='ArrowUp' width='%%width' height='%%height' viewBox='0 0 18 18'><path fill='%%color' d='M4 11l5-5 5 5H4z'/></svg>"
		},
		"BOOST": {
			"defaultProps": {
				"width": 24,
				"height": 24,
				"foreground": ""
			},
			"icon": "<svg name='Boost' width='%%width' height='%%height' viewBox='0 0 8 12'><path class='%%foreground' fill='%%color' d='M4 0L0 4V8L4 12L8 8V4L4 0ZM7 7.59L4 10.59L1 7.59V4.41L4 1.41L7 4.41V7.59Z'/><path class='%%foreground' fill='%%color' d='M2 4.83V7.17L4 9.17L6 7.17V4.83L4 2.83L2 4.83Z'/></svg>"
		},
		"CALENDAR": {
			"icon": "<svg name='Calendar' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' d='M 2 2 C 0.892 2 0 2.892 0 4 L 0 6 L 24 6 L 24 4 C 24 2.892 23.108 2 22 2 L 20 2 L 20 2.4648438 C 20 3.5922824 19.108 4.5 18 4.5 C 16.892 4.5 16 3.5922823 16 2.4648438 L 16 2 L 8 2 L 8 2.4648438 C 8 3.5922824 7.108 4.5 6 4.5 C 4.892 4.5 4 3.5922823 4 2.4648438 L 4 2 L 2 2 z M 0 8 L 0 20 C 0 21.108 0.892 22 2 22 L 22 22 C 23.108 22 24 21.108 24 20 L 24 8 L 0 8 z M 4.0117188 9.5996094 L 6.0371094 9.5996094 C 6.5980344 9.5996094 7.0507812 10.052356 7.0507812 10.613281 L 7.0507812 12.636719 C 7.0507812 13.197644 6.5980344 13.650391 6.0371094 13.650391 L 4.0117188 13.650391 C 3.4507937 13.650391 3 13.197644 3 12.636719 L 3 10.613281 C 3 10.052356 3.4507937 9.5996094 4.0117188 9.5996094 z M 10.988281 9.5996094 L 13.011719 9.5996094 C 13.572644 9.5996094 14.025391 10.052356 14.025391 10.613281 L 14.025391 12.636719 C 14.025391 13.197644 13.572644 13.650391 13.011719 13.650391 L 10.988281 13.650391 C 10.427356 13.650391 9.9746094 13.197644 9.9746094 12.636719 L 9.9746094 10.613281 C 9.9746094 10.052356 10.427356 9.5996094 10.988281 9.5996094 z M 17.962891 9.5996094 L 19.988281 9.5996094 C 20.549206 9.5996094 21 10.052356 21 10.613281 L 21 12.636719 C 21 13.197644 20.549206 13.650391 19.988281 13.650391 L 17.962891 13.650391 C 17.401966 13.650391 16.949219 13.197644 16.949219 12.636719 L 16.949219 10.613281 C 16.949219 10.052356 17.401966 9.5996094 17.962891 9.5996094 z M 4.0117188 15.449219 L 6.0371094 15.449219 C 6.5980344 15.449219 7.0507812 15.901966 7.0507812 16.462891 L 7.0507812 18.488281 C 7.0507812 19.049206 6.5980344 19.5 6.0371094 19.5 L 4.0117188 19.5 C 3.4507937 19.5 3 19.049206 3 18.488281 L 3 16.462891 C 3 15.901966 3.4507938 15.449219 4.0117188 15.449219 z M 10.988281 15.449219 L 13.011719 15.449219 C 13.572644 15.449219 14.025391 15.901966 14.025391 16.462891 L 14.025391 18.488281 C 14.025391 19.049206 13.572644 19.5 13.011719 19.5 L 10.988281 19.5 C 10.427356 19.5 9.9746094 19.049206 9.9746094 18.488281 L 9.9746094 16.462891 C 9.9746094 15.901966 10.427356 15.449219 10.988281 15.449219 z M 17.962891 15.449219 L 19.988281 15.449219 C 20.549206 15.449219 21 15.901966 21 16.462891 L 21 18.488281 C 21 19.049206 20.549206 19.5 19.988281 19.5 L 17.962891 19.5 C 17.401966 19.5 16.949219 19.049206 16.949219 18.488281 L 16.949219 16.462891 C 16.949219 15.901966 17.401966 15.449219 17.962891 15.449219 z'/></svg>"
		},
		"CHANGELOG": {
			"icon": "<svg name='ChangeLog' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' d='M 12.994141,2 C 7.4665894,2 3,6.4779848 3,12 H 1 L 4.0996094,15.408203 7.2226562,12 h -2 c 0,-4.2942525 3.4830736,-7.7773438 7.7773438,-7.7773438 4.294251,0 7.777344,3.4830913 7.777344,7.7773438 0,4.294253 -3.483093,7.779297 -7.777344,7.779297 -2.149914,0 -4.0886771,-0.879641 -5.4941406,-2.285156 L 5.9335938,19.066406 C 7.7390932,20.877425 10.233155,22 12.994141,22 18.521728,22 23,17.522015 23,12 23,6.4779858 18.521728,2 12.994141,2 Z m -1.496094,4.4375 v 6.632812 l 5.675781,3.367188 0.953125,-1.611328 -4.640625,-2.751953 V 6.4375 Z'/></svg>"
		},
		"CHECKBOX": {
			"defaultProps": {
				"background": "",
				"foreground": ""
			},
			"icon": "<svg width='%%width' height='%%height' viewBox='0 0 24 24'><path fill-rule='evenodd' clip-rule='evenodd' d='M5.37499 3H18.625C19.9197 3 21.0056 4.08803 21 5.375V18.625C21 19.936 19.9359 21 18.625 21H5.37499C4.06518 21 3 19.936 3 18.625V5.375C3 4.06519 4.06518 3 5.37499 3Z' class='%%background' fill='%%color'/><path d='M9.58473 14.8636L6.04944 11.4051L4.50003 12.9978L9.58473 18L19.5 8.26174L17.9656 6.64795L9.58473 14.8636Z' class='%%foreground' fill='%%color'/></svg>"
		},
		"CHECKBOX_EMPTY": {
			"defaultProps": {
				"foreground": ""
			},
			"icon": "<svg name='CheckBoxEmpty' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill-rule='evenodd' clip-rule='evenodd' d='M18.625 3H5.375C4.06519 3 3 4.06519 3 5.375V18.625C3 19.936 4.06519 21 5.375 21H18.625C19.936 21 21 19.936 21 18.625V5.375C21.0057 4.08803 19.9197 3 18.625 3ZM19 19V5H4.99999V19H19Z' class='%%foreground' fill='%%color'/></svg>"
		},
		"CHECKMARK": {
			"defaultProps": {
				"width": 18,
				"height": 18
			},
			"icon": "<svg name='Checkmark' width='%%width' height='%%height' viewBox='0 0 18 18'><g fill='none' fill-rule='evenodd'><polyline stroke='%%color' stroke-width='2' points='3.5 9.5 7 13 15 5'></polyline></g></svg>"
		},
		"CHECKMARK_CIRCLE": {
			"icon": "<svg name='CheckmarkCircle' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' d='M 12,1e-7 C 5.376,1e-7 0,5.376 0,12 0,18.624 5.376,24 12,24 18.624,24 24,18.624 24,12 24,5.376 18.624,1e-7 12,1e-7 Z M 9.6,18 l -6,-6 1.692,-1.692 4.308,4.296 9.11,-9.11 1.692,1.704 z'/></svg>"
		},
		"CLOCK": {
			"icon": "<svg name='Clock' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' d='M 12 0 C 8.7946875 0 5.782125 1.2491254 3.515625 3.515625 C 1.249125 5.7821254 0 8.7946875 0 12 C 0 15.205313 1.249125 18.217922 3.515625 20.484375 C 5.782125 22.750828 8.7946875 24 12 24 C 15.205313 24 18.217875 22.750874 20.484375 20.484375 C 22.750875 18.217875 24 15.205313 24 12 C 24 8.7946875 22.750875 5.7820786 20.484375 3.515625 C 18.217875 1.2491254 15.205313 0 12 0 z M 10.75 2.4433594 L 10.75 3.8554688 C 10.75 4.5458054 11.309665 5.1054686 12 5.1054688 C 12.690335 5.1054688 13.25 4.5458054 13.25 3.8554688 L 13.25 2.4472656 C 17.567884 3.0099988 20.991523 6.4336856 21.554688 10.75 L 20.144531 10.75 C 19.454194 10.75 18.894531 11.309664 18.894531 12 C 18.894531 12.690334 19.454194 13.25 20.144531 13.25 L 21.554688 13.25 C 20.991523 17.566315 17.567884 20.990002 13.25 21.552734 L 13.25 20.144531 C 13.25 19.454194 12.690335 18.894531 12 18.894531 C 11.309665 18.894531 10.75 19.454194 10.75 20.144531 L 10.75 21.552734 C 6.4321157 20.990034 3.0084774 17.566319 2.4453125 13.25 L 3.8554688 13.25 C 4.5458057 13.25 5.1054688 12.690335 5.1054688 12 C 5.1054688 11.309665 4.5458057 10.75 3.8554688 10.75 L 2.4453125 10.75 C 3.008225 6.4324405 6.4313845 3.0055795 10.75 2.4433594 z M 7.5429688 6.8457031 C 7.2633181 6.8457031 6.98288 6.9506777 6.7695312 7.1640625 C 6.3427618 7.5908318 6.3427618 8.2842402 6.7695312 8.7109375 L 11.367188 13.308594 C 11.572059 13.513526 11.850845 13.628906 12.140625 13.628906 C 12.430477 13.628906 12.707164 13.513535 12.912109 13.308594 L 16.128906 10.091797 C 16.555532 9.6650989 16.555532 8.9735735 16.128906 8.546875 C 15.702136 8.1201071 15.010683 8.1201071 14.583984 8.546875 L 12.140625 10.992188 L 8.3144531 7.1640625 C 8.1010678 6.950677 7.8226195 6.8457031 7.5429688 6.8457031 z'/></svg>"
		},
		"CLOSE": {
			"defaultProps": {
				"width": 12,
				"height": 12
			},
			"icon": "<svg name='Close' width='%%width' height='%%height' viewBox='0 0 12 12'><g fill='none' fill-rule='evenodd'><path d='M0 0h12v12H0'/><path fill='%%color' d='M9.5 3.205L8.795 2.5 6 5.295 3.205 2.5l-.705.705L5.295 6 2.5 8.795l.705.705L6 6.705 8.795 9.5l.705-.705L6.705 6'/></g></svg>"
		},
		"CLOSE_CIRCLE": {
			"icon": "<svg name='CloseCircle' width='%%width' height='%%height' viewBox='0 0 14 14'><path fill='%%color' d='M7.02799 0.333252C3.346 0.333252 0.361328 3.31792 0.361328 6.99992C0.361328 10.6819 3.346 13.6666 7.02799 13.6666C10.71 13.6666 13.6947 10.6819 13.6947 6.99992C13.6947 3.31792 10.7093 0.333252 7.02799 0.333252ZM10.166 9.19525L9.22333 10.1379L7.02799 7.94325L4.83266 10.1379L3.89 9.19525L6.08466 6.99992L3.88933 4.80459L4.832 3.86259L7.02733 6.05792L9.22266 3.86259L10.1653 4.80459L7.97066 6.99992L10.166 9.19525Z'/></svg>"
		},
		"COG": {
			"icon": "<svg name='Cog' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' d='M 19.738,10 H 22 v 4 h -2.261 c -0.241,0.931 -0.639,1.798 -1.174,2.564 L 20,18 18,20 16.565,18.564 C 15.797,19.099 14.932,19.498 14,19.738 V 22 H 10 V 19.738 C 9.069,19.498 8.203,19.099 7.436,18.564 L 6,20 4,18 5.436,16.564 C 4.901,15.799 4.502,14.932 4.262,14 H 2 V 10 H 4.262 C 4.502,9.068 4.9,8.202 5.436,7.436 L 4,6 6,4 7.436,5.436 C 8.202,4.9 9.068,4.502 10,4.262 V 2 h 4 v 2.261 c 0.932,0.241 1.797,0.639 2.565,1.174 L 18,3.999 l 2,2 -1.436,1.437 C 19.099,8.202 19.498,9.069 19.738,10 Z M 12,16 c 2.2091,0 4,-1.7909 4,-4 0,-2.20914 -1.7909,-4 -4,-4 -2.20914,0 -4,1.79086 -4,4 0,2.2091 1.79086,4 4,4 z'/></svg>"
		},
		"CROWN": {
			"icon": "<svg name='Crown' width='%%width' height='%%height' viewBox='0 0 16 16'><path fill='%%color' fill-rule='evenodd' clip-rule='evenodd' d='M13.6572 5.42868C13.8879 5.29002 14.1806 5.30402 14.3973 5.46468C14.6133 5.62602 14.7119 5.90068 14.6473 6.16202L13.3139 11.4954C13.2393 11.7927 12.9726 12.0007 12.6666 12.0007H3.33325C3.02725 12.0007 2.76058 11.792 2.68592 11.4954L1.35258 6.16202C1.28792 5.90068 1.38658 5.62602 1.60258 5.46468C1.81992 5.30468 2.11192 5.29068 2.34325 5.42868L5.13192 7.10202L7.44592 3.63068C7.46173 3.60697 7.48377 3.5913 7.50588 3.57559C7.5192 3.56612 7.53255 3.55663 7.54458 3.54535L6.90258 2.90268C6.77325 2.77335 6.77325 2.56068 6.90258 2.43135L7.76458 1.56935C7.89392 1.44002 8.10658 1.44002 8.23592 1.56935L9.09792 2.43135C9.22725 2.56068 9.22725 2.77335 9.09792 2.90268L8.45592 3.54535C8.46794 3.55686 8.48154 3.56651 8.49516 3.57618C8.51703 3.5917 8.53897 3.60727 8.55458 3.63068L10.8686 7.10202L13.6572 5.42868ZM2.66667 12.6673H13.3333V14.0007H2.66667V12.6673Z'/></svg>"
		},
		"DOWNLOAD": {
			"defaultProps": {
				"width": 16,
				"height": 16
			},
			"icon": "<svg name='Download' width='%%width' height='%%height' viewBox='0 0 16 16'><path fill='%%color' fill-rule='evenodd' d='M7.47 10.78a.75.75 0 001.06 0l3.75-3.75a.75.75 0 00-1.06-1.06L8.75 8.44V1.75a.75.75 0 00-1.5 0v6.69L4.78 5.97a.75.75 0 00-1.06 1.06l3.75 3.75zM3.75 13a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5z'/></svg>"
		},
		"DROPPER": {
			"defaultProps": {
				"width": 16,
				"height": 16,
				"foreground": ""
			},
			"icon": "<svg width='%%width' height='%%height' viewBox='0 0 16 16'><g fill='none'><path d='M-4-4h24v24H-4z'/><path class='%%foreground' fill='%%color' d='M14.994 1.006C13.858-.257 11.904-.3 10.72.89L8.637 2.975l-.696-.697-1.387 1.388 5.557 5.557 1.387-1.388-.697-.697 1.964-1.964c1.13-1.13 1.3-2.985.23-4.168zm-13.25 10.25c-.225.224-.408.48-.55.764L.02 14.37l1.39 1.39 2.35-1.174c.283-.14.54-.33.765-.55l4.808-4.808-2.776-2.776-4.813 4.803z'/></g></svg>"
		},
		"EYE": {
			"icon": "<svg name='Eye' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' d='m 12,4.8468858 c -4.5854555,0 -8.7437859,2.5087448 -11.8122114,6.5836142 -0.2503836,0.333845 -0.2503836,0.800246 0,1.13409 C 3.2562141,16.644369 7.4145445,19.153114 12,19.153114 c 4.585455,0 8.743786,-2.508745 11.812211,-6.583614 0.250384,-0.333845 0.250384,-0.800246 0,-1.13409 C 20.743786,7.3556306 16.585455,4.8468858 12,4.8468858 Z M 12.328935,17.037128 C 9.2850571,17.228597 6.7714025,14.719852 6.9628723,11.671065 7.1199757,9.1574101 9.1574101,7.1199755 11.671065,6.9628721 c 3.043878,-0.1914698 5.557532,2.317275 5.366063,5.3660629 -0.162013,2.508745 -2.199448,4.54618 -4.708193,4.708193 z m -0.152194,-2.327094 c -1.639766,0.103099 -2.9947829,-1.247009 -2.8867749,-2.886775 0.08346,-1.355017 1.1831849,-2.4498317 2.5382019,-2.5382024 1.639767,-0.1030991 2.994784,1.2470084 2.886775,2.8867754 -0.08837,1.359926 -1.188094,2.45474 -2.538202,2.538202 z'/></svg>"
		},
		"FOLDER": {
			"icon": "<svg name='Folder' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' d='M20 7H12L10.553 5.106C10.214 4.428 9.521 4 8.764 4H3C2.447 4 2 4.447 2 5V19C2 20.104 2.895 21 4 21H20C21.104 21 22 20.104 22 19V9C22 7.896 21.104 7 20 7Z'/></svg>"
		},
		"GAMEPAD": {
			"icon": "<svg name='Gamepad' aria-hidden='false' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' d='M 5.7066445,4.9022473 H 18.293275 c 1.595895,0 2.92046,1.2333283 3.034163,2.8251676 l 0.667683,9.3475611 c 0.0743,1.040197 -0.708715,1.943677 -1.748914,2.017977 -0.04477,0.0032 -0.08964,0.0048 -0.134531,0.0048 -1.191828,0 -2.230714,-0.811138 -2.519775,-1.96738 l -0.522119,-2.08848 H 6.930137 l -0.5221194,2.088478 c -0.2890608,1.156242 -1.3279463,1.96738 -2.5197742,1.96738 -1.0428481,0 -1.8882436,-0.845396 -1.8882436,-1.888243 0,-0.04488 0.0016,-0.08976 0.0048,-0.134532 L 2.6724812,7.7274149 C 2.7861841,6.1355756 4.1107494,4.9022473 5.7066445,4.9022473 Z m 8.8282265,5.0698223 c 0.839995,0 1.520947,-0.680951 1.520947,-1.5209465 0,-0.8399957 -0.680952,-1.5209468 -1.520947,-1.5209468 -0.839996,0 -1.520947,0.6809511 -1.520947,1.5209468 0,0.8399955 0.680951,1.5209465 1.520947,1.5209465 z m 4.055858,3.0418944 c 0.839996,0 1.520947,-0.680952 1.520947,-1.520947 0,-0.839995 -0.680951,-1.5209474 -1.520947,-1.5209474 -0.839996,0 -1.520947,0.6809524 -1.520947,1.5209474 0,0.839995 0.680951,1.520947 1.520947,1.520947 z M 5.9161725,8.9581056 H 3.8882434 v 2.0279294 h 2.0279291 v 2.027929 H 7.9441016 V 10.986035 H 9.9720304 V 8.9581056 H 7.9441016 V 6.9301763 H 5.9161725 Z'/></svg>"
		},
		"GAMEPAD_DISABLED": {
			"defaultProps": {
				"foreground": ""
			},
			"icon": "<svg name='GamepadDisabled' aria-hidden='false' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' d='m 5.707493,4.903746 c -1.5957556,0 -2.921198,1.232272 -3.0348909,2.823972 l -0.6679103,9.346058 c -0.0032,0.04477 -0.00469,0.09105 -0.00469,0.135925 0,0.286145 0.068875,0.553783 0.1827966,0.796805 L 7.1745522,13.014755 H 5.9160685 v -2.02951 H 3.8889021 V 8.958078 H 5.9160685 V 6.930913 H 7.943235 v 2.027165 h 2.0295102 v 1.258484 L 15.285561,4.903746 Z m 15.366625,1.832652 -4.813642,4.813642 -3.491882,3.491882 h 4.300405 l 0.522611,2.088099 c 0.289036,1.156141 1.327587,1.966233 2.519311,1.966233 0.04489,0 0.08882,-0.0014 0.133582,-0.0047 1.040108,-0.0743 1.824922,-0.977685 1.750628,-2.01779 l -0.66791,-9.346079 c -0.02519,-0.352659 -0.11926,-0.683371 -0.253103,-0.99132 z m -2.484157,3.236436 c 0.839921,0 1.52096,0.681039 1.52096,1.52096 0,0.839923 -0.681039,1.520961 -1.52096,1.520961 -0.839923,0 -1.520962,-0.681038 -1.520962,-1.520961 0,-0.839921 0.681039,-1.52096 1.520962,-1.52096 z M 7.943235,10.985245 v 1.260827 l 1.2608277,-1.260827 z'/><path d='M21 4.27L19.73 3L3 19.73L4.27 21L8.46 16.82L9.69 15.58L11.35 13.92L14.99 10.28L21 4.27Z' class='%%foreground' fill='currentColor'/></svg>"
		},
		"GITHUB": {
			"icon": "<svg name='Github' width='%%width' height='%%height' viewBox='0 0 24 24'><g fill='%%color'><path d='m12 .5c-6.63 0-12 5.28-12 11.792 0 5.211 3.438 9.63 8.205 11.188.6.111.82-.254.82-.567 0-.28-.01-1.022-.015-2.005-3.338.711-4.042-1.582-4.042-1.582-.546-1.361-1.335-1.725-1.335-1.725-1.087-.731.084-.716.084-.716 1.205.082 1.838 1.215 1.838 1.215 1.07 1.803 2.809 1.282 3.495.981.108-.763.417-1.282.76-1.577-2.665-.295-5.466-1.309-5.466-5.827 0-1.287.465-2.339 1.235-3.164-.135-.298-.54-1.497.105-3.121 0 0 1.005-.316 3.3 1.209.96-.262 1.98-.392 3-.398 1.02.006 2.04.136 3 .398 2.28-1.525 3.285-1.209 3.285-1.209.645 1.624.24 2.823.12 3.121.765.825 1.23 1.877 1.23 3.164 0 4.53-2.805 5.527-5.475 5.817.42.354.81 1.077.81 2.182 0 1.578-.015 2.846-.015 3.229 0 .309.21.678.825.56 4.801-1.548 8.236-5.97 8.236-11.173 0-6.512-5.373-11.792-12-11.792z'/></g></svg>"
		},
		"GLOBE": {
			"defaultProps": {
				"width": 20,
				"height": 20
			},
			"icon": "<svg name='Globe' width='%%width' height='%%height' viewBox='0 0 20 20'><g fill='%%color'><path d='M 9.99,0 C 4.47,0 0,4.48 0,10 0,15.52 4.47,20 9.99,20 15.52,20 20,15.52 20,10 20,4.48 15.52,0 9.99,0 Z m 6.93,6 H 13.97 C 13.65,4.75 13.19,3.55 12.59,2.44 14.43,3.07 15.96,4.35 16.92,6 Z M 10,2.04 c 0.83,1.2 1.48,2.53 1.91,3.96 H 8.09 C 8.52,4.57 9.17,3.24 10,2.04 Z M 2.26,12 C 2.1,11.36 2,10.69 2,10 2,9.31 2.1,8.64 2.26,8 H 5.64 C 5.56,8.66 5.5,9.32 5.5,10 c 0,0.68 0.06,1.34 0.14,2 z m 0.82,2 h 2.95 c 0.32,1.25 0.78,2.45 1.38,3.56 C 5.57,16.93 4.04,15.66 3.08,14 Z M 6.03,6 H 3.08 C 4.04,4.34 5.57,3.07 7.41,2.44 6.81,3.55 6.35,4.75 6.03,6 Z M 10,17.96 C 9.17,16.76 8.52,15.43 8.09,14 h 3.82 C 11.48,15.43 10.83,16.76 10,17.96 Z M 12.34,12 H 7.66 C 7.57,11.34 7.5,10.68 7.5,10 7.5,9.32 7.57,8.65 7.66,8 h 4.68 c 0.09,0.65 0.16,1.32 0.16,2 0,0.68 -0.07,1.34 -0.16,2 z m 0.25,5.56 c 0.6,-1.11 1.06,-2.31 1.38,-3.56 h 2.95 c -0.96,1.65 -2.49,2.93 -4.33,3.56 z M 14.36,12 c 0.08,-0.66 0.14,-1.32 0.14,-2 0,-0.68 -0.06,-1.34 -0.14,-2 h 3.38 C 17.9,8.64 18,9.31 18,10 c 0,0.69 -0.1,1.36 -0.26,2 z'/></g></svg>"
		},
		"GRADIENT": {
			"defaultProps": {
				"width": 36,
				"height": 36
			},
			"icon": "<svg name='Gradient' width='%%width' height='%%height' viewBox='0 0 36 36'><path fill='%%color' d='M 5,0 C 0,0 0,5 0,5 V 31 c 0,5 5,5 5,5 h 26 c 5,0 5,-5 5,-5 V 5 C 36,0 31,0 31,0 Z M 4,4 h 8 v 4 h 4 v -4 h 4 v 4 h 4 V 12 h -4 v 4 h 4 v 4 h -4 v 4 h 4 v 4 h -4 v 4 h -4 v -4 h -4 v 4 H 4 Z M 16,28 h 4 v -4 h -4 z m 0,-4 v -4 h -4 v 4 z m 0,-4 h 4 v -4 h -4 z m 0,-4 v -4 h -4 v 4 z m 0,-4 h 4 V 8 h -4 z'/></svg>"
		},
		"HEART": {
			"defaultProps": {
				"width": 16,
				"height": 16
			},
			"icon": "<svg name='Heart' width='%%width' height='%%height' viewBox='0 0 16 16'><path fill='%%color' fill-rule='evenodd' d='M4.25 2.5c-1.336 0-2.75 1.164-2.75 3 0 2.15 1.58 4.144 3.365 5.682A20.565 20.565 0 008 13.393a20.561 20.561 0 003.135-2.211C12.92 9.644 14.5 7.65 14.5 5.5c0-1.836-1.414-3-2.75-3-1.373 0-2.609.986-3.029 2.456a.75.75 0 01-1.442 0C6.859 3.486 5.623 2.5 4.25 2.5zM8 14.25l-.345.666-.002-.001-.006-.003-.018-.01a7.643 7.643 0 01-.31-.17 22.075 22.075 0 01-3.434-2.414C2.045 10.731 0 8.35 0 5.5 0 2.836 2.086 1 4.25 1 5.797 1 7.153 1.802 8 3.02 8.847 1.802 10.203 1 11.75 1 13.914 1 16 2.836 16 5.5c0 2.85-2.045 5.231-3.885 6.818a22.08 22.08 0 01-3.744 2.584l-.018.01-.006.003h-.002L8 14.25zm0 0l.345.666a.752.752 0 01-.69 0L8 14.25z'/></svg>"
		},
		"INFO": {
			"icon": "<svg name='Info' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' d='M 12,0 C 5.376,0 0,5.376 0,12 0,18.624 5.376,24 12,24 18.624,24 24,18.624 24,12 24,5.376 18.624,0 12,0 Z m 1.2,18 h -2.4 v -7.2 h 2.4 z m 0,-9.6 h -2.4 v -2.4 h 2.4 z'/></svg>"
		},
		"LEFT_CARET": {
			"icon": "<svg name='LeftCaret' width='%%width' height='%%height' viewBox='0 0 24 24'><g fill='none' fill-rule='evenodd'><polygon fill='%%color' fill-rule='nonzero' points='18.35 4.35 16 2 6 12 16 22 18.35 19.65 10.717 12'></polygon><polygon points='0 0 24 0 24 24 0 24'></polygon></g></svg>"
		},
		"LEFT_DOUBLE_CARET": {
			"icon": "<svg name='LeftDoubleCaret' width='%%width' height='%%height' viewBox='0 0 24 24'><g fill='none' fill-rule='evenodd'><polygon fill='%%color' fill-rule='nonzero' points='12.35 4.35 10 2 0 12 10 22 12.35 19.65 4.717 12'></polygon><polygon fill='%%color' fill-rule='nonzero' points='24.35 4.35 22 2 12 12 22 22 24.35 19.65 16.717 12'></polygon><polygon points='0 0 24 0 24 24 0 24'></polygon></g></svg>"
		},
		"LOCK_CLOSED": {
			"icon": "<svg name='LockClosed' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' d='M17 11V7C17 4.243 14.756 2 12 2C9.242 2 7 4.243 7 7V11C5.897 11 5 11.896 5 13V20C5 21.103 5.897 22 7 22H17C18.103 22 19 21.103 19 20V13C19 11.896 18.103 11 17 11ZM12 18C11.172 18 10.5 17.328 10.5 16.5C10.5 15.672 11.172 15 12 15C12.828 15 13.5 15.672 13.5 16.5C13.5 17.328 12.828 18 12 18ZM15 11H9V7C9 5.346 10.346 4 12 4C13.654 4 15 5.346 15 7V11Z'/></svg>"
		},
		"MENU_CARET": {
			"getClassName": {
				"": ["menucaretarrow"],
				"props.open": ["menucaretopen"]
			},
			"icon": "<svg name='MenuCaret' width='%%width' height='%%height' viewBox='0 0 24 24'><g fill='none' fill-rule='evenodd'><path fill='%%color' d='M16.59 8.59004L12 13.17L7.41 8.59004L6 10L12 16L18 10L16.59 8.59004Z'/></g></svg>"
		},
		"MORE": {
			"icon": "<svg name='More' width='%%width' height='%%height' viewBox='0 0 24 24'><g fill='none' fill-rule='evenodd'><path fill='%%color' d='M7 12.001C7 10.8964 6.10457 10.001 5 10.001C3.89543 10.001 3 10.8964 3 12.001C3 13.1055 3.89543 14.001 5 14.001C6.10457 14.001 7 13.1055 7 12.001ZM14 12.001C14 10.8964 13.1046 10.001 12 10.001C10.8954 10.001 10 10.8964 10 12.001C10 13.1055 10.8954 14.001 12 14.001C13.1046 14.001 14 13.1055 14 12.001ZM19 10.001C20.1046 10.001 21 10.8964 21 12.001C21 13.1055 20.1046 14.001 19 14.001C17.8954 14.001 17 13.1055 17 12.001C17 10.8964 17.8954 10.001 19 10.001Z'/></g></svg>"
		},
		"NOVA_AT": {
			"icon": "<svg name='Nova_At' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' d='M12 2C6.486 2 2 6.486 2 12C2 17.515 6.486 22 12 22C14.039 22 15.993 21.398 17.652 20.259L16.521 18.611C15.195 19.519 13.633 20 12 20C7.589 20 4 16.411 4 12C4 7.589 7.589 4 12 4C16.411 4 20 7.589 20 12V12.782C20 14.17 19.402 15 18.4 15L18.398 15.018C18.338 15.005 18.273 15 18.209 15H18C17.437 15 16.6 14.182 16.6 13.631V12C16.6 9.464 14.537 7.4 12 7.4C9.463 7.4 7.4 9.463 7.4 12C7.4 14.537 9.463 16.6 12 16.6C13.234 16.6 14.35 16.106 15.177 15.313C15.826 16.269 16.93 17 18 17L18.002 16.981C18.064 16.994 18.129 17 18.195 17H18.4C20.552 17 22 15.306 22 12.782V12C22 6.486 17.514 2 12 2ZM12 14.599C10.566 14.599 9.4 13.433 9.4 11.999C9.4 10.565 10.566 9.399 12 9.399C13.434 9.399 14.6 10.565 14.6 11.999C14.6 13.433 13.434 14.599 12 14.599Z'/></svg>"
		},
		"NOVA_PIN": {
			"icon": "<svg name='Nova_Pin' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' d='M22 12L12.101 2.10101L10.686 3.51401L12.101 4.92901L7.15096 9.87801V9.88001L5.73596 8.46501L4.32196 9.88001L8.56496 14.122L2.90796 19.778L4.32196 21.192L9.97896 15.536L14.222 19.778L15.636 18.364L14.222 16.95L19.171 12H19.172L20.586 13.414L22 12Z'/></svg>"
		},
		"NOVA_TRASH": {
			"icon": "<svg name='Nova_Trash' width='%%width' height='%%height' viewBox='0 0 24 24'><g fill='%%color'><path d='M15 3.999V2H9V3.999H3V5.999H21V3.999H15Z'/><path d='M5 6.99902V18.999C5 20.101 5.897 20.999 7 20.999H17C18.103 20.999 19 20.101 19 18.999V6.99902H5ZM11 17H9V11H11V17ZM15 17H13V11H15V17Z'/></g></svg>"
		},
		"OPEN_EXTERNAL": {
			"icon": "<svg name='OpenExternal' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' d='M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z'/></svg>"
		},
		"OVERLAY": {
			"icon": "<svg name='Overlay' aria-hidden='false' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' fill-rule='evenodd' clip-rule='evenodd' d='M4 2.5C2.897 2.5 2 3.397 2 4.5V15.5C2 16.604 2.897 17.5 4 17.5H11V19.5H7V21.5H17V19.5H13V17.5H20C21.103 17.5 22 16.604 22 15.5V4.5C22 3.397 21.103 2.5 20 2.5H4ZM20 4.5V13.5H4V4.5H20Z'/></svg>"
		},
		"OVERLAY_DISABLED": {
			"icon": "<svg name='OverlayDisabled' aria-hidden='false' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' d='M8.67872 19H11V21H7V23H17V21H13V19H20C21.103 19 22 18.104 22 17V6C22 5.89841 21.9924 5.79857 21.9777 5.70101L20 7.67872V15H12.6787L8.67872 19ZM13.1496 6H4V15H4.14961L2.00515 17.1445C2.00174 17.0967 2 17.0486 2 17V6C2 4.897 2.897 4 4 4H15.1496L13.1496 6Z'/><path d='M21 4.27L19.73 3L3 19.73L4.27 21L8.46 16.82L9.69 15.58L11.35 13.92L14.99 10.28L21 4.27Z' class='%%foreground' fill='currentColor'/></svg>"
		},
		"PATREON": {
			"icon": "<svg name='Patreon' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' d='M 0,-1.2209e-4 V 24 H 4.4021963 V -1.2209e-4 Z m 15.010145,0 c -4.974287,0 -9.020427,4.04121619 -9.020427,9.00819799 0,4.9565461 4.04614,8.9837411 9.020427,8.9837421 C 19.970866,17.991818 24,13.959406 24,9.0080759 24,4.0421376 19.969822,-1.2209e-4 15.010145,-1.2209e-4 Z'/></svg>"
		},
		"PAYPAL": {
			"icon": "<svg name='PayPal' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' d='M 5.6863929,0 C 5.1806043,0 4.7507198,0.3656279 4.6704813,0.85995389 L 1.6795909,19.673995 c -0.058746,0.371103 0.2309887,0.706911 0.6092555,0.706911 h 4.4338638 l 1.1121097,-7.006437 -0.033522,0.22009 c 0.078805,-0.494326 0.5072079,-0.859954 1.0129965,-0.859954 h 2.1061586 c 4.139443,0 7.378419,-1.667588 8.325519,-6.4919233 0.02866,-0.1432829 0.07434,-0.4183163 0.07434,-0.4183163 C 19.589638,4.0390606 19.318112,2.8290903 18.345211,1.7301106 17.276361,0.5193702 15.342278,0 12.867737,0 Z M 21.516831,7.8139196 c -1.028771,4.7498274 -4.3124,7.2629664 -9.522166,7.2629664 H 10.107139 L 8.6962314,24 H 11.76 c 0.442744,0 0.820329,-0.319405 0.889104,-0.753552 l 0.03498,-0.189482 0.705454,-4.428033 0.04519,-0.244868 c 0.06878,-0.434148 0.446338,-0.753554 0.887649,-0.753554 h 0.559699 c 3.620757,0 6.455196,-1.457472 7.283371,-5.677153 0.332416,-1.693603 0.172401,-3.113533 -0.64861,-4.1394384 z'/></svg>"
		},
		"PENCIL": {
			"defaultProps": {
				"width": 16,
				"height": 16
			},
			"icon": "<svg name='Pencil' width='16' height='16' viewBox='0 0 24 24'><path fill='%%color' d='M20.1039 9.58997L20.8239 8.87097C22.3929 7.30197 22.3929 4.74797 20.8239 3.17797C19.2549 1.60897 16.6999 1.60897 15.1309 3.17797L14.4119 3.89797L20.1039 9.58997ZM12.9966 5.30896L4.42847 13.8795L10.1214 19.5709L18.6896 11.0003L12.9966 5.30896ZM3.24398 21.968L8.39998 20.68L3.31998 15.6L2.03098 20.756C1.94598 21.096 2.04598 21.457 2.29398 21.705C2.54198 21.953 2.90298 22.052 3.24398 21.968Z'/></svg>"
		},
		"PIN": {
			"defaultProps": {
				"width": 16,
				"height": 16
			},
			"icon": "<svg name='Pin' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' d='M19 3H5V5H7V12H5V14H11V22H13V14H19V12H17V5H19V3Z'/></svg>"
		},
		"PODIUM": {
			"icon": "<svg name='Podium' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' fill-rule='evenodd' clip-rule='evenodd' d='M14 13C14 14.1 13.1 15 12 15C10.9 15 10 14.1 10 13C10 11.9 10.9 11 12 11C13.1 11 14 11.9 14 13ZM8.5 20V19.5C8.5 17.8 9.94 16.5 12 16.5C14.06 16.5 15.5 17.8 15.5 19.5V20H8.5ZM7 13C7 10.24 9.24 8 12 8C14.76 8 17 10.24 17 13C17 13.91 16.74 14.75 16.31 15.49L17.62 16.25C18.17 15.29 18.5 14.19 18.5 13C18.5 9.42 15.58 6.5 12 6.5C8.42 6.5 5.5 9.42 5.5 13C5.5 14.18 5.82 15.29 6.38 16.25L7.69 15.49C7.26 14.75 7 13.91 7 13ZM2.5 13C2.5 7.75 6.75 3.5 12 3.5C17.25 3.5 21.5 7.75 21.5 13C21.5 14.73 21.03 16.35 20.22 17.75L21.51 18.5C22.45 16.88 23 15 23 13C23 6.93 18.07 2 12 2C5.93 2 1 6.93 1 13C1 15 1.55 16.88 2.48 18.49L3.77 17.74C2.97 16.35 2.5 14.73 2.5 13Z'/></svg>"
		},
		"QUESTIONMARK": {
			"icon": "<svg name='QuestionMark' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' d='M12 2C6.486 2 2 6.487 2 12C2 17.515 6.486 22 12 22C17.514 22 22 17.515 22 12C22 6.487 17.514 2 12 2ZM12 18.25C11.31 18.25 10.75 17.691 10.75 17C10.75 16.31 11.31 15.75 12 15.75C12.69 15.75 13.25 16.31 13.25 17C13.25 17.691 12.69 18.25 12 18.25ZM13 13.875V15H11V12H12C13.104 12 14 11.103 14 10C14 8.896 13.104 8 12 8C10.896 8 10 8.896 10 10H8C8 7.795 9.795 6 12 6C14.205 6 16 7.795 16 10C16 11.861 14.723 13.429 13 13.875Z'/></svg>"
		},
		"QUESTIONMARK_ACTIVITY": {
			"defaultProps": {
				"width": 40,
				"height": 40
			},
			"icon": "<svg name='QuestionMark_Activity' width='%%width' height='%%height' viewBox='0 0 40 40'><g fill='none' fill-rule='evenodd'><path fill='currentColor' fill-opacity='.8' d='M21.226 30v-4.154h-3.755V30h3.755zm-.512-8.62c3.67-1.337 5.718-2.959 5.718-6.145 0-3.272-2.36-5.235-6.088-5.235-2.589 0-4.637.825-6.344 2.048l.484 3.3c1.621-1.251 3.47-2.162 5.49-2.162 1.707 0 2.845.854 2.845 2.305 0 1.593-1.08 2.475-3.812 3.442l-.882.342.342 4.523 2.076-.455.171-1.963z'></path><rect width='38' height='38' x='1' y='1' stroke='currentColor' stroke-opacity='.4' stroke-width='2' rx='5'></rect><circle cx='7' cy='7' r='2' fill='currentColor' fill-opacity='.4'></circle><circle cx='7' cy='33' r='2' fill='currentColor' fill-opacity='.4'></circle><circle cx='33' cy='7' r='2' fill='currentColor' fill-opacity='.4'></circle><circle cx='33' cy='33' r='2' fill='currentColor' fill-opacity='.4'></circle></g></svg>"
		},
		"QUOTE": {
			"icon": "<svg name='Quote' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' d='M19.8401 5.39392C20.1229 4.73405 19.6389 4 18.921 4H17.1231C16.7417 4 16.3935 4.21695 16.2254 4.55933L13.3297 10.4581C13.195 10.7324 13.125 11.0339 13.125 11.3394V19C13.125 19.5523 13.5727 20 14.125 20H20C20.5523 20 21 19.5523 21 19V12.875C21 12.3227 20.5523 11.875 20 11.875H17.8208C17.4618 11.875 17.2198 11.508 17.3612 11.178L19.8401 5.39392ZM9.71511 5.39392C9.99791 4.73405 9.51388 4 8.79596 4H6.99809C6.61669 4 6.2685 4.21695 6.10042 4.55933L3.20466 10.4581C3.07001 10.7324 3 11.0339 3 11.3394V19C3 19.5523 3.44772 20 4 20H9.875C10.4273 20 10.875 19.5523 10.875 19V12.875C10.875 12.3227 10.4273 11.875 9.875 11.875H7.69577C7.33681 11.875 7.0948 11.508 7.2362 11.178L9.71511 5.39392Z'/></svg>"
		},
		"RAW_TEXT": {
			"icon": "<svg name='RawText' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' d='M 2,2.9181818 V 5.6454545 H 7.4545455 V 21.1 H 10.181818 V 5.6454545 h 5.454546 V 2.9181818 Z M 12,9.281818 v 2.727273 h 3.636364 V 21.1 h 2.727272 V 12.009091 H 22 V 9.281818 Z'/></svg>"
		},
		"RIGHT_CARET": {
			"icon": "<svg name='RightCaret' width='%%width' height='%%height' viewBox='0 0 24 24'><g fill='none' fill-rule='evenodd'><polygon fill='%%color' fill-rule='nonzero' points='8.47 2 6.12 4.35 13.753 12 6.12 19.65 8.47 22 18.47 12'></polygon><polygon points='0 0 24 0 24 24 0 24'></polygon></g></svg>"
		},
		"RIGHT_DOUBLE_CARET": {
			"icon": "<svg name='RightDoubleCaret' width='%%width' height='%%height' viewBox='0 0 24 24'><g fill='none' fill-rule='evenodd'><polygon fill='%%color' fill-rule='nonzero' points='2.47 2 0.12 4.35 7.753 12 0.12 19.65 2.47 22 12.47 12'></polygon><polygon fill='%%color' fill-rule='nonzero' points='14.47 2 12.12 4.35 19.753 12 12.12 19.65 14.47 22 24.47 12'></polygon><polygon points='0 0 24 0 24 24 0 24'></polygon></g></svg>"
		},
		"SEARCH": {
			"defaultProps": {
				"width": 18,
				"height": 18
			},
			"icon": "<svg name='Search' width='%%width' height='%%height' viewBox='0 0 18 18'><g fill='none' fill-rule='evenodd'><path fill='%%color' d='M3.60091481,7.20297313 C3.60091481,5.20983419 5.20983419,3.60091481 7.20297313,3.60091481 C9.19611206,3.60091481 10.8050314,5.20983419 10.8050314,7.20297313 C10.8050314,9.19611206 9.19611206,10.8050314 7.20297313,10.8050314 C5.20983419,10.8050314 3.60091481,9.19611206 3.60091481,7.20297313 Z M12.0057176,10.8050314 L11.3733562,10.8050314 L11.1492281,10.5889079 C11.9336764,9.67638651 12.4059463,8.49170955 12.4059463,7.20297313 C12.4059463,4.32933105 10.0766152,2 7.20297313,2 C4.32933105,2 2,4.32933105 2,7.20297313 C2,10.0766152 4.32933105,12.4059463 7.20297313,12.4059463 C8.49170955,12.4059463 9.67638651,11.9336764 10.5889079,11.1492281 L10.8050314,11.3733562 L10.8050314,12.0057176 L14.8073185,16 L16,14.8073185 L12.2102538,11.0099776 L12.0057176,10.8050314 Z'/></g></svg>"
		},
		"SPEAKER": {
			"icon": "<svg name='Speaker' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' fill-rule='evenodd' clip-rule='evenodd' d='M11.383 3.07904C11.009 2.92504 10.579 3.01004 10.293 3.29604L6 8.00204H3C2.45 8.00204 2 8.45304 2 9.00204V15.002C2 15.552 2.45 16.002 3 16.002H6L10.293 20.71C10.579 20.996 11.009 21.082 11.383 20.927C11.757 20.772 12 20.407 12 20.002V4.00204C12 3.59904 11.757 3.23204 11.383 3.07904ZM14 5.00195V7.00195C16.757 7.00195 19 9.24595 19 12.002C19 14.759 16.757 17.002 14 17.002V19.002C17.86 19.002 21 15.863 21 12.002C21 8.14295 17.86 5.00195 14 5.00195ZM14 9.00195C15.654 9.00195 17 10.349 17 12.002C17 13.657 15.654 15.002 14 15.002V13.002C14.551 13.002 15 12.553 15 12.002C15 11.451 14.551 11.002 14 11.002V9.00195Z'/></svg>"
		},
		"STREAM": {
			"icon": "<svg name='Stream' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' fill-rule='evenodd' clip-rule='evenodd' d='M20 3V4L23 3V7L20 6V7C20 7.553 19.552 8 19 8H15C14.448 8 14 7.553 14 7V3C14 2.447 14.448 2 15 2H19C19.552 2 20 2.447 20 3ZM18 15V10H19H20V17C20 18.104 19.103 19 18 19H11V21H15V23H5V21H9V19H2C0.897 19 0 18.104 0 17V6C0 4.897 0.897 4 2 4H12V6H2V15H7H10H13H18Z'/></svg>"
		},
		"TRASH": {
			"icon": "<svg name='Trash' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='none' d='M0 0h24v24H0V0z'/><path fill='%%color' d='M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zm2.46-7.12l1.41-1.41L12 12.59l2.12-2.12 1.41 1.41L13.41 14l2.12 2.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14l-2.13-2.12zM15.5 4l-1-1h-5l-1 1H5v2h14V4z'/></svg>"
		},
		"WARNING": {
			"icon": "<svg name='Warning' width='%%width' height='%%height' viewBox='0 0 24 24'><path fill='%%color' d='M 0,22.35 H 24 L 12,1.6227273 Z m 13.090909,-3.272727 h -2.181818 v -2.181818 h 2.181818 z m 0,-4.363637 H 10.909091 V 10.35 h 2.181818 z'/></svg>"
		}
	},
	"CustomClassModules": {
		"BDFDB": {
			"BDFDBundefined": "BDFDB_undefined",
			"avatarDisabled": "disabled-6G33EE",
			"badge": "badge-7R_W3s",
			"badgeAvatar": "avatar-hF52Er",
			"bdControlsCustom": "custom-L9FFs5",
			"bdRepoEntry": "entry-9JnAPs",
			"bdRepoFooterControls": "controls-p0SrvV",
			"bdRepoHeaderControls": "controls-18FQsW",
			"bdRepoListHeader": "repoHeader-2KfNvH",
			"bdRepoListWrapper": "repoList-9JnAPs",
			"cardDisabled": "cardDisabled-wnh5ZW",
			"cardHorizontal": "horizontal-0ffRsT",
			"cardInner": "inner-OP_8zd",
			"cardWrapper": "card-rT4Wbb",
			"charCounter": "counter-uAzbKp",
			"changeLogModal": "changeLogModal-ny_dHC",
			"collapseContainer": "container-fAVkOf",
			"collapseContainerCollapsed": "collapsed-2BUBZm",
			"collapseContainerHeader": "header-2s6x-5",
			"collapseContainerInner": "inner-TkGytd",
			"collapseContainerMini": "container-fAVkOf containerMini-_k6Rts",
			"collapseContainerTitle": "title-ROsJi-",
			"colorPicker": "colorPicker-h5sF8g",
			"colorPickerAlpha": "alpha-VcPGeR",
			"colorPickerAlphaCheckered": "alpha-checkered",
			"colorPickerAlphaCursor": "alpha-cursor",
			"colorPickerAlphaHorizontal": "alpha-horizontal",
			"colorPickerGradient": "gradient-TJOYTr",
			"colorPickerGradientCheckered": "gradient-checkered",
			"colorPickerGradientCursor": "gradient-cursor",
			"colorPickerGradientCursorEdge": "gradient-cursor-edge",
			"colorPickerGradientCursorSelected": "gradient-cursor-selected",
			"colorPickerGradientHorizontal": "gradient-horizontal",
			"colorPickerGradientButton": "gradientButton-eBBuwD",
			"colorPickerGradientButtonEnabled": "enabled-MypHME",
			"colorPickerSwatches": "swatches-QxZw_N",
			"colorPickerSwatchesDisabled": "disabled-2JgNxl",
			"colorPickerSwatchSelected": "selected-f5IVXN",
			"colorPickerSwatchSingle": "single-Fbb1wB",
			"colorPickerSwatchSingleWrapper": "swatch-7FsRaa",
			"confirmModal": "confirmModal-t-WDWJ",
			"dateInputButton": "dateInputButton-jTGUJg",
			"dateInputButtonSelected": "selected-8F23Ra",
			"dateInputControls": "dateInputControls-cgfPf9",
			"dateInputField": "dateInputField-2vhGP1",
			"dateInputInner": "dateInputInner-ORXFwT",
			"dateInputPreview": "dateInputPreview-lG5sMM",
			"dateInputPreviewPrefix": "dateInputPreviewPrefix-6Fww21",
			"dateInputPreviewSuffix": "dateInputPreviewSuffix-f4Sr32",
			"dateInputWrapper": "dateInputWrapper-6tQOYp",
			"dev": "dev-A7f2Rx",
			"discoveryCard": "card-x5zW6z",
			"discoveryCardAuthor": "author-d2JIcl",
			"discoveryCardButton": "button-coQXfM",
			"discoveryCardControls": "controls-T0w-Wc",
			"discoveryCardCover": "cover-qyY86I",
			"discoveryCardCoverBadge": "coverBadge-I41ZIY",
			"discoveryCardCoverWrapper": "coverWrapper-J-mDGJ",
			"discoveryCardDescription": "description-zXiu5E",
			"discoveryCardFooter": "footer-C1KpS6",
			"discoveryCardHeader": "header-4hHJgv",
			"discoveryCardIcon": "icon-0jmVrJ",
			"discoveryCardIconLoading": "loading-f8Gs22",
			"discoveryCardIconWrapper": "iconWrapper-eK7GO6",
			"discoveryCardInfo": "info-xw-o76",
			"discoveryCardName": "name-OSUjF9",
			"discoveryCards": "list-QuW8QR",
			"discoveryCardStat": "stat-eRknnn",
			"discoveryCardStatIcon": "statIcon-o40EX1",
			"discoveryCardStats": "stats-Pc5tYW",
			"discoveryCardTag": "tag-PbPfwP",
			"discoveryCardTags": "tags-9KJ-1X",
			"discoveryCardTitle": "title-SSzExd",
			"discoveryCardTitleButton": "button-SxdSzE",
			"favButtonContainer": "favbutton-8Fzu45",
			"guild": "guild-r3yAE_",
			"guildLowerLeftBadge": "lowerLeftBadge-zr4T_9",
			"guildsLabel": "label-2wRs_g",
			"guildSummaryClickableIcon": "clickableIcon-7I6aVc",
			"guildSummaryContainer": "container-5VyO4t",
			"guildSummaryEmptyGuild": "emptyGuild-Am9XfC",
			"guildSummaryIcon": "icon-r6DlKo",
			"guildSummaryIconContainer": "iconContainer-IBAtWs",
			"guildSummaryIconContainerMasked": "iconContainerMasked-G-akdf iconContainer-IBAtWs",
			"guildSummaryMoreGuilds": "moreGuilds-c5JVlC",
			"guildSummarySvgIcon": "icon-5TsFrr",
			"guildUpperLeftBadge": "upperLeftBadge-e35IpL",
			"hasBadge": "hasBadge-4rT8_u",
			"hotkeyResetButton": "resetButton-hI9Ax7",
			"hotkeyWrapper": "recorder-can0vx",
			"inputNumberButton": "button-J9muv5",
			"inputNumberButtonDown": "down-cOY7Qp button-J9muv5",
			"inputNumberButtonUp": "up-mUs_72 button-J9muv5",
			"inputNumberButtons": "buttons-our3p-",
			"inputNumberWrapper": "numberInputWrapper-j4svZS",
			"inputNumberWrapperDefault": "numberInputWrapperDefault-gRxcuK numberInputWrapper-j4svZS",
			"inputNumberWrapperMini": "numberInputWrapperMini-wtUU31 numberInputWrapper-j4svZS",
			"layerContainerZIndexDisabled": "zIndexDisabled-Pf4Txx",
			"listInput": "listInput-11g5Sr",
			"listInputDelete": "delete-M_nPTt",
			"listInputItem": "item-wGC8aX",
			"listInputItems": "items-D9PGwH",
			"listRow": "listRow-7SfZww",
			"loadingIcon": "loadingIcon-cOYMPl",
			"loadingIconWrapper": "loadingIconWrapper-PsVJ9m",
			"overflowEllipsis": "ellipsis-qlo9sA",
			"pagination": "pagination-09Sd5R",
			"paginationBottom": "bottom-jTb32i",
			"paginationList": "list-PIKebU",
			"paginationListAlphabet": "alphabet-2ANo0x",
			"paginationListAlphabetChar": "alphabetChar-bq-8Go",
			"paginationListAlphabetCharDisabled": "disabled-XmhCq2",
			"paginationListContent": "listContent-aG3Fq8",
			"paginationListMini": "mini-GMiniS",
			"paginationMini": "mini-hODxXf",
			"paginationTop": "top-v-18jZ",
			"popoutWrapper": "popout-xwjvsX",
			"quickSelectWrapper": "quickSelectWrapper-UCfTKz",
			"marginLeft4": "marginLeft4-58StzA",
			"marginLeft8": "marginLeft8-3RhhAa",
			"menuColorCustom": "colorCustom-44asd2",
			"menuItemHint": "hint-BK71lM",
			"modalHeaderShade": "shade-h6F4sT",
			"modalHeaderHasSibling": "hasSiblings-fRyjyl",
			"modalNoScroller": "noScroller-YgPpF3",
			"modalSidebar": "sidebar-_0OpfR",
			"modalTabContent": "tabContent-nZ-1U5",
			"modalTabContentOpen": "open-yICTYu",
			"modalSubInner": "inner-t84Frz",
			"modalTextContent": "text-8fSrts",
			"modalWrapper": "modal-6GHvdM",
			"multiInput": "multiInput-Ft9zQo",
			"multiInputField": "multiInputField-GfMBpr",
			"multiInputFirst": "multiInputFirst-5rMj_O",
			"multiInputLast": "multiInputLast-HWxgTr",
			"multiInputWrapper": "multiInputWrapper-g6Srtv",
			"noticeClosing": "closing-g5Srr2",
			"noticeText": "text-kRs522",
			"noticeUpdate": "updateNotice-2DjjHs",
			"noticeUpdateButtonAll": "all-iF7Saa",
			"noticeUpdateButtonReload": "reload-LkMrac",
			"noticeUpdateEntries": "entries-Br6Sda",
			"noticeUpdateEntry": "entry-oFts5R",
			"noticeUpdateText": "notice-message",
			"noticeUpdateSeparator": "separator-g5DsaR",
			"noticeWrapper": "noticeWrapper-8z511t",
			"searchBarWrapper": "searchBarWrapper-1GpKvB",
			"selectWrapper": "selectWrapper-yPjeij",
			"settingsGuild": "guild-J3Egt5",
			"settingsGuildDisabled": "disabled-b2o83O",
			"settingsPanel": "settingsPanel-w2ySNR",
			"settingsPanelList": "settingsList-eZjkXj",
			"settingsPanelListWrapper": "wrapper-kRsR33",
			"settingsPanelListWrapperMini": "mini-2Iug3W",
			"settingsRow": "settingsRow-o9Ft44",
			"settingsTableCard": "settingsTableCard-628t52",
			"settingsTableCardConfigs": "settingsTableCardConfigs-w5X9-Z",
			"settingsTableCardLabel": "settingsTableCardLabel-MElgIg",
			"settingsTableHeaderOptions": "headerOptions-8F_5Ss",
			"settingsTableHeaders": "settingsTableHeaders-WKzw9_",
			"settingsTableHeaderVertical": "headerVertical-4MNxqk",
			"settingsTableList": "settingsTableList-f6sW2y",
			"sidebar": "sidebar-frSZx3",
			"sidebarContent": "content-1SbgDG",
			"sidebarList": "list-VCoBc2",
			"sliderBubble": "bubble-3we2di",
			"switchMini": "mini-6F2SSa",
			"supporter": "supporter-Z3FfwL",
			"supporterTier1": "tier1-841W86",
			"supporterTier2": "tier2-VDTzC3",
			"supporterTier3": "tier3-yTxjsy",
			"supporterTier4": "tier4-5RNl6k",
			"svgIcon": "icon-GhnIRB",
			"svgIconWrapper": "iconWrapper-g20jFn",
			"tabBarContainerBottom": "bottom-b8sdfs",
			"table": "table-moqjM0",
			"tableBodyCell": "bodyCell-dQam9V",
			"tableHeaderCell": "headerCell-T6Fo3K",
			"textScroller": "textScroller-dc9_kz",
			"themedPopout": "themedPopout-1TrfdI",
			"tooltipCustom": "tooltipCustom-hH39_Z",
			"tooltipNote": "note-e4Jh6_",
			"tooltipRowExtra": "extraRow-6F2Dss",
			"userInfoDate": "date-YN6TCS"
		},
		"BD": {
			"bdAddonCard": "bd-addon-card",
			"bdAddonList": "bd-addon-list",
			"bdAddonModal": "bd-addon-modal",
			"bdAddonModalFooter": "bd-addon-modal-footer",
			"bdAddonModalHeader": "bd-addon-modal-header",
			"bdAddonModalSettings": "bd-addon-modal-settings",
			"bdAuthor": "bd-author",
			"bdButton": "bd-button",
			"bdButtonDanger": "bd-button-danger",
			"bdControls": "bd-controls",
			"bdControlsButton": "bd-addon-button",
			"bdDescription": "bd-description",
			"bdDescriptionWrap": "bd-description-wrap",
			"bdFolderButton": "bd-pfbtn",
			"bdFooter": "bd-footer",
			"bdGuild": "bd-guild",
			"bdGuildAnimatable": "bd-animatable",
			"bdGuildAudio": "bd-audio",
			"bdGuildSelected": "bd-selected",
			"bdGuildSeparator": "bd-guild-separator",
			"bdGuildUnread": "bd-unread",
			"bdGuildVideo": "bd-video",
			"bdHeader": "bd-addon-header",
			"bdHeaderTitle": "bd-title",
			"bdIcon": "bd-icon",
			"bdLink": "bd-link",
			"bdLinks": "bd-links",
			"bdMeta": "bd-meta",
			"bdMinimalMode": "bd-minimal",
			"bdName": "bd-name",
			"bdPillSelected": "bd-selected",
			"bdPillUnread": "bd-unread",
			"bdSwitch": "bd-switch",
			"bdSwitchChecked": "bd-switch-checked",
			"bdSwitchInner": "bd-checkbox",
			"bdUpdatebtn": "bd-updatebtn",
			"bdVersion": "bd-version",
			"settings": "plugin-settings",
			"settingsOpen": "settings-open",
			"settingsClosed": "settings-closed",
			"switch": "ui-switch",
			"switchCheckbox": "ui-switch-checkbox",
			"switchChecked": "checked",
			"switchItem": "ui-switch-item",
			"switchWrapper": "ui-switch-wrapper"
		},
		"BadgesEverywhere": {
			"badge": "badge-7CsdQq",
			"badges": "badges-XRnWAp",
			"badgesChat": "badgesChat-f_cbR8",
			"badgesInner": "inner-dA0J42",
			"badgesList": "badgesList-Aw_p52",
			"badgesSettings": "badgesSettings-ychoGn",
			"indicator": "indicator-cY1-b4",
			"indicatorInner": "indicatorInner-08W8Jl",
			"mini": "mini-g-JPgX",
			"size17": "size17-2GsONg",
			"size21": "size21-Y634b3",
			"size22": "size22-AJj9xV",
			"size24": "size24-NlR6be"
		},
		"BetterFriendList": {
			"mutualGuilds": "mutualGuilds-s7F2aa",
			"nameCell": "nameCell-7F4sRs",
			"title": "title-3aDrFs"
		},
		"BetterNsfwTag": {
			"nsfwTag": "nsfwTag-666omg"
		},
		"BetterSearchPage": {
			"pagination": "pagination-shit69"
		},
		"ChatFilter": {
			"blocked": "blocked-jUhayi",
			"blockedStamp": "blockedStamp-ijVeNn",
			"censored": "censored-UYfeYg",
			"censoredStamp": "censoredStamp-fb2cYb"
		},
		"CharCounter": {
			"charCounter": "charCounter-7fw40k",
			"chatCounter": "chatCounter-XOMPsh",
			"counterAdded": "charCounterAdded-zz9O4t",
			"customStatusCounter": "customStatusCounter-G8FrsT",
			"editCounter": "editCounter-pNT1Xe",
			"nickCounter": "nickCounter-tJrO_4",
			"popoutNoteCounter": "popoutNoteCounter-62U4Rh",
			"profileNoteCounter": "profileNoteCounter-p0fWA_",
			"uploadCounter": "uploadCounter-iEGQQk"
		},
		"CreationDate": {
			"date": "creationDate-CJwdKT"
		},
		"CustomStatusPresets": {
			"customStatusItem": "customStatusItem-f5Trsa",
			"deleteButton": "deleteButton-k8a4Sa",
			"deleteIcon": "deleteIcon-22SgHa",
			"dragPreview": "dragPreview-3F0ssT",
			"sortableCard": "sortableCard-oF6sTT",
			"sortDivider": "sortDivider-d8SzzU",
			"status": "status-0f5Sr2"
		},
		"DisplayServersAsChannels": {
			"badge": "badge-fxFrUP",
			"name": "name-z5133D",
			"styled": "styledGuildsAsChannels-DNHtg_"
		},
		"EmojiStatistics": {
			"amountCell": "amountCell-g_W6Rx",
			"iconCell": "iconCell--wniOu",
			"nameCell": "nameCell-xyXENZ",
			"statisticsButton": "statisticsButton-nW2KoM"
		},
		"FriendNotifications": {
			"friendsOnline": "friendsOnline-2JkivW",
			"friendsOnlineWrap": "friendsOnlineWrap-0gZ63m",
			"logAvatar": "avatar-GgGssS",
			"logContent": "content-_3_FFs",
			"logTime": "time-00Fs44",
			"timeLogModal": "timeLogModal-9s4Rts",
			"typeLabel": "label-9FgsSa"
		},
		"GoogleTranslateOption": {
			"reverseButton": "reverseButton-5S47qV",
			"translateButton": "translateButton-DhP9x8",
			"translated": "translated-5YO8i3",
			"translating": "translating-Yi-YxC"
		},
		"ImageUtilities": {
			"details": "details-9dkFPc",
			"detailsAdded": "detailsAdded-fHiJlm",
			"detailsLabel": "label-mrlccN",
			"detailsWrapper": "detailsWrapper-TE1mu5",
			"gallery": "gallery-JViwKR",
			"imageDetails": "imageDetails-1t6Zms",
			"lens": "zoomLens-uOK8xV",
			"lensBackdrop": "lensBackdrop-yEm7Om",
			"next": "next-SHEZrz",
			"operations": "operations-3V47CY",
			"previous": "previous-xsNq6B",
			"sibling": "sibling-6vI7Pu",
			"switchIcon": "switchIcon-QY6cR4"
		},
		"JoinedAtDate": {
			"date": "joinedAtDate-IawR02"
		},
		"LastMessageDate": {
			"date": "lastMessageDate-ocEw13"
		},
		"OldTitleBar": {
			"oldTitleBarEnabled": "oldTitleBarEnabled-D8ppJQ",
			"settingsToolbar": "settingsToolbar-wu4yfQ",
			"toolbar": "toolbar-hRzFw-"
		},
		"PinDMs": {
			"dragPreview": "dragPreview-nXiByA",
			"dmChannelPinned": "pinned-0lM4wD",
			"dmChannelPlaceholder": "placeholder-7bhR5s",
			"pinnedChannelsHeaderAmount": "headerAmount-_-7GrS",
			"pinnedChannelsHeaderArrow": "pinnedChannelsHeaderArrow-44rrTz",
			"pinnedChannelsHeaderCollapsed": "collapsed-3w_-ff",
			"pinnedChannelsHeaderColored": "colored-oIzG5s",
			"pinnedChannelsHeaderContainer": "pinnedChannelsHeaderContainer-89Gjv4",
			"recentPinned": "pinned-jHvFrr",
			"recentPlaceholder": "placeholder-Uff-gH",
			"unpinButton": "unpinButton-z3-UVO",
			"unpinIcon": "unpinIcon-79ZnEr"
		},
		"PluginRepo": {
			"failNotice": "failNotice-OtHUGb",
			"loadingIcon": "loadingIcon-dB3qSe",
			"loadingTooltip": "loadingTooltip-SzsTEU",
			"newEntriesNotice": "newEntriesNotice-qvvpPx",
			"outdatedNotice": "outdatedNotice-9Q9gJv",
			"repoNotice": "repoNotice-P5ss6R"
		},
		"ReadAllNotificationsButton": {
			"button": "button-Jt-tIg",
			"frame": "frame-oXWS21",
			"innerFrame": "innerFrame-8Hg64E"
		},
		"ServerCounter": {
			"serverCount": "serverCount-FsTTs1",
			"serverCountWrap": "serverCountWrap-k8F5De"
		},
		"ServerDetails": {
			"details": "details-08FrsT",
			"icon": "icon-hSL42R",
			"tooltip": "detailsTooltip-G9hSSa"
		},
		"ServerFolders": {
			"dragPreview": "dragPreview-nXiByA",
			"guildPlaceholder": "placeholder-7bhR5s",
			"folderContent": "content-Pph8t6",
			"folderContentClosed": "closed-j55_T-",
			"folderContentIsOpen": "folderContentIsOpen-zz6FgW",
			"iconSwatch": "iconSwatch-_78Ghj",
			"iconSwatchInner": "iconInner-aOY-qk",
			"iconSwatchPreview": "preview-Bbg_24",
			"iconSwatchNoPreview": "noPreview-G8SS4t",
			"iconSwatchSelected": "selected-P5oePO"
		},
		"SpellCheck": {
			"error": "error-k9z2IV",
			"overlay": "spellCheckOverlay-cNSap5"
		},
		"ShowHiddenChannels": {
			"accessModal": "accessModal-w5HjsV"
		},
		"SpotifyControls": {
			"activityButton": "activityButton-5Fs4Aa",
			"bar": "bar-g2ZMIm",
			"barGabber": "grabber-7sd5f5",
			"barFill": "barFill-Dhkah7",
			"barText": "barText-lmqc5O",
			"buttonActive": "active-6TsW-_",
			"container": "container-6sXIoE",
			"containerInner": "inner-WRV6k5",
			"containerMaximized": "maximized-vv2Wr0",
			"containerWithTimeline": "withTimeline-824fT_",
			"cover": "cover-SwJ-ck",
			"coverMaximizer": "maximizer-RVu85p",
			"coverWrapper": "coverWrapper-YAplwJ",
			"details": "details-ntX2k5",
			"interpret": "interpret-F93iqP",
			"settingsIcon": "icon-F4SSra",
			"settingsLabel": "label-3f00Sr",
			"song": "song-tIdBpF",
			"timeline": "timeline-UWmgAx",
			"volumeSlider": "volumeSlider-sR5g00"
		},
		"StaffTag": {
			"adminIcon": "admin-Kv1Hp_",
			"managementIcon": "management-3fF_o8",
			"ownerIcon": "owner-FfFh3B"
		},
		"ThemeRepo": {
			"dragBar": "dragBar-4FsRaa",
			"dragCorner": "dragCorner-PgJJk2",
			"dragInterface": "dragInterface-OT5s2A",
			"failNotice": "failNotice-pZAzjZ",
			"loadingIcon": "loadingIcon-h7OqHY",
			"loadingTooltip": "loadingTooltip-YszEmb",
			"moveBar": "moveBar-lZ555a",
			"newEntriesNotice": "newEntriesNotice-abF6e1",
			"preview": "preview-7Gh5tS",
			"previewFullscreen": "fullscreen-h78TsW",
			"previewMoving": "moving-Wa22fA",
			"outdatedNotice": "outdatedNotice-fw8ams",
			"repoNotice": "repoNotice-TV3RFr"
		},
		"TimedLightDarkMode": {
			"dateGrabber": "dateGrabber-QrRkIX",
			"timerGrabber": "timerGrabber-zpRAIk",
			"timerSettings": "timerSettings-wkvEfF"
		},
		"TopRolesEverywhere": {
			"badgeStyle": "badgeStyle-tFiEQ8",
			"chatTag": "chatTag-Y-5TDc",
			"memberTag": "memberTag-QVWzGc",
			"roleStyle": "roleStyle-jQ7KI2",
			"tag": "tag-wWVHyf",
			"voiceTag": "voiceTag-0F4Ss0"
		},
		"NotFound": {
			"_": "",
			"badgeWrapper": "wrapper-232cHJ",
			"appOuter": "app-1q1i1E",
			"channelPanelTitle": "title-eS5yk3",
			"emoji": "emoji",
			"highlight": "highlight",
			"hoverCardButton": "button-2CgfFz",
			"loginScreen": "wrapper-3Q5DdO",
			"mention": "mention",
			"mentionInteractive": "interactive",
			"mentionWrapper": "wrapper-3WhCwL",
			"messagesLoadingWrapper": "wrapper-3vR61M",
			"messagesWelcomeChannelButtonContainer": "buttonContainer-2GVjL_",
			"nameContainerNameContainer": "container-2ax-kl",
			"hueCursor": "hue-cursor",
			"hueHorizontal": "hue-horizontal",
			"hueVertical": "hue-vertical",
			"saturationBlack": "saturation-black",
			"saturationColor": "saturation-color",
			"saturationCursor": "saturation-cursor",
			"saturationWhite": "saturation-white",
			"searchResultsPagination": "container-NdaZbY",
			"splashBackground": "splashBackground-1FRCko",
			"stopAnimations": "stop-animations",
			"subtext": "subtext-3CDbHg",
			"themeDark": "theme-dark",
			"themeLight": "theme-light",
			"themeUndefined": "theme-undefined",
			"voiceDraggable": "draggable-1KoBzC"
		},
		"ColorPicker": {
			"colorPickerCustom": "colorPickerCustom-2CWBn2",
			"colorPickerDropper": "colorPickerDropper-3c2mIf",
			"colorPickerDropperFg": "colorPickerDropperFg-3jYKWI",
			"colorPickerRow": "colorPickerRow-1LgLnl",
			"colorPickerSwatch": "colorPickerSwatch-5GX3Ve",
			"container": "container-3sNMIc",
			"custom": "custom-2SJn4n",
			"customContainer": "customContainer-3fZxdw",
			"customColorPickerInput": "customColorPickerInput-14pB0r",
			"default": "default-cS_caM",
			"defaultContainer": "defaultContainer-Z8qCJn",
			"disabled": "disabled-1C4eHl",
			"input": "input-GfazGc",
			"noColor": "noColor-1pdBDm"
		},
		"ColorPickerInner": {
			"hue": "hue-13HAGb",
			"saturation": "saturation-1FDvtn",
			"wrapper": "wrapper-2AQieU"
		},
		"Toast": {
			"avatar": "avatar-3xmbmC",
			"bar": "bar-95Sdw1",
			"barInner": "barInner-u7Frsw",
			"bg": "bg-8df5St",
			"brand": "colorBrand-WfDfzD",
			"center": "center-9SpJeg",
			"closable": "closable-7ShrRt",
			"closeIcon": "closeIcon-8R553s",
			"closing": "closing-K489s7",
			"custom": "colorCustom-WKsPgT",
			"customBar": "customBar-3RsUzs",
			"danger": "colorDanger-O5wq9n",
			"default": "colorDefault-XdNdIp",
			"icon": "icon-OZgBPQ",
			"info": "colorInfo-ujWH4-",
			"inner": "inner-6Fsw34",
			"left": "left-IXnX5I",
			"opening": "opening-3TzSw2",
			"right": "right-Eka_pI",
			"success": "colorSuccess-6GreWs",
			"text": "text-28VADE",
			"toast": "toast-g4bfgI",
			"toasts": "toasts-tApoHv",
			"warning": "colorWarning-qZNMsx"
		}
	},
	"DiscordClassModules": {
		"AccountDetails": {"props": ["usernameContainer", "container"]},
		"AccountDetailsButtons": {"props": ["button", "enabled", "disabled"]},
		"Anchor": {"props": ["anchor", "anchorUnderlineOnHover"]},
		"AnimationContainer": {"props": ["animatorLeft", "didRender"]},
		"AppBase": {"props": ["container", "base"]},
		"AppInner": {"props": ["app", "layers"]},
		"AppMount": {"props": ["appMount"]},
		"ApplicationStore": {"props": ["applicationStore", "navigation"]},
		"AppOuter": {"props": ["app", "mobileApp"]},
		"Attachment": {"props": ["wrapper", "video", "metadataDownload"]},
		"AuditLog": {"props": ["auditLog"]},
		"AuditLogPopout": {"props": ["guildSettingsAuditLogsUserFilterPopout"]},
		"AuthBox": {"props": ["authBox"]},
		"Autocomplete": {"props": ["autocomplete", "autocompleteRow"]},
		"AutocompleteAliases": {"props": ["autocompleteLayer", "stickerAutoComplete"]},
		"Avatar": {"props": ["avatar", "mask", "wrapper"]},
		"AvatarIcon": {"props": ["iconActiveLarge", "iconActiveMedium"]},
		"Backdrop": {"props": ["backdrop", "withLayer"]},
		"Badge": {"props": ["numberBadge", "textBadge", "iconBadge"]},
		"BotTag": {"props": ["botTag", "botTagInvert"]},
		"Button": {"props": ["colorBlack", "button"]},
		"CallCurrent": {"props": ["wrapper", "fullScreen"]},
		"CallDetails": {"props": ["container", "hotspot"]},
		"CallIncoming": {"props": ["wrapper", "mainChannelInfo"]},
		"Card": {"props": ["card", "cardBrand"]},
		"Category": {"props": ["wrapper", "children", "addButtonIcon"]},
		"CategoryArrow": {"props": ["arrow", "open"]},
		"ChangeLog": {"props": ["added", "fixed", "improved", "progress"]},
		"Channel": {"props": ["wrapper", "content", "modeSelected"]},
		"ChannelContainer": {"props": ["actionIcon", "containerDefault"]},
		"ChannelLimit": {"props": ["users", "total", "wrapper"]},
		"ChannelTextArea": {"props": ["textArea", "buttons"]},
		"ChannelTextAreaAttachButton": {"props": ["attachButton", "attachWrapper"]},
		"ChannelTextAreaButton": {"props": ["buttonWrapper", "active"]},
		"ChannelTextAreaCharCounter": {"props": ["characterCount", "error"]},
		"ChannelTextAreaSlate": {"props": ["slateContainer", "placeholder"]},
		"ChatWindow": {"props": ["chat", "channelTextArea"]},
		"Checkbox": {"props": ["checkboxWrapper", "round"]},
		"Combobox": {"props": ["combobox", "itemLabel"]},
		"Cursor": {"props": ["cursorDefault", "userSelectNone"]},
		"CustomStatusIcon": {"props": ["textRuler", "emoji", "icon"]},
		"CustomStatusModal": {"props": ["inputContainer", "emojiButton"]},
		"CustomStatusPopout": {"props": ["customStatusItem", "customEmoji"]},
		"DmAddPopout": {"props": ["popout", "searchBarComponent"]},
		"DmAddPopoutItems": {"props": ["friendSelected", "friendWrapper"]},
		"DownloadLink": {"props": ["downloadLink"]},
		"Embed": {"props": ["embed", "embedAuthorIcon"]},
		"EmbedActions": {"props": ["iconPlay", "iconWrapperActive"]},
		"Emoji": {"props": ["emoji"], "length": 1},
		"EmojiButton": {"props": ["emojiButton", "sprite"]},
		"EmojiPicker": {"props": ["emojiPicker", "inspector"]},
		"EmojiPickerDiversitySelector": {"props": ["diversityEmojiItemImage", "diversitySelectorOptions"]},
		"EmojiPickerItem": {"props": ["emojiSpriteImage"]},
		"EmojiPickerInspector": {"props": ["inspector", "graphicPrimary"]},
		"EmojiPickerInspectorEmoji": {"props": ["emoji", "glyphEmoji"]},
		"ErrorScreen": {"props": ["wrapper", "flexWrapper", "note"]},
		"ExpressionPicker": {"props": ["contentWrapper", "navButton", "navList"]},
		"File": {"props": ["downloadButton", "fileNameLink"]},
		"Flex": {"props": ["alignBaseline", "alignCenter"]},
		"FlexChild": {"props": ["flexChild", "flex"]},
		"FlowerStar": {"props": ["flowerStarContainer", "flowerStar"]},
		"FormText": {"props": ["description", "modeDefault"]},
		"Game": {"props": ["game", "gameName"]},
		"GameIcon": {"props": ["gameIcon", "small", "xsmall"]},
		"GameLibraryTable": {"props": ["stickyHeader", "emptyStateText"]},
		"GifFavoriteButton": {"props": ["gifFavoriteButton", "showPulse"]},
		"GoLiveDetails": {"props": ["panel", "gameWrapper"]},
		"Guild": {"props": ["wrapper", "lowerBadge", "svg"]},
		"GuildChannels": {"props": ["positionedContainer", "unreadBar"]},
		"GuildChannelsWrapper": {"props": ["subscribeTooltipWrapper", "container"]},
		"GuildDiscovery": {"props": ["pageWrapper", "guildList"]},
		"GuildDm": {"props": ["pill"], "length": 1},
		"GuildEdges": {"props": ["wrapper", "edge", "autoPointerEvents"]},
		"GuildFolder": {"props": ["folder", "expandedFolderIconWrapper"]},
		"GuildHeader": {"props": ["header", "name", "bannerImage"]},
		"GuildHeaderButton": {"props": ["button", "open"]},
		"GuildIcon": {"props": ["acronym", "selected", "wrapper"]},
		"GuildInvite": {"props": ["wrapper", "guildIconJoined"]},
		"GuildSettingsBanned": {"props": ["bannedUser", "bannedUserAvatar"]},
		"GuildSettingsEmoji": {"props": ["emojiRow", "emojiAliasPlaceholder"]},
		"GuildSettingsInvite": {"props": ["countdownColumn", "inviteSettingsInviteRow"]},
		"GuildSettingsMember": {"props": ["member", "membersFilterPopout"]},
		"GuildServer": {"props": ["blobContainer", "pill"]},
		"GuildsItems": {"props": ["guildSeparator", "guildsError"]},
		"GuildsWrapper": {"props": ["scroller", "unreadMentionsBar", "wrapper"]},
		"HeaderBar": {"props": ["container", "children", "toolbar"]},
		"HeaderBarExtras": {"props": ["headerBarLoggedOut", "search"]},
		"HeaderBarSearch": {"props": ["search", "searchBar", "open"]},
		"HeaderBarTopic": {"props": ["topic", "expandable", "content"]},
		"HomeIcon": {"props": ["homeIcon"]},
		"HotKeyRecorder": {"props": ["editIcon", "recording"]},
		"HoverCard": {"props": ["card", "active"]},
		"IconDirection": {"props": ["directionDown", "directionUp"]},
		"ImageModal": {"props": ["image", "modal"], "length": 4, "smaller": true},
		"ImageWrapper": {"props": ["clickable", "imageWrapperBackground"]},
		"Input": {"props": ["inputMini", "inputDefault"]},
		"InviteModal": {"props": ["inviteRow", "modal"]},
		"Item": {"props": ["item", "side", "header"]},
		"ItemRole": {"props": ["role", "dragged"]},
		"ItemLayerContainer": {"props": ["layer", "layerContainer"]},
		"LayerModal": {"props": ["root", "small", "medium"]},
		"Layers": {"props": ["layer", "layers"]},
		"LiveTag": {"props": ["liveLarge", "live"]},
		"LoadingScreen": {"props": ["container", "problemsText", "problems"]},
		"Margins": {"props": ["marginBottom4", "marginCenterHorz"]},
		"Menu": {"props": ["menu", "styleFlexible", "item"]},
		"MenuCaret": {"props": ["arrow", "open"]},
		"MenuReactButton": {"props": ["wrapper", "icon", "focused"]},
		"MenuSlider": {"props": ["slider", "sliderContainer"]},
		"Member": {"props": ["member", "ownerIcon"]},
		"MembersWrapper": {"props": ["membersWrap", "membersGroup"]},
		"Message": {"props": ["message", "mentioned"]},
		"MessageAccessory": {"props": ["embedWrapper", "gifFavoriteButton"]},
		"MessageBlocked": {"props": ["blockedMessageText", "expanded"]},
		"MessageBody": {"props": ["markupRtl", "edited"]},
		"MessageDivider": {"props": ["isUnread", "divider"]},
		"MessageElements": {"props": ["messageGroupBlockedBtn", "dividerRed"]},
		"MessageFile": {"props": ["cancelButton", "filenameLinkWrapper"]},
		"MessageLocalBot": {"props": ["ephemeralMessage", "icon"]},
		"MessageMarkup": {"props": ["markup"]},
		"MessagePopout": {"props": ["message", "spacing"]},
		"MessageOperations": {"props": ["operations"], "length": 1},
		"MessageReactions": {"props": ["reactions", "reactionMe"]},
		"MessageReactionsModal": {"props": ["reactor", "reactionSelected"]},
		"MessageReply": {"props": ["container", "text", "closeButton"]},
		"MessagesPopout": {"props": ["messagesPopoutWrap", "jumpButton"]},
		"MessagesPopoutButtons": {"props": ["secondary", "tertiary", "button"]},
		"MessagesPopoutTabBar": {"props": ["header", "tabBar", "active"]},
		"MessagesLoading": {"props": ["attachment", "blob", "cozy"]},
		"MessagesWelcome": {"props": ["emptyChannelIcon", "description", "header"]},
		"MessagesWelcomeButton": {"props": ["button", "buttonIcon"], "length": 2},
		"MessagesWrap": {"props": ["messagesWrapper", "messageGroupBlocked"]},
		"MessageSystem": {"props": ["container", "actionAnchor"]},
		"MessageToolbar": {"props": ["container", "icon", "isHeader"]},
		"MessageToolbarItems": {"props": ["wrapper", "button", "separator"]},
		"Modal": {"props": ["modal", "sizeLarge"]},
		"ModalDivider": {"props": ["divider"], "length": 1},
		"ModalItems": {"props": ["guildName", "checkboxContainer"]},
		"ModalMiniContent": {"props": ["modal", "content"], "length": 2},
		"ModalWrap": {"props": ["modal", "inner"], "length": 2},
		"NameContainer": {"props": ["nameAndDecorators", "name"]},
		"NameTag": {"props": ["bot", "nameTag"]},
		"NitroStore": {"props": ["applicationStore", "marketingHeader"]},
		"NoteTextarea": {"props": ["textarea"], "length": 1},
		"Notice": {"props": ["notice", "platformIcon"]},
		"NoticePlatform": {"props": ["iconAndroid", "textLink"]},
		"Pagination": {"props": ["pageButton", "pageControl"]},
		"PeopleItem": {"props": ["peopleListItem", "active"]},
		"PeopleItemInfo": {"props": ["listItemContents", "actions"], "length": 2},
		"Peoples": {"props": ["peopleColumn", "tabBar"]},
		"PictureInPicture": {"props": ["pictureInPicture", "pictureInPictureWindow"]},
		"PillWrapper": {"props": ["item", "wrapper"], "length": 2},
		"PrivateChannel": {"props": ["channel", "closeButton"]},
		"PrivateChannelList": {"props": ["privateChannels", "searchBar"]},
		"PrivateChannelListScroller": {"props": ["privateChannelsHeaderContainer", "headerText"]},
		"Popout": {"props": ["popout", "arrowAlignmentTop"]},
		"PopoutActivity": {"props": ["ellipsis", "activityActivityFeed"]},
		"QuickMessage": {"props": ["input"], "length": 1},
		"QuickSelect": {"props": ["quickSelectArrow", "selected"]},
		"QuickSwitch": {"props": ["resultFocused", "guildIconContainer"]},
		"QuickSwitchWrap": {"props": ["container", "miscContainer"]},
		"RadioGroup": {"props": ["radioBar", "item"]},
		"Reactions": {"props": ["reactionBtn", "reaction"]},
		"RecentMentions": {"props": ["recentMentionsPopout"]},
		"RecentMentionsHeader": {"props": ["channelName", "channelHeader", "dmIcon"]},
		"Role": {"props": ["roleCircle", "roleName", "roleRemoveIcon"]},
		"Scrollbar": {"props": ["scrollbar", "scrollbarGhost"]},
		"Scroller": {"props": ["scrollerBase", "none", "fade"]},
		"SearchBar": {"props": ["clear", "container", "pointer"]},
		"SearchPopout": {"props": ["datePicker", "searchResultChannelIconBackground"]},
		"SearchPopoutWrap": {"props": ["container", "queryContainer"]},
		"SearchResults": {"props": ["noResults", "searchResultsWrap"]},
		"SearchResultsElements": {"props": ["totalResults", "tab"]},
		"SearchResultsGroup": {"props": ["searchResultGroup", "channelName"]},
		"SearchResultsMessage": {"props": ["message", "searchResult"]},
		"Select": {"props": ["select", "error", "errorMessage"]},
		"SelectSearchable": {"props": ["searchable", "option", "selectedIcon"]},
		"SettingsCloseButton": {"props": ["closeButton", "keybind"]},
		"SettingsItems": {"props": ["labelRow", "note"]},
		"SettingsTable": {"props": ["headerOption", "headerName"]},
		"SettingsWindow": {"props": ["contentRegion", "standardSidebarView"]},
		"SettingsWindowScroller": {"props": ["sidebarScrollable", "content", "scroller"]},
		"Slider": {"props": ["slider", "grabber"]},
		"Spoiler": {"props": ["spoilerContainer", "hidden"]},
		"SpoilerEmbed": {"props": ["hiddenSpoilers", "spoiler"]},
		"Switch": {"props": ["container", "slider", "input"]},
		"Table": {"props": ["stickyHeader", "sortIcon"]},
		"Text": {"props": ["defaultColor", "defaultMarginh1"]},
		"TextColor": {"props": ["colorStandard", "colorMuted", "colorError"]},
		"TextColor2": {"props": ["muted", "wrapper", "base"]},
		"TextSize": {"props": ["size10", "size14", "size20"]},
		"TextStyle": {"props": ["strikethrough", "underline", "bold"]},
		"Tip": {"props": ["pro", "inline"]},
		"TitleBar": {"props": ["titleBar", "wordmark"]},
		"Tooltip": {"props": ["tooltip", "tooltipTop"]},
		"TooltipGuild": {"props": ["rowIcon", "rowGuildName"]},
		"Typing": {"props": ["cooldownWrapper", "typing"]},
		"UnreadBar": {"props": ["active", "bar", "unread"]},
		"UploadModal": {"props": ["uploadModal", "bgScale"]},
		"UserBadges": {"props": ["profileBadgeStaff", "profileBadgePremium"]},
		"UserInfo": {"props": ["userInfo", "discordTag"]},
		"UserPopout": {"props": ["headerNormal", "profileBadges"]},
		"UserPopoutBanner": {"props": ["profileBanner", "profileBannerPremium"]},
		"UserPopoutWrapper": {"props": ["userPopout", "rolesList"]},
		"UserProfile": {"props": ["topSectionNormal", "tabBarContainer"]},
		"UserSettingsAppearancePreview": {"props": ["preview", "firstMessage"]},
		"UserSummaryItem": {"props": ["avatarContainerMasked", "container"]},
		"Video": {"props": ["video", "fullScreen"]},
		"VoiceChannel": {"props": ["avatarSpeaking", "voiceUser"]},
		"VoiceChannelLimit": {"props": ["total", "users", "wrapper"]},
		"VoiceChannelList": {"props": ["list", "collapsed"]},
		"VoiceDetails": {"props": ["container", "customStatusContainer"]},
		"VoiceDetailsPing": {"props": ["rtcConnectionQualityBad", "rtcConnectionQualityFine"]},
		"WebhookCard": {"props": ["pulseBorder", "copyButton"]}
	},
	"DiscordClasses": {
		"_bdguild": ["BD", "bdGuild"],
		"_bdguildanimatable": ["BD", "bdGuildAnimatable"],
		"_bdguildaudio": ["BD", "bdGuildAudio"],
		"_bdguildselected": ["BD", "bdGuildSelected"],
		"_bdguildseparator": ["BD", "bdGuildSeparator"],
		"_bdguildunread": ["BD", "bdGuildUnread"],
		"_bdguildvideo": ["BD", "bdGuildVideo"],
		"_bdminimalmode": ["BD", "bdMinimalMode"],
		"_bdpillselected": ["BD", "bdPillSelected"],
		"_bdpillunread": ["BD", "bdPillUnread"],
		"_badgeseverywherebadge": ["BadgesEverywhere", "badge"],
		"_badgeseverywherebadges": ["BadgesEverywhere", "badges"],
		"_badgeseverywherebadgeschat": ["BadgesEverywhere", "badgesChat"],
		"_badgeseverywherebadgesinner": ["BadgesEverywhere", "badgesInner"],
		"_badgeseverywherebadgeslist": ["BadgesEverywhere", "badgesList"],
		"_badgeseverywherebadgessettings": ["BadgesEverywhere", "badgesSettings"],
		"_badgeseverywhereindicator": ["BadgesEverywhere", "indicator"],
		"_badgeseverywhereindicatorinner": ["BadgesEverywhere", "indicatorInner"],
		"_badgeseverywheremini": ["BadgesEverywhere", "mini"],
		"_badgeseverywheresize17": ["BadgesEverywhere", "size17"],
		"_badgeseverywheresize21": ["BadgesEverywhere", "size21"],
		"_badgeseverywheresize22": ["BadgesEverywhere", "size22"],
		"_badgeseverywheresize24": ["BadgesEverywhere", "size24"],
		"_betterfriendlistmutualguilds": ["BetterFriendList", "mutualGuilds"],
		"_betterfriendlistnamecell": ["BetterFriendList", "nameCell"],
		"_betterfriendlisttitle": ["BetterFriendList", "title"],
		"_betternsfwtagtag": ["BetterNsfwTag", "nsfwTag"],
		"_bettersearchpagepagination": ["BetterSearchPage", "pagination"],
		"_chatfilterblocked": ["ChatFilter", "blocked"],
		"_chatfilterblockedstamp": ["ChatFilter", "blockedStamp"],
		"_chatfiltercensored": ["ChatFilter", "censored"],
		"_chatfiltercensoredstamp": ["ChatFilter", "censoredStamp"],
		"_charcountercounter": ["CharCounter", "charCounter"],
		"_charcounterchatcounter": ["CharCounter", "chatCounter"],
		"_charcountercounteradded": ["CharCounter", "counterAdded"],
		"_charcountercustomstatuscounter": ["CharCounter", "customStatusCounter"],
		"_charcountereditcounter": ["CharCounter", "editCounter"],
		"_charcounternickcounter": ["CharCounter", "nickCounter"],
		"_charcounterpopoutnotecounter": ["CharCounter", "popoutNoteCounter"],
		"_charcounterprofilenotecounter": ["CharCounter", "profileNoteCounter"],
		"_charcounteruploadcounter": ["CharCounter", "uploadCounter"],
		"_creationdatedate": ["CreationDate", "date"],
		"_customstatuspresetscustomstatusitem": ["CustomStatusPresets", "customStatusItem"],
		"_customstatuspresetsdeletebutton": ["CustomStatusPresets", "deleteButton"],
		"_customstatuspresetsdeleteicon": ["CustomStatusPresets", "deleteIcon"],
		"_customstatuspresetsdragpreview": ["CustomStatusPresets", "dragPreview"],
		"_customstatuspresetssortablecard": ["CustomStatusPresets", "sortableCard"],
		"_customstatuspresetssortdivider": ["CustomStatusPresets", "sortDivider"],
		"_customstatuspresetsstatus": ["CustomStatusPresets", "status"],
		"_displayserversaschannelsbadge": ["DisplayServersAsChannels", "badge"],
		"_displayserversaschannelsname": ["DisplayServersAsChannels", "name"],
		"_displayserversaschannelsstyled": ["DisplayServersAsChannels", "styled"],
		"_emojistatisticsstatisticsbutton": ["EmojiStatistics", "statisticsButton"],
		"_emojistatisticsamountcell": ["EmojiStatistics", "amountCell"],
		"_emojistatisticsiconcell": ["EmojiStatistics", "iconCell"],
		"_emojistatisticsnamecell": ["EmojiStatistics", "nameCell"],
		"_friendnotificationslogavatar": ["FriendNotifications", "logAvatar"],
		"_friendnotificationslogcontent": ["FriendNotifications", "logContent"],
		"_friendnotificationslogtime": ["FriendNotifications", "logTime"],
		"_friendnotificationsfriendsonline": ["FriendNotifications", "friendsOnline"],
		"_friendnotificationsfriendsonlinewrap": ["FriendNotifications", "friendsOnlineWrap"],
		"_friendnotificationstimelogmodal": ["FriendNotifications", "timeLogModal"],
		"_friendnotificationstypelabel": ["FriendNotifications", "typeLabel"],
		"_imageutilitiesdetails": ["ImageUtilities", "details"],
		"_imageutilitiesdetailsadded": ["ImageUtilities", "detailsAdded"],
		"_imageutilitiesdetailslabel": ["ImageUtilities", "detailsLabel"],
		"_imageutilitiesdetailswrapper": ["ImageUtilities", "detailsWrapper"],
		"_imageutilitiesgallery": ["ImageUtilities", "gallery"],
		"_imageutilitiesimagedetails": ["ImageUtilities", "imageDetails"],
		"_imageutilitieslense": ["ImageUtilities", "lens"],
		"_imageutilitieslensebackdrop": ["ImageUtilities", "lensBackdrop"],
		"_imageutilitiesnext": ["ImageUtilities", "next"],
		"_imageutilitiesoperations": ["ImageUtilities", "operations"],
		"_imageutilitiesprevious": ["ImageUtilities", "previous"],
		"_imageutilitiessibling": ["ImageUtilities", "sibling"],
		"_imageutilitiesswitchicon": ["ImageUtilities", "switchIcon"],
		"_joinedatdatedate": ["JoinedAtDate", "date"],
		"_lastmessagedatedate": ["LastMessageDate", "date"],
		"_googletranslateoptionreversebutton": ["GoogleTranslateOption", "reverseButton"],
		"_googletranslateoptiontranslatebutton": ["GoogleTranslateOption", "translateButton"],
		"_googletranslateoptiontranslated": ["GoogleTranslateOption", "translated"],
		"_googletranslateoptiontranslating": ["GoogleTranslateOption", "translating"],
		"_oldtitlebarenabled": ["OldTitleBar", "oldTitleBarEnabled"],
		"_oldtitlebarsettingstoolbar": ["OldTitleBar", "settingsToolbar"],
		"_oldtitlebartoolbar": ["OldTitleBar", "toolbar"],
		"_pindmsdragpreview": ["PinDMs", "dragPreview"],
		"_pindmsdmchannelpinned": ["PinDMs", "dmChannelPinned"],
		"_pindmsdmchannelplaceholder": ["PinDMs", "dmChannelPlaceholder"],
		"_pindmspinnedchannelsheaderamount": ["PinDMs", "pinnedChannelsHeaderAmount"],
		"_pindmspinnedchannelsheaderarrow": ["PinDMs", "pinnedChannelsHeaderArrow"],
		"_pindmspinnedchannelsheadercollapsed": ["PinDMs", "pinnedChannelsHeaderCollapsed"],
		"_pindmspinnedchannelsheadercolored": ["PinDMs", "pinnedChannelsHeaderColored"],
		"_pindmspinnedchannelsheadercontainer": ["PinDMs", "pinnedChannelsHeaderContainer"],
		"_pindmsrecentpinned": ["PinDMs", "recentPinned"],
		"_pindmsrecentplaceholder": ["PinDMs", "recentPlaceholder"],
		"_pindmsunpinbutton": ["PinDMs", "unpinButton"],
		"_pindmsunpinicon": ["PinDMs", "unpinIcon"],
		"_pluginrepofailnotice": ["PluginRepo", "failNotice"],
		"_pluginrepoloadingicon": ["PluginRepo", "loadingIcon"],
		"_pluginrepoloadingtooltip": ["PluginRepo", "loadingTooltip"],
		"_pluginreponewentriesnotice": ["PluginRepo", "newEntriesNotice"],
		"_pluginreponotice": ["PluginRepo", "repoNotice"],
		"_pluginrepooutdatednotice": ["PluginRepo", "outdatedNotice"],
		"_readallnotificationsbuttonbutton": ["ReadAllNotificationsButton", "button"],
		"_readallnotificationsbuttonframe": ["ReadAllNotificationsButton", "frame"],
		"_readallnotificationsbuttoninner": ["ReadAllNotificationsButton", "innerFrame"],
		"_servercounterservercount": ["ServerCounter", "serverCount"],
		"_servercounterservercountwrap": ["ServerCounter", "serverCountWrap"],
		"_serverdetailsdetails": ["ServerDetails", "details"],
		"_serverdetailsicon": ["ServerDetails", "icon"],
		"_serverdetailstooltip": ["ServerDetails", "tooltip"],
		"_serverfoldersdragpreview": ["ServerFolders", "dragPreview"],
		"_serverfoldersfoldercontent": ["ServerFolders", "folderContent"],
		"_serverfoldersfoldercontentclosed": ["ServerFolders", "folderContentClosed"],
		"_serverfoldersfoldercontentisopen": ["ServerFolders", "folderContentIsOpen"],
		"_serverfoldersguildplaceholder": ["ServerFolders", "guildPlaceholder"],
		"_serverfoldersiconswatch": ["ServerFolders", "iconSwatch"],
		"_serverfoldersiconswatchinner": ["ServerFolders", "iconSwatchInner"],
		"_serverfoldersiconswatchpreview": ["ServerFolders", "iconSwatchPreview"],
		"_serverfoldersiconswatchnopreview": ["ServerFolders", "iconSwatchNoPreview"],
		"_serverfoldersiconswatchselected": ["ServerFolders", "iconSwatchSelected"],
		"_showhiddenchannelsaccessmodal": ["ShowHiddenChannels", "accessModal"],
		"_spellcheckerror": ["SpellCheck", "error"],
		"_spellcheckoverlay": ["SpellCheck", "overlay"],
		"_spotifycontrolsactivitybutton": ["SpotifyControls", "activityButton"],
		"_spotifycontrolsbar": ["SpotifyControls", "bar"],
		"_spotifycontrolsbarfill": ["SpotifyControls", "barFill"],
		"_spotifycontrolsbargrabber": ["SpotifyControls", "barGabber"],
		"_spotifycontrolsbartext": ["SpotifyControls", "barText"],
		"_spotifycontrolsbuttonactive": ["SpotifyControls", "buttonActive"],
		"_spotifycontrolscontainer": ["SpotifyControls", "container"],
		"_spotifycontrolscontainerinner": ["SpotifyControls", "containerInner"],
		"_spotifycontrolscontainermaximized": ["SpotifyControls", "containerMaximized"],
		"_spotifycontrolscontainerwithtimeline": ["SpotifyControls", "containerWithTimeline"],
		"_spotifycontrolscover": ["SpotifyControls", "cover"],
		"_spotifycontrolscovermaximizer": ["SpotifyControls", "coverMaximizer"],
		"_spotifycontrolscoverwrapper": ["SpotifyControls", "coverWrapper"],
		"_spotifycontrolsdetails": ["SpotifyControls", "details"],
		"_spotifycontrolsinterpret": ["SpotifyControls", "interpret"],
		"_spotifycontrolssettingsicon": ["SpotifyControls", "settingsIcon"],
		"_spotifycontrolssettingslabel": ["SpotifyControls", "settingsLabel"],
		"_spotifycontrolssong": ["SpotifyControls", "song"],
		"_spotifycontrolstimeline": ["SpotifyControls", "timeline"],
		"_spotifycontrolsvolumeslider": ["SpotifyControls", "volumeSlider"],
		"_stafftagadminicon": ["StaffTag", "adminIcon"],
		"_stafftagmanagementicon": ["StaffTag", "managementIcon"],
		"_stafftagownericon": ["StaffTag", "ownerIcon"],
		"_themerepodragbar": ["ThemeRepo", "dragBar"],
		"_themerepodragcorner": ["ThemeRepo", "dragCorner"],
		"_themerepodraginterface": ["ThemeRepo", "dragInterface"],
		"_themerepofailnotice": ["ThemeRepo", "failNotice"],
		"_themerepoloadingicon": ["ThemeRepo", "loadingIcon"],
		"_themerepoloadingtooltip": ["ThemeRepo", "loadingTooltip"],
		"_themerepomovebar": ["ThemeRepo", "moveBar"],
		"_themereponewentriesnotice": ["ThemeRepo", "newEntriesNotice"],
		"_themereponotice": ["ThemeRepo", "repoNotice"],
		"_themerepooutdatednotice": ["ThemeRepo", "outdatedNotice"],
		"_themerepopreview": ["ThemeRepo", "preview"],
		"_themerepopreviewfullscreen": ["ThemeRepo", "previewFullscreen"],
		"_themerepopreviewmoving": ["ThemeRepo", "previewMoving"],
		"_timedlightdarkmodedategrabber": ["TimedLightDarkMode", "dateGrabber"],
		"_timedlightdarkmodetimergrabber": ["TimedLightDarkMode", "timerGrabber"],
		"_timedlightdarkmodetimersettings": ["TimedLightDarkMode", "timerSettings"],
		"_toproleseverywherebadgestyle": ["TopRolesEverywhere", "badgeStyle"],
		"_toproleseverywherechattag": ["TopRolesEverywhere", "chatTag"],
		"_toproleseverywheremembertag": ["TopRolesEverywhere", "memberTag"],
		"_toproleseverywhererolestyle": ["TopRolesEverywhere", "roleStyle"],
		"_toproleseverywheretag": ["TopRolesEverywhere", "tag"],
		"_toproleseverywherevoicetag": ["TopRolesEverywhere", "voiceTag"],
		"_repoauthor": ["BD", "bdAuthor"],
		"_repobutton": ["BD", "bdButton"],
		"_repobuttondanger": ["BD", "bdButtonDanger"],
		"_repocard": ["BD", "bdAddonCard"],
		"_repocheckbox": ["BD", "switchCheckbox"],
		"_repocheckboxchecked": ["BD", "switchChecked"],
		"_repocheckboxinner": ["BD", "switch"],
		"_repocheckboxitem": ["BD", "switchItem"],
		"_repocheckboxwrap": ["BD", "switchWrapper"],
		"_repocontrols": ["BD", "bdControls"],
		"_repocontrolsbutton": ["BD", "bdControlsButton"],
		"_repocontrolscustom": ["BDFDB", "bdControlsCustom"],
		"_repodescription": ["BD", "bdDescription"],
		"_repodescriptionwrap": ["BD", "bdDescriptionWrap"],
		"_repoentry": ["BDFDB", "bdRepoEntry"],
		"_repofolderbutton": ["BD", "bdFolderButton"],
		"_repofooter": ["BD", "bdFooter"],
		"_repofootercontrols": ["BDFDB", "bdRepoFooterControls"],
		"_repoheader": ["BD", "bdHeader"],
		"_repoheadercontrols": ["BDFDB", "bdRepoHeaderControls"],
		"_repoheadertitle": ["BD", "bdHeaderTitle"],
		"_repoicon": ["BD", "bdIcon"],
		"_repolist": ["BD", "bdAddonList"],
		"_repolistheader": ["BDFDB", "bdRepoListHeader"],
		"_repolistwrapper": ["BDFDB", "bdRepoListWrapper"],
		"_repolink": ["BD", "bdLink"],
		"_repolinks": ["BD", "bdLinks"],
		"_repometa": ["BD", "bdMeta"],
		"_repomodal": ["BD", "bdAddonModal"],
		"_repomodalfooter": ["BD", "bdAddonModalFooter"],
		"_repomodalheader": ["BD", "bdAddonModalHeader"],
		"_repomodalsettings": ["BD", "bdAddonModalSettings"],
		"_reponame": ["BD", "bdName"],
		"_reposettings": ["BD", "settings"],
		"_reposettingsopen": ["BD", "settingsOpen"],
		"_reposettingsclosed": ["BD", "settingsClosed"],
		"_reposwitch": ["BD", "bdSwitch"],
		"_reposwitchchecked": ["BD", "bdSwitchChecked"],
		"_reposwitchinner": ["BD", "bdSwitchInner"],
		"_repoupdatebutton": ["BD", "bdUpdatebtn"],
		"_repoversion": ["BD", "bdVersion"],
		"accountinfo": ["AccountDetails", "container"],
		"accountinfoavatar": ["AccountDetails", "avatar"],
		"accountinfoavatarwrapper": ["AccountDetails", "avatarWrapper"],
		"accountinfobutton": ["AccountDetailsButtons", "button"],
		"accountinfobuttondisabled": ["AccountDetailsButtons", "disabled"],
		"accountinfobuttonenabled": ["AccountDetailsButtons", "enabled"],
		"accountinfobuttonstrikethrough": ["AccountDetails", "strikethrough"],
		"accountinfodetails": ["AccountDetails", "usernameContainer"],
		"accountinfonametag": ["AccountDetails", "nameTag"],
		"aliasautocomplete": ["AutocompleteAliases", "autocomplete"],
		"anchor": ["Anchor", "anchor"],
		"anchorunderlineonhover": ["Anchor", "anchorUnderlineOnHover"],
		"animationcontainerbottom": ["AnimationContainer", "animatorBottom"],
		"animationcontainerleft": ["AnimationContainer", "animatorLeft"],
		"animationcontainerright": ["AnimationContainer", "animatorRight"],
		"animationcontainertop": ["AnimationContainer", "animatorTop"],
		"animationcontainerrender": ["AnimationContainer", "didRender"],
		"animationcontainerscale": ["AnimationContainer", "scale"],
		"animationcontainertranslate": ["AnimationContainer", "translate"],
		"app": ["NotFound", "appOuter"],
		"appcontainer": ["AppBase", "container"],
		"appinner": ["AppInner", "app"],
		"appmount": ["AppMount", "appMount"],
		"applayers": ["AppInner", "layers"],
		"applicationstore": ["ApplicationStore", "applicationStore"],
		"attachment": ["Attachment", "wrapper"],
		"attachmentvideo": ["Attachment", "video"],
		"auditlog": ["AuditLog", "auditLog"],
		"auditlogoverflowellipsis": ["AuditLog", "overflowEllipsis"],
		"auditlogpopoutaction": ["AuditLogPopout", "guildSettingsAuditLogsActionFilterPopout"],
		"auditlogpopoutavatar": ["AuditLogPopout", "avatar"],
		"auditlogpopoutuser": ["AuditLogPopout", "guildSettingsAuditLogsUserFilterPopout"],
		"auditlogpopoutusertext": ["AuditLogPopout", "userText"],
		"auditlogtimestamp": ["AuditLog", "timestamp"],
		"auditloguserhook": ["AuditLog", "userHook"],
		"authbox": ["AuthBox", "authBox"],
		"autocomplete": ["Autocomplete", "autocomplete"],
		"autocompletecontenttitle": ["Autocomplete", "contentTitle"],
		"autocompletedescriptiondiscriminator": ["Autocomplete", "descriptionDiscriminator"],
		"autocompleteemoji": ["Autocomplete", "emojiImage"],
		"autocompleteicon": ["Autocomplete", "icon"],
		"autocompleteiconforeground": ["Autocomplete", "iconForeground"],
		"autocompleteinner": ["Autocomplete", "autocompleteInner"],
		"autocompleterow": ["Autocomplete", "autocompleteRow"],
		"autocompleterowcontent": ["Autocomplete", "autocompleteRowContent"],
		"autocompleterowcontentprimary": ["Autocomplete", "autocompleteRowContentPrimary"],
		"autocompleterowcontentsecondary": ["Autocomplete", "autocompleteRowContentSecondary"],
		"autocompleterowhorizontal": ["Autocomplete", "autocompleteRowHorizontal"],
		"autocompleterowicon": ["Autocomplete", "autocompleteRowIcon"],
		"autocompleterowsubheading": ["Autocomplete", "autocompleteRowSubheading"],
		"autocompleterowvertical": ["Autocomplete", "autocompleteRowVertical"],
		"autocompleteselectable": ["Autocomplete", "selectable"],
		"autocompleteselected": ["Autocomplete", "selected"],
		"avatar": ["Avatar", "avatar"],
		"avatarcursordefault": ["Avatar", "cursorDefault"],
		"avatardisabled": ["BDFDB", "avatarDisabled"],
		"avataricon": ["AvatarIcon", "icon"],
		"avatariconactivelarge": ["AvatarIcon", "iconActiveLarge"],
		"avatariconactivemedium": ["AvatarIcon", "iconActiveMedium"],
		"avatariconactivemini": ["AvatarIcon", "iconActiveMini"],
		"avatariconactivesmall": ["AvatarIcon", "iconActiveSmall"],
		"avatariconactivexlarge": ["AvatarIcon", "iconActiveXLarge"],
		"avatariconinactive": ["AvatarIcon", "iconInactive"],
		"avatariconsizelarge": ["AvatarIcon", "iconSizeLarge"],
		"avatariconsizemedium": ["AvatarIcon", "iconSizeMedium"],
		"avatariconsizemini": ["AvatarIcon", "iconSizeMini"],
		"avatariconsizesmol": ["AvatarIcon", "iconSizeSmol"],
		"avatariconsizesmall": ["AvatarIcon", "iconSizeSmall"],
		"avatariconsizexlarge": ["AvatarIcon", "iconSizeXLarge"],
		"avatarmask": ["Avatar", "mask"],
		"avatarnoicon": ["AvatarIcon", "noIcon"],
		"avatarpointer": ["Avatar", "pointer"],
		"avatarpointerevents": ["Avatar", "pointerEvents"],
		"avatarstack": ["Avatar", "avatarStack"],
		"avatarsvg": ["Avatar", "svg"],
		"avatarwrapper": ["Avatar", "wrapper"],
		"backdrop": ["Backdrop", "backdrop"],
		"backdropwithlayer": ["Backdrop", "withLayer"],
		"badgebase": ["Badge", "base"],
		"badgeicon": ["Badge", "icon"],
		"badgeiconbadge": ["Badge", "iconBadge"],
		"badgenumberbadge": ["Badge", "numberBadge"],
		"badgeshaperound": ["Badge", "baseShapeRound"],
		"badgeshaperoundleft": ["Badge", "baseShapeRoundLeft"],
		"badgeshaperoundright": ["Badge", "baseShapeRoundRight"],
		"badgetextbadge": ["Badge", "textBadge"],
		"badgewrapper": ["NotFound", "badgeWrapper"],
		"bdfdbbadge": ["BDFDB", "badge"],
		"bdfdbbadgeavatar": ["BDFDB", "badgeAvatar"],
		"bdfdbdev": ["BDFDB", "dev"],
		"bdfdbhasbadge": ["BDFDB", "hasBadge"],
		"bdfdbsupporter": ["BDFDB", "supporter"],
		"bdfdbsupportert1": ["BDFDB", "supporterTier1"],
		"bdfdbsupportert2": ["BDFDB", "supporterTier2"],
		"bdfdbsupportert3": ["BDFDB", "supporterTier3"],
		"bdfdbsupportert4": ["BDFDB", "supporterTier4"],
		"bold": ["TextStyle", "bold"],
		"bottag": ["BotTag", "botTag"],
		"bottaginvert": ["BotTag", "botTagInvert"],
		"bottagmember": ["Member", "botTag"],
		"bottagnametag": ["NameTag", "bot"],
		"bottagpx": ["BotTag", "px"],
		"bottagregular": ["BotTag", "botTagRegular"],
		"bottagrem": ["BotTag", "rem"],
		"bottagtext": ["BotTag", "botText"],
		"bottagverified": ["BotTag", "botTagVerified"],
		"button": ["Button", "button"],
		"buttoncolorblack": ["Button", "colorBlack"],
		"buttoncolorbrand": ["Button", "colorBrand"],
		"buttoncolorgreen": ["Button", "colorGreen"],
		"buttoncolorgrey": ["Button", "colorGrey"],
		"buttoncolorlink": ["Button", "colorLink"],
		"buttoncolorprimary": ["Button", "colorPrimary"],
		"buttoncolorred": ["Button", "colorRed"],
		"buttoncolortransparent": ["Button", "colorTransparent"],
		"buttoncolorwhite": ["Button", "colorWhite"],
		"buttoncoloryellow": ["Button", "colorYellow"],
		"buttoncontents": ["Button", "contents"],
		"buttondisabledoverlay": ["Button", "disabledButtonOverlay"],
		"buttondisabledwrapper": ["Button", "disabledButtonWrapper"],
		"buttonfullwidth": ["Button", "fullWidth"],
		"buttongrow": ["Button", "grow"],
		"buttonhashover": ["Button", "hasHover"],
		"buttonhoverblack": ["Button", "hoverBlack"],
		"buttonhoverbrand": ["Button", "hoverBrand"],
		"buttonhovergreen": ["Button", "hoverGreen"],
		"buttonhovergrey": ["Button", "hoverGrey"],
		"buttonhoverlink": ["Button", "hoverLink"],
		"buttonhoverprimary": ["Button", "hoverPrimary"],
		"buttonhoverred": ["Button", "hoverRed"],
		"buttonhovertransparent": ["Button", "hoverTransparent"],
		"buttonhoverwhite": ["Button", "hoverWhite"],
		"buttonhoveryellow": ["Button", "hoverYellow"],
		"buttonlookblank": ["Button", "lookBlank"],
		"buttonlookfilled": ["Button", "lookFilled"],
		"buttonlookghost": ["Button", "lookGhost"],
		"buttonlookinverted": ["Button", "lookInverted"],
		"buttonlooklink": ["Button", "lookLink"],
		"buttonlookoutlined": ["Button", "lookOutlined"],
		"buttonsizeicon": ["Button", "sizeIcon"],
		"buttonsizelarge": ["Button", "sizeLarge"],
		"buttonsizemax": ["Button", "sizeMax"],
		"buttonsizemedium": ["Button", "sizeMedium"],
		"buttonsizemin": ["Button", "sizeMin"],
		"buttonsizesmall": ["Button", "sizeSmall"],
		"buttonsizexlarge": ["Button", "sizeXlarge"],
		"buttonspinner": ["Button", "spinner"],
		"buttonspinneritem": ["Button", "spinnerItem"],
		"buttonsubmitting": ["Button", "submitting"],
		"callcurrentcontainer": ["CallCurrent", "wrapper"],
		"callcurrentdetails": ["CallDetails", "container"],
		"callcurrentvideo": ["Video", "video"],
		"callincomingicon": ["CallIncoming", "icon"],
		"callincomingroot": ["CallIncoming", "root"],
		"callincomingtitle": ["CallIncoming", "title"],
		"callincomingwrapper": ["CallIncoming", "wrapper"],
		"card": ["Card", "card"],
		"cardbrand": ["Card", "cardBrand"],
		"cardbrandoutline": ["Card", "cardBrandOutline"],
		"carddanger": ["Card", "cardDanger"],
		"carddangeroutline": ["Card", "cardDangerOutline"],
		"cardprimary": ["Card", "cardPrimary"],
		"cardprimaryeditable": ["Card", "cardPrimaryEditable"],
		"cardprimaryoutline": ["Card", "cardPrimaryOutline"],
		"cardprimaryoutlineeditable": ["Card", "cardPrimaryOutlineEditable"],
		"cardsuccess": ["Card", "cardSuccess"],
		"cardsuccessoutline": ["Card", "cardSuccessOutline"],
		"cardwarning": ["Card", "cardWarning"],
		"cardwarningoutline": ["Card", "cardWarningOutline"],
		"categoryarrow": ["CategoryArrow", "arrow"],
		"categoryarrowopen": ["CategoryArrow", "open"],
		"categoryaddbutton": ["Category", "addButton"],
		"categoryaddbuttonicon": ["Category", "addButtonIcon"],
		"categorychildren": ["Category", "children"],
		"categoryclickable": ["Category", "clickable"],
		"categorycollapsed": ["Category", "collapsed"],
		"categorycontainerdefault": ["Category", "containerDefault"],
		"categoryforcevisible": ["Category", "forceVisible"],
		"categoryicon": ["Category", "icon"],
		"categoryiconvisibility": ["Category", "iconVisibility"],
		"categorymaincontent": ["Category", "mainContent"],
		"categorymuted": ["Category", "muted"],
		"categoryname": ["Category", "name"],
		"categorywrapper": ["Category", "wrapper"],
		"changelogadded": ["ChangeLog", "added"],
		"changelogcontainer": ["ChangeLog", "container"],
		"changelogfixed": ["ChangeLog", "fixed"],
		"changelogfooter": ["ChangeLog", "footer"],
		"changelogimproved": ["ChangeLog", "improved"],
		"changelogprogress": ["ChangeLog", "progress"],
		"changelogsociallink": ["ChangeLog", "socialLink"],
		"changelogtitle": ["ChangeLog", "title"],
		"channelactionicon": ["ChannelContainer", "actionIcon"],
		"channelchildicon": ["ChannelContainer", "iconItem"],
		"channelchildiconbase": ["ChannelContainer", "iconBase"],
		"channelchildren": ["Channel", "children"],
		"channelcontainerdefault": ["ChannelContainer", "containerDefault"],
		"channelcontent": ["Channel", "content"],
		"channeldisabled": ["ChannelContainer", "disabled"],
		"channelheaderchannelname": ["ChatWindow", "channelName"],
		"channelheaderchildren": ["HeaderBar", "children"],
		"channelheaderdivider": ["HeaderBar", "divider"],
		"channelheaderheaderbar": ["HeaderBar", "container"],
		"channelheaderheaderbarthemed": ["HeaderBar", "themed"],
		"channelheaderheaderbartitle": ["HeaderBar", "title"],
		"channelheadericon": ["HeaderBar", "icon"],
		"channelheadericonbadge": ["HeaderBar", "iconBadge"],
		"channelheadericonclickable": ["HeaderBar", "clickable"],
		"channelheadericonselected": ["HeaderBar", "selected"],
		"channelheadericonwrapper": ["HeaderBar", "iconWrapper"],
		"channelheadertitle": ["ChatWindow", "title"],
		"channelheadertitlewrapper": ["ChatWindow", "titleWrapper"],
		"channelheadersearch": ["HeaderBarExtras", "search"],
		"channelheadersearchbar": ["HeaderBarSearch", "searchBar"],
		"channelheadersearchicon": ["HeaderBarSearch", "icon"],
		"channelheadersearchinner": ["HeaderBarSearch", "search"],
		"channelheadertoolbar": ["HeaderBar", "toolbar"],
		"channelheadertoolbar2": ["HeaderBarExtras", "toolbar"],
		"channelheadertopic": ["HeaderBarTopic", "topic"],
		"channelheadertopicexpandable": ["HeaderBarTopic", "expandable"],
		"channelicon": ["Channel", "icon"],
		"channeliconcontainer": ["Channel", "iconContainer"],
		"channeliconitem": ["ChannelContainer", "iconItem"],
		"channeliconvisibility": ["ChannelContainer", "iconVisibility"],
		"channelmaincontent": ["Channel", "mainContent"],
		"channelmentionsbadge": ["ChannelContainer", "mentionsBadge"],
		"channelmodeconnected": ["Channel", "modeConnected"],
		"channelmodelocked": ["Channel", "modeLocked"],
		"channelmodemuted": ["Channel", "modeMuted"],
		"channelmodeselected": ["Channel", "modeSelected"],
		"channelmodeunread": ["Channel", "modeUnread"],
		"channelname": ["Channel", "name"],
		"channelnameinner": ["Channel", "channelName"],
		"channelpanel": ["AppBase", "activityPanel"],
		"channelpaneltitle": ["NotFound", "channelPanelTitle"],
		"channelpanels": ["AppBase", "panels"],
		"channels": ["AppBase", "sidebar"],
		"channelselected": ["ChannelContainer", "selected"],
		"channelsscroller": ["GuildChannels", "scroller"],
		"channelsunreadbar": ["GuildChannels", "unreadBar"],
		"channelsunreadbarcontainer": ["GuildChannels", "positionedContainer"],
		"channelsunreadbarbottom": ["GuildChannels", "unreadBottom"],
		"channelsunreadbarunread": ["GuildChannels", "unread"],
		"channelsunreadbartop": ["GuildChannels", "unreadTop"],
		"channelunread": ["Channel", "unread"],
		"channeluserlimit": ["ChannelLimit", "wrapper"],
		"channeluserlimitcontainer": ["ChannelContainer", "userLimit"],
		"channeluserlimittotal": ["ChannelLimit", "total"],
		"channeluserlimitusers": ["ChannelLimit", "users"],
		"channelwrapper": ["Channel", "wrapper"],
		"charcounter": ["BDFDB", "charCounter"],
		"chat": ["ChatWindow", "chat"],
		"chatbase": ["AppBase", "base"],
		"chatcontent": ["ChatWindow", "chatContent"],
		"chatform": ["ChatWindow", "form"],
		"chatinner": ["ChatWindow", "content"],
		"chatspacer": ["AppBase", "content"],
		"checkbox": ["Checkbox", "checkbox"],
		"checkboxbox": ["Checkbox", "box"],
		"checkboxchecked": ["Checkbox", "checked"],
		"checkboxcontainer": ["ModalItems", "checkboxContainer"],
		"checkboxinput": ["Checkbox", "input"],
		"checkboxinputdefault": ["Checkbox", "inputDefault"],
		"checkboxinputdisabled": ["Checkbox", "inputDisabled"],
		"checkboxinputreadonly": ["Checkbox", "inputReadonly"],
		"checkboxlabel": ["Checkbox", "label"],
		"checkboxlabelclickable": ["Checkbox", "labelClickable"],
		"checkboxlabeldisabled": ["Checkbox", "labelDisabled"],
		"checkboxlabelforward": ["Checkbox", "labelForward"],
		"checkboxlabelreversed": ["Checkbox", "labelReversed"],
		"checkboxround": ["Checkbox", "round"],
		"checkboxwrapper": ["Checkbox", "checkboxWrapper"],
		"checkboxwrapperdisabled": ["Checkbox", "checkboxWrapperDisabled"],
		"collapsecontainer": ["BDFDB", "collapseContainer"],
		"collapsecontainercollapsed": ["BDFDB", "collapseContainerCollapsed"],
		"collapsecontainerheader": ["BDFDB", "collapseContainerHeader"],
		"collapsecontainerinner": ["BDFDB", "collapseContainerInner"],
		"collapsecontainermini": ["BDFDB", "collapseContainerMini"],
		"collapsecontainertitle": ["BDFDB", "collapseContainerTitle"],
		"colorbase": ["TextColor2", "base"],
		"colorbrand": ["TextColor", "colorBrand"],
		"colorerror": ["TextColor", "colorError"],
		"colormuted": ["TextColor", "colorMuted"],
		"colorgreen": ["TextColor", "colorStatusGreen"],
		"colorpicker": ["ColorPicker", "colorPickerCustom"],
		"colorpickeralpha": ["BDFDB", "colorPickerAlpha"],
		"colorpickeralphacheckered": ["BDFDB", "colorPickerAlphaCheckered"],
		"colorpickeralphacursor": ["BDFDB", "colorPickerAlphaCursor"],
		"colorpickeralphahorizontal": ["BDFDB", "colorPickerAlphaHorizontal"],
		"colorpickergradient": ["BDFDB", "colorPickerGradient"],
		"colorpickergradientbutton": ["BDFDB", "colorPickerGradientButton"],
		"colorpickergradientbuttonenabled": ["BDFDB", "colorPickerGradientButtonEnabled"],
		"colorpickergradientcheckered": ["BDFDB", "colorPickerGradientCheckered"],
		"colorpickergradientcursor": ["BDFDB", "colorPickerGradientCursor"],
		"colorpickergradientcursoredge": ["BDFDB", "colorPickerGradientCursorEdge"],
		"colorpickergradientcursorselected": ["BDFDB", "colorPickerGradientCursorSelected"],
		"colorpickergradienthorizontal": ["BDFDB", "colorPickerGradientHorizontal"],
		"colorpickerhexinput": ["ColorPicker", "customColorPickerInput"],
		"colorpickerhue": ["ColorPickerInner", "hue"],
		"colorpickerhuecursor": ["NotFound", "hueCursor"],
		"colorpickerhuehorizontal": ["NotFound", "hueHorizontal"],
		"colorpickerhuevertical": ["NotFound", "hueVertical"],
		"colorpickerinner": ["ColorPickerInner", "wrapper"],
		"colorpickerrow": ["ColorPicker", "colorPickerRow"],
		"colorpickersaturation": ["ColorPickerInner", "saturation"],
		"colorpickersaturationblack": ["NotFound", "saturationBlack"],
		"colorpickersaturationcolor": ["NotFound", "saturationColor"],
		"colorpickersaturationcursor": ["NotFound", "saturationCursor"],
		"colorpickersaturationwhite": ["NotFound", "saturationWhite"],
		"colorpickerswatch": ["ColorPicker", "colorPickerSwatch"],
		"colorpickerswatches": ["BDFDB", "colorPickerSwatches"],
		"colorpickerswatchescontainer": ["ColorPicker", "container"],
		"colorpickerswatchesdisabled": ["BDFDB", "colorPickerSwatchesDisabled"],
		"colorpickerswatchcustom": ["ColorPicker", "custom"],
		"colorpickerswatchcustomcontainer": ["ColorPicker", "customContainer"],
		"colorpickerswatchdefault": ["ColorPicker", "default"],
		"colorpickerswatchdefaultcontainer": ["ColorPicker", "defaultContainer"],
		"colorpickerswatchdisabled": ["ColorPicker", "disabled"],
		"colorpickerswatchdropper": ["ColorPicker", "colorPickerDropper"],
		"colorpickerswatchdropperfg": ["ColorPicker", "colorPickerDropperFg"],
		"colorpickerswatchnocolor": ["ColorPicker", "noColor"],
		"colorpickerswatchselected": ["BDFDB", "colorPickerSwatchSelected"],
		"colorpickerswatchsingle": ["BDFDB", "colorPickerSwatchSingle"],
		"colorpickerswatchsinglewrapper": ["BDFDB", "colorPickerSwatchSingleWrapper"],
		"colorpickerwrapper": ["BDFDB", "colorPicker"],
		"colorprimary": ["TextColor", "colorHeaderPrimary"],
		"colorred": ["TextColor", "colorStatusRed"],
		"colorsecondary": ["TextColor", "colorHeaderSecondary"],
		"colorselectable": ["TextColor", "selectable"],
		"colorstandard": ["TextColor", "colorStandard"],
		"coloryellow": ["TextColor", "colorStatusYellow"],
		"combobox": ["Combobox", "combobox"],
		"comboboxitem": ["Combobox", "item"],
		"comboboxitemlabel": ["Combobox", "itemLabel"],
		"cursordefault": ["Cursor", "cursorDefault"],
		"cursorpointer": ["Cursor", "cursorPointer"],
		"customstatusemoji": ["CustomStatusIcon", "emoji"],
		"customstatusicon": ["CustomStatusIcon", "icon"],
		"customstatusitem": ["CustomStatusPopout", "statusItem"],
		"customstatusitemclearbutton": ["CustomStatusPopout", "clearStatusButton"],
		"customstatusitemclearicon": ["CustomStatusPopout", "clearStatusIcon"],
		"customstatusitemcustom": ["CustomStatusPopout", "customStatusItem"],
		"customstatusitemcustomtext": ["CustomStatusPopout", "customText"],
		"customstatusitemcustomwithemoji": ["CustomStatusPopout", "customStatusWithEmoji"],
		"customstatusitememoji": ["CustomStatusPopout", "customEmoji"],
		"customstatusmodal": ["CustomStatusModal", "modalRoot"],
		"dateinputbutton": ["BDFDB", "dateInputButton"],
		"dateinputbuttonselected": ["BDFDB", "dateInputButtonSelected"],
		"dateinputcontrols": ["BDFDB", "dateInputControls"],
		"dateinputfield": ["BDFDB", "dateInputField"],
		"dateinputinner": ["BDFDB", "dateInputInner"],
		"dateinputpreview": ["BDFDB", "dateInputPreview"],
		"dateinputpreviewprefix": ["BDFDB", "dateInputPreviewPrefix"],
		"dateinputpreviewsuffix": ["BDFDB", "dateInputPreviewSuffix"],
		"dateinputwrapper": ["BDFDB", "dateInputWrapper"],
		"defaultcolor": ["Text", "defaultColor"],
		"description": ["FormText", "description"],
		"directiondown": ["IconDirection", "directionDown"],
		"directionleft": ["IconDirection", "directionLeft"],
		"directionright": ["IconDirection", "directionRight"],
		"directionup": ["IconDirection", "directionUp"],
		"directiontransition": ["IconDirection", "transition"],
		"discriminator": ["NameTag", "discriminator"],
		"divider": ["ModalDivider", "divider"],
		"dividerdefault": ["SettingsItems", "dividerDefault"],
		"dmchannel": ["PrivateChannel", "channel"],
		"dmchannelactivity": ["PrivateChannel", "activity"],
		"dmchannelactivityemoji": ["PrivateChannel", "activityEmoji"],
		"dmchannelactivitytext": ["PrivateChannel", "activityText"],
		"dmchannelclose": ["PrivateChannel", "closeButton"],
		"dmchannelheadercontainer": ["PrivateChannelListScroller", "privateChannelsHeaderContainer"],
		"dmchannelheadertext": ["PrivateChannelListScroller", "headerText"],
		"dmchannels": ["PrivateChannelList", "privateChannels"],
		"dmchannelsempty": ["PrivateChannelListScroller", "empty"],
		"dmchannelsscroller": ["PrivateChannelListScroller", "scroller"],
		"dmpill": ["GuildDm", "pill"],
		"downloadlink": ["DownloadLink", "downloadLink"],
		"ellipsis": ["PopoutActivity", "ellipsis"],
		"embed": ["Embed", "embed"],
		"embedauthor": ["Embed", "embedAuthor"],
		"embedauthoricon": ["Embed", "embedAuthorIcon"],
		"embedauthorname": ["Embed", "embedAuthorName"],
		"embedauthornamelink": ["Embed", "embedAuthorNameLink"],
		"embedcentercontent": ["Embed", "centerContent"],
		"embeddescription": ["Embed", "embedDescription"],
		"embedfield": ["Embed", "embedField"],
		"embedfieldname": ["Embed", "embedFieldName"],
		"embedfields": ["Embed", "embedFields"],
		"embedfieldvalue": ["Embed", "embedFieldValue"],
		"embedfooter": ["Embed", "embedFooter"],
		"embedfootericon": ["Embed", "embedFooterIcon"],
		"embedfooterseparator": ["Embed", "embedFooterSeparator"],
		"embedfootertext": ["Embed", "embedFooterText"],
		"embedfull": ["Embed", "embedFull"],
		"embedgiftag": ["Embed", "embedGIFTag"],
		"embedgrid": ["Embed", "grid"],
		"embedhasthumbnail": ["Embed", "hasThumbnail"],
		"embedhiddenspoiler": ["Embed", "hiddenSpoiler"],
		"embediframe": ["Embed", "embedIframe"],
		"embedimage": ["Embed", "embedImage"],
		"embedlink": ["Embed", "embedLink"],
		"embedmargin": ["Embed", "embedMargin"],
		"embedmedia": ["Embed", "embedMedia"],
		"embedprovider": ["Embed", "embedProvider"],
		"embedspoilerattachment": ["Embed", "spoilerAttachment"],
		"embedspoilerembed": ["Embed", "spoilerEmbed"],
		"embedspotify": ["Embed", "embedSpotify"],
		"embedthumbnail": ["Embed", "embedThumbnail"],
		"embedtitle": ["Embed", "embedTitle"],
		"embedtitlelink": ["Embed", "embedTitleLink"],
		"embedvideo": ["Embed", "embedVideo"],
		"embedvideoaction": ["Embed", "embedVideoAction"],
		"embedvideoactions": ["Embed", "embedVideoActions"],
		"embedvideoimagecomponent": ["Embed", "embedVideoImageComponent"],
		"embedvideoimagecomponentinner": ["Embed", "embedVideoImageComponentInner"],
		"embedwrapper": ["MessageAccessory", "embedWrapper"],
		"emoji": ["Emoji", "emoji"],
		"emojiold": ["NotFound", "emoji"],
		"emojibutton": ["EmojiButton", "emojiButton"],
		"emojibuttonhovered": ["EmojiButton", "emojiButtonHovered"],
		"emojibuttonnormal": ["EmojiButton", "emojiButtonNormal"],
		"emojibuttonsprite": ["EmojiButton", "sprite"],
		"emojiinput": ["CustomStatusModal", "input"],
		"emojiinputbutton": ["CustomStatusModal", "emojiButton"],
		"emojiinputbuttoncontainer": ["CustomStatusModal", "emojiButtonContainer"],
		"emojiinputclearbutton": ["CustomStatusModal", "clearButton"],
		"emojiinputclearicon": ["CustomStatusModal", "clearIcon"],
		"emojiinputcontainer": ["CustomStatusModal", "inputContainer"],
		"emojipickerbutton": ["Reactions", "reactionBtn"],
		"emojipicker": ["EmojiPicker", "emojiPicker"],
		"emojipickerdiversityemojiitem": ["EmojiPickerDiversitySelector", "diversityEmojiItem"],
		"emojipickerdiversityemojiitemimage": ["EmojiPickerDiversitySelector", "diversityEmojiItemImage"],
		"emojipickerdiversityselector": ["EmojiPicker", "diversitySelector"],
		"emojipickerdiversityselectoroptions": ["EmojiPickerDiversitySelector", "diversitySelectorOptions"],
		"emojipickerdiversityselectorwrapper": ["EmojiPicker", "diversitySelector"],
		"emojipickeremojispriteimage": ["EmojiPickerItem", "emojiSpriteImage"],
		"emojipickerheader": ["EmojiPicker", "header"],
		"emojipickerinspector": ["EmojiPickerInspector", "inspector"],
		"emojipickerinspectoremoji": ["EmojiPickerInspectorEmoji", "emoji"],
		"errorscreen": ["ErrorScreen", "wrapper"],
		"expressionpicker": ["ExpressionPicker", "contentWrapper"],
		"expressionpickernav": ["ExpressionPicker", "nav"],
		"expressionpickernavbutton": ["ExpressionPicker", "navButton"],
		"expressionpickernavbuttonactive": ["ExpressionPicker", "navButtonActive"],
		"expressionpickernavitem": ["ExpressionPicker", "navItem"],
		"expressionpickernavlist": ["ExpressionPicker", "navList"],
		"discoverycard": ["BDFDB", "discoveryCard"],
		"discoverycardauthor": ["BDFDB", "discoveryCardAuthor"],
		"discoverycardbutton": ["BDFDB", "discoveryCardButton"],
		"discoverycardcontrols": ["BDFDB", "discoveryCardControls"],
		"discoverycardcover": ["BDFDB", "discoveryCardCover"],
		"discoverycardcoverbadge": ["BDFDB", "discoveryCardCoverBadge"],
		"discoverycardcoverwrapper": ["BDFDB", "discoveryCardCoverWrapper"],
		"discoverycarddescription": ["BDFDB", "discoveryCardDescription"],
		"discoverycardfooter": ["BDFDB", "discoveryCardFooter"],
		"discoverycardheader": ["BDFDB", "discoveryCardHeader"],
		"discoverycardicon": ["BDFDB", "discoveryCardIcon"],
		"discoverycardiconloading": ["BDFDB", "discoveryCardIconLoading"],
		"discoverycardiconwrapper": ["BDFDB", "discoveryCardIconWrapper"],
		"discoverycardinfo": ["BDFDB", "discoveryCardInfo"],
		"discoverycardname": ["BDFDB", "discoveryCardName"],
		"discoverycards": ["BDFDB", "discoveryCards"],
		"discoverycardstat": ["BDFDB", "discoveryCardStat"],
		"discoverycardstaticon": ["BDFDB", "discoveryCardStatIcon"],
		"discoverycardstats": ["BDFDB", "discoveryCardStats"],
		"discoverycardtag": ["BDFDB", "discoveryCardTag"],
		"discoverycardtags": ["BDFDB", "discoveryCardTags"],
		"discoverycardtitle": ["BDFDB", "discoveryCardTitle"],
		"discoverycardtitlebutton": ["BDFDB", "discoveryCardTitleButton"],
		"favbuttoncontainer": ["BDFDB", "favButtonContainer"],
		"fileattachment": ["File", "attachment"],
		"fileattachmentinner": ["File", "attachmentInner"],
		"filecancelbutton": ["File", "cancelButton"],
		"filedownloadbutton": ["File", "downloadButton"],
		"filename": ["File", "filename"],
		"filenamelink": ["File", "fileNameLink"],
		"filenamelinkwrapper": ["File", "filenameLinkWrapper"],
		"filenamewrapper": ["File", "filenameWrapper"],
		"flex": ["FlexChild", "flex"],
		"flex2": ["Flex", "flex"],
		"flexalignbaseline": ["Flex", "alignBaseline"],
		"flexaligncenter": ["Flex", "alignCenter"],
		"flexalignend": ["Flex", "alignEnd"],
		"flexalignstart": ["Flex", "alignStart"],
		"flexalignstretch": ["Flex", "alignStretch"],
		"flexcenter": ["Flex", "flexCenter"],
		"flexchild": ["FlexChild", "flexChild"],
		"flexdirectioncolumn": ["Flex", "directionColumn"],
		"flexdirectionrow": ["Flex", "directionRow"],
		"flexdirectionrowreverse": ["Flex", "directionRowReverse"],
		"flexhorizontal": ["FlexChild", "horizontal"],
		"flexhorizontalreverse": ["FlexChild", "horizontalReverse"],
		"flexjustifycenter": ["Flex", "justifyCenter"],
		"flexjustifyend": ["Flex", "justifyEnd"],
		"flexjustifystart": ["Flex", "justifyStart"],
		"flexmarginreset": ["FlexChild", "flexMarginReset"],
		"flexnowrap": ["Flex", "noWrap"],
		"flexspacer": ["Flex", "spacer"],
		"flexvertical": ["Flex", "vertical"],
		"flexwrap": ["Flex", "wrap"],
		"flexwrapreverse": ["Flex", "wrapReverse"],
		"flowerstar": ["FlowerStar", "flowerStar"],
		"flowerstarchild": ["FlowerStar", "childContainer"],
		"flowerstarcontainer": ["FlowerStar", "flowerStarContainer"],
		"formtext": ["FormText", "formText"],
		"game": ["Game", "game"],
		"gameicon": ["GameIcon", "gameIcon"],
		"gameiconlarge": ["GameIcon", "large"],
		"gameiconmedium": ["GameIcon", "medium"],
		"gameiconsmall": ["GameIcon", "small"],
		"gameiconxsmall": ["GameIcon", "xsmall"],
		"gamelibrarytable": ["GameLibraryTable", "table"],
		"gamelibrarytableheader": ["GameLibraryTable", "header"],
		"gamelibrarytableheadercell": ["GameLibraryTable", "headerCell"],
		"gamelibrarytableheadercellsorted": ["GameLibraryTable", "headerCellSorted"],
		"gamelibrarytablerow": ["GameLibraryTable", "row"],
		"gamelibrarytablerowwrapper": ["GameLibraryTable", "rowWrapper"],
		"gamelibrarytablestickyheader": ["GameLibraryTable", "stickyHeader"],
		"gamename": ["Game", "gameName"],
		"gamenameinput": ["Game", "gameNameInput"],
		"giffavoritebutton": ["MessageAccessory", "gifFavoriteButton"],
		"giffavoritecolor": ["GifFavoriteButton", "gifFavoriteButton"],
		"giffavoriteicon": ["GifFavoriteButton", "icon"],
		"giffavoriteshowpulse": ["GifFavoriteButton", "showPulse"],
		"giffavoritesize": ["GifFavoriteButton", "size"],
		"giffavoriteselected": ["GifFavoriteButton", "selected"],
		"goliveactions": ["GoLiveDetails", "actions"],
		"golivebody": ["GoLiveDetails", "body"],
		"goliveclickablegamewrapper": ["GoLiveDetails", "clickableGameWrapper"],
		"golivegameicon": ["GoLiveDetails", "gameIcon"],
		"golivegamename": ["GoLiveDetails", "gameName"],
		"golivegamewrapper": ["GoLiveDetails", "gameWrapper"],
		"goliveinfo": ["GoLiveDetails", "info"],
		"golivepanel": ["GoLiveDetails", "panel"],
		"guild": ["BDFDB", "guild"],
		"guildbuttonbase": ["GuildsItems", "circleButtonBase"],
		"guildbuttoninner": ["GuildsItems", "circleIconButton"],
		"guildbuttonicon": ["GuildsItems", "circleIcon"],
		"guildbuttonpill": ["GuildsItems", "pill"],
		"guildbuttonselected": ["GuildsItems", "selected"],
		"guildchannels": ["GuildChannelsWrapper", "container"],
		"guildcontainer": ["GuildServer", "blobContainer"],
		"guilddiscovery": ["GuildDiscovery", "pageWrapper"],
		"guildedge": ["GuildEdges", "edge"],
		"guildedgehalf": ["GuildEdges", "half"],
		"guildedgehigher": ["GuildEdges", "higher"],
		"guildedgemiddle": ["GuildEdges", "middle"],
		"guildedgewrapper": ["GuildEdges", "wrapper"],
		"guildserror": ["GuildsItems", "guildsError"],
		"guildserrorinner": ["GuildsItems", "errorInner"],
		"guildfolder": ["GuildFolder", "folder"],
		"guildfolderexpandedbackground": ["GuildFolder", "expandedFolderBackground"],
		"guildfolderexpandedbackgroundcollapsed": ["GuildFolder", "collapsed"],
		"guildfolderexpandedbackgroundhover": ["GuildFolder", "hover"],
		"guildfolderguildicon": ["GuildFolder", "guildIcon"],
		"guildfoldericonwrapper": ["GuildFolder", "folderIconWrapper"],
		"guildfoldericonwrapperclosed": ["GuildFolder", "closedFolderIconWrapper"],
		"guildfoldericonwrapperexpanded": ["GuildFolder", "expandedFolderIconWrapper"],
		"guildfolderwrapper": ["GuildFolder", "wrapper"],
		"guildheader": ["GuildHeader", "container"],
		"guildheaderbannerimage": ["GuildHeader", "bannerImage"],
		"guildheaderbannerimagecontainer": ["GuildHeader", "animatedContainer"],
		"guildheaderbannervisible": ["GuildHeader", "bannerVisible"],
		"guildheaderbutton": ["GuildHeaderButton", "button"],
		"guildheaderbuttonopen": ["GuildHeaderButton", "open"],
		"guildheaderclickable": ["GuildHeader", "clickable"],
		"guildheaderhasbanner": ["GuildHeader", "hasBanner"],
		"guildheadericoncontainer": ["GuildHeader", "guildIconContainer"],
		"guildheadericonbgtiernone": ["GuildHeader", "iconBackgroundTierNone"],
		"guildheadericonbgtierone": ["GuildHeader", "iconBackgroundTierOne"],
		"guildheadericonbgtierthree": ["GuildHeader", "iconBackgroundTierThree"],
		"guildheadericonbgtiertwo": ["GuildHeader", "iconBackgroundTierTwo"],
		"guildheadericonpremiumgem": ["GuildHeader", "premiumGuildIconGem"],
		"guildheadericontiernone": ["GuildHeader", "iconTierNone"],
		"guildheadericontierone": ["GuildHeader", "iconTierOne"],
		"guildheadericontierthree": ["GuildHeader", "iconTierThree"],
		"guildheadericontiertwo": ["GuildHeader", "iconTierTwo"],
		"guildheaderheader": ["GuildHeader", "header"],
		"guildheadername": ["GuildHeader", "name"],
		"guildicon": ["GuildIcon", "icon"],
		"guildiconacronym": ["GuildIcon", "acronym"],
		"guildiconbadge": ["GuildsItems", "iconBadge"],
		"guildiconchildwrapper": ["GuildIcon", "childWrapper"],
		"guildiconselected": ["GuildIcon", "selected"],
		"guildiconwrapper": ["GuildIcon", "wrapper"],
		"guildinner": ["Guild", "wrapper"],
		"guildinnerwrapper": ["GuildsItems", "listItemWrapper"],
		"guildlowerbadge": ["Guild", "lowerBadge"],
		"guildlowerleftbadge": ["BDFDB", "guildLowerLeftBadge"],
		"guildouter": ["GuildsItems", "listItem"],
		"guildpill": ["GuildServer", "pill"],
		"guildpillitem": ["PillWrapper", "item"],
		"guildpillwrapper": ["PillWrapper", "wrapper"],
		"guildplaceholder": ["GuildsItems", "dragInner"],
		"guildplaceholdermask": ["GuildsItems", "placeholderMask"],
		"guilds": ["AppBase", "guilds"],
		"guildseparator": ["GuildsItems", "guildSeparator"],
		"guildserror": ["GuildsItems", "guildsError"],
		"guildsettingsbannedcard": ["GuildSettingsBanned", "bannedUser"],
		"guildsettingsbanneddiscrim": ["GuildSettingsBanned", "discrim"],
		"guildsettingsbannedusername": ["GuildSettingsBanned", "username"],
		"guildsettingsemojicard": ["GuildSettingsEmoji", "emojiRow"],
		"guildsettingsinvitecard": ["GuildSettingsInvite", "inviteSettingsInviteRow"],
		"guildsettingsinvitechannelname": ["GuildSettingsInvite", "channelName"],
		"guildsettingsinviteusername": ["GuildSettingsInvite", "username"],
		"guildsettingsmembercard": ["GuildSettingsMember", "member"],
		"guildsettingsmembername": ["GuildSettingsMember", "name"],
		"guildsettingsmembernametag": ["GuildSettingsMember", "nameTag"],
		"guildslabel": ["BDFDB", "guildsLabel"],
		"guildsscroller": ["GuildsWrapper", "scroller"],
		"guildstree": ["GuildsWrapper", "tree"],
		"guildsummaryclickableicon": ["BDFDB", "guildSummaryClickableIcon"],
		"guildsummarycontainer": ["BDFDB", "guildSummaryContainer"],
		"guildsummaryemptyguild": ["BDFDB", "guildSummaryEmptyGuild"],
		"guildsummaryicon": ["BDFDB", "guildSummaryIcon"],
		"guildsummaryiconcontainer": ["BDFDB", "guildSummaryIconContainer"],
		"guildsummaryiconcontainermasked": ["BDFDB", "guildSummaryIconContainerMasked"],
		"guildsummarymoreguilds": ["BDFDB", "guildSummaryMoreGuilds"],
		"guildsummarysvgicon": ["BDFDB", "guildSummarySvgIcon"],
		"guildsvg": ["Guild", "svg"],
		"guildswrapper": ["GuildsWrapper", "wrapper"],
		"guildswrapperhidden": ["GuildsWrapper", "hidden"],
		"guildswrapperunreadmentionsbar": ["GuildsWrapper", "unreadMentionsBar"],
		"guildswrapperunreadmentionsbarbottom": ["GuildsWrapper", "unreadMentionsIndicatorBottom"],
		"guildswrapperunreadmentionsbartop": ["GuildsWrapper", "unreadMentionsIndicatorTop"],
		"guildtutorialcontainer": ["GuildsItems", "tutorialContainer"],
		"guildupperbadge": ["Guild", "upperBadge"],
		"guildupperleftbadge": ["BDFDB", "guildUpperLeftBadge"],
		"h1": ["Text", "h1"],
		"h1defaultmargin": ["Text", "defaultMarginh1"],
		"h2": ["Text", "h2"],
		"h2defaultmargin": ["Text", "defaultMarginh2"],
		"h3": ["Text", "h3"],
		"h3defaultmargin": ["Text", "defaultMarginh3"],
		"h4": ["Text", "h4"],
		"h4defaultmargin": ["Text", "defaultMarginh4"],
		"h5": ["Text", "h5"],
		"h5defaultmargin": ["Text", "defaultMarginh5"],
		"headertitle": ["Text", "title"],
		"headerwrapper": ["TextColor2", "wrapper"],
		"height12": ["UserPopout", "height12"],
		"highlight": ["NotFound", "highlight"],
		"homebuttonicon": ["HomeIcon", "homeIcon"],
		"homebuttonpill": ["HomeIcon", "pill"],
		"hotkeybutton": ["HotKeyRecorder", "button"],
		"hotkeycontainer": ["HotKeyRecorder", "container"],
		"hotkeydisabled": ["HotKeyRecorder", "disabled"],
		"hotkeyediticon": ["HotKeyRecorder", "editIcon"],
		"hotkeyhasvalue": ["HotKeyRecorder", "hasValue"],
		"hotkeyinput": ["HotKeyRecorder", "input"],
		"hotkeyinput2": ["HotKeyRecorder", "input"],
		"hotkeylayout": ["HotKeyRecorder", "layout"],
		"hotkeylayout2": ["HotKeyRecorder", "layout"],
		"hotkeyrecording": ["HotKeyRecorder", "recording"],
		"hotkeyresetbutton": ["BDFDB", "hotkeyResetButton"],
		"hotkeyshadowpulse": ["HotKeyRecorder", "shadowPulse"],
		"hotkeytext": ["HotKeyRecorder", "text"],
		"hotkeywrapper": ["BDFDB", "hotkeyWrapper"],
		"hovercard": ["HoverCard", "card"],
		"hovercardbutton": ["NotFound", "hoverCardButton"],
		"hovercarddisabled": ["BDFDB", "cardDisabled"],
		"hovercardhorizontal": ["BDFDB", "cardHorizontal"],
		"hovercardinner": ["BDFDB", "cardInner"],
		"hovercardwrapper": ["BDFDB", "cardWrapper"],
		"icon": ["EmbedActions", "icon"],
		"iconactionswrapper": ["EmbedActions", "wrapper"],
		"iconexternal": ["EmbedActions", "iconExternal"],
		"iconexternalmargins": ["EmbedActions", "iconExternalMargins"],
		"iconplay": ["EmbedActions", "iconPlay"],
		"iconwrapper": ["EmbedActions", "iconWrapper"],
		"iconwrapperactive": ["EmbedActions", "iconWrapperActive"],
		"imageaccessory": ["ImageWrapper", "imageAccessory"],
		"imageclickable": ["ImageWrapper", "clickable"],
		"imageerror": ["ImageWrapper", "imageError"],
		"imageplaceholder": ["ImageWrapper", "imagePlaceholder"],
		"imageplaceholderoverlay": ["ImageWrapper", "imagePlaceholderOverlay"],
		"imagemodal": ["ImageModal", "modal"],
		"imagemodalimage": ["ImageModal", "image"],
		"imagewrapper": ["ImageWrapper", "imageWrapper"],
		"imagewrapperbackground": ["ImageWrapper", "imageWrapperBackground"],
		"imagewrapperinner": ["ImageWrapper", "imageWrapperInner"],
		"imagezoom": ["ImageWrapper", "imageZoom"],
		"itemlayer": ["ItemLayerContainer", "layer"],
		"itemlayercontainer": ["ItemLayerContainer", "layerContainer"],
		"itemlayercontainerzindexdisabled": ["BDFDB", "layerContainerZIndexDisabled"],
		"itemlayerdisabledpointerevents": ["ItemLayerContainer", "disabledPointerEvents"],
		"input": ["Input", "input"],
		"inputdefault": ["Input", "inputDefault"],
		"inputdisabled": ["Input", "disabled"],
		"inputeditable": ["Input", "editable"],
		"inputerror": ["Input", "error"],
		"inputfocused": ["Input", "focused"],
		"inputlist": ["BDFDB", "listInput"],
		"inputlistdelete": ["BDFDB", "listInputDelete"],
		"inputlistitem": ["BDFDB", "listInputItem"],
		"inputlistitems": ["BDFDB", "listInputItems"],
		"inputmini": ["Input", "inputMini"],
		"inputmulti": ["BDFDB", "multiInput"],
		"inputmultifield": ["BDFDB", "multiInputField"],
		"inputmultifirst": ["BDFDB", "multiInputFirst"],
		"inputmultilast": ["BDFDB", "multiInputLast"],
		"inputmultiwrapper": ["BDFDB", "multiInputWrapper"],
		"inputnumberbutton": ["BDFDB", "inputNumberButton"],
		"inputnumberbuttondown": ["BDFDB", "inputNumberButtonDown"],
		"inputnumberbuttonup": ["BDFDB", "inputNumberButtonUp"],
		"inputnumberbuttons": ["BDFDB", "inputNumberButtons"],
		"inputnumberwrapper": ["BDFDB", "inputNumberWrapper"],
		"inputnumberwrapperdefault": ["BDFDB", "inputNumberWrapperDefault"],
		"inputnumberwrappermini": ["BDFDB", "inputNumberWrapperMini"],
		"inputprefix": ["Input", "inputPrefix"],
		"inputsuccess": ["Input", "success"],
		"inputwrapper": ["Input", "inputWrapper"],
		"invite": ["GuildInvite", "wrapper"],
		"invitebutton": ["GuildInvite", "button"],
		"invitebuttonfornonmember": ["GuildInvite", "buttonForNonMember"],
		"invitebuttonresolving": ["GuildInvite", "invite-button-resolving"],
		"invitebuttonsize": ["GuildInvite", "buttonSize"],
		"invitechannel": ["GuildInvite", "channel"],
		"invitechannelicon": ["GuildInvite", "channelIcon"],
		"invitechannelname": ["GuildInvite", "channelName"],
		"invitecontent": ["GuildInvite", "content"],
		"invitecount": ["GuildInvite", "count"],
		"invitecursordefault": ["GuildInvite", "cursorDefault"],
		"invitedestination": ["GuildInvite", "inviteDestination"],
		"invitedestinationexpired": ["GuildInvite", "inviteDestinationExpired"],
		"invitedestinationjoined": ["GuildInvite", "inviteDestinationJoined"],
		"inviteguildbadge": ["GuildInvite", "guildBadge"],
		"inviteguilddetail": ["GuildInvite", "guildDetail"],
		"inviteguildicon": ["GuildInvite", "guildIcon"],
		"inviteguildiconexpired": ["GuildInvite", "guildIconExpired"],
		"inviteguildiconimage": ["GuildInvite", "guildIconImage"],
		"inviteguildiconimagejoined": ["GuildInvite", "guildIconImageJoined"],
		"inviteguildiconjoined": ["GuildInvite", "guildIconJoined"],
		"inviteguildinfo": ["GuildInvite", "guildInfo"],
		"inviteguildname": ["GuildInvite", "guildName"],
		"inviteguildnamewrapper": ["GuildInvite", "guildNameWrapper"],
		"inviteheader": ["GuildInvite", "header"],
		"invitemodal": ["InviteModal", "modal"],
		"invitemodalinviterow": ["InviteModal", "inviteRow"],
		"invitemodalinviterowname": ["InviteModal", "inviteRowName"],
		"invitemodalwrapper": ["InviteModal", "wrapper"],
		"invitesplash": ["GuildInvite", "inviteSplash"],
		"invitesplashimage": ["GuildInvite", "inviteSplashImage"],
		"invitesplashimageloaded": ["GuildInvite", "inviteSplashImageLoaded"],
		"inviteresolving": ["GuildInvite", "resolving"],
		"inviteresolvingbackground": ["GuildInvite", "resolvingBackground"],
		"invitestatus": ["GuildInvite", "status"],
		"invitestatuscounts": ["GuildInvite", "statusCounts"],
		"invitestatusoffline": ["GuildInvite", "statusOffline"],
		"invitestatusonline": ["GuildInvite", "statusOnline"],
		"inviteuserselectnone": ["GuildInvite", "userSelectNone"],
		"italics": ["TextStyle", "italics"],
		"layermodal": ["LayerModal", "root"],
		"layermodallarge": ["LayerModal", "large"],
		"layermodalmedium": ["LayerModal", "medium"],
		"layermodalsmall": ["LayerModal", "small"],
		"layer": ["Layers", "layer"],
		"layerbase": ["Layers", "baseLayer"],
		"layers": ["Layers", "layers"],
		"layersbg": ["Layers", "bg"],
		"listavatar": ["UserProfile", "listAvatar"],
		"listdiscriminator": ["UserProfile", "listDiscriminator"],
		"listname": ["UserProfile", "listName"],
		"listrow": ["UserProfile", "listRow"],
		"listrowcontent": ["UserProfile", "listRowContent"],
		"listrowwrapper": ["BDFDB", "listRow"],
		"listscroller": ["UserProfile", "listScroller"],
		"livetag": ["LiveTag", "live"],
		"livetaggrey": ["LiveTag", "grey"],
		"livetaglarge": ["LiveTag", "liveLarge"],
		"livetagsmall": ["LiveTag", "liveSmall"],
		"loadingicon": ["BDFDB", "loadingIcon"],
		"loadingiconwrapper": ["BDFDB", "loadingIconWrapper"],
		"loadingscreen": ["LoadingScreen", "container"],
		"loginscreen": ["NotFound", "loginScreen"],
		"marginbottom4": ["Margins", "marginBottom4"],
		"marginbottom8": ["Margins", "marginBottom8"],
		"marginbottom20": ["Margins", "marginBottom20"],
		"marginbottom40": ["Margins", "marginBottom40"],
		"marginbottom60": ["Margins", "marginBottom60"],
		"margincenterhorz": ["Margins", "marginCenterHorz"],
		"marginleft4": ["BDFDB", "marginLeft4"],
		"marginleft8": ["BDFDB", "marginLeft8"],
		"marginreset": ["Margins", "marginReset"],
		"margintop4": ["Margins", "marginTop4"],
		"margintop8": ["Margins", "marginTop8"],
		"margintop20": ["Margins", "marginTop20"],
		"margintop40": ["Margins", "marginTop40"],
		"margintop60": ["Margins", "marginTop60"],
		"member": ["Member", "member"],
		"memberactivity": ["Member", "activity"],
		"membericon": ["Member", "icon"],
		"memberoffline": ["Member", "offline"],
		"memberownericon": ["Member", "ownerIcon"],
		"memberpremiumicon": ["Member", "premiumIcon"],
		"members": ["MembersWrapper", "members"],
		"membersgroup": ["MembersWrapper", "membersGroup"],
		"memberswrap": ["MembersWrapper", "membersWrap"],
		"memberusername": ["Member", "roleColor"],
		"mention": ["NotFound", "mention"],
		"mentioninteractive": ["NotFound", "mentionInteractive"],
		"mentionwrapper": ["NotFound", "mentionWrapper"],
		"menu": ["Menu", "menu"],
		"menucaret": ["Menu", "caret"],
		"menucaretarrow": ["MenuCaret", "arrow"],
		"menucaretopen": ["MenuCaret", "open"],
		"menucheck": ["Menu", "check"],
		"menucheckbox": ["Menu", "checkbox"],
		"menucolorbrand": ["Menu", "colorBrand"],
		"menucolorcustom": ["BDFDB", "menuColorCustom"],
		"menucolordanger": ["Menu", "colorDanger"],
		"menucolordefault": ["Menu", "colorDefault"],
		"menucolorpremium": ["Menu", "colorPremium"],
		"menucustomitem": ["Menu", "customItem"],
		"menudisabled": ["Menu", "disabled"],
		"menufocused": ["Menu", "focused"],
		"menuhideinteraction": ["Menu", "hideInteraction"],
		"menuhint": ["BDFDB", "menuItemHint"],
		"menuhintcontainer": ["Menu", "hintContainer"],
		"menuicon": ["Menu", "icon"],
		"menuiconcontainer": ["Menu", "iconContainer"],
		"menuimage": ["Menu", "image"],
		"menuimagecontainer": ["Menu", "imageContainer"],
		"menuitem": ["Menu", "item"],
		"menulabel": ["Menu", "label"],
		"menulabelcontainer": ["Menu", "labelContainer"],
		"menureactbutton": ["MenuReactButton", "button"],
		"menureactbuttonfocused": ["MenuReactButton", "focused"],
		"menureactbuttonicon": ["MenuReactButton", "icon"],
		"menureactbuttons": ["MenuReactButton", "wrapper"],
		"menuscroller": ["Menu", "scroller"],
		"menuseparator": ["Menu", "separator"],
		"menuslider": ["MenuSlider", "slider"],
		"menuslidercontainer": ["MenuSlider", "sliderContainer"],
		"menustylefixed": ["Menu", "styleFixed"],
		"menustyleflexible": ["Menu", "styleFlexible"],
		"menusubmenu": ["Menu", "submenu"],
		"menusubmenucontainer": ["Menu", "submenuContainer"],
		"menusubtext": ["Menu", "subtext"],
		"message": ["Message", "message"],
		"messageaccessory": ["MessageAccessory", "container"],
		"messageavatar": ["MessageBody", "avatar"],
		"messageavatarclickable": ["MessageBody", "clickable"],
		"messagebackgroundflash": ["Message", "backgroundFlash"],
		"messagebarbase": ["MessageElements", "barBase"],
		"messagebarbuttonalt": ["MessageElements", "barButtonAlt"],
		"messagebarbuttonbase": ["MessageElements", "barButtonBase"],
		"messagebarbuttonicon": ["MessageElements", "barButtonIcon"],
		"messagebarbuttonmain": ["MessageElements", "barButtonMain"],
		"messagebarhasmore": ["MessageElements", "hasMore"],
		"messagebarjumptopresentbar": ["MessageElements", "jumpToPresentBar"],
		"messagebarloadingmore": ["MessageElements", "loadingMore"],
		"messagebarnewmessagesbar": ["MessageElements", "newMessagesBar"],
		"messagebarspan": ["MessageElements", "span"],
		"messagebarspinner": ["MessageElements", "spinner"],
		"messagebarspinneritem": ["MessageElements", "spinnerItem"],
		"messagebeforegroup": ["Message", "beforeGroup"],
		"messageblockedaction": ["MessageBlocked", "blockedAction"],
		"messageblockedcontainer": ["MessageBlocked", "container"],
		"messageblockedexpanded": ["MessageBlocked", "expanded"],
		"messageblockedicon": ["MessageBlocked", "blockedIcon"],
		"messageblockedsystemmessage": ["MessageBlocked", "blockedSystemMessage"],
		"messageblockedtext": ["MessageBlocked", "blockedMessageText"],
		"messageblockquotecontainer": ["MessageMarkup", "blockquoteContainer"],
		"messageblockquotedivider": ["MessageMarkup", "blockquoteDivider"],
		"messagebottag": ["MessageBody", "botTag"],
		"messagebottagcompact": ["MessageBody", "botTagCompact"],
		"messagebottagcozy": ["MessageBody", "botTagCozy"],
		"messagebuttoncontainer": ["MessageBody", "buttonContainer"],
		"messagebuttons": ["Message", "buttons"],
		"messagechanneltextarea": ["Message", "channelTextArea"],
		"messagecompact": ["MessageBody", "compact"],
		"messagecontents": ["MessageBody", "contents"],
		"messagecozy": ["MessageBody", "cozy"],
		"messagecozymessage": ["Message", "cozyMessage"],
		"messagedisableinteraction": ["Message", "disableInteraction"],
		"messagedivider": ["Message", "divider"],
		"messagedividerhascontent": ["Message", "hasContent"],
		"messageedited": ["MessageBody", "edited"],
		"messagegroupstart": ["Message", "groupStart"],
		"messagegroupblocked": ["MessageElements", "messageGroupBlocked"],
		"messagegroupblockedbtn": ["MessageElements", "messageGroupBlockedBtn"],
		"messagegroupblockedrevealed": ["MessageElements", "revealed"],
		"messageheader": ["MessageBody", "header"],
		"messageheadertext": ["MessageBody", "headerText"],
		"messagelocalbot": ["Message", "ephemeral"],
		"messagelocalboticon": ["MessageLocalBot", "icon"],
		"messagelocalbotoperations": ["MessageLocalBot", "ephemeralMessage"],
		"messagemarkup": ["MessageMarkup", "markup"],
		"messagemarkupcompact": ["MessageBody", "compact"],
		"messagemarkupcontent": ["MessageBody", "messageContent"],
		"messagemarkupcozy": ["MessageBody", "cozy"],
		"messagemarkupisfailed": ["MessageBody", "isFailed"],
		"messagemarkupissending": ["MessageBody", "isSending"],
		"messagemarkuprtl": ["MessageBody", "markupRtl"],
		"messagementioned": ["Message", "mentioned"],
		"messagepopout": ["MessagePopout", "message"],
		"messageoperations": ["MessageOperations", "operations"],
		"messagereaction": ["MessageReactions", "reaction"],
		"messagereactionme": ["MessageReactions", "reactionMe"],
		"messagereactions": ["MessageReactions", "reactions"],
		"messagereactionsmodalemoji": ["MessageReactionsModal", "emoji"],
		"messagereactionsmodalname": ["MessageReactionsModal", "name"],
		"messagereactionsmodalnickname": ["MessageReactionsModal", "nickname"],
		"messagereactionsmodalreactor": ["MessageReactionsModal", "reactor"],
		"messagereactionsmodalusername": ["MessageReactionsModal", "username"],
		"messagerepliedmessage": ["MessageBody", "repliedMessage"],
		"messagerepliedmessagecontent": ["MessageBody", "repliedTextContent"],
		"messagerepliedmessagecontentclickable": ["MessageBody", "clickable"],
		"messagerepliedmessagepreview": ["MessageBody", "repliedTextPreview"],
		"messagereply": ["MessageReply", "container"],
		"messagereplyname": ["MessageReply", "name"],
		"messagereplytext": ["MessageReply", "text"],
		"messageselected": ["Message", "selected"],
		"messages": ["MessagesWrap", "messages"],
		"messagesdivider": ["MessagesWrap", "divider"],
		"messagesloadingavatar": ["MessagesLoading", "avatar"],
		"messagesloadingcompact": ["MessagesLoading", "compact"],
		"messagesloadingcozy": ["MessagesLoading", "cozy"],
		"messagesloadingmessage": ["MessagesLoading", "wrapper"],
		"messagesloadingwrapper": ["NotFound", "messagesLoadingWrapper"],
		"messagespopout": ["MessagesPopout", "messagesPopout"],
		"messagespopoutactionbuttons": ["MessagesPopout", "actionButtons"],
		"messagespopoutbody": ["MessagesPopout", "body"],
		"messagespopoutbottom": ["MessagesPopout", "bottom"],
		"messagespopoutbutton": ["MessagesPopoutButtons", "button"],
		"messagespopoutbuttonsecondary": ["MessagesPopoutButtons", "secondary"],
		"messagespopoutbuttonsize24": ["MessagesPopoutButtons", "size24"],
		"messagespopoutbuttonsize32": ["MessagesPopoutButtons", "size32"],
		"messagespopoutbuttonsize36": ["MessagesPopoutButtons", "size36"],
		"messagespopoutbuttontertiary": ["MessagesPopoutButtons", "tertiary"],
		"messagespopoutchannelname": ["MessagesPopout", "channelName"],
		"messagespopoutchannelseparator": ["MessagesPopout", "channelSeparator"],
		"messagespopoutclosebutton": ["MessagesPopout", "closeIcon"],
		"messagespopoutemptyplaceholder": ["MessagesPopout", "emptyPlaceholder"],
		"messagespopoutfooter": ["MessagesPopout", "footer"],
		"messagespopoutguildname": ["MessagesPopout", "guildName"],
		"messagespopoutgroupcozy": ["MessagesPopout", "messageGroupCozy"],
		"messagespopoutgroupwrapper": ["MessagesPopout", "messageGroupWrapper"],
		"messagespopouthasmore": ["MessagesPopout", "hasMore"],
		"messagespopoutheader": ["MessagesPopout", "header"],
		"messagespopoutimage": ["MessagesPopout", "image"],
		"messagespopoutjumpbutton": ["MessagesPopout", "jumpButton"],
		"messagespopoutloading": ["MessagesPopout", "loading"],
		"messagespopoutloadingmore": ["MessagesPopout", "loadingMore"],
		"messagespopoutloadingplaceholder": ["MessagesPopout", "loadingPlaceholder"],
		"messagespopoutscrollingfooterwrap": ["MessagesPopout", "scrollingFooterWrap"],
		"messagespopoutspinner": ["MessagesPopout", "spinner"],
		"messagespopouttabbar": ["MessagesPopoutTabBar", "tabBar"],
		"messagespopouttabbarheader": ["MessagesPopoutTabBar", "header"],
		"messagespopouttabbartab": ["MessagesPopoutTabBar", "tab"],
		"messagespopouttabbartabactive": ["MessagesPopoutTabBar", "active"],
		"messagespopouttitle": ["MessagesPopout", "title"],
		"messagespopoutvisible": ["MessagesPopout", "visible"],
		"messagespopoutwrap": ["MessagesPopout", "messagesPopoutWrap"],
		"messagesscroller": ["MessagesWrap", "scroller"],
		"messagesscrollercontent": ["MessagesWrap", "scrollerContent"],
		"messagesscrollerinner": ["MessagesWrap", "scrollerInner"],
		"messagesscrollerwrapper": ["MessagesWrap", "scrollerWrap"],
		"messageswelcome": ["MessagesWelcome", "container"],
		"messageswelcomebutton": ["MessagesWelcomeButton", "button"],
		"messageswelcomebuttoncontainer": ["NotFound", "messagesWelcomeChannelButtonContainer"],
		"messageswelcomebuttonicon": ["MessagesWelcomeButton", "buttonIcon"],
		"messageswelcomedescription": ["MessagesWelcome", "description"],
		"messageswelcomeemptychannelicon": ["MessagesWelcome", "emptyChannelIcon"],
		"messageswelcomeheader": ["MessagesWelcome", "header"],
		"messageswelcomelocked": ["MessagesWelcome", "locked"],
		"messageswrapper": ["MessagesWrap", "messagesWrapper"],
		"messagesystem": ["Message", "systemMessage"],
		"messagesystemaccessories": ["MessageBody", "systemMessageAccessories"],
		"messagesystemcontainer": ["MessageSystem", "container"],
		"messagesystemcontent": ["MessageSystem", "content"],
		"messagesystemicon": ["MessageSystem", "icon"],
		"messagesystemiconcontainer": ["MessageSystem", "iconContainer"],
		"messagesystemiconsize": ["MessageSystem", "iconSize"],
		"messagetimedivider": ["MessageDivider", "divider"],
		"messagetimedividercontent": ["MessageDivider", "content"],
		"messagetimedividerhascontent": ["MessageDivider", "hasContent"],
		"messagetimedividerisunread": ["MessageDivider", "isUnread"],
		"messagetimedividerunreadpill": ["MessageDivider", "unreadPill"],
		"messagetimedividerunreadpillcap": ["MessageDivider", "unreadPillCap"],
		"messagetimedividerunreadpillcapstroke": ["MessageDivider", "unreadPillCapStroke"],
		"messagetimestampasiancompact": ["MessageBody", "asianCompactTimeStamp"],
		"messagetimestamp": ["MessageBody", "timestamp"],
		"messagetimestampalt": ["MessageBody", "alt"],
		"messagetimestampinline": ["MessageBody", "timestampInline"],
		"messagetimestamplatin12compact": ["MessageBody", "latin12CompactTimeStamp"],
		"messagetimestamplatin24compact": ["MessageBody", "latin24CompactTimeStamp"],
		"messagetimestampseparator": ["MessageBody", "separator"],
		"messagetimestampsystem": ["MessageSystem", "timestamp"],
		"messagetimestamptooltip": ["MessageBody", "timestampTooltip"],
		"messagetimestampvisibleonhover": ["MessageBody", "timestampVisibleOnHover"],
		"messagetoolbar": ["MessageToolbar", "container"],
		"messagetoolbarbutton": ["MessageToolbarItems", "button"],
		"messagetoolbarbuttondisabled": ["MessageToolbarItems", "disabled"],
		"messagetoolbarbuttonselected": ["MessageToolbarItems", "selected"],
		"messagetoolbaricon": ["MessageToolbar", "icon"],
		"messagetoolbarinner": ["MessageToolbarItems", "wrapper"],
		"messagetoolbarisheader": ["MessageToolbar", "isHeader"],
		"messagetoolbarseparator": ["MessageToolbarItems", "separator"],
		"messageuploadcancel": ["MessageFile", "cancelButton"],
		"messageusername": ["MessageBody", "username"],
		"messagewrapper": ["MessageBody", "wrapper"],
		"messagezalgo": ["MessageBody", "zalgo"],
		"modal": ["ModalWrap", "modal"],
		"modalcancelbutton": ["CustomStatusModal", "cancelButton"],
		"modalclose": ["LayerModal", "close"],
		"modalchangelogmodal": ["BDFDB", "changeLogModal"],
		"modalconfirmmodal": ["BDFDB", "confirmModal"],
		"modalcontent": ["LayerModal", "content"],
		"modalfooter": ["LayerModal", "footer"],
		"modalguildname": ["ModalItems", "guildName"],
		"modalheader": ["LayerModal", "header"],
		"modalheaderhassibling": ["BDFDB", "modalHeaderHasSibling"],
		"modalheadershade": ["BDFDB", "modalHeaderShade"],
		"modalinner": ["ModalWrap", "inner"],
		"modalmini": ["ModalMiniContent", "modal"],
		"modalminicontent": ["ModalMiniContent", "content"],
		"modalminitext": ["HeaderBarTopic", "content"],
		"modalnoscroller": ["BDFDB", "modalNoScroller"],
		"modalseparator": ["LayerModal", "separator"],
		"modalsidebar": ["BDFDB", "modalSidebar"],
		"modalsizelarge": ["Modal", "sizeLarge"],
		"modalsizemedium": ["Modal", "sizeMedium"],
		"modalsizesmall": ["Modal", "sizeSmall"],
		"modalsub": ["Modal", "modal"],
		"modalsubinner": ["BDFDB", "modalSubInner"],
		"modaltabcontent": ["BDFDB", "modalTabContent"],
		"modaltabcontentopen": ["BDFDB", "modalTabContentOpen"],
		"modaltextcontent": ["BDFDB", "modalTextContent"],
		"modalwrapper": ["BDFDB", "modalWrapper"],
		"modedefault": ["FormText", "modeDefault"],
		"modedisabled": ["FormText", "modeDisabled"],
		"modeselectable": ["FormText", "modeSelectable"],
		"namecontainer": ["NameContainer", "container"],
		"namecontaineravatar": ["NameContainer", "avatar"],
		"namecontainerchildren": ["NameContainer", "children"],
		"namecontainerclickable": ["NameContainer", "clickable"],
		"namecontainercontent": ["NameContainer", "content"],
		"namecontainerlayout": ["NameContainer", "layout"],
		"namecontainername": ["NameContainer", "name"],
		"namecontainernamecontainer": ["NotFound", "nameContainerNameContainer"],
		"namecontainernamewrapper": ["NameContainer", "nameAndDecorators"],
		"namecontainerselected": ["NameContainer", "selected"],
		"namecontainersubtext": ["NameContainer", "subText"],
		"nametag": ["NameTag", "nameTag"],
		"nitrostore": ["NitroStore", "applicationStore"],
		"nochannel": ["ChatWindow", ["noChannel", "noChat"]],
		"notice": ["Notice", "notice"],
		"noticebrand": ["Notice", "colorBrand"],
		"noticebutton": ["Notice", "button"],
		"noticeclosing": ["BDFDB", "noticeClosing"],
		"noticecustom": ["Notice", "colorCustom"],
		"noticedanger": ["Notice", "colorDanger"],
		"noticedark": ["Notice", "colorDark"],
		"noticedefault": ["Notice", "colorDefault"],
		"noticedownload": ["Notice", "colorDownload"],
		"noticedismiss": ["Notice", "closeButton"],
		"noticeicon": ["NoticePlatform", "icon"],
		"noticeiconandroid": ["NoticePlatform", "iconAndroid"],
		"noticeiconapple": ["NoticePlatform", "iconApple"],
		"noticeiconwindows": ["NoticePlatform", "iconWindows"],
		"noticeinfo": ["Notice", "colorInfo"],
		"noticeneutral": ["Notice", "colorNeutral"],
		"noticenotification": ["Notice", "colorNotification"],
		"noticeplatformicon": ["NoticePlatform", "platformIcon"],
		"noticepremium": ["Notice", "colorPremium"],
		"noticepremiumaction": ["NoticePlatform", "premiumAction"],
		"noticepremiumicon": ["NoticePlatform", "premiumIcon"],
		"noticepremiumlogo": ["NoticePlatform", "premiumLogo"],
		"noticepremiumtext": ["NoticePlatform", "premiumText"],
		"noticepremiumtier1": ["Notice", "colorPremiumTier1"],
		"noticepremiumtier2": ["Notice", "colorPremiumTier2"],
		"noticespotify": ["Notice", "colorSpotify"],
		"noticestreamer": ["Notice", "colorStreamerMode"],
		"noticesuccess": ["Notice", "colorSuccess"],
		"noticetext": ["BDFDB", "noticeText"],
		"noticetextlink": ["NoticePlatform", "textLink"],
		"noticeupdate": ["BDFDB", "noticeUpdate"],
		"noticeupdatebuttonall": ["BDFDB", "noticeUpdateButtonAll"],
		"noticeupdatebuttonreload": ["BDFDB", "noticeUpdateButtonReload"],
		"noticeupdateentries": ["BDFDB", "noticeUpdateEntries"],
		"noticeupdateentry": ["BDFDB", "noticeUpdateEntry"],
		"noticeupdatetext": ["BDFDB", "noticeUpdateText"],
		"noticeupdateseparator": ["BDFDB", "noticeUpdateSeparator"],
		"noticewrapper": ["BDFDB", "noticeWrapper"],
		"overflowellipsis": ["BDFDB", "overflowEllipsis"],
		"pagination": ["BDFDB", "pagination"],
		"paginationbottom": ["BDFDB", "paginationBottom"],
		"paginationbutton": ["Pagination", "pageButton"],
		"paginationbuttonactive": ["Pagination", "activeButton"],
		"paginationbuttonend": ["Pagination", "endButton"],
		"paginationbuttonendinner": ["Pagination", "endButtonInner"],
		"paginationbuttonround": ["Pagination", "roundButton"],
		"paginationcontainer": ["Pagination", "pageControlContainer"],
		"paginationcontrol": ["Pagination", "pageControl"],
		"paginationgap": ["Pagination", "gap"],
		"paginationicon": ["Pagination", "iconCaret"],
		"paginationlist": ["BDFDB", "paginationList"],
		"paginationlistalphabet": ["BDFDB", "paginationListAlphabet"],
		"paginationlistalphabetchar": ["BDFDB", "paginationListAlphabetChar"],
		"paginationlistalphabetchardisabled": ["BDFDB", "paginationListAlphabetCharDisabled"],
		"paginationlistcontent": ["BDFDB", "paginationListContent"],
		"paginationlistmini": ["BDFDB", "paginationListMini"],
		"paginationmini": ["BDFDB", "paginationMini"],
		"paginationtop": ["BDFDB", "paginationTop"],
		"peopleactions": ["PeopleItemInfo", "actions"],
		"peopleinner": ["PeopleItemInfo", "listItemContents"],
		"peoples": ["Peoples", "container"],
		"peoplesbadge": ["Peoples", "badge"],
		"peoplesnowplayingcolumn": ["Peoples", "nowPlayingColumn"],
		"peoplespeoplecolumn": ["Peoples", "peopleColumn"],
		"peoplestabbar": ["Peoples", "tabBar"],
		"peoplewrapper": ["PeopleItem", "peopleListItem"],
		"pictureinpicture": ["PictureInPicture", "pictureInPicture"],
		"pictureinpicturewindow": ["PictureInPicture", "pictureInPictureWindow"],
		"popout": ["Popout", "popout"],
		"popoutarrowalignmentmiddle": ["Popout", "arrowAlignmentMiddle"],
		"popoutarrowalignmenttop": ["Popout", "arrowAlignmentTop"],
		"popoutbottom": ["Popout", "popoutBottom"],
		"popoutbottomleft": ["Popout", "popoutBottomLeft"],
		"popoutbottomright": ["Popout", "popoutBottomRight"],
		"popoutinvert": ["Popout", "popoutInvert"],
		"popoutleft": ["Popout", "popoutLeft"],
		"popoutnoarrow": ["Popout", "noArrow"],
		"popoutnoshadow": ["Popout", "noShadow"],
		"popoutright": ["Popout", "popoutRight"],
		"popouts": ["Popout", "popouts"],
		"popoutthemedpopout": ["BDFDB", "themedPopout"],
		"popouttop": ["Popout", "popoutTop"],
		"popouttopleft": ["Popout", "popoutTopLeft"],
		"popouttopright": ["Popout", "popoutTopRight"],
		"popoutwrapper": ["BDFDB", "popoutWrapper"],
		"quickmessage": ["QuickMessage", "input"],
		"quickselect": ["QuickSelect", "quickSelect"],
		"quickselectarrow": ["QuickSelect", "quickSelectArrow"],
		"quickselectclick": ["QuickSelect", "quickSelectClick"],
		"quickselectlabel": ["QuickSelect", "quickSelectLabel"],
		"quickselectvalue": ["QuickSelect", "quickSelectValue"],
		"quickselectwrapper": ["BDFDB", "quickSelectWrapper"],
		"quickswitcher": ["QuickSwitchWrap", "quickswitcher"],
		"quickswitchresult": ["QuickSwitch", "result"],
		"quickswitchresultfocused": ["QuickSwitch", "resultFocused"],
		"quickswitchresultguildicon": ["QuickSwitch", "guildIcon"],
		"quickswitchresulticon": ["QuickSwitch", "icon"],
		"quickswitchresulticoncontainer": ["QuickSwitch", "iconContainer"],
		"quickswitchresultmatch": ["QuickSwitch", "match"],
		"quickswitchresultmisccontainer": ["QuickSwitchWrap", "miscContainer"],
		"quickswitchresultname": ["QuickSwitch", "name"],
		"quickswitchresultnote": ["QuickSwitch", "note"],
		"quickswitchresultusername": ["QuickSwitch", "username"],
		"radiogroup": ["RadioGroup", "item"],
		"radiogroupinner": ["RadioGroup", "radioBar"],
		"recentmentionschannelname": ["RecentMentionsHeader", "channelName"],
		"recentmentionsclosebutton": ["RecentMentions", "closeButton"],
		"recentmentionsdmicon": ["RecentMentionsHeader", "dmIcon"],
		"recentmentionsguildicon": ["RecentMentionsHeader", "guildIcon"],
		"recentmentionsguildname": ["RecentMentionsHeader", "guildName"],
		"recentmentionsjumpbutton": ["RecentMentions", "jumpButton"],
		"recentmentionspopout": ["RecentMentions", "recentMentionsPopout"],
		"scrollbar": ["Scrollbar", "scrollbar"],
		"scrollbardefault": ["Scrollbar", "scrollbarDefault"],
		"scrollbarghost": ["Scrollbar", "scrollbarGhost"],
		"scrollbarghosthairline": ["Scrollbar", "scrollbarGhostHairline"],
		"scroller": ["Scroller", "scrollerBase"],
		"scrollerauto": ["Scroller", "auto"],
		"scrollercontent": ["Scroller", "content"],
		"scrollerdisablescrollanchor": ["Scroller", "disableScrollAnchor"],
		"scrollerfade": ["Scroller", "fade"],
		"scrollernone": ["Scroller", "none"],
		"scrollerscrolling": ["Scroller", "scrolling"],
		"scrollerthin": ["Scroller", "thin"],
		"searchbar": ["SearchBar", "container"],
		"searchbarclear": ["SearchBar", "clear"],
		"searchbarclose": ["SearchBar", "close"],
		"searchbaricon": ["SearchBar", "icon"],
		"searchbariconlayout": ["SearchBar", "iconLayout"],
		"searchbariconwrap": ["SearchBar", "iconContainer"],
		"searchbarinner": ["SearchBar", "inner"],
		"searchbarinput": ["SearchBar", "input"],
		"searchbarlarge": ["SearchBar", "large"],
		"searchbarmedium": ["SearchBar", "medium"],
		"searchbarsmall": ["SearchBar", "small"],
		"searchbartag": ["SearchBar", "tag"],
		"searchbarvisible": ["SearchBar", "visible"],
		"searchbarwrapper": ["BDFDB", "searchBarWrapper"],
		"searchpopout": ["SearchPopoutWrap", "container"],
		"searchpopoutanswer": ["SearchPopout", "answer"],
		"searchpopoutdatepicker": ["SearchPopout", "datePicker"],
		"searchpopoutdatepickerhint": ["SearchPopout", "datePickerHint"],
		"searchpopoutdmaddpopout": ["DmAddPopout", "popout"],
		"searchpopoutddmadddiscordtag": ["DmAddPopoutItems", "discordTag"],
		"searchpopoutddmaddfriend": ["DmAddPopoutItems", "friend"],
		"searchpopoutddmaddfriendwrapper": ["DmAddPopoutItems", "friendWrapper"],
		"searchpopoutddmaddnickname": ["DmAddPopoutItems", "nickname"],
		"searchpopoutdisplayavatar": ["SearchPopout", "displayAvatar"],
		"searchpopoutdisplayusername": ["SearchPopout", "displayUsername"],
		"searchpopoutdisplayednick": ["SearchPopout", "displayedNick"],
		"searchpopoutfilter": ["SearchPopout", "filter"],
		"searchpopoutheader": ["SearchPopout", "header"],
		"searchpopouthint": ["SearchPopout", "hint"],
		"searchpopouthintvalue": ["SearchPopout", "hintValue"],
		"searchpopoutlinksource": ["SearchPopout", "linkSource"],
		"searchpopoutnontext": ["SearchPopout", "nonText"],
		"searchpopoutoption": ["SearchPopout", "option"],
		"searchpopoutplusicon": ["SearchPopout", "plusIcon"],
		"searchpopoutresultchannel": ["SearchPopout", "resultChannel"],
		"searchpopoutresultsgroup": ["SearchPopout", "resultsGroup"],
		"searchpopoutsearchclearhistory": ["SearchPopout", "searchClearHistory"],
		"searchpopoutsearchlearnmore": ["SearchPopout", "searchLearnMore"],
		"searchpopoutsearchoption": ["SearchPopout", "searchOption"],
		"searchpopoutsearchresultchannelcategory": ["SearchPopout", "searchResultChannelCategory"],
		"searchpopoutsearchresultchannelicon": ["SearchPopout", "searchResultChannelIcon"],
		"searchpopoutsearchresultchanneliconbackground": ["SearchPopout", "searchResultChannelIconBackground"],
		"searchpopoutselected": ["SearchPopout", "selected"],
		"searchpopoutuser": ["SearchPopout", "user"],
		"searchresultschannelname": ["SearchResultsGroup", "channelName"],
		"searchresultsgroup": ["SearchResultsGroup", "searchResultGroup"],
		"searchresultsmessage": ["SearchResultsMessage", "message"],
		"searchresultspagination": ["NotFound", "searchResultsPagination"],
		"searchresultsresult": ["SearchResultsMessage", "searchResult"],
		"searchresultswrap": ["SearchResults", "searchResultsWrap"],
		"select": ["SelectSearchable", "select"],
		"selectoption": ["SelectSearchable", "option"],
		"selectsearchinput": ["SelectSearchable", "searchInput"],
		"selectselectedicon": ["SelectSearchable", "selectedIcon"],
		"selectwrapper": ["BDFDB", "selectWrapper"],
		"settingsclosebutton": ["SettingsCloseButton", "closeButton"],
		"settingsclosebuttoncontainer": ["SettingsCloseButton", "container"],
		"settingsguild": ["BDFDB", "settingsGuild"],
		"settingsguilddisabled": ["BDFDB", "settingsGuildDisabled"],
		"settingsheader": ["Item", "header"],
		"settingsitem": ["Item", "item"],
		"settingsitemdragged": ["ItemRole", "dragged"],
		"settingsitemdlock": ["ItemRole", "lock"],
		"settingsitemrole": ["ItemRole", "role"],
		"settingsitemroleinner": ["ItemRole", "roleInner"],
		"settingsitemselected": ["Item", "selected"],
		"settingsitemthemed": ["Item", "themed"],
		"settingspanel": ["BDFDB", "settingsPanel"],
		"settingspanellist": ["BDFDB", "settingsPanelList"],
		"settingspanellistwrapper": ["BDFDB", "settingsPanelListWrapper"],
		"settingspanellistwrappermini": ["BDFDB", "settingsPanelListWrapperMini"],
		"settingsrow": ["SettingsItems", "container"],
		"settingsrowcontainer": ["BDFDB", "settingsRow"],
		"settingsrowcontrol": ["SettingsItems", "control"],
		"settingsrowdisabled": ["SettingsItems", "disabled"],
		"settingsrowlabel": ["SettingsItems", "labelRow"],
		"settingsrownote": ["SettingsItems", "note"],
		"settingsrowtitle": ["SettingsItems", "title"],
		"settingsrowtitledefault": ["SettingsItems", "titleDefault"],
		"settingsrowtitlemini": ["SettingsItems", "titleMini"],
		"settingsseparator": ["Item", "separator"],
		"settingstableheader": ["SettingsTable", "header"],
		"settingstableheadername": ["SettingsTable", "headerName"],
		"settingstableheaderoption": ["SettingsTable", "headerOption"],
		"settingstableheaderoptions": ["BDFDB", "settingsTableHeaderOptions"],
		"settingstableheaders": ["BDFDB", "settingsTableHeaders"],
		"settingstableheadervertical": ["BDFDB", "settingsTableHeaderVertical"],
		"settingstablecard": ["BDFDB", "settingsTableCard"],
		"settingstablecardconfigs": ["BDFDB", "settingsTableCardConfigs"],
		"settingstablecardlabel": ["BDFDB", "settingsTableCardLabel"],
		"settingstablelist": ["BDFDB", "settingsTableList"],
		"settingswindowcontentcolumn": ["SettingsWindow", "contentColumn"],
		"settingswindowcontentregion": ["SettingsWindow", "contentRegion"],
		"settingswindowcontentregionscroller": ["SettingsWindow", "contentRegionScroller"],
		"settingswindowsidebarregion": ["SettingsWindow", "sidebarRegion"],
		"settingswindowsidebarregionscroller": ["SettingsWindow", "sidebarRegionScroller"],
		"settingswindowstandardsidebarview": ["SettingsWindow", "standardSidebarView"],
		"settingswindowsubsidebarcontent": ["SettingsWindowScroller", "content"],
		"settingswindowsubsidebarscroller": ["SettingsWindowScroller", "scroller"],
		"settingswindowtoolscontainer": ["SettingsWindow", "toolsContainer"],
		"sidebar": ["BDFDB", "sidebar"],
		"sidebarcontent": ["BDFDB", "sidebarContent"],
		"sidebarlist": ["BDFDB", "sidebarList"],
		"size10": ["TextSize", "size10"],
		"size12": ["TextSize", "size12"],
		"size14": ["TextSize", "size14"],
		"size16": ["TextSize", "size16"],
		"size20": ["TextSize", "size20"],
		"size24": ["TextSize", "size24"],
		"size32": ["TextSize", "size32"],
		"slider": ["Slider", "slider"],
		"sliderbar": ["Slider", "bar"],
		"sliderbarfill": ["Slider", "barFill"],
		"sliderbubble": ["BDFDB", "sliderBubble"],
		"sliderdisabled": ["Slider", "disabled"],
		"slidergrabber": ["Slider", "grabber"],
		"sliderinput": ["Slider", "input"],
		"slidermark": ["Slider", "mark"],
		"slidermarkdash": ["Slider", "markDash"],
		"slidermarkdashsimple": ["Slider", "markDashSimple"],
		"slidermarkvalue": ["Slider", "markValue"],
		"slidermini": ["Slider", "mini"],
		"slidertrack": ["Slider", "track"],
		"spoilercontainer": ["Spoiler", "spoilerContainer"],
		"spoilerembed": ["SpoilerEmbed", "spoiler"],
		"spoilerembedhidden": ["SpoilerEmbed", "hiddenSpoilers"],
		"spoilerembedinline": ["SpoilerEmbed", "inline"],
		"spoilerhidden": ["Spoiler", "hidden"],
		"spoilertext": ["Spoiler", "spoilerText"],
		"spoilerwarning": ["Spoiler", "spoilerWarning"],
		"splashbackground": ["NotFound", "splashBackground"],
		"strikethrough": ["TextStyle", "strikethrough"],
		"status": ["Avatar", "status"],
		"stopanimations": ["NotFound", "stopAnimations"],
		"subtext": ["NotFound", "subtext"],
		"svgicon": ["BDFDB", "svgIcon"],
		"svgiconwrapper": ["BDFDB", "svgIconWrapper"],
		"switch": ["Switch", "container"],
		"switchinner": ["Switch", "input"],
		"switchmini": ["BDFDB", "switchMini"],
		"switchslider": ["Switch", "slider"],
		"tabbar": ["UserProfile", "tabBar"],
		"tabbarcontainer": ["UserProfile", "tabBarContainer"],
		"tabbarcontainerbottom": ["BDFDB", "tabBarContainerBottom"],
		"tabbaritem": ["UserProfile", "tabBarItem"],
		"tabbartop": ["Item", "top"],
		"table": ["BDFDB", "table"],
		"tablebodycell": ["BDFDB", "tableBodyCell"],
		"tableheadercell": ["BDFDB", "tableHeaderCell"],
		"tableheadercellclickable": ["Table", "clickable"],
		"tableheadercellcontent": ["Table", "headerCellContent"],
		"tableheadercellsorted": ["Table", "headerCellSorted"],
		"tableheadercellwrapper": ["Table", "headerCell"],
		"tableheadersorticon": ["Table", "sortIcon"],
		"tablerow": ["Table", "row"],
		"tablespacerheader": ["Table", "spacerHeader"],
		"tablestickyheader": ["Table", "stickyHeader"],
		"textarea": ["ChannelTextArea", "textArea"],
		"textareaattachbutton": ["ChannelTextAreaAttachButton", "attachButton"],
		"textareaattachbuttoninner": ["ChannelTextAreaAttachButton", "attachButtonInner"],
		"textareaattachbuttonplus": ["ChannelTextAreaAttachButton", "attachButtonPlus"],
		"textareaattachwrapper": ["ChannelTextAreaAttachButton", "attachWrapper"],
		"textareabutton": ["ChannelTextAreaButton", "button"],
		"textareabuttonactive": ["ChannelTextAreaButton", "active"],
		"textareabuttonpulse": ["ChannelTextAreaButton", "pulseButton"],
		"textareabuttonwrapper": ["ChannelTextAreaButton", "buttonWrapper"],
		"textareacharcounter": ["ChannelTextAreaCharCounter", "characterCount"],
		"textareacharcountererror": ["ChannelTextAreaCharCounter", "error"],
		"textareadisabled": ["ChannelTextArea", "textAreaDisabled"],
		"textareafontsize12padding": ["ChannelTextArea", "fontSize12Padding"],
		"textareafontsize14padding": ["ChannelTextArea", "fontSize14Padding"],
		"textareafontsize15padding": ["ChannelTextArea", "fontSize15Padding"],
		"textareafontsize16padding": ["ChannelTextArea", "fontSize16Padding"],
		"textareafontsize18padding": ["ChannelTextArea", "fontSize18Padding"],
		"textareafontsize20padding": ["ChannelTextArea", "fontSize20Padding"],
		"textareafontsize24padding": ["ChannelTextArea", "fontSize24Padding"],
		"textareaicon": ["ChannelTextAreaButton", "icon"],
		"textareaiconpulse": ["ChannelTextAreaButton", "pulseIcon"],
		"textareainner": ["ChannelTextArea", "inner"],
		"textareainnerdisabled": ["ChannelTextArea", "innerDisabled"],
		"textareapickerbutton": ["ChannelTextArea", "button"],
		"textareapickerbuttoncontainer": ["ChannelTextArea", "buttonContainer"],
		"textareapickerbuttons": ["ChannelTextArea", "buttons"],
		"textareascrollablecontainer": ["ChannelTextArea", "scrollableContainer"],
		"textareaslate": ["ChannelTextArea", "textAreaSlate"],
		"textareaslatemarkup": ["ChannelTextAreaSlate", "slateTextArea"],
		"textareaslatecontainer": ["ChannelTextAreaSlate", "slateContainer"],
		"textareaslateplaceholder": ["ChannelTextAreaSlate", "placeholder"],
		"textareauploadinput": ["ChannelTextAreaAttachButton", "uploadInput"],
		"textareawebkit": ["ChannelTextArea", "webkit"],
		"textareawrapall": ["ChannelTextArea", "channelTextArea"],
		"textareawrapchat": ["ChatWindow", "channelTextArea"],
		"textareawrapdisabled": ["ChannelTextArea", "channelTextAreaDisabled"],
		"textrow": ["PopoutActivity", "textRow"],
		"textscroller": ["BDFDB", "textScroller"],
		"themedark": ["NotFound", "themeDark"],
		"themelight": ["NotFound", "themeLight"],
		"themeundefined": ["NotFound", "themeUndefined"],
		"tip": ["Tip", "tip"],
		"tipblock": ["Tip", "block"],
		"tippro": ["Tip", "pro"],
		"tipinline": ["Tip", "inline"],
		"titlebar": ["TitleBar", "titleBar"],
		"titlebarmac": ["TitleBar", "typeMacOS"],
		"titlebarmacbutton": ["TitleBar", "macButton"],
		"titlebarmacbuttonclose": ["TitleBar", "macButtonClose"],
		"titlebarmacbuttonmin": ["TitleBar", "macButtonMinimize"],
		"titlebarmacbuttonmax": ["TitleBar", "macButtonMaximize"],
		"titlebarmacbuttons": ["TitleBar", "macButtons"],
		"titlebarmacwithframe": ["TitleBar", "typeMacOSWithFrame"],
		"titlebarwinbutton": ["TitleBar", "winButton"],
		"titlebarwinbuttonclose": ["TitleBar", "winButtonClose"],
		"titlebarwinbuttonminmax": ["TitleBar", "winButtonMinMax"],
		"titlebarwindows": ["TitleBar", "typeWindows"],
		"titlebarwithframe": ["TitleBar", "withFrame"],
		"titlebarwordmark": ["TitleBar", "wordmark"],
		"titlebarwordmarkmac": ["TitleBar", "wordmarkMacOS"],
		"titlebarwordmarkwindows": ["TitleBar", "wordmarkWindows"],
		"titlesize10": ["UserPopout", "size10"],
		"titlesize12": ["UserPopout", "size12"],
		"titlesize14": ["UserPopout", "size14"],
		"titlesize16": ["UserPopout", "size16"],
		"toast": ["Toast", "toast"],
		"toastavatar": ["Toast", "avatar"],
		"toastbar": ["Toast", "bar"],
		"toastbarinner": ["Toast", "barInner"],
		"toastbg": ["Toast", "bg"],
		"toastbrand": ["Toast", "brand"],
		"toastclosable": ["Toast", "closable"],
		"toastcloseicon": ["Toast", "closeIcon"],
		"toastclosing": ["Toast", "closing"],
		"toastcustom": ["Toast", "custom"],
		"toastcustombar": ["Toast", "customBar"],
		"toastdanger": ["Toast", "danger"],
		"toastdefault": ["Toast", "default"],
		"toasticon": ["Toast", "icon"],
		"toastinfo": ["Toast", "info"],
		"toastinner": ["Toast", "inner"],
		"toastopening": ["Toast", "opening"],
		"toasts": ["Toast", "toasts"],
		"toastscenter": ["Toast", "center"],
		"toastsleft": ["Toast", "left"],
		"toastsright": ["Toast", "right"],
		"toastsuccess": ["Toast", "success"],
		"toasttext": ["Toast", "text"],
		"toastwarning": ["Toast", "warning"],
		"tooltip": ["Tooltip", "tooltip"],
		"tooltipactivityicon": ["TooltipGuild", "activityIcon"],
		"tooltipblack": ["Tooltip", "tooltipBlack"],
		"tooltipbottom": ["Tooltip", "tooltipBottom"],
		"tooltipbrand": ["Tooltip", "tooltipBrand"],
		"tooltipcontent": ["Tooltip", "tooltipContent"],
		"tooltipcontentallowoverflow": ["Tooltip", "tooltipContentAllowOverflow"],
		"tooltipcustom": ["BDFDB", "tooltipCustom"],
		"tooltipgreen": ["Tooltip", "tooltipGreen"],
		"tooltipgrey": ["Tooltip", "tooltipGrey"],
		"tooltipguildnametext": ["TooltipGuild", "guildNameText"],
		"tooltipguildnametextlimitedsize": ["TooltipGuild", "guildNameTextLimitedSize"],
		"tooltipleft": ["Tooltip", "tooltipLeft"],
		"tooltiplistitem": ["GuildsItems", "listItemTooltip"],
		"tooltipmutetext": ["TooltipGuild", "muteText"],
		"tooltipmutetextwithactivity": ["TooltipGuild", "muteTextWithActivity"],
		"tooltipnote": ["BDFDB", "tooltipNote"],
		"tooltippointer": ["Tooltip", "tooltipPointer"],
		"tooltipprimary": ["Tooltip", "tooltipPrimary"],
		"tooltipred": ["Tooltip", "tooltipRed"],
		"tooltipright": ["Tooltip", "tooltipRight"],
		"tooltiprow": ["TooltipGuild", "row"],
		"tooltiprowextra": ["BDFDB", "tooltipRowExtra"],
		"tooltiprowguildname": ["TooltipGuild", "rowGuildName"],
		"tooltiprowicon": ["TooltipGuild", "rowIcon"],
		"tooltiptop": ["Tooltip", "tooltipTop"],
		"tooltipyellow": ["Tooltip", "tooltipYellow"],
		"typing": ["Typing", "typing"],
		"typingcooldownwrapper": ["Typing", "cooldownWrapper"],
		"typingtext": ["Typing", "text"],
		"underline": ["TextStyle", "underline"],
		"unreadbar": ["UnreadBar", "bar"],
		"unreadbaractive": ["UnreadBar", "active"],
		"unreadbarcontainer": ["UnreadBar", "container"],
		"unreadbaricon": ["UnreadBar", "icon"],
		"unreadbarmention": ["UnreadBar", "mention"],
		"unreadbartext": ["UnreadBar", "text"],
		"unreadbarunread": ["UnreadBar", "unread"],
		"uploadmodal": ["UploadModal", "uploadModal"],
		"userbadge": ["UserBadges", "profileBadge"],
		"userbadgenitro": ["UserBadges", "profileBadgePremium"],
		"userbadges": ["UserBadges", "container"],
		"userbadgescolored": ["UserBadges", "colored"],
		"userbadgespopout": ["UserPopout", "profileBadges"],
		"userinfo": ["UserInfo", "userInfo"],
		"userinfoavatar": ["UserInfo", "avatar"],
		"userinfodate": ["BDFDB", "userInfoDate"],
		"userinfodiscordtag": ["UserInfo", "discordTag"],
		"userinfodiscriminator": ["UserInfo", "discriminator"],
		"userinfohovered": ["UserInfo", "hovered"],
		"userinfosubtext": ["UserInfo", "subtext"],
		"userinfotext": ["UserInfo", "text"],
		"userinfousername": ["UserInfo", "username"],
		"userpopout": ["UserPopoutWrapper", "userPopout"],
		"userpopoutactivity": ["UserPopout", "activity"],
		"userpopoutavatar": ["UserPopout", "avatar"],
		"userpopoutavatarhint": ["UserPopout", "avatarHint"],
		"userpopoutavatarhintinner": ["UserPopout", "avatarHintInner"],
		"userpopoutavataravatarposition": ["UserPopout", "avatarPosition"],
		"userpopoutavataravatarpositionnormal": ["UserPopout", "avatarPositionNormal"],
		"userpopoutavataravatarpositionpremium": ["UserPopout", "avatarPositionPremium"],
		"userpopoutavatarwrappernonuserbot": ["UserPopout", "avatarWrapperNonUserBot"],
		"userpopoutavatarwrapper": ["UserPopout", "avatarWrapper"],
		"userpopoutavatarwrappernormal": ["UserPopout", "avatarWrapperNormal"],
		"userpopoutbanner": ["UserPopoutBanner", "banner"],
		"userpopoutbannernormal": ["UserPopoutBanner", "profileBanner"],
		"userpopoutbannerpremium": ["UserPopoutBanner", "profileBannerPremium"],
		"userpopoutbody": ["UserPopoutWrapper", "body"],
		"userpopoutbodyinnerwrapper": ["UserPopoutWrapper", "bodyInnerWrapper"],
		"userpopoutbodytitle": ["UserPopoutWrapper", "bodyTitle"],
		"userpopoutcustomstatus": ["UserPopout", "customStatus"],
		"userpopoutcustomstatusemoji": ["UserPopout", "customStatusEmoji"],
		"userpopoutcustomstatussoloemoji": ["UserPopout", "customStatusSoloEmoji"],
		"userpopoutcustomstatustext": ["UserPopout", "customStatusText"],
		"userpopoutendbodysection": ["UserPopoutWrapper", "endBodySection"],
		"userpopoutfooter": ["UserPopoutWrapper", "footer"],
		"userpopoutheaderbottag": ["UserPopout", "headerBotTag"],
		"userpopoutheaderbottagwithnickname": ["UserPopout", "headerBotTagWithNickname"],
		"userpopoutheaderdiscriminatorbase": ["UserPopout", "discrimBase"],
		"userpopoutheaderdiscriminatornonickname": ["UserPopout", "headerTagDiscriminatorNoNickname"],
		"userpopoutheadernickname": ["UserPopout", "nickname"],
		"userpopoutheadernormal": ["UserPopout", "headerNormal"],
		"userpopoutheadertag": ["UserPopout", "headerTag"],
		"userpopoutheadertagnonickname": ["UserPopout", "headerTagNoNickname"],
		"userpopoutheadertagusernamebase": ["UserPopout", "headerTagUsernameBase"],
		"userpopoutheadertagusernamenonickname": ["UserPopout", "headerTagUsernameNoNickname"],
		"userpopoutheadertagwithnickname": ["UserPopout", "headerTagWithNickname"],
		"userpopoutheadertext": ["UserPopout", "headerText"],
		"userpopoutheadertop": ["UserPopout", "headerTop"],
		"userpopoutprotip": ["UserPopoutWrapper", "protip"],
		"userpopoutrole": ["Role", "role"],
		"userpopoutrolecircle": ["Role", "roleCircle"],
		"userpopoutrolelist": ["UserPopoutWrapper", "rolesList"],
		"userpopoutrolename": ["Role", "roleName"],
		"userpopoutroles": ["Role", "root"],
		"userprofile": ["UserProfile", "root"],
		"userprofilebody": ["UserProfile", "body"],
		"userprofilebottag": ["UserProfile", "botTag"],
		"userprofilecustomstatus": ["UserProfile", "customStatusText"],
		"userprofilecustomstatusemoji": ["UserProfile", "customStatusEmoji"],
		"userprofileheader": ["UserProfile", "header"],
		"userprofileheaderfill": ["UserProfile", "headerFill"],
		"userprofileheaderinfo": ["UserProfile", "headerInfo"],
		"userprofilelistavatar": ["UserProfile", "listAvatar"],
		"userprofilelistguildavatarwithouticon": ["UserProfile", "guildAvatarWithoutIcon"],
		"userprofilenametag": ["UserProfile", "nameTag"],
		"userprofiletopsectionnormal": ["UserProfile", "topSectionNormal"],
		"userprofiletopsectionplaying": ["UserProfile", "topSectionPlaying"],
		"userprofiletopsectionspotify": ["UserProfile", "topSectionSpotify"],
		"userprofiletopsectionstreaming": ["UserProfile", "topSectionStreaming"],
		"userprofiletopsectionxbox": ["UserProfile", "topSectionXbox"],
		"userprofileusername": ["UserProfile", "username"],
		"username": ["NameTag", "username"],
		"usernotepopout": ["UserPopoutWrapper", "note"],
		"usernoteprofile": ["UserProfile", "note"],
		"usernotetextarea": ["NoteTextarea", "textarea"],
		"usersettingsappearancepreview": ["UserSettingsAppearancePreview", "preview"],
		"usersettingsappearancepreviewcompact": ["UserSettingsAppearancePreview", "compactPreview"],
		"usersettingsappearancepreviewfirst": ["UserSettingsAppearancePreview", "firstMessage"],
		"usersummaryavatar": ["UserSummaryItem", "avatar"],
		"usersummaryavatarcontainer": ["UserSummaryItem", "avatarContainer"],
		"usersummaryavatarcontainermasked": ["UserSummaryItem", "avatarContainerMasked"],
		"usersummaryclickableavatar": ["UserSummaryItem", "clickableAvatar"],
		"usersummarycontainer": ["UserSummaryItem", "container"],
		"usersummaryemptyuser": ["UserSummaryItem", "emptyUser"],
		"usersummaryicon": ["UserSummaryItem", "icon"],
		"usersummarymoreUsers": ["UserSummaryItem", "moreUsers"],
		"voiceavatar": ["VoiceChannel", "avatar"],
		"voiceavatarcontainer": ["VoiceChannel", "avatarContainer"],
		"voiceavatarlarge": ["VoiceChannel", "avatarLarge"],
		"voiceavatarsmall": ["VoiceChannel", "avatarSmall"],
		"voiceavatarspeaking": ["VoiceChannel", "avatarSpeaking"],
		"voiceclickable": ["VoiceChannel", "clickable"],
		"voicecontent": ["VoiceChannel", "content"],
		"voicedetails": ["VoiceDetails", "container"],
		"voicedetailsactionbuttons": ["VoiceDetails", "actionButtons"],
		"voicedetailsbutton": ["VoiceDetails", "button"],
		"voicedetailsbuttonactive": ["VoiceDetails", "buttonActive"],
		"voicedetailsbuttoncolor": ["VoiceDetails", "buttonColor"],
		"voicedetailsbuttonicon": ["VoiceDetails", "buttonIcon"],
		"voicedetailsbuttonwithtext": ["VoiceDetails", "withText"],
		"voicedetailschannel": ["VoiceDetails", "channel"],
		"voicedetailscustomstatuscontainer": ["VoiceDetails", "customStatusContainer"],
		"voicedetailshotspot": ["VoiceDetails", "hotspot"],
		"voicedetailsinner": ["VoiceDetails", "inner"],
		"voicedetailslabelwrapper": ["VoiceDetailsPing", "labelWrapper"],
		"voicedetailsping": ["VoiceDetailsPing", "ping"],
		"voicedetailspingforeground": ["VoiceDetailsPing", "pingForeground"],
		"voicedetailsqualityaverage": ["VoiceDetailsPing", "rtcConnectionQualityAverage"],
		"voicedetailsqualitybad": ["VoiceDetailsPing", "rtcConnectionQualityBad"],
		"voicedetailsqualityfine": ["VoiceDetailsPing", "rtcConnectionQualityFine"],
		"voicedetailsstatus": ["VoiceDetailsPing", "rtcConnectionStatus"],
		"voicedetailsstatusconnected": ["VoiceDetailsPing", "rtcConnectionStatusConnected"],
		"voicedetailsstatusconnecting": ["VoiceDetailsPing", "rtcConnectionStatusConnecting"],
		"voicedetailsstatuserror": ["VoiceDetailsPing", "rtcConnectionStatusError"],
		"voicedetailsstatuswithpopout": ["VoiceDetails", "statusWithPopout"],
		"voicedraggable": ["NotFound", "voiceDraggable"],
		"voiceflipped": ["VoiceChannel", "flipped"],
		"voiceicon": ["VoiceChannel", "icon"],
		"voiceicons": ["VoiceChannel", "icons"],
		"voiceiconspacing": ["VoiceChannel", "iconSpacing"],
		"voicelimit": ["VoiceChannelLimit", "wrapper"],
		"voicelimittotal": ["VoiceChannelLimit", "total"],
		"voicelimitusers": ["VoiceChannelLimit", "users"],
		"voicelist": ["VoiceChannel", "list"],
		"voicelist2": ["VoiceChannelList", "list"],
		"voicelistcollapsed": ["VoiceChannel", "listCollapse"],
		"voicelistcollapsed2": ["VoiceChannelList", "collapsed"],
		"voicelistdefault": ["VoiceChannel", "listDefault"],
		"voiceliveicon": ["VoiceChannel", "liveIcon"],
		"voicename": ["VoiceChannel", "username"],
		"voicenamefont": ["VoiceChannel", "usernameFont"],
		"voicenamespeaking": ["VoiceChannel", "usernameSpeaking"],
		"voiceselected": ["VoiceChannel", "selected"],
		"voiceuser": ["VoiceChannel", "voiceUser"],
		"voiceuserlarge": ["VoiceChannel", "userLarge"],
		"voiceusersmall": ["VoiceChannel", "userSmall"],
		"webhookcard": ["WebhookCard", "card"],
		"webhookcardbody": ["WebhookCard", "body"],
		"webhookcardcopybutton": ["WebhookCard", "copyButton"],
		"webhookcardheader": ["WebhookCard", "header"]
	},
	"myId": "278543574059057154",
	"myGuildId": "410787888507256842",
	"userIdAttribute": "data-user-id",
	"userBackgroundsProperties": {
		"background": "--user-background",
		"orientation": "--user-popout-position"
	},
	"userBackgroundsUrl": "https://discord-custom-covers.github.io/usrbg/dist/usrbg.json",
	"Languages": {
		"$discord": 	{"name":"Discord (English))",			"id":"en",		"ownlang":"English"},
		"af":			{"name":"Afrikaans",					"id":"af",		"ownlang":"Afrikaans"},
		"sq":			{"name":"Albanian",						"id":"sq",		"ownlang":"Shqiptar"},
		"am":			{"name":"Amharic",						"id":"am",		"ownlang":"áŠ áˆ›áˆ­áŠ›"},
		"ar":			{"name":"Arabic",						"id":"ar",		"ownlang":"Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©"},
		"hy":			{"name":"Armenian",						"id":"hy",		"ownlang":"Õ€Õ¡ÕµÕ¥Ö€Õ¥Õ¶"},
		"az":			{"name":"Azerbaijani",					"id":"az",		"ownlang":"Ø¢Ø°Ø±Ø¨Ø§ÛŒØ¬Ø§Ù† Ø¯ÛŒÙ„ÛŒ"},
		"ba":			{"name":"Bashkir",						"id":"ba",		"ownlang":"Ð‘Ð°ÑˆÒ¡Ð¾Ñ€Ñ‚"},
		"eu":			{"name":"Basque",						"id":"eu",		"ownlang":"Euskara"},
		"be":			{"name":"Belarusian",					"id":"be",		"ownlang":"Ð‘ÐµÐ»Ð°Ñ€ÑƒÑÐºÐ°Ñ"},
		"bn":			{"name":"Bengali",						"id":"bn",		"ownlang":"à¦¬à¦¾à¦‚à¦²à¦¾"},
		"bs":			{"name":"Bosnian",						"id":"bs",		"ownlang":"Ð‘Ð¾ÑÐ°Ð½ÑÐºÐ¸"},
		"bg":			{"name":"Bulgarian",					"id":"bg",		"ownlang":"Ð±ÑŠÐ»Ð³Ð°Ñ€ÑÐºÐ¸",					"discord":true},
		"my":			{"name":"Burmese",						"id":"my",		"ownlang":"á€™á€¼á€”á€ºá€™á€¬á€…á€¬"},
		"ca":			{"name":"Catalan",						"id":"ca",		"ownlang":"CatalÃ "},
		"ceb":			{"name":"Cebuano",						"id":"ceb",		"ownlang":"Bisaya"},
		"ny":			{"name":"Chichewa",						"id":"ny",		"ownlang":"Nyanja"},
		"zh":			{"name":"Chinese",						"id":"zh",		"ownlang":"ä¸­æ–‡"},
		"zh-CN":		{"name":"Chinese (China)",				"id":"zh-CN",	"ownlang":"ä¸­æ–‡",						"discord":true},
		"zh-HK":		{"name":"Chinese (Hong Kong)",			"id":"zh-HK",	"ownlang":"é¦™æ¸¯ä¸­æ–‡"},
		"zh-TW":		{"name":"Chinese (Taiwan)",				"id":"zh-TW",	"ownlang":"ç¹é«”ä¸­æ–‡",					"discord":true},
		"co":			{"name":"Corsican",						"id":"co",		"ownlang":"Corsu"},
		"hr":			{"name":"Croatian",						"id":"hr",		"ownlang":"Hrvatski",					"discord":true},
		"cs":			{"name":"Czech",						"id":"cs",		"ownlang":"ÄŒeÅ¡tina"},
		"da":			{"name":"Danish",						"id":"da",		"ownlang":"Dansk",						"discord":true},
		"nl":			{"name":"Dutch",						"id":"nl",		"ownlang":"Nederlands",					"discord":true},
		"en":			{"name":"English",						"id":"en",		"ownlang":"English"},
		"en-GB":		{"name":"English (UK)",					"id":"en-GB",	"ownlang":"English (UK)",				"discord":true},
		"en-US":		{"name":"English (US)",					"id":"en-US",	"ownlang":"English (US)",				"discord":true},
		"eo":			{"name":"Esperanto",					"id":"eo",		"ownlang":"Esperanto"},
		"et":			{"name":"Estonian",						"id":"et",		"ownlang":"Eesti"},
		"fil":			{"name":"Filipino",						"id":"fil",		"ownlang":"Wikang Filipino"},
		"tl":			{"name":"Filipino (Tagalog)",			"id":"tl",		"ownlang":"Wikang Tagalog"},
		"fi":			{"name":"Finnish",						"id":"fi",		"ownlang":"Suomi",						"discord":true},
		"fr":			{"name":"French",						"id":"fr",		"ownlang":"FranÃ§ais",					"discord":true},
		"fr-CA":		{"name":"French (Canadian)",			"id":"fr-CA",	"ownlang":"FranÃ§ais Canadien"},
		"fy":			{"name":"Frisian",						"id":"fy",		"ownlang":"Frysk"},
		"gl":			{"name":"Galician",						"id":"gl",		"ownlang":"Galego"},
		"ka":			{"name":"Georgian",						"id":"ka",		"ownlang":"áƒ¥áƒáƒ áƒ—áƒ£áƒšáƒ˜"},
		"de":			{"name":"German",						"id":"de",		"ownlang":"Deutsch",					"discord":true},
		"de-AT":		{"name":"German (Austria)",				"id":"de-AT",	"ownlang":"Ã–sterreichisch Deutsch"},
		"de-CH":		{"name":"German (Switzerland)",			"id":"de-CH",	"ownlang":"Schweizerdeutsch"},
		"el":			{"name":"Greek",						"id":"el",		"ownlang":"Î•Î»Î»Î·Î½Î¹ÎºÎ¬",					"discord":true},
		"gu":			{"name":"Gujarati",						"id":"gu",		"ownlang":"àª—à«àªœàª°àª¾àª¤à«€"},
		"ht":			{"name":"Haitian Creole",				"id":"ht",		"ownlang":"KreyÃ²l Ayisyen"},
		"ha":			{"name":"Hausa",						"id":"ha",		"ownlang":"Ø­ÙŽÙˆÙ’Ø³ÙŽ"},
		"haw":			{"name":"Hawaiian",						"id":"haw",		"ownlang":"Ê»ÅŒlelo HawaiÊ»i"},
		"he":			{"name":"Hebrew",						"id":"he",		"ownlang":"×¢×‘×¨×™×ª"},
		"iw":			{"name":"Hebrew (Israel)",				"id":"iw",		"ownlang":"×¢×‘×¨×™×ª"},
		"hi":			{"name":"Hindi",						"id":"hi",		"ownlang":"à¤¹à¤¿à¤¨à¥à¤¦à¥€"},
		"hmn":			{"name":"Hmong",						"id":"hmn",		"ownlang":"lol Hmongb"},
		"hu":			{"name":"Hungarian",					"id":"hu",		"ownlang":"Magyar",						"discord":true},
		"is":			{"name":"Icelandic",					"id":"is",		"ownlang":"Ãslenska"},
		"ig":			{"name":"Igbo",							"id":"ig",		"ownlang":"Asá»¥sá»¥ Igbo"},
		"id":			{"name":"Indonesian",					"id":"id",		"ownlang":"Bahasa Indonesia"},
		"ga":			{"name":"Irish",						"id":"ga",		"ownlang":"Gaeilge"},
		"it":			{"name":"Italian",						"id":"it",		"ownlang":"Italiano",					"discord":true},
		"ja":			{"name":"Japanese",						"id":"ja",		"ownlang":"æ—¥æœ¬èªž",						"discord":true},
		"jv":			{"name":"Javanese",						"id":"jv",		"ownlang":"ê¦§ê¦±ê¦—ê¦®"},
		"jw":			{"name":"Javanese (Javanese)",			"id":"jw",		"ownlang":"ê¦§ê¦±ê¦—ê¦®"},
		"kn":			{"name":"Kannada",						"id":"kn",		"ownlang":"à²•à²¨à³à²¨à²¡"},
		"kk":			{"name":"Kazakh",						"id":"kk",		"ownlang":"ÒšÐ°Ð·Ð°Ò› TÑ–Ð»Ñ–"},
		"km":			{"name":"Khmer",						"id":"km",		"ownlang":"áž—áž¶ážŸáž¶ážáŸ’áž˜áŸ‚ážš"},
		"rw":			{"name":"Kinyarwanda",					"id":"rw",		"ownlang":"Ikinyarwanda"},
		"ko":			{"name":"Korean",						"id":"ko",		"ownlang":"í•œêµ­ì–´",						"discord":true},
		"ku":			{"name":"Kurdish",						"id":"ku",		"ownlang":"Ú©ÙˆØ±Ø¯ÛŒ"},
		"ky":			{"name":"Kyrgyz",						"id":"ky",		"ownlang":"ÐºÑ‹Ñ€Ð³Ñ‹Ð·Ñ‡Ð°"},
		"lo":			{"name":"Lao",							"id":"lo",		"ownlang":"àºžàº²àºªàº²àº¥àº²àº§"},
		"la":			{"name":"Latin",						"id":"la",		"ownlang":"Latina"},
		"lv":			{"name":"Latvian",						"id":"lv",		"ownlang":"LatvieÅ¡u"},
		"lt":			{"name":"Lithuanian",					"id":"lt",		"ownlang":"LietuviÅ³",					"discord":true},
		"lb":			{"name":"Luxembourgish",				"id":"lb",		"ownlang":"LÃ«tzebuergesch"},
		"mk":			{"name":"Macedonian",					"id":"mk",		"ownlang":"MÐ°ÐºÐµÐ´Ð¾Ð½ÑÐºÐ¸"},
		"mg":			{"name":"Malagasy",						"id":"mg",		"ownlang":"Malagasy"},
		"ms":			{"name":"Malay",						"id":"ms",		"ownlang":"Ø¨Ù‡Ø§Ø³ Ù…Ù„Ø§ÙŠÙˆ"},
		"ml":			{"name":"Malayalam",					"id":"ml",		"ownlang":"à´®à´²à´¯à´¾à´³à´‚"},
		"mt":			{"name":"Maltese",						"id":"mt",		"ownlang":"Malti"},
		"mi":			{"name":"Maori",						"id":"mi",		"ownlang":"te Reo MÄori"},
		"mr":			{"name":"Marathi",						"id":"mr",		"ownlang":"à¤®à¤°à¤¾à¤ à¥€"},
		"mhr":			{"name":"Mari",							"id":"mhr",		"ownlang":"Ð¼Ð°Ñ€Ð¸Ð¹ Ð¹Ñ‹Ð»Ð¼Ðµ"},
		"mn":			{"name":"Mongolian",					"id":"mn",		"ownlang":"ÐœÐ¾Ð½Ð³Ð¾Ð» Ð¥ÑÐ»"},
		"my":			{"name":"Myanmar (Burmese)",			"id":"my",		"ownlang":"á€™á€¼á€”á€ºá€™á€¬Ð» Ð¥ÑÐ»"},
		"ne":			{"name":"Nepali",						"id":"ne",		"ownlang":"à¤¨à¥‡à¤ªà¤¾à¤²à¥€"},
		"no":			{"name":"Norwegian",					"id":"no",		"ownlang":"Norsk",						"discord":true},
		"or":			{"name":"Odia",							"id":"or",		"ownlang":"à¬“à¬¡à¬¼à¬¿à¬†"},
		"pap":			{"name":"Papiamento",					"id":"pap",		"ownlang":"Papiamentu"},
		"ps":			{"name":"Pashto",						"id":"ps",		"ownlang":"Ù¾ÚšØªÙˆ"},
		"fa":			{"name":"Persian",						"id":"fa",		"ownlang":"ÙØ§Ø±Ø³ÛŒ"},
		"pl":			{"name":"Polish",						"id":"pl",		"ownlang":"Polski",						"discord":true},
		"pt":			{"name":"Portuguese",					"id":"pt",		"ownlang":"PortuguÃªs"},
		"pt-BR":		{"name":"Portuguese (Brazil)",			"id":"pt-BR",	"ownlang":"PortuguÃªs do Brasil",		"discord":true},
		"pt-PT":		{"name":"Portuguese (Portugal)",		"id":"pt-PT",	"ownlang":"PortuguÃªs do Portugal"},
		"pa":			{"name":"Punjabi",						"id":"pa",		"ownlang":"à¤ªà¤‚à¤œà¤¾à¤¬à¥€"},
		"ro":			{"name":"Romanian",						"id":"ro",		"ownlang":"RomÃ¢nÄƒ",						"discord":true},
		"ru":			{"name":"Russian",						"id":"ru",		"ownlang":"PÑƒÑÑÐºÐ¸Ð¹",					"discord":true},
		"sm":			{"name":"Samoan",						"id":"sm",		"ownlang":"Gagana SÄmoa"},
		"gd":			{"name":"Scottish Gaelic",				"id":"gd",		"ownlang":"GÃ idhlig"},
		"sr":			{"name":"Serbian",						"id":"sr",		"ownlang":"Ð¡Ñ€Ð¿ÑÐºÐ¸"},
		"st":			{"name":"Sesotho",						"id":"st",		"ownlang":"Sesotho"},
		"sn":			{"name":"Shona",						"id":"sn",		"ownlang":"Shona"},
		"sd":			{"name":"Sindhi",						"id":"sd",		"ownlang":"Ø³Ù†ÚŒÙŠ"},
		"si":			{"name":"Sinhala",						"id":"si",		"ownlang":"à·ƒà·’à¶‚à·„à¶½"},
		"sk":			{"name":"Slovak",						"id":"sk",		"ownlang":"SlovenÄina"},
		"sl":			{"name":"Slovenian",					"id":"sl",		"ownlang":"SlovenÅ¡Äina"},
		"so":			{"name":"Somali",						"id":"so",		"ownlang":"Soomaali"},
		"es":			{"name":"Spanish",						"id":"es",		"ownlang":"EspaÃ±ol",					"discord":true},
		"es-419":		{"name":"Spanish (Latin America)",		"id":"es-419",	"ownlang":"EspaÃ±ol latinoamericano"},
		"su":			{"name":"Sundanese",					"id":"su",		"ownlang":"Basa Sunda"},
		"sw":			{"name":"Swahili",						"id":"sw",		"ownlang":"Kiswahili"},
		"sv":			{"name":"Swedish",						"id":"sv",		"ownlang":"Svenska",					"discord":true},
		"tg":			{"name":"Tajik",						"id":"tg",		"ownlang":"Ñ‚Ð¾Ò·Ð¸ÐºÓ£"},
		"ta":			{"name":"Tamil",						"id":"ta",		"ownlang":"à®¤à®®à®¿à®´à¯"},
		"tt":			{"name":"Tatar",						"id":"tt",		"ownlang":"Ñ‚Ð°Ñ‚Ð°Ñ€Ñ‡Ð°"},
		"te":			{"name":"Telugu",						"id":"te",		"ownlang":"à°¤à±†à°²à±à°—à±"},
		"th":			{"name":"Thai",							"id":"th",		"ownlang":"à¸ à¸²à¸©à¸²à¹„à¸—à¸¢",						"discord":true},
		"tr":			{"name":"Turkish",						"id":"tr",		"ownlang":"TÃ¼rkÃ§e",						"discord":true},
		"tk":			{"name":"Turkmen",						"id":"tk",		"ownlang":"TÃ¼rkmenÃ§e"},
		"udm":			{"name":"Udmurt",						"id":"udm",		"ownlang":"ÑƒÐ´Ð¼ÑƒÑ€Ñ‚ ÐºÑ‹Ð»"},
		"uk":			{"name":"Ukrainian",					"id":"uk",		"ownlang":"YÐºÑ€Ð°Ñ—Ð½ÑÑŒÐºÐ¸Ð¹",				"discord":true},
		"ur":			{"name":"Urdu",							"id":"ur",		"ownlang":"Ø§ÙØ±Ø¯ÙÙˆ"},
		"ug":			{"name":"Uyghur",						"id":"ug",		"ownlang":"Ø¦Û‡ÙŠØºÛ‡Ø± ØªÙ‰Ù„Ù‰"},
		"uz":			{"name":"Uzbek",						"id":"uz",		"ownlang":"Ø§ÙˆØ²Ø¨ÛŒÚ©"},
		"vi":			{"name":"Vietnamese",					"id":"vi",		"ownlang":"Tiáº¿ng Viá»‡t Nam",				"discord":true},
		"cy":			{"name":"Welsh",						"id":"cy",		"ownlang":"Cymraeg"},
		"xh":			{"name":"Xhosa",						"id":"xh",		"ownlang":"Xhosa"},
		"yi":			{"name":"Yiddish",						"id":"yi",		"ownlang":"×™×™Ö´×“×™×© ×™×™Ö´×“×™×©â€¬"},
		"yo":			{"name":"Yoruba",						"id":"yo",		"ownlang":"ÃˆdÃ¨ YorÃ¹bÃ¡"},
		"zu":			{"name":"Zulu",							"id":"zu",		"ownlang":"Zulu"}
	},
	"LibraryStrings": {
		"bg": {
			"add_to": "Ð”Ð¾Ð±Ð°Ð²ÑÐ½Ðµ ÐºÑŠÐ¼ {{var0}}",
			"ascending": "Ð’ÑŠÐ·Ñ…Ð¾Ð´ÑÑ‰",
			"center": "Ð¦ÐµÐ½Ñ‚Ñ€Ð¸Ñ€Ð°Ð½Ð¾",
			"changelog_added": "ÐÐ¾Ð²Ð¸ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¸",
			"changelog_fixed": "ÐžÑ‚ÑÑ‚Ñ€Ð°Ð½ÑÐ²Ð°Ð½Ðµ Ð½Ð° Ð½ÐµÐ¸Ð·Ð¿Ñ€Ð°Ð²Ð½Ð¾ÑÑ‚Ð¸",
			"changelog_improved": "ÐŸÐ¾Ð´Ð¾Ð±Ñ€ÐµÐ½Ð¸Ñ",
			"changelog_progress": "ÐÐ°Ð¿Ñ€ÐµÐ´ÑŠÐº",
			"check_for_updates": "ÐŸÑ€Ð¾Ð²ÐµÑ€Ð¸ Ð·Ð° Ð°ÐºÑ‚ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸",
			"confirm": "Ð¡Ð¸Ð³ÑƒÑ€ÐµÐ½ Ð»Ð¸ ÑÐ¸?",
			"delete_fail": "{{var0}} Ð½Ðµ Ð¼Ð¾Ð¶Ðµ Ð´Ð° Ð±ÑŠÐ´Ðµ Ð¸Ð·Ñ‚Ñ€Ð¸Ñ‚Ð¾",
			"delete_success": "{{var0}} Ð¸Ð·Ñ‚Ñ€Ð¸Ñ‚Ð¾ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾",
			"descending": "ÐÐ¸Ð·Ñ…Ð¾Ð´ÑÑ‰",
			"developer": "Ð Ð°Ð·Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸Ðº",
			"donate_message": "ÐŸÐ¾Ð´ÐºÑ€ÐµÐ¿ÐµÑ‚Ðµ Ð¼Ðµ Ð·Ð° Ð¿Ð¾Ð²ÐµÑ‡Ðµ Ð°ÐºÑ‚ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸!",
			"download": "Ð˜Ð·Ñ‚ÐµÐ³Ð»Ð¸",
			"download_fail": "{{var0}} Ð½Ðµ Ð¼Ð¾Ð¶Ðµ Ð´Ð° Ð±ÑŠÐ´Ðµ Ð¸Ð·Ñ‚ÐµÐ³Ð»ÐµÐ½",
			"download_success": "{{var0}} Ð¸Ð·Ñ‚ÐµÐ³Ð»ÐµÐ½Ð¾ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾",
			"file_navigator_text": "ÐŸÑ€ÐµÐ³Ð»ÐµÐ´ Ð½Ð° Ñ„Ð°Ð¹Ð»",
			"first": "ÐŸÑŠÑ€Ð²Ð¾",
			"from": "ÐžÑ‚",
			"gradient": "Ð“Ñ€Ð°Ð´Ð¸ÐµÐ½Ñ‚",
			"last": "ÐŸÐ¾ÑÐ»ÐµÐ´Ð½Ð¾",
			"left": "ÐÐ°Ð»ÑÐ²Ð¾",
			"loading": "Ð—Ð°Ñ€ÐµÐ¶Ð´Ð° ÑÐµ {{var0}}",
			"location": "ÐœÐµÑÑ‚Ð¾Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ",
			"order": "ÐŸÐ¾ÑÐ»ÐµÐ´Ð¾Ð²Ð°Ñ‚ÐµÐ»Ð½Ð¾ÑÑ‚",
			"outdated": "ÐžÑÑ‚Ð°Ñ€ÑÐ»",
			"please_wait": "ÐŸÑ€Ð¸ÑÑ‚Ð½Ð¾ Ñ‡Ð°ÐºÐ°Ð½Ðµ",
			"right": "ÐÐ°Ð»Ð¸",
			"save_fail": "{{var0}} Ð½Ðµ Ð¼Ð¾Ð¶Ðµ Ð´Ð° Ð±ÑŠÐ´Ðµ Ð·Ð°Ð¿Ð°Ð·ÐµÐ½",
			"save_success": "{{var0}} Ð·Ð°Ð¿Ð°Ð·ÐµÐ½Ð¾ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾",
			"server": "Ð¡ÑŠÑ€Ð²ÑŠÑ€",
			"settings_showSupportBadges_description": "ÐŸÐ¾ÐºÐ°Ð·Ð²Ð° Ð¼Ð°Ð»ÐºÐ¸ Ð·Ð½Ð°Ñ‡ÐºÐ¸ Ð·Ð° Ð¿Ð¾Ñ‚Ñ€ÐµÐ±Ð¸Ñ‚ÐµÐ»Ð¸, ÐºÐ¾Ð¸Ñ‚Ð¾ Ð¿Ð¾Ð´Ð´ÑŠÑ€Ð¶Ð°Ñ‚ Ð¼Ð¾Ñ Patreon",
			"settings_showToasts_description": "ÐŸÐ¾ÐºÐ°Ð·Ð²Ð° Ñ‚Ð¾ÑÑ‚Ð¾Ð²Ðµ Ð·Ð° ÑÑ‚Ð°Ñ€Ñ‚Ð¸Ñ€Ð°Ð½Ðµ Ð¸ ÑÐ¿Ð¸Ñ€Ð°Ð½Ðµ Ð½Ð° Ð¿Ñ€Ð¸ÑÑ‚Ð°Ð²ÐºÐ°Ñ‚Ð°",
			"settings_showToasts_note": "Ð”ÐµÐ°ÐºÑ‚Ð¸Ð²Ð¸Ñ€Ð°Ð¹Ñ‚Ðµ Ð¾Ð±Ñ‰Ð°Ñ‚Ð° Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ° '{{var0}}' Ð½Ð° BD, Ð¿Ñ€ÐµÐ´Ð¸ Ð´Ð° Ð³Ð¸ Ð´ÐµÐ°ÐºÑ‚Ð¸Ð²Ð¸Ñ€Ð°Ñ‚Ðµ",
			"settings_toastPosition_description": "ÐŸÐ¾Ð·Ð¸Ñ†Ð¸Ñ Ð·Ð° Ñ‚Ð¾ÑÑ‚ Ð¿Ð¾ Ð¿Ð¾Ð´Ñ€Ð°Ð·Ð±Ð¸Ñ€Ð°Ð½Ðµ",
			"settings_toastPosition_note": "ÐŸÑ€Ð¾Ð¼ÐµÐ½Ñ ÑÐ°Ð¼Ð¾ Ð¿Ð¾Ð·Ð¸Ñ†Ð¸ÑÑ‚Ð° Ð½Ð° Ñ‚Ð¾ÑÑ‚Ð¾Ð²Ðµ, ÑÑŠÐ·Ð´Ð°Ð´ÐµÐ½Ð¸ Ð¾Ñ‚ Ð¼Ð¾Ð¸Ñ‚Ðµ Ð¿Ñ€Ð¸ÑÑ‚Ð°Ð²ÐºÐ¸",
			"settings_useChromium_description": "ÐžÑ‚Ð²Ð¾Ñ€ÐµÑ‚Ðµ Ð²Ñ€ÑŠÐ·ÐºÐ¸ Ð² Discord Ð²Ð¼ÐµÑÑ‚Ð¾ Ð²Ð°ÑˆÐ¸Ñ Ð±Ñ€Ð°ÑƒÐ·ÑŠÑ€",
			"sort_by": "Ð¡Ð¾Ñ€Ñ‚Ð¸Ñ€Ð°Ð½Ðµ Ð¿Ð¾",
			"time": "Ð’Ñ€ÐµÐ¼Ðµ",
			"timezone": "Ð§Ð°ÑÐ¾Ð²Ð° Ð·Ð¾Ð½Ð°",
			"to": "Ð”Ð° ÑÐµ",
			"toast_plugin_force_updated": "{{var0}} ÑÐµ Ð°ÐºÑ‚ÑƒÐ°Ð»Ð¸Ð·Ð¸Ñ€Ð° Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡Ð½Ð¾, Ñ‚ÑŠÐ¹ ÐºÐ°Ñ‚Ð¾ Ð²ÐµÑ€ÑÐ¸ÑÑ‚Ð° Ð²Ð¸ Ð±ÐµÑˆÐµ Ð¼Ð½Ð¾Ð³Ð¾ Ð¾ÑÑ‚Ð°Ñ€ÑÐ»Ð°",
			"toast_plugin_loaded": "{{var0}} Ðµ Ð·Ð°Ñ€ÐµÐ´ÐµÐ½",
			"toast_plugin_started": "{{var0}} Ð·Ð°Ð¿Ð¾Ñ‡Ð½Ð°",
			"toast_plugin_stopped": "{{var0}} ÑÐ¿Ñ€Ñ",
			"toast_plugin_translated": "Ð¿Ñ€ÐµÐ²ÐµÐ´ÐµÐ½Ð¾ Ð½Ð° {{var0}}",
			"toast_plugin_unloaded": "{{var0}} Ðµ Ñ€Ð°Ð·Ñ‚Ð¾Ð²Ð°Ñ€ÐµÐ½",
			"toast_plugin_update_failed": "ÐÐºÑ‚ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸ÑÑ‚Ð° Ð·Ð° {{var0}} Ð½Ðµ Ð¼Ð¾Ð¶Ðµ Ð´Ð° Ð±ÑŠÐ´Ðµ Ð¸Ð·Ñ‚ÐµÐ³Ð»ÐµÐ½Ð°",
			"toast_plugin_updated": "{{var0}} {{var1}} Ðµ Ð·Ð°Ð¼ÐµÐ½ÐµÐ½Ð¾ Ñ {{var2}} {{var3}}",
			"update_check_complete": "ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ°Ñ‚Ð° Ð·Ð° Ð°ÐºÑ‚ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð½Ð° Ð¿Ñ€Ð¸ÑÑ‚Ð°Ð²ÐºÐ°Ñ‚Ð° Ð·Ð°Ð²ÑŠÑ€ÑˆÐ¸",
			"update_check_complete_outdated": "ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ°Ñ‚Ð° Ð·Ð° Ð°ÐºÑ‚ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ Ð½Ð° Ð¿Ñ€Ð¸ÑÑ‚Ð°Ð²ÐºÐ°Ñ‚Ð° Ð·Ð°Ð²ÑŠÑ€ÑˆÐ¸ - {{var0}} Ð¾ÑÑ‚Ð°Ñ€ÑÐ»Ð°!",
			"update_check_info": "ÐŸÑ€Ð¾Ð²ÐµÑ€ÐµÑ‚Ðµ Ð¿Ñ€Ð¸ÑÑ‚Ð°Ð²ÐºÐ¸, ÐºÐ¾Ð¸Ñ‚Ð¾ Ð¿Ð¾Ð´Ð´ÑŠÑ€Ð¶Ð°Ñ‚ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ°Ñ‚Ð° Ð½Ð° Ð°ÐºÑ‚ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸ÑÑ‚Ð°",
			"update_notice_click": "Ð©Ñ€Ð°ÐºÐ½ÐµÑ‚Ðµ Ð·Ð° Ð°ÐºÑ‚ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ!",
			"update_notice_reload": "ÐŸÑ€ÐµÐ·Ð°Ñ€ÐµÐ´ÐµÑ‚Ðµ, Ð·Ð° Ð´Ð° Ð·Ð°Ð²ÑŠÑ€ÑˆÐ¸Ñ‚Ðµ Ð°ÐºÑ‚ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸ÑÑ‚Ð°",
			"update_notice_update": "Ð¡Ð»ÐµÐ´Ð½Ð¸Ñ‚Ðµ Ð¿Ñ€Ð¸ÑÑ‚Ð°Ð²ÐºÐ¸ Ñ‚Ñ€ÑÐ±Ð²Ð° Ð´Ð° Ð±ÑŠÐ´Ð°Ñ‚ Ð°ÐºÑ‚ÑƒÐ°Ð»Ð¸Ð·Ð¸Ñ€Ð°Ð½Ð¸: ",
			"updated": "ÐÐºÑ‚ÑƒÐ°Ð»Ð¸Ð·Ð¸Ñ€Ð°Ð½Ð¾"
		},
		"da": {
			"add_to": "FÃ¸j til {{var0}}",
			"ascending": "Stigende",
			"center": "Centreret",
			"changelog_added": "Nye funktioner",
			"changelog_fixed": "Fejlfinding",
			"changelog_improved": "Forbedringer",
			"changelog_progress": "Fremskridt",
			"check_for_updates": "SÃ¸g efter opdateringer",
			"confirm": "Er du sikker?",
			"delete_fail": "{{var0}} kan ikke slettes",
			"delete_success": "{{var0}} blev slettet",
			"descending": "Aftagende",
			"developer": "Udvikler",
			"donate_message": "StÃ¸t mig for flere opdateringer!",
			"download": "Hent",
			"download_fail": "{{var0}} kan ikke downloades",
			"download_success": "{{var0}} downloadet med succes",
			"file_navigator_text": "Gennemse fil",
			"first": "FÃ¸rst",
			"from": "Fra",
			"gradient": "Gradient",
			"last": "Sidst",
			"left": "Venstre",
			"loading": "IndlÃ¦ser {{var0}}",
			"location": "Beliggenhed",
			"order": "Sekvens",
			"outdated": "ForÃ¦ldet",
			"please_wait": "Vent venligst",
			"right": "Ret",
			"save_fail": "{{var0}} kan ikke gemmes",
			"save_success": "{{var0}} blev gemt",
			"server": "Server",
			"settings_showSupportBadges_description": "Viser smÃ¥ badges til brugere, der understÃ¸tter min Patreon",
			"settings_showToasts_description": "Viser plugin start og stop toasts",
			"settings_showToasts_note": "Deaktiver den generelle indstilling '{{var0}}' for BD'er, inden du deaktiverer dem",
			"settings_toastPosition_description": "Standard skÃ¥lposition",
			"settings_toastPosition_note": "Ã†ndrer kun placeringen af â€‹â€‹skÃ¥le oprettet af mine plugins",
			"settings_useChromium_description": "Ã…bn Links i Discord i stedet for din browser",
			"sort_by": "Sorter efter",
			"time": "Tid",
			"timezone": "Tidszone",
			"to": "Til",
			"toast_plugin_force_updated": "{{var0}} blev automatisk opdateret, fordi din version var meget forÃ¦ldet",
			"toast_plugin_loaded": "{{var0}} er indlÃ¦st",
			"toast_plugin_started": "{{var0}} er startet",
			"toast_plugin_stopped": "{{var0}} er stoppet",
			"toast_plugin_translated": "oversat til {{var0}}",
			"toast_plugin_unloaded": "{{var0}} er blevet aflÃ¦st",
			"toast_plugin_update_failed": "Opdatering til {{var0}} kan ikke downloades",
			"toast_plugin_updated": "{{var0}} {{var1}} er blevet erstattet af {{var2}} {{var3}}",
			"update_check_complete": "Kontrollen af plugin-opdatering afsluttet",
			"update_check_complete_outdated": "Kontrollen af â€‹â€‹plugin-opdatering afsluttet - {{var0}} forÃ¦ldet!",
			"update_check_info": "Kontroller plugins, der understÃ¸tter opdateringskontrollen",
			"update_notice_click": "Klik for at opdatere!",
			"update_notice_reload": "GenindlÃ¦s for at fuldfÃ¸re opdateringen",
			"update_notice_update": "FÃ¸lgende plugins skal opdateres: ",
			"updated": "Opdateret"
		},
		"de": {
			"add_to": "Zu {{var0}} hinzufÃ¼gen",
			"ascending": "Aufsteigend",
			"center": "Zentriert",
			"changelog_added": "Neue Features",
			"changelog_fixed": "Fehlerbehebung",
			"changelog_improved": "Verbesserungen",
			"changelog_progress": "Fortschritt",
			"check_for_updates": "Suche nach Updates",
			"confirm": "Bist du sicher?",
			"delete_fail": "{{var0}} kann nicht gelÃ¶scht werden",
			"delete_success": "{{var0}} erfolgreich gelÃ¶scht",
			"descending": "Absteigend",
			"developer": "Entwickler",
			"donate_message": "UnterstÃ¼tze mich, um weitere Updates zu erhalten!",
			"download": "Herunterladen",
			"download_fail": "{{var0}} kann nicht heruntergeladen werden",
			"download_success": "{{var0}} erfolgreich heruntergeladen",
			"file_navigator_text": "Datei durchsuchen",
			"first": "Zuerst",
			"from": "Von",
			"gradient": "Gradient",
			"last": "Zuletzt",
			"left": "Links",
			"loading": "LÃ¤dt {{var0}}",
			"location": "Ort",
			"order": "Reihenfolge",
			"outdated": "Veraltet",
			"please_wait": "Bitte warten",
			"right": "Rechts",
			"save_fail": "{{var0}} kann nicht gespeichert werden",
			"save_success": "{{var0}} erfolgreich gespeichert",
			"server": "Server",
			"settings_showSupportBadges_description": "Zeigt kleine Abzeichen fÃ¼r Benutzer, die meinen Patreon unterstÃ¼tzen",
			"settings_showToasts_description": "Zeigt Plugin Start und Stopp Toasts",
			"settings_showToasts_note": "Deaktiviere die allgemeine BD Einstellung '{{var0}}', bevor du diese deaktivierst",
			"settings_toastPosition_description": "Standard Toast Position",
			"settings_toastPosition_note": "Ã„ndert nur die Position von Toasts, die von meinen Plugins erstellt wurden",
			"settings_useChromium_description": "Ã–ffne Links in Discord anstelle deines Browsers",
			"sort_by": "Sortieren nach",
			"time": "Zeit",
			"timezone": "Zeitzone",
			"to": "Zu",
			"toast_plugin_force_updated": "{{var0}} wurde automatisch aktualisiert, da deine Version stark veraltet war",
			"toast_plugin_loaded": "{{var0}} wurde geladen",
			"toast_plugin_started": "{{var0}} wurde gestartet",
			"toast_plugin_stopped": "{{var0}} wurde gestoppt",
			"toast_plugin_translated": "Ã¼bersetzt nach {{var0}}",
			"toast_plugin_unloaded": "{{var0}} wurde entladen",
			"toast_plugin_update_failed": "Update fÃ¼r {{var0}} kann nicht heruntergeladen werden",
			"toast_plugin_updated": "{{var0}} {{var1}} wurde durch {{var2}} {{var3}} ersetzt",
			"update_check_complete": "Plugin Update Check abgeschlossen",
			"update_check_complete_outdated": "Plugin Update Check abgeschlossen - {{var0}} veraltet!",
			"update_check_info": "Check Plugins, die den Update Check unterstÃ¼tzen",
			"update_notice_click": "Zum Aktualisieren klicken!",
			"update_notice_reload": "Neu laden, um die Aktualisierung abzuschlieÃŸen",
			"update_notice_update": "Die folgenden Plugins mÃ¼ssen aktualisiert werden: ",
			"updated": "Aktualisiert"
		},
		"el": {
			"add_to": "Î ÏÎ¿ÏƒÎ¸Î®ÎºÎ· ÏƒÏ„Î¿ {{var0}}",
			"ascending": "Î‘Î½ÎµÏÏ‡ÏŒÎ¼ÎµÎ½Î¿Ï‚",
			"center": "Î£Ï„Î¿ ÎºÎ­Î½Ï„ÏÎ¿",
			"changelog_added": "ÎÎ­Î± Ï‡Î±ÏÎ±ÎºÏ„Î·ÏÎ¹ÏƒÏ„Î¹ÎºÎ¬",
			"changelog_fixed": "Î‘Î½Ï„Î¹Î¼ÎµÏ„ÏŽÏ€Î¹ÏƒÎ· Ï€ÏÎ¿Î²Î»Î·Î¼Î¬Ï„Ï‰Î½",
			"changelog_improved": "Î’ÎµÎ»Ï„Î¹ÏŽÏƒÎµÎ¹Ï‚",
			"changelog_progress": "Î ÏÏŒÎ¿Î´Î¿Ï‚",
			"check_for_updates": "Î•Î»ÎµÎ³Ï‡Î¿Ï‚ Î³Î¹Î± ÎµÎ½Î·Î¼ÎµÏÏŽÏƒÎµÎ¹Ï‚",
			"confirm": "Î•Î¯ÏƒÎ±Î¹ ÏƒÎ¯Î³Î¿Ï…ÏÎ¿Ï‚?",
			"delete_fail": "Î”ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î´Ï…Î½Î±Ï„Î® Î· Î´Î¹Î±Î³ÏÎ±Ï†Î® Ï„Î¿Ï… {{var0}}",
			"delete_success": "Î¤Î¿ {{var0}} Î´Î¹Î±Î³ÏÎ¬Ï†Î·ÎºÎµ Î¼Îµ ÎµÏ€Î¹Ï„Ï…Ï‡Î¯Î±",
			"descending": "Î¦Î¸Î¯Î½Ï‰Î½",
			"developer": "Î ÏÎ¿Î³ÏÎ±Î¼Î¼Î±Ï„Î¹ÏƒÏ„Î®Ï‚",
			"donate_message": "Î¥Ï€Î¿ÏƒÏ„Î·ÏÎ¯Î¾Ï„Îµ Î¼Îµ Î³Î¹Î± Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÎµÏ‚ ÎµÎ½Î·Î¼ÎµÏÏŽÏƒÎµÎ¹Ï‚!",
			"download": "ÎšÎ±Ï„ÎµÎ²Î¬ÏƒÏ„Îµ",
			"download_fail": "Î”ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î´Ï…Î½Î±Ï„Î® Î· Î»Î®ÏˆÎ· Ï„Î¿Ï… {{var0}}",
			"download_success": "Î— Î»Î®ÏˆÎ· Ï„Î¿Ï… {{var0}} Î¿Î»Î¿ÎºÎ»Î·ÏÏŽÎ¸Î·ÎºÎµ Î¼Îµ ÎµÏ€Î¹Ï„Ï…Ï‡Î¯Î±",
			"file_navigator_text": "Î‘Î½Î±Î¶Î®Ï„Î·ÏƒÎ· Î±ÏÏ‡ÎµÎ¯Î¿Ï…",
			"first": "Î ÏÏŽÏ„Î±",
			"from": "Î‘Ï€ÏŒ",
			"gradient": "Î’Î±Î¸Î¼Î¯Î´Î±",
			"last": "Î¤ÎµÎ»ÎµÏ…Ï„Î±Î¯Î¿Ï‚",
			"left": "Î‘ÏÎ¹ÏƒÏ„ÎµÏÎ¬",
			"loading": "Î¦ÏŒÏÏ„Ï‰ÏƒÎ· {{var0}}",
			"location": "Î¤Î¿Ï€Î¿Î¸ÎµÏƒÎ¯Î±",
			"order": "Î‘Î»Î»Î·Î»Î¿Ï…Ï‡Î¯Î±",
			"outdated": "Î‘Ï€Î±ÏÏ‡Î±Î¹Ï‰Î¼Î­Î½Î¿Ï‚",
			"please_wait": "Î•Ï…Ï‡Î¬ÏÎ¹ÏƒÏ„Î· Î±Î½Î±Î¼Î¿Î½Î®",
			"right": "Î£Ï‰ÏƒÏ„Î¬",
			"save_fail": "Î”ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î´Ï…Î½Î±Ï„Î® Î· Î±Ï€Î¿Î¸Î®ÎºÎµÏ…ÏƒÎ· Ï„Î¿Ï… {{var0}}",
			"save_success": "Î¤Î¿ {{var0}} Î±Ï€Î¿Î¸Î·ÎºÎµÏÏ„Î·ÎºÎµ Î¼Îµ ÎµÏ€Î¹Ï„Ï…Ï‡Î¯Î±",
			"server": "Î¥Ï€Î·ÏÎ­Ï„Î·Ï‚",
			"settings_showSupportBadges_description": "Î•Î¼Ï†Î±Î½Î¯Î¶ÎµÎ¹ Î¼Î¹ÎºÏÎ¬ ÏƒÎ®Î¼Î±Ï„Î± Î³Î¹Î± Ï‡ÏÎ®ÏƒÏ„ÎµÏ‚ Ï€Î¿Ï… Ï…Ï€Î¿ÏƒÏ„Î·ÏÎ¯Î¶Î¿Ï…Î½ Ï„Î¿ Patreon Î¼Î¿Ï…",
			"settings_showToasts_description": "Î”ÎµÎ¯Ï‡Î½ÎµÎ¹ Ï„Î¹Ï‚ Ï€ÏÎ¿ÏƒÎ¸Î®ÎºÎ·Ï‚ Î­Î½Î±ÏÎ¾Î·Ï‚ ÎºÎ±Î¹ Î´Î¹Î±ÎºÎ¿Ï€Î®Ï‚ Ï„Î¿ÏƒÏ„",
			"settings_showToasts_note": "Î‘Ï€ÎµÎ½ÎµÏÎ³Î¿Ï€Î¿Î¹Î®ÏƒÏ„Îµ Ï„Î· Î³ÎµÎ½Î¹ÎºÎ® ÏÏÎ¸Î¼Î¹ÏƒÎ· '{{var0}}' Ï„Ï‰Î½ BD Ï€ÏÎ¹Î½ Î±Ï€ÎµÎ½ÎµÏÎ³Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ",
			"settings_toastPosition_description": "Î ÏÎ¿ÎµÏ€Î¹Î»ÎµÎ³Î¼Î­Î½Î· Î¸Î­ÏƒÎ· Ï„Î¿ÏƒÏ„",
			"settings_toastPosition_note": "Î‘Î»Î»Î¬Î¶ÎµÎ¹ Î¼ÏŒÎ½Î¿ Ï„Î· Î¸Î­ÏƒÎ· Ï„Ï‰Î½ Î¤Î¿ÏƒÏ„ Ï€Î¿Ï… Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î®Î¸Î·ÎºÎ±Î½ Î±Ï€ÏŒ Ï„Î¹Ï‚ Ï€ÏÎ¿ÏƒÎ¸Î®ÎºÎµÏ‚ Î¼Î¿Ï…",
			"settings_useChromium_description": "Î‘Î½Î¿Î¯Î¾Ï„Îµ Ï„Î¿Ï…Ï‚ ÏƒÏ…Î½Î´Î­ÏƒÎ¼Î¿Ï…Ï‚ ÏƒÏ„Î¿ Discord Î±Î½Ï„Î¯ Î³Î¹Î± Ï„Î¿ Ï€ÏÏŒÎ³ÏÎ±Î¼Î¼Î± Ï€ÎµÏÎ¹Î®Î³Î·ÏƒÎ®Ï‚ ÏƒÎ±Ï‚",
			"sort_by": "Î¤Î±Î¾Î¹Î½ÏŒÎ¼Î·ÏƒÎ· ÎºÎ±Ï„Î¬",
			"time": "Î§ÏÏŒÎ½Î¿Ï‚",
			"timezone": "Î–ÏŽÎ½Î· ÏŽÏÎ±Ï‚",
			"to": "Î ÏÎ¿Ï‚ Ï„Î¿",
			"toast_plugin_force_updated": "Î¤Î¿ {{var0}} ÎµÎ½Î·Î¼ÎµÏÏŽÎ¸Î·ÎºÎµ Î±Ï…Ï„ÏŒÎ¼Î±Ï„Î± ÎµÏ€ÎµÎ¹Î´Î® Î· Î­ÎºÎ´Î¿ÏƒÎ® ÏƒÎ±Ï‚ Î®Ï„Î±Î½ Ï€Î¿Î»Ï Ï€Î±Î»Î¹Î¬",
			"toast_plugin_loaded": "Î¤Î¿ {{var0}} Î­Ï‡ÎµÎ¹ Ï†Î¿ÏÏ„Ï‰Î¸ÎµÎ¯",
			"toast_plugin_started": "Î¤Î¿ {{var0}} Î­Ï‡ÎµÎ¹ Î¾ÎµÎºÎ¹Î½Î®ÏƒÎµÎ¹",
			"toast_plugin_stopped": "Î¤Î¿ {{var0}} Î­Ï‡ÎµÎ¹ ÏƒÏ„Î±Î¼Î±Ï„Î®ÏƒÎµÎ¹",
			"toast_plugin_translated": "Î¼ÎµÏ„Î±Ï†ÏÎ¬ÏƒÏ„Î·ÎºÎµ ÏƒÎµ {{var0}}",
			"toast_plugin_unloaded": "Î¤Î¿ {{var0}} Î­Ï‡ÎµÎ¹ ÎµÎºÏ†Î¿ÏÏ„Ï‰Î¸ÎµÎ¯",
			"toast_plugin_update_failed": "Î”ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î´Ï…Î½Î±Ï„Î® Î· Î»Î®ÏˆÎ· Ï„Î·Ï‚ ÎµÎ½Î·Î¼Î­ÏÏ‰ÏƒÎ·Ï‚ Î³Î¹Î± Ï„Î¿ {{var0}}",
			"toast_plugin_updated": "Î¤Î¿ {{var0}} {{var1}} Î±Î½Ï„Î¹ÎºÎ±Ï„Î±ÏƒÏ„Î¬Î¸Î·ÎºÎµ Î±Ï€ÏŒ Ï„Î¿ {{var2}} {{var3}}",
			"update_check_complete": "ÎŸ Î­Î»ÎµÎ³Ï‡Î¿Ï‚ ÎµÎ½Î·Î¼Î­ÏÏ‰ÏƒÎ·Ï‚ Ï€ÏÎ¿ÏƒÎ¸Î®ÎºÎ·Ï‚ Î¿Î»Î¿ÎºÎ»Î·ÏÏŽÎ¸Î·ÎºÎµ",
			"update_check_complete_outdated": "ÎŸ Î­Î»ÎµÎ³Ï‡Î¿Ï‚ ÎµÎ½Î·Î¼Î­ÏÏ‰ÏƒÎ·Ï‚ Ï€ÏÎ¿ÏƒÎ¸Î®ÎºÎ·Ï‚ Î¿Î»Î¿ÎºÎ»Î·ÏÏŽÎ¸Î·ÎºÎµ - {{var0}} Î´ÎµÎ½ ÎµÎ¯Î½Î±Î¹ ÎµÎ½Î·Î¼ÎµÏÏ‰Î¼Î­Î½Î¿Ï‚!",
			"update_check_info": "ÎˆÎ»ÎµÎ³Ï‡Î¿Ï‚ Ï€ÏÎ¿ÏƒÎ¸Î®ÎºÎµÏ‚ Ï€Î¿Ï… Ï…Ï€Î¿ÏƒÏ„Î·ÏÎ¯Î¶Î¿Ï…Î½ Ï„Î¿Î½ Î­Î»ÎµÎ³Ï‡Î¿ ÎµÎ½Î·Î¼Î­ÏÏ‰ÏƒÎ·Ï‚",
			"update_notice_click": "ÎšÎ¬Î½Ï„Îµ ÎºÎ»Î¹Îº Î³Î¹Î± ÎµÎ½Î·Î¼Î­ÏÏ‰ÏƒÎ·!",
			"update_notice_reload": "Î•Ï€Î±Î½Î±Î»Î¬Î²ÎµÏ„Îµ Ï„Î· Ï†ÏŒÏÏ„Ï‰ÏƒÎ· Î³Î¹Î± Î½Î± Î¿Î»Î¿ÎºÎ»Î·ÏÏŽÏƒÎµÏ„Îµ Ï„Î·Î½ ÎµÎ½Î·Î¼Î­ÏÏ‰ÏƒÎ·",
			"update_notice_update": "ÎŸÎ¹ Î±ÎºÏŒÎ»Î¿Ï…Î¸ÎµÏ‚ Ï€ÏÎ¿ÏƒÎ¸Î®ÎºÎµÏ‚ Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± ÎµÎ½Î·Î¼ÎµÏÏ‰Î¸Î¿ÏÎ½: ",
			"updated": "Î•Î Î™ÎšÎ‘Î™Î¡ÎŸÎ ÎŸÎ™Î—ÎœÎ•ÎÎŸ"
		},
		"es": {
			"add_to": "Agregar a {{var0}}",
			"ascending": "Ascendente",
			"center": "Centrado",
			"changelog_added": "Nuevas caracterÃ­sticas",
			"changelog_fixed": "SoluciÃ³n de problemas",
			"changelog_improved": "Mejoras",
			"changelog_progress": "Progreso",
			"check_for_updates": "Buscar actualizaciones",
			"confirm": "Â¿EstÃ¡s seguro?",
			"delete_fail": "{{var0}} no se puede eliminar",
			"delete_success": "{{var0}} eliminado correctamente",
			"descending": "Descendiendo",
			"developer": "Desarrollador",
			"donate_message": "Â¡ApÃ³yanme para obtener mÃ¡s actualizaciones!",
			"download": "Descargar",
			"download_fail": "{{var0}} no se puede descargar",
			"download_success": "{{var0}} descargado correctamente",
			"file_navigator_text": "Buscar Archivo",
			"first": "Primero",
			"from": "Desde",
			"gradient": "Degradado",
			"last": "Ãšltimo",
			"left": "Izquierda",
			"loading": "Cargando {{var0}}",
			"location": "LocalizaciÃ³n",
			"order": "Secuencia",
			"outdated": "Anticuado",
			"please_wait": "Por favor espera",
			"right": "Correcto",
			"save_fail": "{{var0}} no se puede guardar",
			"save_success": "{{var0}} guardado correctamente",
			"server": "Servidor",
			"settings_showSupportBadges_description": "Muestra pequeÃ±as insignias para los usuarios que apoyan mi Patreon",
			"settings_showToasts_description": "Muestra el inicio y la parada del complemento.",
			"settings_showToasts_note": "Desactive la configuraciÃ³n general '{{var0}}' de los BD antes de desactivarlos",
			"settings_toastPosition_description": "PosiciÃ³n de tostada predeterminada",
			"settings_toastPosition_note": "Solo cambia la posiciÃ³n de los brindis creados por mis complementos",
			"settings_useChromium_description": "Abra enlaces en Discord en lugar de su navegador",
			"sort_by": "Ordenar por",
			"time": "Hora",
			"timezone": "Zona horaria",
			"to": "A",
			"toast_plugin_force_updated": "{{var0}} se actualizÃ³ automÃ¡ticamente porque su versiÃ³n estaba muy desactualizada",
			"toast_plugin_loaded": "Se cargÃ³ {{var0}}",
			"toast_plugin_started": "{{var0}} ha comenzado",
			"toast_plugin_stopped": "{{var0}} se detuvo",
			"toast_plugin_translated": "traducido a {{var0}}",
			"toast_plugin_unloaded": "{{var0}} se ha descargado",
			"toast_plugin_update_failed": "No se puede descargar la actualizaciÃ³n para {{var0}}",
			"toast_plugin_updated": "{{var0}} {{var1}} ha sido reemplazado por {{var2}} {{var3}}",
			"update_check_complete": "ComprobaciÃ³n de actualizaciÃ³n del complemento completada",
			"update_check_complete_outdated": "ComprobaciÃ³n de actualizaciÃ³n del complemento completada: {{var0}} desactualizada.",
			"update_check_info": "Verifique los complementos que admiten la verificaciÃ³n de actualizaciones",
			"update_notice_click": "Â¡Haz clic para actualizar!",
			"update_notice_reload": "Recargar para completar la actualizaciÃ³n",
			"update_notice_update": "Los siguientes complementos deben actualizarse: ",
			"updated": "Actualizado"
		},
		"fi": {
			"add_to": "LisÃ¤Ã¤ {{var0}}",
			"ascending": "Nouseva",
			"center": "Keskitetty",
			"changelog_added": "Uudet ominaisuudet",
			"changelog_fixed": "Ongelmien karttoittaminen",
			"changelog_improved": "Parannuksia",
			"changelog_progress": "EdistystÃ¤",
			"check_for_updates": "Tarkista pÃ¤ivitykset",
			"confirm": "Oletko varma?",
			"delete_fail": "{{var0}} ei voi poistaa",
			"delete_success": "{{var0}} poistettu",
			"descending": "Laskeva",
			"developer": "KehittÃ¤jÃ¤",
			"donate_message": "Tue minua lisÃ¤Ã¤ pÃ¤ivityksiÃ¤ varten!",
			"download": "Ladata",
			"download_fail": "{{var0}} ei voi ladata",
			"download_success": "{{var0}} ladattu onnistuneesti",
			"file_navigator_text": "Selaa tiedostoa",
			"first": "EnsimmÃ¤inen",
			"from": "Alkaen",
			"gradient": "Kaltevuus",
			"last": "KestÃ¤Ã¤",
			"left": "Vasen",
			"loading": "Ladataan {{var0}}",
			"location": "Sijainti",
			"order": "JÃ¤rjestys",
			"outdated": "Vanhentunut",
			"please_wait": "Odota",
			"right": "Aivan",
			"save_fail": "Kohdetta {{var0}} ei voi tallentaa",
			"save_success": "{{var0}} tallennettu onnistuneesti",
			"server": "Palvelin",
			"settings_showSupportBadges_description": "NÃ¤yttÃ¤Ã¤ pienet merkit kÃ¤yttÃ¤jille, jotka tukevat Patreoniani",
			"settings_showToasts_description": "NÃ¤yttÃ¤Ã¤ laajennuksen aloitus- ja lopetusleivokset",
			"settings_showToasts_note": "Poista BD-levyjen yleinen asetus {{var0}} ennen niiden poistamista kÃ¤ytÃ¶stÃ¤",
			"settings_toastPosition_description": "Oletus paahtoleipÃ¤Ã¤",
			"settings_toastPosition_note": "Muuttaa vain laajennukset luomien paahtoleivien sijaintia",
			"settings_useChromium_description": "Avaa Linkit ristiriidassa selaimen sijaan",
			"sort_by": "JÃ¤rjestÃ¤",
			"time": "Aika",
			"timezone": "AikavyÃ¶hyke",
			"to": "Vastaanottaja",
			"toast_plugin_force_updated": "{{var0}} pÃ¤ivitettiin automaattisesti, koska versiosi oli vanhentunut",
			"toast_plugin_loaded": "{{var0}} on ladattu",
			"toast_plugin_started": "{{var0}} on alkanut",
			"toast_plugin_stopped": "{{var0}} on pysÃ¤htynyt",
			"toast_plugin_translated": "kÃ¤Ã¤nnetty kielelle {{var0}}",
			"toast_plugin_unloaded": "{{var0}} on purettu",
			"toast_plugin_update_failed": "Verkkotunnuksen {{var0}} pÃ¤ivitystÃ¤ ei voi ladata",
			"toast_plugin_updated": "{{var0}} {{var1}} on korvattu sanalla {{var2}} {{var3}}",
			"update_check_complete": "Laajennuksen pÃ¤ivityksen tarkistus valmis",
			"update_check_complete_outdated": "Laajennuksen pÃ¤ivityksen tarkistus valmis - {{var0}} vanhentunut!",
			"update_check_info": "Tarkista pÃ¤ivitystarkistusta tukevat laajennukset",
			"update_notice_click": "Napsauta pÃ¤ivittÃ¤Ã¤ksesi!",
			"update_notice_reload": "Lataa pÃ¤ivitys loppuun",
			"update_notice_update": "Seuraavat laajennukset on pÃ¤ivitettÃ¤vÃ¤: ",
			"updated": "PÃ¤ivitetty"
		},
		"fr": {
			"add_to": "Ajouter Ã  {{var0}}",
			"ascending": "Ascendant",
			"center": "CentrÃ©",
			"changelog_added": "Nouvelles fonctionnalitÃ©s",
			"changelog_fixed": "DÃ©pannage",
			"changelog_improved": "AmÃ©liorations",
			"changelog_progress": "Le progrÃ¨s",
			"check_for_updates": "Rechercher des mises Ã  jour",
			"confirm": "ÃŠtes-vous sÃ»r?",
			"delete_fail": "{{var0}} ne peut pas Ãªtre supprimÃ©",
			"delete_success": "{{var0}} supprimÃ© avec succÃ¨s",
			"descending": "Descendant",
			"developer": "DÃ©veloppeur",
			"donate_message": "Soutenez-moi pour plus de mises Ã  jour!",
			"download": "TÃ©lÃ©charger",
			"download_fail": "{{var0}} ne peut pas Ãªtre tÃ©lÃ©chargÃ©",
			"download_success": "{{var0}} tÃ©lÃ©chargÃ© avec succÃ¨s",
			"file_navigator_text": "Parcourir le fichier",
			"first": "PremiÃ¨re",
			"from": "De",
			"gradient": "Pente",
			"last": "Dernier",
			"left": "Gauche",
			"loading": "Chargement de {{var0}}",
			"location": "Emplacement",
			"order": "SÃ©quence",
			"outdated": "DÃ©passÃ©",
			"please_wait": "S'il vous plaÃ®t, attendez",
			"right": "Droite",
			"save_fail": "{{var0}} ne peut pas Ãªtre enregistrÃ©",
			"save_success": "{{var0}} a bien Ã©tÃ© enregistrÃ©",
			"server": "Serveur",
			"settings_showSupportBadges_description": "Affiche de petits badges pour les utilisateurs qui soutiennent mon Patreon",
			"settings_showToasts_description": "Affiche les toasts de dÃ©marrage et d'arrÃªt du plugin",
			"settings_showToasts_note": "DÃ©sactivez le paramÃ¨tre gÃ©nÃ©ral '{{var0}}' des BD avant de les dÃ©sactiver",
			"settings_toastPosition_description": "Position de toast par dÃ©faut",
			"settings_toastPosition_note": "Modifie uniquement la position des toasts crÃ©Ã©s par mes plugins",
			"settings_useChromium_description": "Ouvrez les liens dans Discord au lieu de votre navigateur",
			"sort_by": "Trier par",
			"time": "Temps",
			"timezone": "Fuseau horaire",
			"to": "Ã€",
			"toast_plugin_force_updated": "{{var0}} a Ã©tÃ© automatiquement mis Ã  jour car votre version Ã©tait trÃ¨s obsolÃ¨te",
			"toast_plugin_loaded": "{{var0}} a Ã©tÃ© chargÃ©",
			"toast_plugin_started": "{{var0}} a commencÃ©",
			"toast_plugin_stopped": "{{var0}} s'est arrÃªtÃ©",
			"toast_plugin_translated": "traduit en {{var0}}",
			"toast_plugin_unloaded": "{{var0}} a Ã©tÃ© dÃ©chargÃ©",
			"toast_plugin_update_failed": "La mise Ã  jour pour {{var0}} ne peut pas Ãªtre tÃ©lÃ©chargÃ©e",
			"toast_plugin_updated": "{{var0}} {{var1}} a Ã©tÃ© remplacÃ© par {{var2}} {{var3}}",
			"update_check_complete": "VÃ©rification de la mise Ã  jour du plugin terminÃ©e",
			"update_check_complete_outdated": "VÃ©rification de la mise Ã  jour du plugin terminÃ©e - {{var0}} obsolÃ¨te!",
			"update_check_info": "VÃ©rifiez les plugins prenant en charge la vÃ©rification des mises Ã  jour",
			"update_notice_click": "Cliquez pour mettre Ã  jour!",
			"update_notice_reload": "Recharger pour terminer la mise Ã  jour",
			"update_notice_update": "Les plugins suivants doivent Ãªtre mis Ã  jour: ",
			"updated": "Mis Ã  jour"
		},
		"hr": {
			"add_to": "Dodaj u {{var0}}",
			"ascending": "Uzlazni",
			"center": "Centrirano",
			"changelog_added": "Nove znaÄajke",
			"changelog_fixed": "RjeÅ¡avanje problema",
			"changelog_improved": "PoboljÅ¡anja",
			"changelog_progress": "Napredak",
			"check_for_updates": "Provjerite ima li aÅ¾uriranja",
			"confirm": "Jesi li siguran?",
			"delete_fail": "{{var0}} nije moguÄ‡e izbrisati",
			"delete_success": "{{var0}} uspjeÅ¡no je izbrisano",
			"descending": "Silazni",
			"developer": "Programer",
			"donate_message": "PodrÅ¾ite me za joÅ¡ novosti!",
			"download": "Preuzimanje datoteka",
			"download_fail": "{{var0}} nije moguÄ‡e preuzeti",
			"download_success": "{{var0}} uspjeÅ¡no preuzeto",
			"file_navigator_text": "Pregledaj datoteku",
			"first": "Prvi",
			"from": "Iz",
			"gradient": "Gradijent",
			"last": "Posljednji",
			"left": "Lijevo",
			"loading": "UÄitavanje {{var0}}",
			"location": "Mjesto",
			"order": "Slijed",
			"outdated": "Zastario",
			"please_wait": "Drago mi je Äekati",
			"right": "Pravo",
			"save_fail": "{{var0}} nije moguÄ‡e spremiti",
			"save_success": "{{var0}} uspjeÅ¡no spremljeno",
			"server": "PosluÅ¾itelju",
			"settings_showSupportBadges_description": "Prikazuje male znaÄke za korisnike koji podrÅ¾avaju moj Patreon",
			"settings_showToasts_description": "Prikazuje tost za pokretanje i zaustavljanje dodatka",
			"settings_showToasts_note": "OnemoguÄ‡ite opÄ‡u postavku '{{var0}}' BD-ova prije nego Å¡to ih onemoguÄ‡ite",
			"settings_toastPosition_description": "Zadani poloÅ¾aj tosta",
			"settings_toastPosition_note": "Mijenja samo poloÅ¾aj zdravica koje su stvorili moji dodatke",
			"settings_useChromium_description": "Otvorite veze u Discordu umjesto u pregledniku",
			"sort_by": "Poredati po",
			"time": "Vrijeme",
			"timezone": "Vremenska zona",
			"to": "Do",
			"toast_plugin_force_updated": "{{var0}} je automatski aÅ¾uriran jer je vaÅ¡a verzija bila vrlo zastarjela",
			"toast_plugin_loaded": "UÄitana je {{var0}}",
			"toast_plugin_started": "{{var0}} je zapoÄeo",
			"toast_plugin_stopped": "{{var0}} je zaustavljen",
			"toast_plugin_translated": "prevedeno na {{var0}}",
			"toast_plugin_unloaded": "{{var0}} je istovaren",
			"toast_plugin_update_failed": "AÅ¾uriranje za {{var0}} nije moguÄ‡e preuzeti",
			"toast_plugin_updated": "{{var0}} {{var1}} zamijenjen je s {{var2}} {{var3}}",
			"update_check_complete": "Provjera aÅ¾uriranja dodatka dovrÅ¡ena",
			"update_check_complete_outdated": "Provjera aÅ¾uriranja dodatka dovrÅ¡ena - {{var0}} zastarjelo!",
			"update_check_info": "Provjerite dodatke koji podrÅ¾avaju provjeru aÅ¾uriranja",
			"update_notice_click": "Kliknite za aÅ¾uriranje!",
			"update_notice_reload": "Ponovo uÄitajte da biste dovrÅ¡ili aÅ¾uriranje",
			"update_notice_update": "Treba aÅ¾urirati sljedeÄ‡e dodatke: ",
			"updated": "AÅ¾urirano"
		},
		"hu": {
			"add_to": "HozzÃ¡adÃ¡s a kÃ¶vetkezÅ‘hÃ¶z: {{var0}}",
			"ascending": "NÃ¶vekvÅ‘",
			"center": "KÃ¶zÃ©pre",
			"changelog_added": "Ãšj funkciÃ³k",
			"changelog_fixed": "HibaelhÃ¡rÃ­tÃ¡s",
			"changelog_improved": "FejlesztÃ©sek",
			"changelog_progress": "ElÅ‘rehalad",
			"check_for_updates": "FrissÃ­tÃ©sek keresÃ©se",
			"confirm": "Biztos vagy ebben?",
			"delete_fail": "A {{var0}} nem tÃ¶rÃ¶lhetÅ‘",
			"delete_success": "{{var0}} sikeresen tÃ¶rÃ¶lve",
			"descending": "CsÃ¶kkenÅ‘",
			"developer": "FejlesztÅ‘",
			"donate_message": "TÃ¡mogasson tovÃ¡bbi frissÃ­tÃ©sekÃ©rt!",
			"download": "LetÃ¶ltÃ©s",
			"download_fail": "A {{var0}} nem tÃ¶lthetÅ‘ le",
			"download_success": "A {{var0}} letÃ¶ltÃ©se sikeresen megtÃ¶rtÃ©nt",
			"file_navigator_text": "TallÃ³zÃ¡s a fÃ¡jlban",
			"first": "ElsÅ‘",
			"from": "TÃ³l tÅ‘l",
			"gradient": "Gradiens",
			"last": "UtolsÃ³",
			"left": "Bal",
			"loading": "{{var0}} betÃ¶ltÃ©se",
			"location": "ElhelyezkedÃ©s",
			"order": "Sorrend",
			"outdated": "Elavult",
			"please_wait": "VÃ¡rj",
			"right": "Jobb",
			"save_fail": "A {{var0}} nem menthetÅ‘",
			"save_success": "{{var0}} sikeresen mentve",
			"server": "Szerver",
			"settings_showSupportBadges_description": "AprÃ³ jelvÃ©nyeket mutat azoknak a felhasznÃ¡lÃ³knak, akik tÃ¡mogatjÃ¡k a Patreon-t",
			"settings_showToasts_description": "Mutatja a bÅ‘vÃ­tmÃ©ny start Ã©s stop pirÃ­tÃ³sokat",
			"settings_showToasts_note": "MielÅ‘tt letiltanÃ¡ Å‘ket, tiltsa le a BD-k '{{var0}} â€ Ã¡ltalÃ¡nos beÃ¡llÃ­tÃ¡sÃ¡t",
			"settings_toastPosition_description": "AlapÃ©rtelmezett pirÃ­tÃ³s pozÃ­ciÃ³",
			"settings_toastPosition_note": "Csak a bÅ‘vÃ­tmÃ©nyeket Ã¡ltal lÃ©trehozott pirÃ­tÃ³sok pozÃ­ciÃ³jÃ¡t vÃ¡ltoztatja meg",
			"settings_useChromium_description": "Nyissa meg a Linkeket a diszkordban a bÃ¶ngÃ©szÅ‘je helyett",
			"sort_by": "Sorrend",
			"time": "IdÅ‘",
			"timezone": "IdÅ‘zÃ³na",
			"to": "Nak nek",
			"toast_plugin_force_updated": "A {{var0}} automatikusan frissÃ¼lt, mert a verziÃ³ja nagyon elavult",
			"toast_plugin_loaded": "{{var0}} betÃ¶ltve",
			"toast_plugin_started": "A {{var0}} elindult",
			"toast_plugin_stopped": "A {{var0}} leÃ¡llt",
			"toast_plugin_translated": "lefordÃ­tva {{var0}} nyelvre",
			"toast_plugin_unloaded": "{{var0}} kirakva",
			"toast_plugin_update_failed": "A {{var0}} frissÃ­tÃ©se nem tÃ¶lthetÅ‘ le",
			"toast_plugin_updated": "A {{var0}} {{var1}} helyÃ©be a kÃ¶vetkezÅ‘ lÃ©pett: {{var2}} {{var3}}",
			"update_check_complete": "A bÅ‘vÃ­tmÃ©ny modul frissÃ­tÃ©sÃ©nek ellenÅ‘rzÃ©se befejezÅ‘dÃ¶tt",
			"update_check_complete_outdated": "A bÅ‘vÃ­tmÃ©ny modul frissÃ­tÃ©sÃ©nek ellenÅ‘rzÃ©se befejezÅ‘dÃ¶tt - {{var0}} elavult!",
			"update_check_info": "EllenÅ‘rizze a FrissÃ­tÃ©s ellenÅ‘rzÃ©sÃ©t tÃ¡mogatÃ³ bÅ‘vÃ­tmÃ©nyeket modulokat",
			"update_notice_click": "Kattintson a frissÃ­tÃ©shez!",
			"update_notice_reload": "TÃ¶ltse be Ãºjra a frissÃ­tÃ©s befejezÃ©sÃ©hez",
			"update_notice_update": "A kÃ¶vetkezÅ‘ bÅ‘vÃ­tmÃ©nyeket frissÃ­teni kell: ",
			"updated": "FrissÃ­tve"
		},
		"it": {
			"add_to": "Aggiungi a {{var0}}",
			"ascending": "Ascendente",
			"center": "Centrato",
			"changelog_added": "Nuove caratteristiche",
			"changelog_fixed": "Risoluzione dei problemi",
			"changelog_improved": "Miglioramenti",
			"changelog_progress": "Progresso",
			"check_for_updates": "Controlla gli aggiornamenti",
			"confirm": "Sei sicuro?",
			"delete_fail": "{{var0}} non puÃ² essere eliminato",
			"delete_success": "{{var0}} eliminato correttamente",
			"descending": "Discendente",
			"developer": "Sviluppatore",
			"donate_message": "Supportami per ulteriori aggiornamenti!",
			"download": "Scarica",
			"download_fail": "{{var0}} non puÃ² essere scaricato",
			"download_success": "{{var0}} scaricato correttamente",
			"file_navigator_text": "Sfoglia file",
			"first": "Primo",
			"from": "A partire dal",
			"gradient": "Pendenza",
			"last": "Scorso",
			"left": "Sinistra",
			"loading": "Caricamento di {{var0}}",
			"location": "Posizione",
			"order": "Sequenza",
			"outdated": "Obsoleto",
			"please_wait": "Attendere prego",
			"right": "Destra",
			"save_fail": "{{var0}} non puÃ² essere salvato",
			"save_success": "{{var0}} salvato correttamente",
			"server": "Server",
			"settings_showSupportBadges_description": "Mostra piccoli badge per gli utenti che supportano il mio Patreon",
			"settings_showToasts_description": "Mostra l'avvio e l'arresto del plugin",
			"settings_showToasts_note": "Disabilita l'impostazione generale '{{var0}}' dei BD prima di disabilitarli",
			"settings_toastPosition_description": "Posizione predefinita del pane tostato",
			"settings_toastPosition_note": "Cambia solo la posizione dei toast creati dai miei plugins",
			"settings_useChromium_description": "Apri link in Discord invece che nel tuo browser",
			"sort_by": "Ordina per",
			"time": "Tempo",
			"timezone": "Fuso orario",
			"to": "Per",
			"toast_plugin_force_updated": "{{var0}} Ã¨ stato aggiornato automaticamente perchÃ© la tua versione era molto obsoleta",
			"toast_plugin_loaded": "{{var0}} Ã¨ stato caricato",
			"toast_plugin_started": "{{var0}} Ã¨ iniziato",
			"toast_plugin_stopped": "{{var0}} si Ã¨ fermato",
			"toast_plugin_translated": "tradotto in {{var0}}",
			"toast_plugin_unloaded": "{{var0}} Ã¨ stato scaricato",
			"toast_plugin_update_failed": "Impossibile scaricare l'aggiornamento per {{var0}}",
			"toast_plugin_updated": "{{var0}} {{var1}} Ã¨ stato sostituito da {{var2}} {{var3}}",
			"update_check_complete": "Controllo dell'aggiornamento del plugin completato",
			"update_check_complete_outdated": "Controllo dell'aggiornamento del plugin completato - {{var0}} non aggiornato!",
			"update_check_info": "Controlla i plugins che supportano il controllo degli aggiornamenti",
			"update_notice_click": "Fare clic per aggiornare!",
			"update_notice_reload": "Ricarica per completare l'aggiornamento",
			"update_notice_update": "I seguenti plugins devono essere aggiornati: ",
			"updated": "Aggiornato"
		},
		"ja": {
			"add_to": "{{var0}} ã«è¿½åŠ ",
			"ascending": "ä¸Šæ˜‡",
			"center": "ä¸­å¤®æƒãˆ",
			"changelog_added": "æ–°æ©Ÿèƒ½",
			"changelog_fixed": "ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°",
			"changelog_improved": "æ”¹å–„ç‚¹",
			"changelog_progress": "é€²æ—",
			"check_for_updates": "ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã‚’ç¢ºèªã™ã‚‹",
			"confirm": "æœ¬æ°—ã§ã™ã‹ï¼Ÿ",
			"delete_fail": "{{var0}} ã¯å‰Šé™¤ã§ãã¾ã›ã‚“",
			"delete_success": "{{var0}} ãŒæ­£å¸¸ã«å‰Šé™¤ã•ã‚Œã¾ã—ãŸ",
			"descending": "é™é †",
			"developer": "é–‹ç™ºè€…",
			"donate_message": "ã‚ˆã‚Šå¤šãã®ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆã®ãŸã‚ã«ç§ã‚’ã‚µãƒãƒ¼ãƒˆã—ã¦ãã ã•ã„ï¼",
			"download": "ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰",
			"download_fail": "{{var0}} ã¯ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã§ãã¾ã›ã‚“",
			"download_success": "{{var0}} ãŒæ­£å¸¸ã«ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¾ã—ãŸ",
			"file_navigator_text": "ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‚ç…§",
			"first": "æœ€åˆ",
			"from": "ã‹ã‚‰",
			"gradient": "å‹¾é…",
			"last": "æœ€çµ‚",
			"left": "å·¦",
			"loading": "ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™ {{var0}}",
			"location": "ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³",
			"order": "ã‚·ãƒ¼ã‚±ãƒ³ã‚¹",
			"outdated": "æ™‚ä»£é…ã‚Œ",
			"please_wait": "ãŠå¾…ã¡ãã ã•ã„",
			"right": "æ­£ã—ã„",
			"save_fail": "{{var0}} ã¯ä¿å­˜ã§ãã¾ã›ã‚“",
			"save_success": "{{var0}} ã¯æ­£å¸¸ã«ä¿å­˜ã•ã‚Œã¾ã—ãŸ",
			"server": "ã‚µãƒ¼ãƒ",
			"settings_showSupportBadges_description": "ç§ã®ãƒ‘ãƒˆãƒ¬ã‚ªãƒ³ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«å°ã•ãªãƒãƒƒã‚¸ã‚’è¡¨ç¤ºã—ã¾ã™",
			"settings_showToasts_description": "ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®é–‹å§‹ã¨åœæ­¢ã®ãƒˆãƒ¼ã‚¹ãƒˆã‚’è¡¨ç¤ºã—ã¾ã™",
			"settings_showToasts_note": "BD ã‚’ç„¡åŠ¹ã«ã™ã‚‹å‰ã«ã€BD ã®ä¸€èˆ¬è¨­å®š '{{var0}}' ã‚’ç„¡åŠ¹ã«ã—ã¦ãã ã•ã„",
			"settings_toastPosition_description": "ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒˆãƒ¼ã‚¹ãƒˆä½ç½®",
			"settings_toastPosition_note": "ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã«ã‚ˆã£ã¦ä½œæˆã•ã‚ŒãŸãƒˆãƒ¼ã‚¹ãƒˆã®ä½ç½®ã®ã¿ã‚’å¤‰æ›´ã—ã¾ã™",
			"settings_useChromium_description": "ãƒ–ãƒ©ã‚¦ã‚¶ã®ä»£ã‚ã‚Šã« Discord ã§ãƒªãƒ³ã‚¯ã‚’é–‹ã",
			"sort_by": "ä¸¦ã³æ›¿ãˆ",
			"time": "æ™‚é–“",
			"timezone": "ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³",
			"to": "ã«",
			"toast_plugin_force_updated": "ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãŒéžå¸¸ã«å¤ããªã£ãŸãŸã‚ã€ {{var0}} ã¯è‡ªå‹•çš„ã«æ›´æ–°ã•ã‚Œã¾ã—ãŸ",
			"toast_plugin_loaded": "{{var0}} ãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã—ãŸ",
			"toast_plugin_started": "{{var0}} ãŒé–‹å§‹ã•ã‚Œã¾ã—ãŸ",
			"toast_plugin_stopped": "{{var0}} ãŒåœæ­¢ã—ã¾ã—ãŸ",
			"toast_plugin_translated": "{{var0}} ã«å¤‰æ›",
			"toast_plugin_unloaded": "{{var0}} ãŒã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¾ã—ãŸ",
			"toast_plugin_update_failed": "{{var0}} ã®æ›´æ–°ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã§ãã¾ã›ã‚“",
			"toast_plugin_updated": "{{var0}} {{var1}} ã¯ {{var2}} {{var3}} ã«ç½®ãæ›ãˆã‚‰ã‚Œã¾ã—ãŸ",
			"update_check_complete": "ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®æ›´æ–°ãƒã‚§ãƒƒã‚¯ãŒå®Œäº†ã—ã¾ã—ãŸ",
			"update_check_complete_outdated": "ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®æ›´æ–°ãƒã‚§ãƒƒã‚¯ãŒå®Œäº†ã—ã¾ã—ãŸ- {{var0}} ãŒå¤ããªã£ã¦ã„ã¾ã™ï¼",
			"update_check_info": "ã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™",
			"update_notice_click": "ã‚¯ãƒªãƒƒã‚¯ã—ã¦æ›´æ–°ã—ã¦ãã ã•ã„ï¼",
			"update_notice_reload": "ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦æ›´æ–°ã‚’å®Œäº†ã—ã¾ã™",
			"update_notice_update": "æ¬¡ã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’æ›´æ–°ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚",
			"updated": "æ›´æ–°ã—ã¾ã—ãŸ"
		},
		"ko": {
			"add_to": "{{var0}} ì— ì¶”ê°€",
			"ascending": "ì˜¤ë¦„ì°¨ìˆœ",
			"center": "ì¤‘ì‹¬",
			"changelog_added": "ìƒˆë¡œìš´ ê¸°ëŠ¥",
			"changelog_fixed": "ë¬¸ì œ í•´ê²°",
			"changelog_improved": "ê°œëŸ‰",
			"changelog_progress": "ì§„í–‰",
			"check_for_updates": "ì—…ë°ì´íŠ¸ í™•ì¸",
			"confirm": "í™•ì‹¤í•´?",
			"delete_fail": "{{var0}} ì„ (ë¥¼) ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
			"delete_success": "{{var0}} ì´ (ê°€) ì„±ê³µì ìœ¼ë¡œ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.",
			"descending": "ë‚´ë¦¼ì°¨ìˆœ",
			"developer": "ê°œë°œìž",
			"donate_message": "ë” ë§Žì€ ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•´ ì €ë¥¼ ì§€ì›í•˜ì‹­ì‹œì˜¤!",
			"download": "ë‹¤ìš´ë¡œë“œ",
			"download_fail": "{{var0}} ì„ (ë¥¼) ë‹¤ìš´ë¡œë“œ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
			"download_success": "{{var0}} ë‹¤ìš´ë¡œë“œ ì™„ë£Œ",
			"file_navigator_text": "íŒŒì¼ ì°¾ì•„ë³´ê¸°",
			"first": "ë¨¼ì €",
			"from": "ì—ì„œ",
			"gradient": "êµ¬ë°°",
			"last": "ë§ˆì§€ë§‰",
			"left": "ì™¼ìª½",
			"loading": "ë¡œë“œ ì¤‘ {{var0}}",
			"location": "ìœ„ì¹˜",
			"order": "ìˆœì„œ",
			"outdated": "ì‹œëŒ€ì— ë’¤ì³ì§„",
			"please_wait": "ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”",
			"right": "ê¶Œë¦¬",
			"save_fail": "{{var0}} ì„ ì €ìž¥í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
			"save_success": "{{var0}} ì´ ì„±ê³µì ìœ¼ë¡œ ì €ìž¥ë˜ì—ˆìŠµë‹ˆë‹¤.",
			"server": "ì„¬ê¸°ëŠ” ì‚¬ëžŒ",
			"settings_showSupportBadges_description": "ë‚´ Patreon ì„ ì§€ì›í•˜ëŠ” ì‚¬ìš©ìžì—ê²Œ ìž‘ì€ ë°°ì§€ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.",
			"settings_showToasts_description": "í”ŒëŸ¬ê·¸ì¸ ì‹œìž‘ ë° ì¤‘ì§€ ì•Œë¦¼ í‘œì‹œ",
			"settings_showToasts_note": "BD ë¥¼ ë¹„í™œì„±í™”í•˜ê¸° ì „ì— BD ì˜ ì¼ë°˜ ì„¤ì • '{{var0}}' ì„ ë¹„í™œì„±í™”í•˜ì‹­ì‹œì˜¤.",
			"settings_toastPosition_description": "ê¸°ë³¸ í† ìŠ¤íŠ¸ ìœ„ì¹˜",
			"settings_toastPosition_note": "ë‚´ í”ŒëŸ¬ê·¸ì¸ì— ì˜í•´ ìƒì„± ëœ í† ìŠ¤íŠ¸ì˜ ìœ„ì¹˜ ë§Œ ë³€ê²½",
			"settings_useChromium_description": "ë¸Œë¼ìš°ì € ëŒ€ì‹  Discord ì—ì„œ ë§í¬ ì—´ê¸°",
			"sort_by": "ì •ë ¬ ê¸°ì¤€",
			"time": "ì‹œê°",
			"timezone": "ì‹œê°„ëŒ€",
			"to": "ì—",
			"toast_plugin_force_updated": "ë²„ì „ì´ ë§¤ìš° ì˜¤ëž˜ë˜ì–´ {{var0}} ì´ ìžë™ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.",
			"toast_plugin_loaded": "{{var0}} ì´ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.",
			"toast_plugin_started": "{{var0}} ì´ ì‹œìž‘ë˜ì—ˆìŠµë‹ˆë‹¤.",
			"toast_plugin_stopped": "{{var0}} ì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.",
			"toast_plugin_translated": "{{var0}} ë¡œ ë²ˆì—­ë¨",
			"toast_plugin_unloaded": "{{var0}} ì´ (ê°€) ì–¸ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.",
			"toast_plugin_update_failed": "{{var0}} ì— ëŒ€í•œ ì—…ë°ì´íŠ¸ë¥¼ ë‹¤ìš´ë¡œë“œ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
			"toast_plugin_updated": "{{var0}} {{var1}}ì´ {{var2}} {{var3}}ë¡œ ëŒ€ì²´ë˜ì—ˆìŠµë‹ˆë‹¤.",
			"update_check_complete": "í”ŒëŸ¬ê·¸ì¸ ì—…ë°ì´íŠ¸ í™•ì¸ ì™„ë£Œ",
			"update_check_complete_outdated": "í”ŒëŸ¬ê·¸ì¸ ì—…ë°ì´íŠ¸ í™•ì¸ ì™„ë£Œ - {{var0}} ì´ (ê°€) ì˜¤ëž˜ë˜ì—ˆìŠµë‹ˆë‹¤!",
			"update_check_info": "ì—…ë°ì´íŠ¸ í™•ì¸ì„ ì§€ì›í•˜ëŠ” í”ŒëŸ¬ê·¸ì¸ í™•ì¸",
			"update_notice_click": "ì—…ë°ì´íŠ¸í•˜ë ¤ë©´ í´ë¦­í•˜ì„¸ìš”!",
			"update_notice_reload": "ì—…ë°ì´íŠ¸ë¥¼ ì™„ë£Œí•˜ë ¤ë©´ ìƒˆë¡œ ê³ ì¹¨í•˜ì„¸ìš”.",
			"update_notice_update": "ë‹¤ìŒ í”ŒëŸ¬ê·¸ì¸ì„ ì—…ë°ì´íŠ¸í•´ì•¼í•©ë‹ˆë‹¤.",
			"updated": "ì—…ë°ì´íŠ¸ ë¨"
		},
		"lt": {
			"add_to": "PridÄ—ti prie {{var0}}",
			"ascending": "Kylanti",
			"center": "Centruotas",
			"changelog_added": "Naujos savybÄ—s",
			"changelog_fixed": "ProblemÅ³ sprendimas",
			"changelog_improved": "Patobulinimai",
			"changelog_progress": "Progresas",
			"check_for_updates": "Tikrinti, ar yra atnaujinimÅ³",
			"confirm": "Ar tu tuo tikras?",
			"delete_fail": "{{var0}} negalima iÅ¡trinti",
			"delete_success": "{{var0}} sÄ—kmingai iÅ¡trinta",
			"descending": "MaÅ¾Ä—jantis",
			"developer": "Programuotojas",
			"donate_message": "Palaikykite mane, kad gautumÄ—te daugiau naujiniÅ³!",
			"download": "ParsisiÅ³sti",
			"download_fail": "{{var0}} negalima atsisiÅ³sti",
			"download_success": "{{var0}} sÄ—kmingai atsisiÅ³sta",
			"file_navigator_text": "NarÅ¡yti failÄ…",
			"first": "Pirmas",
			"from": "Nuo",
			"gradient": "Gradientas",
			"last": "Paskutinis",
			"left": "KairÄ—je",
			"loading": "Ä®keliama {{var0}}",
			"location": "Vieta",
			"order": "Seka",
			"outdated": "PasenÄ™s",
			"please_wait": "Maloniai palauk",
			"right": "Teisingai",
			"save_fail": "{{var0}} negalima iÅ¡saugoti",
			"save_success": "{{var0}} iÅ¡saugota sÄ—kmingai",
			"server": "Serverio",
			"settings_showSupportBadges_description": "Rodo maÅ¾us Å¾enklelius vartotojams, palaikantiems mano Patreon",
			"settings_showToasts_description": "Parodo Ä¯skiepiÅ³ paleidimo ir sustabdymo tostus",
			"settings_showToasts_note": "PrieÅ¡ iÅ¡jungdami, iÅ¡junkite bendrÄ… BD nustatymÄ… '{{var0}}'",
			"settings_toastPosition_description": "Numatytoji skrudintos duonos padÄ—tis",
			"settings_toastPosition_note": "KeiÄia tik mano Ä¯skiepiai sukurtÅ³ tostÅ³ pozicijÄ…",
			"settings_useChromium_description": "Vietoj savo narÅ¡yklÄ—s atidarykite nuorodas nesantaikoje",
			"sort_by": "RÅ«Å¡iuoti pagal",
			"time": "Laikas",
			"timezone": "Laiko zona",
			"to": "Ä®",
			"toast_plugin_force_updated": "'{{var0}}' buvo automatiÅ¡kai atnaujinta, nes jÅ«sÅ³ versija buvo labai pasenusi",
			"toast_plugin_loaded": "{{var0}} buvo Ä¯kelta",
			"toast_plugin_started": "{{var0}} prasidÄ—jo",
			"toast_plugin_stopped": "{{var0}} sustabdyta",
			"toast_plugin_translated": "iÅ¡versta Ä¯ {{var0}}",
			"toast_plugin_unloaded": "{{var0}} buvo iÅ¡krautas",
			"toast_plugin_update_failed": "Negalima atsisiÅ³sti {{var0}} naujinio",
			"toast_plugin_updated": "{{var0}} {{var1}} pakeista Ä¯ {{var2}} {{var3}}",
			"update_check_complete": "Ä®skiepiÅ³ atnaujinimo patikrinimas baigtas",
			"update_check_complete_outdated": "Ä®skiepiÅ³ atnaujinimo patikrinimas baigtas - {{var0}} pasenÄ™s!",
			"update_check_info": "Patikrinkite Ä¯skiepiai, kurie palaiko naujinimo patikrÄ…",
			"update_notice_click": "SpustelÄ—kite norÄ—dami atnaujinti!",
			"update_notice_reload": "Ä®kelkite iÅ¡ naujo, kad uÅ¾baigtumÄ—te atnaujinimÄ…",
			"update_notice_update": "Reikia atnaujinti Å¡iuos Ä¯skiepiai: ",
			"updated": "Atnaujinta"
		},
		"nl": {
			"add_to": "Toevoegen aan {{var0}}",
			"ascending": "Oplopend",
			"center": "Gecentreerd",
			"changelog_added": "Nieuwe features",
			"changelog_fixed": "Probleemoplossen",
			"changelog_improved": "Verbeteringen",
			"changelog_progress": "Vooruitgang",
			"check_for_updates": "Controleer op updates",
			"confirm": "Weet je zeker dat?",
			"delete_fail": "{{var0}} kan niet worden verwijderd",
			"delete_success": "{{var0}} is verwijderd",
			"descending": "Aflopend",
			"developer": "Ontwikkelaar",
			"donate_message": "Steun mij voor meer updates!",
			"download": "Downloaden",
			"download_fail": "{{var0}} kan niet worden gedownload",
			"download_success": "{{var0}} succesvol gedownload",
			"file_navigator_text": "Bestand zoeken",
			"first": "Eerste",
			"from": "Van",
			"gradient": "Verloop",
			"last": "Laatste",
			"left": "Links",
			"loading": "Laden {{var0}}",
			"location": "Plaats",
			"order": "Volgorde",
			"outdated": "Verouderd",
			"please_wait": "Wacht even",
			"right": "Rechtsaf",
			"save_fail": "{{var0}} kan niet worden opgeslagen",
			"save_success": "{{var0}} succesvol opgeslagen",
			"server": "Server",
			"settings_showSupportBadges_description": "Toont kleine badges voor gebruikers die mijn Patreon ondersteunen",
			"settings_showToasts_description": "Toont plugin start en stop toasts",
			"settings_showToasts_note": "Schakel de algemene instelling '{{var0}}' van BD's uit voordat u ze uitschakelt",
			"settings_toastPosition_description": "Standaard toastpositie",
			"settings_toastPosition_note": "Verandert alleen de positie van toast gemaakt door mijn plugins",
			"settings_useChromium_description": "Open links in Discord in plaats van uw browser",
			"sort_by": "Sorteer op",
			"time": "Tijd",
			"timezone": "Tijdzone",
			"to": "Naar",
			"toast_plugin_force_updated": "{{var0}} is automatisch bijgewerkt omdat uw versie erg verouderd was",
			"toast_plugin_loaded": "{{var0}} is geladen",
			"toast_plugin_started": "{{var0}} is gestart",
			"toast_plugin_stopped": "{{var0}} is gestopt",
			"toast_plugin_translated": "vertaald naar {{var0}}",
			"toast_plugin_unloaded": "{{var0}} is verwijderd",
			"toast_plugin_update_failed": "Update voor {{var0}} kan niet worden gedownload",
			"toast_plugin_updated": "{{var0}} {{var1}} is vervangen door {{var2}} {{var3}}",
			"update_check_complete": "Controle op update van plugin voltooid",
			"update_check_complete_outdated": "Controle van update van plugin voltooid - {{var0}} verouderd!",
			"update_check_info": "Controleer plugins die de updatecontrole ondersteunen",
			"update_notice_click": "Klik om te updaten!",
			"update_notice_reload": "Laad opnieuw om de update te voltooien",
			"update_notice_update": "De volgende plugins moeten worden bijgewerkt: ",
			"updated": "Bijgewerkt"
		},
		"no": {
			"add_to": "Legg til i {{var0}}",
			"ascending": "Stigende",
			"center": "Sentrert",
			"changelog_added": "Nye funksjoner",
			"changelog_fixed": "FeilsÃ¸king",
			"changelog_improved": "Forbedringer",
			"changelog_progress": "Framgang",
			"check_for_updates": "Se etter oppdateringer",
			"confirm": "Er du sikker?",
			"delete_fail": "{{var0}} kan ikke slettes",
			"delete_success": "{{var0}} ble slettet",
			"descending": "Fallende",
			"developer": "Utvikler",
			"donate_message": "StÃ¸tt meg for flere oppdateringer!",
			"download": "Nedlasting",
			"download_fail": "{{var0}} kan ikke lastes ned",
			"download_success": "{{var0}} lastet ned",
			"file_navigator_text": "Bla gjennom filen",
			"first": "FÃ¸rst",
			"from": "Fra",
			"gradient": "Gradient",
			"last": "Siste",
			"left": "Venstre",
			"loading": "Laster inn {{var0}}",
			"location": "Plassering",
			"order": "Sekvens",
			"outdated": "Utdatert",
			"please_wait": "Vennligst vent",
			"right": "Ikke sant",
			"save_fail": "{{var0}} kan ikke lagres",
			"save_success": "{{var0}} lagret",
			"server": "Server",
			"settings_showSupportBadges_description": "Viser smÃ¥ merker for brukere som stÃ¸tter min Patreon",
			"settings_showToasts_description": "Viser plugin start og stopp toasts",
			"settings_showToasts_note": "Deaktiver den generelle innstillingen '{{var0}}' for BD-er fÃ¸r du deaktiverer dem",
			"settings_toastPosition_description": "Standard toastposisjon",
			"settings_toastPosition_note": "Endrer bare posisjonen for ristet brÃ¸d opprettet av plugins mine",
			"settings_useChromium_description": "Ã…pne koblinger i Discord i stedet for nettleseren din",
			"sort_by": "Sorter etter",
			"time": "Tid",
			"timezone": "Tidssone",
			"to": "Til",
			"toast_plugin_force_updated": "{{var0}} ble automatisk oppdatert fordi versjonen din var veldig utdatert",
			"toast_plugin_loaded": "{{var0}} er lastet inn",
			"toast_plugin_started": "{{var0}} har startet",
			"toast_plugin_stopped": "{{var0}} har stoppet",
			"toast_plugin_translated": "oversatt til {{var0}}",
			"toast_plugin_unloaded": "{{var0}} er lastet ut",
			"toast_plugin_update_failed": "Oppdatering for {{var0}} kan ikke lastes ned",
			"toast_plugin_updated": "{{var0}} {{var1}} er erstattet av {{var2}} {{var3}}",
			"update_check_complete": "Sjekk plugin-oppdatering fullfÃ¸rt",
			"update_check_complete_outdated": "Sjekk plugin-oppdatering fullfÃ¸rt - {{var0}} utdatert!",
			"update_check_info": "Sjekk plugins som stÃ¸tter oppdateringskontrollen",
			"update_notice_click": "Klikk for Ã¥ oppdatere!",
			"update_notice_reload": "Last inn for Ã¥ fullfÃ¸re oppdateringen",
			"update_notice_update": "FÃ¸lgende plugins mÃ¥ oppdateres: ",
			"updated": "Oppdatert"
		},
		"pl": {
			"add_to": "Dodaj do {{var0}}",
			"ascending": "RosnÄ…co",
			"center": "Åšrodek",
			"changelog_added": "Dodano",
			"changelog_fixed": "Naprawiono",
			"changelog_improved": "Ulepszono",
			"changelog_progress": "PostÄ™p",
			"check_for_updates": "SprawdÅº aktualizacje",
			"confirm": "Na pewno?",
			"delete_fail": "Nie moÅ¼na usunÄ…Ä‡ {{var0}}",
			"delete_success": "PomyÅ›lnie usuniÄ™to {{var0}}",
			"descending": "MalejÄ…co",
			"developer": "Deweloper",
			"donate_message": "Wesprzyj mnie, aby uzyskaÄ‡ wiÄ™cej aktualizacji!",
			"download": "Pobieranie",
			"download_fail": "Nie moÅ¼na pobraÄ‡ {{var0}}",
			"download_success": "PomyÅ›lnie pobrano {{var0}}",
			"file_navigator_text": "PrzeglÄ…daj plik",
			"first": "Pierwszy",
			"from": "Od",
			"gradient": "Gradient",
			"last": "Ostatni",
			"left": "Lewo",
			"loading": "Åadowanie {{var0}}",
			"location": "Lokalizacja",
			"order": "KolejnoÅ›Ä‡",
			"outdated": "PrzestarzaÅ‚y",
			"please_wait": "ProszÄ™ czekaÄ‡",
			"right": "Prawo",
			"save_fail": "Nie moÅ¼na zapisaÄ‡ {{var0}}",
			"save_success": "PomyÅ›lnie zapisano {{var0}}",
			"server": "Serwer",
			"settings_showSupportBadges_description": "Pokazuje maÅ‚e odznaki dla wspierajÄ…cych mojego Patreona",
			"settings_showToasts_description": "Pokazuje toasty uruchamiajÄ…ce i zatrzymujÄ…ce wtyczki",
			"settings_showToasts_note": "WyÅ‚Ä…cz ogÃ³lne ustawienie '{{var0}} â€ dyskÃ³w BD przed ich wyÅ‚Ä…czeniem",
			"settings_toastPosition_description": "DomyÅ›lna pozycja toastÃ³w",
			"settings_toastPosition_note": "Zmienia tylko pozycjÄ™ toastÃ³w utworzonych przez moje wtyczki",
			"settings_useChromium_description": "Otwieraj linki w Discordzie zamiast w przeglÄ…darce",
			"sort_by": "Sortuj wedÅ‚ug",
			"time": "Czas",
			"timezone": "Strefa czasowa",
			"to": "Do",
			"toast_plugin_force_updated": "{{var0}} zostaÅ‚ automatycznie zaktualizowany, poniewaÅ¼ Twoja wersja byÅ‚a bardzo nieaktualna",
			"toast_plugin_loaded": "ZaÅ‚adowano {{var0}}",
			"toast_plugin_started": "RozpoczÄ™to {{var0}}",
			"toast_plugin_stopped": "{{var0}} zostaÅ‚ zatrzymany",
			"toast_plugin_translated": "przetÅ‚umaczone na {{var0}}",
			"toast_plugin_unloaded": "UsuniÄ™to {{var0}}",
			"toast_plugin_update_failed": "Nie moÅ¼na pobraÄ‡ aktualizacji dla {{var0}}",
			"toast_plugin_updated": "{{var0}} {{var1}} zostaÅ‚ zastÄ…piony przez {{var2}} {{var3}}",
			"update_check_complete": "Sprawdzanie aktualizacji wtyczki zakoÅ„czone",
			"update_check_complete_outdated": "Sprawdzanie aktualizacji wtyczki zakoÅ„czone - {{var0}} nieaktualne!",
			"update_check_info": "SprawdÅº wtyczki obsÅ‚ugujÄ…ce sprawdzanie aktualizacji",
			"update_notice_click": "Kliknij, aby zaktualizowaÄ‡!",
			"update_notice_reload": "ZaÅ‚aduj ponownie, aby zakoÅ„czyÄ‡ aktualizacjÄ™",
			"update_notice_update": "NaleÅ¼y zaktualizowaÄ‡ nastÄ™pujÄ…ce wtyczki: ",
			"updated": "Zaktualizowano"
		},
		"pt-BR": {
			"add_to": "Adicionar a {{var0}}",
			"ascending": "Ascendente",
			"center": "Centrado",
			"changelog_added": "Novas caracterÃ­sticas",
			"changelog_fixed": "SoluÃ§Ã£o de problemas",
			"changelog_improved": "Melhorias",
			"changelog_progress": "Progresso",
			"check_for_updates": "Verifique se hÃ¡ atualizaÃ§Ãµes",
			"confirm": "VocÃª tem certeza?",
			"delete_fail": "{{var0}} nÃ£o pode ser excluÃ­do",
			"delete_success": "{{var0}} excluÃ­do com sucesso",
			"descending": "Descendente",
			"developer": "Desenvolvedor",
			"donate_message": "Apoie-me para mais atualizaÃ§Ãµes!",
			"download": "Baixar",
			"download_fail": "{{var0}} nÃ£o pode ser baixado",
			"download_success": "{{var0}} baixado com sucesso",
			"file_navigator_text": "Procurar arquivo",
			"first": "Primeiro",
			"from": "De",
			"gradient": "Gradiente",
			"last": "Ãšltimo",
			"left": "Esquerda",
			"loading": "Carregando {{var0}}",
			"location": "LocalizaÃ§Ã£o",
			"order": "SeqÃ¼Ãªncia",
			"outdated": "Desatualizado",
			"please_wait": "Por favor espere",
			"right": "Direito",
			"save_fail": "{{var0}} nÃ£o pode ser salvo",
			"save_success": "{{var0}} salvo com sucesso",
			"server": "Servidor",
			"settings_showSupportBadges_description": "Mostra pequenos emblemas para usuÃ¡rios que apÃ³iam meu Patreon",
			"settings_showToasts_description": "Mostra o inÃ­cio e o fim do plugin do brinde",
			"settings_showToasts_note": "Desative a configuraÃ§Ã£o geral '{{var0}}' de BDs antes de desativÃ¡-los",
			"settings_toastPosition_description": "PosiÃ§Ã£o padrÃ£o do brinde",
			"settings_toastPosition_note": "Apenas altera a posiÃ§Ã£o dos brindes criados pelos meus plugins",
			"settings_useChromium_description": "Abra links no Discord em vez do seu navegador",
			"sort_by": "Ordenar por",
			"time": "Tempo",
			"timezone": "Fuso horÃ¡rio",
			"to": "Para",
			"toast_plugin_force_updated": "{{var0}} foi atualizado automaticamente porque sua versÃ£o estava muito desatualizada",
			"toast_plugin_loaded": "{{var0}} foi carregado",
			"toast_plugin_started": "{{var0}} comeÃ§ou",
			"toast_plugin_stopped": "{{var0}} parou",
			"toast_plugin_translated": "traduzido para {{var0}}",
			"toast_plugin_unloaded": "{{var0}} foi descarregado",
			"toast_plugin_update_failed": "A atualizaÃ§Ã£o para {{var0}} nÃ£o pode ser baixada",
			"toast_plugin_updated": "{{var0}} {{var1}} foi substituÃ­do por {{var2}} {{var3}}",
			"update_check_complete": "VerificaÃ§Ã£o de atualizaÃ§Ã£o do plugin concluÃ­da",
			"update_check_complete_outdated": "VerificaÃ§Ã£o de atualizaÃ§Ã£o do plugin concluÃ­da - {{var0}} desatualizado!",
			"update_check_info": "Verifique os plugins que suportam a verificaÃ§Ã£o de atualizaÃ§Ã£o",
			"update_notice_click": "Clique para atualizar!",
			"update_notice_reload": "Recarregue para completar a atualizaÃ§Ã£o",
			"update_notice_update": "Os seguintes plugins precisam ser atualizados: ",
			"updated": "Atualizada"
		},
		"ro": {
			"add_to": "AdÄƒugaÈ›i la {{var0}}",
			"ascending": "Ascendent",
			"center": "Centrat",
			"changelog_added": "Functii noi",
			"changelog_fixed": "Depanare",
			"changelog_improved": "ÃŽmbunÄƒtÄƒÈ›iri",
			"changelog_progress": "Progres",
			"check_for_updates": "VerificÄƒ pentru actualizÄƒri",
			"confirm": "Esti sigur?",
			"delete_fail": "{{var0}} nu poate fi È™ters",
			"delete_success": "{{var0}} È™ters cu succes",
			"descending": "DescendentÄƒ",
			"developer": "Dezvoltator",
			"donate_message": "SprijinÄƒ-mÄƒ pentru mai multe actualizÄƒri!",
			"download": "Descarca",
			"download_fail": "{{var0}} nu poate fi descÄƒrcat",
			"download_success": "{{var0}} descÄƒrcat cu succes",
			"file_navigator_text": "RÄƒsfoiÈ›i fiÈ™ierul",
			"first": "Primul",
			"from": "Din",
			"gradient": "Gradient",
			"last": "Ultimul",
			"left": "StÃ¢nga",
			"loading": "Se Ã®ncarcÄƒ {{var0}}",
			"location": "LocaÈ›ie",
			"order": "SecvenÅ£Äƒ",
			"outdated": "ÃŽnvechit",
			"please_wait": "AÈ™teptaÈ›i plÄƒcut",
			"right": "Dreapta",
			"save_fail": "{{var0}} nu poate fi salvat",
			"save_success": "{{var0}} salvat cu succes",
			"server": "Server",
			"settings_showSupportBadges_description": "AfiÈ™eazÄƒ insigne mici pentru utilizatorii care acceptÄƒ Patreon",
			"settings_showToasts_description": "AfiÈ™eazÄƒ pornirea È™i oprirea toastelor pluginului",
			"settings_showToasts_note": "DezactivaÈ›i setarea generalÄƒ '{{var0}} â€ a BD-urilor Ã®nainte de a le dezactiva",
			"settings_toastPosition_description": "PoziÈ›ie implicitÄƒ Toast",
			"settings_toastPosition_note": "ModificÄƒ doar poziÈ›ia toastelor create de pluginuri mele",
			"settings_useChromium_description": "DeschideÈ›i linkuri Ã®n discordie Ã®n loc de browser",
			"sort_by": "FiltreazÄƒ dupÄƒ",
			"time": "Timp",
			"timezone": "Fus orar",
			"to": "La",
			"toast_plugin_force_updated": "{{var0}} a fost actualizat automat deoarece versiunea dvs. a fost foarte depÄƒÈ™itÄƒ",
			"toast_plugin_loaded": "{{var0}} a fost Ã®ncÄƒrcat",
			"toast_plugin_started": "{{var0}} a Ã®nceput",
			"toast_plugin_stopped": "{{var0}} s-a oprit",
			"toast_plugin_translated": "tradus Ã®n {{var0}}",
			"toast_plugin_unloaded": "{{var0}} a fost descÄƒrcat",
			"toast_plugin_update_failed": "Actualizarea pentru {{var0}} nu poate fi descÄƒrcatÄƒ",
			"toast_plugin_updated": "{{var0}} {{var1}} a fost Ã®nlocuit cu {{var2}} {{var3}}",
			"update_check_complete": "Verificarea actualizÄƒrii pluginului s-a finalizat",
			"update_check_complete_outdated": "Verificarea actualizÄƒrii pluginului s-a finalizat - {{var0}} nu este actualizatÄƒ!",
			"update_check_info": "VerificaÈ›i pluginuri care acceptÄƒ verificarea actualizÄƒrii",
			"update_notice_click": "FaceÈ›i clic pentru a actualiza!",
			"update_notice_reload": "ReÃ®ncÄƒrcaÈ›i pentru a finaliza actualizarea",
			"update_notice_update": "UrmÄƒtoarele pluginuri trebuie actualizate: ",
			"updated": "La curent"
		},
		"ru": {
			"add_to": "Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð² {{var0}}",
			"ascending": "Ð’Ð¾ÑÑ…Ð¾Ð´ÑÑ‰Ð¸Ð¹",
			"center": "ÐŸÐ¾ Ñ†ÐµÐ½Ñ‚Ñ€Ñƒ",
			"changelog_added": "ÐÐ¾Ð²Ñ‹Ðµ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ÑÑ‚Ð¸",
			"changelog_fixed": "ÐŸÐ¾Ð¸ÑÐº Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹",
			"changelog_improved": "Ð£Ð»ÑƒÑ‡ÑˆÐµÐ½Ð¸Ñ",
			"changelog_progress": "ÐŸÑ€Ð¾Ð³Ñ€ÐµÑÑ",
			"check_for_updates": "ÐŸÑ€Ð¾Ð²ÐµÑ€Ð¸Ñ‚ÑŒ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ",
			"confirm": "Ð¢Ñ‹ ÑƒÐ²ÐµÑ€ÐµÐ½?",
			"delete_fail": "{{var0}} Ð½ÐµÐ»ÑŒÐ·Ñ ÑƒÐ´Ð°Ð»Ð¸Ñ‚ÑŒ",
			"delete_success": "{{var0}} ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ ÑƒÐ´Ð°Ð»ÐµÐ½",
			"descending": "ÐŸÐ¾ ÑƒÐ±Ñ‹Ð²Ð°Ð½Ð¸ÑŽ",
			"developer": "Ð Ð°Ð·Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸Ðº",
			"donate_message": "ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ñ‚Ðµ Ð¼ÐµÐ½Ñ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¿Ð¾Ð»ÑƒÑ‡Ð°Ñ‚ÑŒ Ð±Ð¾Ð»ÑŒÑˆÐµ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ð¹!",
			"download": "Ð¡ÐºÐ°Ñ‡Ð°Ñ‚ÑŒ",
			"download_fail": "{{var0}} Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½",
			"download_success": "{{var0}} ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½",
			"file_navigator_text": "ÐŸÑ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€ÐµÑ‚ÑŒ Ñ„Ð°Ð¹Ð»",
			"first": "ÐŸÐµÑ€Ð²Ñ‹Ð¹",
			"from": "Ð˜Ð·",
			"gradient": "Ð“Ñ€Ð°Ð´Ð¸ÐµÐ½Ñ‚",
			"last": "ÐŸÐ¾ÑÐ»ÐµÐ´Ð½Ð¸Ð¹",
			"left": "Ð¡Ð»ÐµÐ²Ð°",
			"loading": "Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° {{var0}}",
			"location": "ÐœÐµÑÑ‚Ð¾ Ñ€Ð°ÑÐ¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ",
			"order": "ÐŸÐ¾ÑÐ»ÐµÐ´Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ",
			"outdated": "Ð£ÑÑ‚Ð°Ñ€ÐµÐ²ÑˆÐ¸Ð¹",
			"please_wait": "ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð¿Ð¾Ð´Ð¾Ð¶Ð´Ð¸Ñ‚Ðµ",
			"right": "ÐŸÑ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¾",
			"save_fail": "{{var0}} Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½",
			"save_success": "{{var0}} ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½",
			"server": "Ð¡ÐµÑ€Ð²ÐµÑ€",
			"settings_showSupportBadges_description": "ÐŸÐ¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÑ‚ Ð¼Ð°Ð»ÐµÐ½ÑŒÐºÐ¸Ðµ Ð·Ð½Ð°Ñ‡ÐºÐ¸ Ð´Ð»Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÐµÐ¹, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÑŽÑ‚ Ð¼Ð¾Ð¹ Patreon",
			"settings_showToasts_description": "ÐŸÐ¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÑ‚ Ð·Ð°Ð¿ÑƒÑÐº Ð¸ Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²ÐºÑƒ Ð²ÑÐ¿Ð»Ñ‹Ð²Ð°ÑŽÑ‰Ð¸Ñ… Ð¾ÐºÐ¾Ð½",
			"settings_showToasts_note": "ÐžÑ‚ÐºÐ»ÑŽÑ‡Ð¸Ñ‚Ðµ Ð¾Ð±Ñ‰ÑƒÑŽ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÑƒ '{{var0}}' BD Ð¿ÐµÑ€ÐµÐ´ Ð¸Ñ… Ð¾Ñ‚ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸ÐµÐ¼",
			"settings_toastPosition_description": "ÐŸÐ¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ñ‚Ð¾ÑÑ‚Ð° Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ",
			"settings_toastPosition_note": "Ð˜Ð·Ð¼ÐµÐ½ÑÐµÑ‚ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¿Ð¾Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ñ‚Ð¾ÑÑ‚Ð¾Ð², ÑÐ¾Ð·Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¼Ð¾Ð¸Ð¼Ð¸ Ð¿Ð»Ð°Ð³Ð¸Ð½Ñ‹",
			"settings_useChromium_description": "ÐžÑ‚ÐºÑ€Ñ‹Ð²Ð°Ð¹Ñ‚Ðµ ÑÑÑ‹Ð»ÐºÐ¸ Ð² Discord, Ð° Ð½Ðµ Ð² Ð±Ñ€Ð°ÑƒÐ·ÐµÑ€Ðµ",
			"sort_by": "Ð¡Ð¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð¿Ð¾",
			"time": "Ð’Ñ€ÐµÐ¼Ñ",
			"timezone": "Ð§Ð°ÑÐ¾Ð²Ð¾Ð¹ Ð¿Ð¾ÑÑ",
			"to": "Ð§Ñ‚Ð¾Ð±Ñ‹",
			"toast_plugin_force_updated": "{{var0}} Ð±Ñ‹Ð» Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸, Ð¿Ð¾ÑÐºÐ¾Ð»ÑŒÐºÑƒ Ð²Ð°ÑˆÐ° Ð²ÐµÑ€ÑÐ¸Ñ Ð¾Ñ‡ÐµÐ½ÑŒ ÑƒÑÑ‚Ð°Ñ€ÐµÐ»Ð°",
			"toast_plugin_loaded": "{{var0}} Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ð¾",
			"toast_plugin_started": "{{var0}} Ð½Ð°Ñ‡Ð°Ð»Ð¾ÑÑŒ",
			"toast_plugin_stopped": "{{var0}} Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½",
			"toast_plugin_translated": "Ð¿ÐµÑ€ÐµÐ²ÐµÐ´ÐµÐ½Ð¾ Ð½Ð° {{var0}}",
			"toast_plugin_unloaded": "{{var0}} Ð²Ñ‹Ð³Ñ€ÑƒÐ¶ÐµÐ½",
			"toast_plugin_update_failed": "ÐžÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ð´Ð»Ñ {{var0}} Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ð¾",
			"toast_plugin_updated": "{{var0}} {{var1}} Ð±Ñ‹Ð» Ð·Ð°Ð¼ÐµÐ½ÐµÐ½ Ð½Ð° {{var2}} {{var3}}",
			"update_check_complete": "ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ð¹ Ð¿Ð»Ð°Ð³Ð¸Ð½Ð° Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð°",
			"update_check_complete_outdated": "ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ð¹ Ð¿Ð»Ð°Ð³Ð¸Ð½Ð° Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð° - {{var0}} ÑƒÑÑ‚Ð°Ñ€ÐµÐ»Ð¾!",
			"update_check_info": "ÐŸÑ€Ð¾Ð²ÐµÑ€Ð¸Ñ‚ÑŒ Ð¿Ð»Ð°Ð³Ð¸Ð½Ñ‹, Ð¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð¸Ð²Ð°ÑŽÑ‰Ð¸Ðµ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÑƒ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ð¹",
			"update_notice_click": "ÐÐ°Ð¶Ð¼Ð¸Ñ‚Ðµ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¾Ð±Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ!",
			"update_notice_reload": "ÐŸÐµÑ€ÐµÐ·Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚Ðµ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð·Ð°Ð²ÐµÑ€ÑˆÐ¸Ñ‚ÑŒ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ",
			"update_notice_update": "ÐÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ð¾ Ð¾Ð±Ð½Ð¾Ð²Ð¸Ñ‚ÑŒ ÑÐ»ÐµÐ´ÑƒÑŽÑ‰Ð¸Ðµ Ð¿Ð»Ð°Ð³Ð¸Ð½Ñ‹: ",
			"updated": "ÐžÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾"
		},
		"sv": {
			"add_to": "LÃ¤gg till i {{var0}}",
			"ascending": "Stigande",
			"center": "Centrerad",
			"changelog_added": "Nya egenskaper",
			"changelog_fixed": "FelsÃ¶kning",
			"changelog_improved": "FÃ¶rbÃ¤ttringar",
			"changelog_progress": "Framsteg",
			"check_for_updates": "SÃ¶k efter uppdateringar",
			"confirm": "Ã„r du sÃ¤ker?",
			"delete_fail": "{{var0}} kan inte raderas",
			"delete_success": "{{var0}} har tagits bort",
			"descending": "NedÃ¥tgÃ¥ende",
			"developer": "Utvecklaren",
			"donate_message": "StÃ¶d mig fÃ¶r fler uppdateringar!",
			"download": "Ladda ner",
			"download_fail": "{{var0}} kan inte laddas ner",
			"download_success": "{{var0}} laddades ner",
			"file_navigator_text": "BlÃ¤ddra i filen",
			"first": "FÃ¶rst",
			"from": "FrÃ¥n",
			"gradient": "Lutning",
			"last": "Sista",
			"left": "VÃ¤nster",
			"loading": "Laddar {{var0}}",
			"location": "Plats",
			"order": "Sekvens",
			"outdated": "FÃ¶rÃ¥ldrad",
			"please_wait": "VÃ¤nligen vÃ¤nta",
			"right": "RÃ¤tt",
			"save_fail": "{{var0}} kan inte sparas",
			"save_success": "{{var0}} har sparats",
			"server": "Server",
			"settings_showSupportBadges_description": "Visar smÃ¥ mÃ¤rken fÃ¶r anvÃ¤ndare som stÃ¶der min Patreon",
			"settings_showToasts_description": "Visar plugin start och stopp toasts",
			"settings_showToasts_note": "Inaktivera den allmÃ¤nna instÃ¤llningen '{{var0}}' fÃ¶r BD-skivor innan du inaktiverar dem",
			"settings_toastPosition_description": "Standard toastposition",
			"settings_toastPosition_note": "Ã„ndrar bara positionen fÃ¶r rostat brÃ¶d som skapats av mina plugins",
			"settings_useChromium_description": "Ã–ppna LÃ¤nkar i Discord istÃ¤llet fÃ¶r din webblÃ¤sare",
			"sort_by": "Sortera efter",
			"time": "Tid",
			"timezone": "Tidszon",
			"to": "Till",
			"toast_plugin_force_updated": "{{var0}} uppdaterades automatiskt eftersom din version var mycket fÃ¶rÃ¥ldrad",
			"toast_plugin_loaded": "{{var0}} har laddats",
			"toast_plugin_started": "{{var0}} har startat",
			"toast_plugin_stopped": "{{var0}} har slutat",
			"toast_plugin_translated": "Ã¶versatt till {{var0}}",
			"toast_plugin_unloaded": "{{var0}} har lossats",
			"toast_plugin_update_failed": "Uppdatering fÃ¶r {{var0}} kan inte laddas ner",
			"toast_plugin_updated": "{{var0}} {{var1}} har ersatts med {{var2}} {{var3}}",
			"update_check_complete": "Kontrollen av plugin-uppdateringen slutfÃ¶rd",
			"update_check_complete_outdated": "Kontrollen av plugin-uppdateringen slutfÃ¶rd - {{var0}} inaktuell!",
			"update_check_info": "Kontrollera plugins som stÃ¶der uppdateringskontrollen",
			"update_notice_click": "Klicka fÃ¶r att uppdatera!",
			"update_notice_reload": "Ladda om fÃ¶r att slutfÃ¶ra uppdateringen",
			"update_notice_update": "FÃ¶ljande plugins mÃ¥ste uppdateras: ",
			"updated": "Uppdaterad"
		},
		"th": {
			"add_to": "à¹€à¸žà¸´à¹ˆà¸¡à¹ƒà¸™{{var0}}",
			"ascending": "à¸ˆà¸²à¸à¸™à¹‰à¸­à¸¢à¹„à¸›à¸¡à¸²à¸",
			"center": "à¸­à¸¢à¸¹à¹ˆà¸à¸¶à¹ˆà¸‡à¸à¸¥à¸²à¸‡",
			"changelog_added": "à¸„à¸¸à¸“à¸ªà¸¡à¸šà¸±à¸•à¸´à¹ƒà¸«à¸¡à¹ˆ",
			"changelog_fixed": "à¸à¸²à¸£à¹à¸à¹‰à¹„à¸‚à¸›à¸±à¸à¸«à¸²",
			"changelog_improved": "à¸à¸²à¸£à¸›à¸£à¸±à¸šà¸›à¸£à¸¸à¸‡",
			"changelog_progress": "à¸„à¸§à¸²à¸¡à¸„à¸·à¸šà¸«à¸™à¹‰à¸²",
			"check_for_updates": "à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸ªà¸³à¸«à¸£à¸±à¸šà¸à¸²à¸£à¸­à¸±à¸žà¹€à¸”à¸•",
			"confirm": "à¸„à¸¸à¸“à¹à¸™à¹ˆà¹ƒà¸ˆà¹„à¸«à¸¡?",
			"delete_fail": "à¹„à¸¡à¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¸¥à¸š{{var0}}à¹„à¸”à¹‰",
			"delete_success": "à¸¥à¸š{{var0}}à¹€à¸£à¸µà¸¢à¸šà¸£à¹‰à¸­à¸¢à¹à¸¥à¹‰à¸§",
			"descending": "à¸ˆà¸²à¸à¸¡à¸²à¸à¹„à¸›à¸™à¹‰à¸­à¸¢",
			"developer": "à¸œà¸¹à¹‰à¸žà¸±à¸’à¸™à¸²",
			"donate_message": "à¸ªà¸™à¸±à¸šà¸ªà¸™à¸¸à¸™à¸‰à¸±à¸™à¸ªà¸³à¸«à¸£à¸±à¸šà¸à¸²à¸£à¸­à¸±à¸›à¹€à¸”à¸•à¹€à¸žà¸´à¹ˆà¸¡à¹€à¸•à¸´à¸¡!",
			"download": "à¸”à¸²à¸§à¸™à¹Œà¹‚à¸«à¸¥à¸”",
			"download_fail": "à¹„à¸¡à¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¸”à¸²à¸§à¸™à¹Œà¹‚à¸«à¸¥à¸”{{var0}}",
			"download_success": "à¸”à¸²à¸§à¸™à¹Œà¹‚à¸«à¸¥à¸”{{var0}}à¸ªà¸³à¹€à¸£à¹‡à¸ˆ",
			"file_navigator_text": "à¹€à¸£à¸µà¸¢à¸à¸”à¸¹à¹„à¸Ÿà¸¥à¹Œ",
			"first": "à¸­à¸±à¸™à¸”à¸±à¸šà¹à¸£à¸",
			"from": "à¸ˆà¸²à¸",
			"gradient": "à¹„à¸¥à¹ˆà¸£à¸°à¸”à¸±à¸šà¸ªà¸µ",
			"last": "à¸¥à¹ˆà¸²à¸ªà¸¸à¸”",
			"left": "à¸‹à¹‰à¸²à¸¢",
			"loading": "à¸à¸³à¸¥à¸±à¸‡à¹‚à¸«à¸¥à¸”{{var0}}",
			"location": "à¸ªà¸–à¸²à¸™à¸—à¸µà¹ˆ",
			"order": "à¸¥à¸³à¸”à¸±à¸š",
			"outdated": "à¹€à¸à¹ˆà¸²",
			"please_wait": "à¹‚à¸›à¸£à¸”à¸£à¸­",
			"right": "à¸‚à¸§à¸²",
			"save_fail": "à¹„à¸¡à¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¸šà¸±à¸™à¸—à¸¶à¸{{var0}}à¹„à¸”à¹‰",
			"save_success": "à¸šà¸±à¸™à¸—à¸¶à¸{{var0}}à¹€à¸£à¸µà¸¢à¸šà¸£à¹‰à¸­à¸¢à¹à¸¥à¹‰à¸§",
			"server": "à¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¹€à¸§à¸­à¸£à¹Œ",
			"settings_showSupportBadges_description": "à¹à¸ªà¸”à¸‡à¸›à¹‰à¸²à¸¢à¸‚à¸™à¸²à¸”à¹€à¸¥à¹‡à¸à¸ªà¸³à¸«à¸£à¸±à¸šà¸œà¸¹à¹‰à¹ƒà¸Šà¹‰à¸—à¸µà¹ˆà¸ªà¸™à¸±à¸šà¸ªà¸™à¸¸à¸™ Patreon à¸‚à¸­à¸‡à¸‰à¸±à¸™",
			"settings_showToasts_description": "à¹à¸ªà¸”à¸‡à¸›à¸¥à¸±à¹Šà¸à¸­à¸´à¸™à¹€à¸£à¸´à¹ˆà¸¡à¹à¸¥à¸°à¸«à¸¢à¸¸à¸”à¸‚à¸™à¸¡à¸›à¸±à¸‡à¸›à¸´à¹‰à¸‡",
			"settings_showToasts_note": "à¸›à¸´à¸”à¸à¸²à¸£à¹ƒà¸Šà¹‰à¸‡à¸²à¸™à¸à¸²à¸£à¸•à¸±à¹‰à¸‡à¸„à¹ˆà¸²à¸—à¸±à¹ˆà¸§à¹„à¸› '{{var0}}' à¸‚à¸­à¸‡ BD à¸à¹ˆà¸­à¸™à¸›à¸´à¸”à¹ƒà¸Šà¹‰à¸‡à¸²à¸™",
			"settings_toastPosition_description": "à¸•à¸³à¹à¸«à¸™à¹ˆà¸‡à¸‚à¸™à¸¡à¸›à¸±à¸‡à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™",
			"settings_toastPosition_note": "à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¹€à¸‰à¸žà¸²à¸°à¸•à¸³à¹à¸«à¸™à¹ˆà¸‡à¸‚à¸­à¸‡à¸‚à¸™à¸¡à¸›à¸±à¸‡à¸—à¸µà¹ˆà¸ªà¸£à¹‰à¸²à¸‡à¹‚à¸”à¸¢à¸›à¸¥à¸±à¹Šà¸à¸­à¸´à¸™à¸‚à¸­à¸‡à¸‰à¸±à¸™",
			"settings_useChromium_description": "à¹€à¸›à¸´à¸”à¸¥à¸´à¸‡à¸„à¹Œà¹ƒà¸™ Discord à¹à¸—à¸™à¹€à¸šà¸£à¸²à¸§à¹Œà¹€à¸‹à¸­à¸£à¹Œà¸‚à¸­à¸‡à¸„à¸¸à¸“",
			"sort_by": "à¸ˆà¸±à¸”à¹€à¸£à¸µà¸¢à¸‡à¸•à¸²à¸¡",
			"time": "à¹€à¸§à¸¥à¸²",
			"timezone": "à¹€à¸‚à¸•à¹€à¸§à¸¥à¸²",
			"to": "à¸–à¸¶à¸‡",
			"toast_plugin_force_updated": "{{var0}} à¹„à¸”à¹‰à¸£à¸±à¸šà¸à¸²à¸£à¸­à¸±à¸›à¹€à¸”à¸•à¹‚à¸”à¸¢à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´à¹€à¸™à¸·à¹ˆà¸­à¸‡à¸ˆà¸²à¸à¹€à¸§à¸­à¸£à¹Œà¸Šà¸±à¸™à¸‚à¸­à¸‡à¸„à¸¸à¸“à¸¥à¹‰à¸²à¸ªà¸¡à¸±à¸¢à¸¡à¸²à¸",
			"toast_plugin_loaded": "à¹‚à¸«à¸¥à¸” {{var0}} à¹à¸¥à¹‰à¸§",
			"toast_plugin_started": "{{var0}} à¹€à¸£à¸´à¹ˆà¸¡à¹à¸¥à¹‰à¸§",
			"toast_plugin_stopped": "{{var0}} à¸«à¸¢à¸¸à¸”à¸—à¸³à¸‡à¸²à¸™",
			"toast_plugin_translated": "à¹à¸›à¸¥à¹€à¸›à¹‡à¸™ {{var0}}",
			"toast_plugin_unloaded": "à¸¢à¸à¹€à¸¥à¸´à¸à¸à¸²à¸£à¹‚à¸«à¸¥à¸” {{var0}} à¹à¸¥à¹‰à¸§",
			"toast_plugin_update_failed": "à¹„à¸¡à¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¸”à¸²à¸§à¸™à¹Œà¹‚à¸«à¸¥à¸”à¸à¸²à¸£à¸­à¸±à¸›à¹€à¸”à¸•à¸ªà¸³à¸«à¸£à¸±à¸š {{var0}}",
			"toast_plugin_updated": "{{var0}} {{var1}} à¸–à¸¹à¸à¹à¸—à¸™à¸—à¸µà¹ˆà¸”à¹‰à¸§à¸¢ {{var2}} {{var3}}",
			"update_check_complete": "à¸à¸²à¸£à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸à¸²à¸£à¸­à¸±à¸›à¹€à¸”à¸•à¸›à¸¥à¸±à¹Šà¸à¸­à¸´à¸™à¹€à¸ªà¸£à¹‡à¸ˆà¸ªà¸¡à¸šà¸¹à¸£à¸“à¹Œ",
			"update_check_complete_outdated": "à¸à¸²à¸£à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸à¸²à¸£à¸­à¸±à¸›à¹€à¸”à¸•à¸›à¸¥à¸±à¹Šà¸à¸­à¸´à¸™à¹€à¸ªà¸£à¹‡à¸ˆà¸ªà¸¡à¸šà¸¹à¸£à¸“à¹Œ - {{var0}} à¸¥à¹‰à¸²à¸ªà¸¡à¸±à¸¢!",
			"update_check_info": "à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸›à¸¥à¸±à¹Šà¸à¸­à¸´à¸™à¸—à¸µà¹ˆà¸£à¸­à¸‡à¸£à¸±à¸šà¸à¸²à¸£à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸à¸²à¸£à¸­à¸±à¸›à¹€à¸”à¸•",
			"update_notice_click": "à¸„à¸¥à¸´à¸à¹€à¸žà¸·à¹ˆà¸­à¸­à¸±à¸žà¹€à¸”à¸—!",
			"update_notice_reload": "à¹‚à¸«à¸¥à¸”à¸‹à¹‰à¸³à¹€à¸žà¸·à¹ˆà¸­à¸­à¸±à¸›à¹€à¸”à¸•à¹ƒà¸«à¹‰à¹€à¸ªà¸£à¹‡à¸ˆà¸ªà¸¡à¸šà¸¹à¸£à¸“à¹Œ",
			"update_notice_update": "à¸ˆà¸³à¹€à¸›à¹‡à¸™à¸•à¹‰à¸­à¸‡à¸­à¸±à¸›à¹€à¸”à¸•à¸›à¸¥à¸±à¹Šà¸à¸­à¸´à¸™à¸•à¹ˆà¸­à¹„à¸›à¸™à¸µà¹‰: ",
			"updated": "à¸­à¸±à¸›à¹€à¸”à¸•à¹à¸¥à¹‰à¸§"
		},
		"tr": {
			"add_to": "{{var0}} ekle",
			"ascending": "Artan",
			"center": "OrtalanmÄ±ÅŸ",
			"changelog_added": "Yeni Ã¶zellikler",
			"changelog_fixed": "Sorun giderme",
			"changelog_improved": "Ä°yileÅŸtirmeler",
			"changelog_progress": "Ilerleme",
			"check_for_updates": "GÃ¼ncellemeleri kontrol et",
			"confirm": "Emin misiniz?",
			"delete_fail": "{{var0}} silinemez",
			"delete_success": "{{var0}} baÅŸarÄ±yla silindi",
			"descending": "Azalan",
			"developer": "GeliÅŸtirici",
			"donate_message": "Daha fazla gÃ¼ncelleme iÃ§in beni destekleyin!",
			"download": "Ä°ndir",
			"download_fail": "{{var0}} indirilemez",
			"download_success": "{{var0}} baÅŸarÄ±yla indirildi",
			"file_navigator_text": "Dosyaya GÃ¶zat",
			"first": "Ä°lk",
			"from": "Nereden",
			"gradient": "Gradyan",
			"last": "Son",
			"left": "AyrÄ±ldÄ±",
			"loading": "YÃ¼kleniyor {{var0}}",
			"location": "Yer",
			"order": "SÄ±ra",
			"outdated": "ModasÄ± geÃ§miÅŸ",
			"please_wait": "LÃ¼tfen bekle",
			"right": "SaÄŸ",
			"save_fail": "{{var0}} kaydedilemez",
			"save_success": "{{var0}} baÅŸarÄ±yla kaydedildi",
			"server": "Sunucu",
			"settings_showSupportBadges_description": "Patreon'umu destekleyen kullanÄ±cÄ±lar iÃ§in kÃ¼Ã§Ã¼k rozetler gÃ¶sterir",
			"settings_showToasts_description": "Eklenti baÅŸlangÄ±Ã§ â€‹â€‹ve bitiÅŸ tostlarÄ±nÄ± gÃ¶sterir",
			"settings_showToasts_note": "Devre dÄ±ÅŸÄ± bÄ±rakmadan Ã¶nce BD'lerin genel ayarÄ±nÄ± '{{var0}}' devre dÄ±ÅŸÄ± bÄ±rakÄ±n",
			"settings_toastPosition_description": "VarsayÄ±lan Tost Konumu",
			"settings_toastPosition_note": "YalnÄ±zca Eklentileri tarafÄ±ndan oluÅŸturulan ToastlarÄ±n Konumunu deÄŸiÅŸtirir",
			"settings_useChromium_description": "TarayÄ±cÄ±nÄ±z yerine Discord'da BaÄŸlantÄ±larÄ± AÃ§Ä±n",
			"sort_by": "GÃ¶re sÄ±rala",
			"time": "Zaman",
			"timezone": "Saat dilimi",
			"to": "Ä°Ã§in",
			"toast_plugin_force_updated": "SÃ¼rÃ¼mÃ¼nÃ¼z Ã§ok eski olduÄŸu iÃ§in {{var0}} otomatik olarak gÃ¼ncellendi",
			"toast_plugin_loaded": "{{var0}} yÃ¼klendi",
			"toast_plugin_started": "{{var0}} baÅŸladÄ±",
			"toast_plugin_stopped": "{{var0}} durdu",
			"toast_plugin_translated": "{{var0}} diline Ã§evrildi",
			"toast_plugin_unloaded": "{{var0}} kaldÄ±rÄ±ldÄ±",
			"toast_plugin_update_failed": "{{var0}} iÃ§in gÃ¼ncelleme indirilemiyor",
			"toast_plugin_updated": "{{var0}} {{var1}}, {{var2}} {{var3}} ile deÄŸiÅŸtirildi",
			"update_check_complete": "Eklenti gÃ¼ncelleme kontrolÃ¼ tamamlandÄ±",
			"update_check_complete_outdated": "Eklenti gÃ¼ncelleme kontrolÃ¼ tamamlandÄ± - {{var0}} gÃ¼ncel deÄŸil!",
			"update_check_info": "GÃ¼ncelleme KontrolÃ¼nÃ¼ destekleyen Eklentileri kontrol edin",
			"update_notice_click": "GÃ¼ncellemek iÃ§in tÄ±klayÄ±n!",
			"update_notice_reload": "GÃ¼ncellemeyi tamamlamak iÃ§in yeniden yÃ¼kleyin",
			"update_notice_update": "AÅŸaÄŸÄ±daki Eklentileri gÃ¼ncellenmesi gerekiyor: ",
			"updated": "GÃ¼ncellenmiÅŸ"
		},
		"uk": {
			"add_to": "Ð”Ð¾Ð´Ð°Ñ‚Ð¸ Ð´Ð¾ {{var0}}",
			"ascending": "Ð’Ð¸ÑÑ…Ñ–Ð´Ð½Ð¸Ð¹",
			"center": "ÐŸÐ¾ Ñ†ÐµÐ½Ñ‚Ñ€Ñƒ",
			"changelog_added": "ÐÐ¾Ð²Ñ– Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ÑÑ‚Ñ–",
			"changelog_fixed": "Ð’Ð¸Ñ€Ñ–ÑˆÐµÐ½Ð½Ñ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼",
			"changelog_improved": "ÐŸÐ¾ÐºÑ€Ð°Ñ‰ÐµÐ½Ð½Ñ",
			"changelog_progress": "ÐŸÑ€Ð¾Ð³Ñ€ÐµÑ",
			"check_for_updates": "ÐŸÐµÑ€ÐµÐ²Ñ–Ñ€Ð¸Ñ‚Ð¸ Ð½Ð°ÑÐ²Ð½Ñ–ÑÑ‚ÑŒ Ð¾Ð½Ð¾Ð²Ð»ÐµÐ½ÑŒ",
			"confirm": "Ð¢Ð¸ Ð²Ð¿ÐµÐ²Ð½ÐµÐ½Ð¸Ð¹?",
			"delete_fail": "{{var0}} Ð½Ðµ Ð¼Ð¾Ð¶Ð½Ð° Ð²Ð¸Ð´Ð°Ð»Ð¸Ñ‚Ð¸",
			"delete_success": "{{var0}} ÑƒÑÐ¿Ñ–ÑˆÐ½Ð¾ Ð²Ð¸Ð´Ð°Ð»ÐµÐ½Ð¾",
			"descending": "Ð—Ð° ÑÐ¿Ð°Ð´Ð°Ð½Ð½ÑÐ¼",
			"developer": "Ð Ð¾Ð·Ñ€Ð¾Ð±Ð½Ð¸Ðº",
			"donate_message": "ÐŸÑ–Ð´Ñ‚Ñ€Ð¸Ð¼Ð°Ð¹Ñ‚Ðµ Ð¼ÐµÐ½Ðµ, Ñ‰Ð¾Ð± Ð¾Ñ‚Ñ€Ð¸Ð¼Ð°Ñ‚Ð¸ Ð±Ñ–Ð»ÑŒÑˆÐµ Ð¾Ð½Ð¾Ð²Ð»ÐµÐ½ÑŒ!",
			"download": "Ð—Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶Ð¸Ñ‚Ð¸",
			"download_fail": "{{var0}} Ð½Ðµ Ð¼Ð¾Ð¶Ð½Ð° Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶Ð¸Ñ‚Ð¸",
			"download_success": "{{var0}} Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶ÐµÐ½Ð¾ ÑƒÑÐ¿Ñ–ÑˆÐ½Ð¾",
			"file_navigator_text": "ÐŸÐµÑ€ÐµÐ³Ð»ÑÐ½ÑƒÑ‚Ð¸ Ñ„Ð°Ð¹Ð»",
			"first": "Ð¡Ð¿Ð¾Ñ‡Ð°Ñ‚ÐºÑƒ",
			"from": "Ð’Ñ–Ð´",
			"gradient": "Ð“Ñ€Ð°Ð´Ñ–Ñ”Ð½Ñ‚",
			"last": "ÐžÑÑ‚Ð°Ð½Ð½Ñ–Ð¹",
			"left": "Ð›Ñ–Ð²Ð¾Ñ€ÑƒÑ‡",
			"loading": "Ð—Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶ÐµÐ½Ð½Ñ {{var0}}",
			"location": "Ð Ð¾Ð·Ñ‚Ð°ÑˆÑƒÐ²Ð°Ð½Ð½Ñ",
			"order": "ÐŸÐ¾ÑÐ»Ñ–Ð´Ð¾Ð²Ð½Ñ–ÑÑ‚ÑŒ",
			"outdated": "Ð—Ð°ÑÑ‚Ð°Ñ€Ñ–Ð»Ð¸Ð¹",
			"please_wait": "Ð—Ð°Ð´Ð¾Ð²Ð¾Ð»ÐµÐ½Ð½Ñ Ð¿Ð¾Ñ‡ÐµÐºÐ°Ð¹Ñ‚Ðµ",
			"right": "ÐŸÑ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¾",
			"save_fail": "{{var0}} Ð½Ðµ Ð¼Ð¾Ð¶Ð½Ð° Ð·Ð±ÐµÑ€ÐµÐ³Ñ‚Ð¸",
			"save_success": "{{var0}} ÑƒÑÐ¿Ñ–ÑˆÐ½Ð¾ Ð·Ð±ÐµÑ€ÐµÐ¶ÐµÐ½Ð¾",
			"server": "Ð¡ÐµÑ€Ð²ÐµÑ€",
			"settings_showSupportBadges_description": "ÐŸÐ¾ÐºÐ°Ð·ÑƒÑ” Ð½ÐµÐ²ÐµÐ»Ð¸ÐºÑ– Ð·Ð½Ð°Ñ‡ÐºÐ¸ Ð´Ð»Ñ ÐºÐ¾Ñ€Ð¸ÑÑ‚ÑƒÐ²Ð°Ñ‡Ñ–Ð², ÑÐºÑ– Ð¿Ñ–Ð´Ñ‚Ñ€Ð¸Ð¼ÑƒÑŽÑ‚ÑŒ Ð¼Ñ–Ð¹ Patreon",
			"settings_showToasts_description": "ÐŸÐ¾ÐºÐ°Ð·ÑƒÑ” Ñ‚Ð¾ÑÑ‚Ð¸ Ð·Ð°Ð¿ÑƒÑÐºÑƒ Ñ‚Ð° Ð·ÑƒÐ¿Ð¸Ð½ÐºÐ¸ Ð¿Ð»Ð°Ð³Ñ–Ð½Ð°",
			"settings_showToasts_note": "Ð’Ð¸Ð¼ÐºÐ½Ñ–Ñ‚ÑŒ Ð·Ð°Ð³Ð°Ð»ÑŒÐ½Ðµ Ð½Ð°Ð»Ð°ÑˆÑ‚ÑƒÐ²Ð°Ð½Ð½Ñ '{{var0}}' BD, Ð¿ÐµÑ€Ñˆ Ð½Ñ–Ð¶ Ñ—Ñ… Ð²Ð¸Ð¼Ð¸ÐºÐ°Ñ‚Ð¸",
			"settings_toastPosition_description": "ÐŸÐ¾Ð·Ð¸Ñ†Ñ–Ñ Ñ‚Ð¾ÑÑ‚Ñ–Ð² Ð·Ð° Ð·Ð°Ð¼Ð¾Ð²Ñ‡ÑƒÐ²Ð°Ð½Ð½ÑÐ¼",
			"settings_toastPosition_note": "Ð—Ð¼Ñ–Ð½ÑŽÑ” Ð»Ð¸ÑˆÐµ Ð¿Ð¾Ð·Ð¸Ñ†Ñ–ÑŽ Ñ‚Ð¾ÑÑ‚Ñ–Ð², ÑÑ‚Ð²Ð¾Ñ€ÐµÐ½Ð¸Ñ… Ð¼Ð¾Ñ—Ð¼Ð¸ Ð¿Ð»Ð°Ð³Ñ–Ð½Ð¸",
			"settings_useChromium_description": "Ð’Ñ–Ð´ÐºÑ€Ð¸Ð¹Ñ‚Ðµ Ð¿Ð¾ÑÐ¸Ð»Ð°Ð½Ð½Ñ Ð² Discord Ð·Ð°Ð¼Ñ–ÑÑ‚ÑŒ Ð±Ñ€Ð°ÑƒÐ·ÐµÑ€Ð°",
			"sort_by": "Ð¡Ð¾Ñ€Ñ‚ÑƒÐ²Ð°Ñ‚Ð¸ Ð·Ð°",
			"time": "Ð§Ð°Ñ",
			"timezone": "Ð§Ð°ÑÐ¾Ð²Ð¸Ð¹ Ð¿Ð¾ÑÑ",
			"to": "Ð”Ð¾",
			"toast_plugin_force_updated": "{{var0}} Ð±ÑƒÐ»Ð¾ Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡Ð½Ð¾ Ð¾Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾, Ð¾ÑÐºÑ–Ð»ÑŒÐºÐ¸ Ð²Ð°ÑˆÐ° Ð²ÐµÑ€ÑÑ–Ñ Ð±ÑƒÐ»Ð° Ð´ÑƒÐ¶Ðµ Ð·Ð°ÑÑ‚Ð°Ñ€Ñ–Ð»Ð¾ÑŽ",
			"toast_plugin_loaded": "{{var0}} Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶ÐµÐ½Ð¾",
			"toast_plugin_started": "{{var0}} Ñ€Ð¾Ð·Ð¿Ð¾Ñ‡Ð°Ñ‚Ð¾",
			"toast_plugin_stopped": "{{var0}} Ð·ÑƒÐ¿Ð¸Ð½ÐµÐ½Ð¾",
			"toast_plugin_translated": "Ð¿ÐµÑ€ÐµÐºÐ»Ð°Ð´ÐµÐ½Ð¾ Ð½Ð° {{var0}}",
			"toast_plugin_unloaded": "{{var0}} Ð²Ð¸Ð²Ð°Ð½Ñ‚Ð°Ð¶ÐµÐ½Ð¾",
			"toast_plugin_update_failed": "ÐÐµ Ð²Ð´Ð°Ñ”Ñ‚ÑŒÑÑ Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶Ð¸Ñ‚Ð¸ Ð¾Ð½Ð¾Ð²Ð»ÐµÐ½Ð½Ñ Ð´Ð»Ñ {{var0}}",
			"toast_plugin_updated": "{{var0}} {{var1}} Ð·Ð°Ð¼Ñ–Ð½ÐµÐ½Ð¾ Ð½Ð° {{var2}} {{var3}}",
			"update_check_complete": "Ð—Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð¾ Ð¿ÐµÑ€ÐµÐ²Ñ–Ñ€ÐºÑƒ Ð¾Ð½Ð¾Ð²Ð»ÐµÐ½Ð½Ñ Ð¿Ð»Ð°Ð³Ñ–Ð½Ð°",
			"update_check_complete_outdated": "Ð—Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð¾ Ð¿ÐµÑ€ÐµÐ²Ñ–Ñ€ÐºÑƒ Ð¾Ð½Ð¾Ð²Ð»ÐµÐ½Ð½Ñ Ð¿Ð»Ð°Ð³Ñ–Ð½Ð° - {{var0}} Ð·Ð°ÑÑ‚Ð°Ñ€Ñ–Ð»Ð¾!",
			"update_check_info": "ÐŸÐµÑ€ÐµÐ²Ñ–Ñ€Ñ‚Ðµ Ð¿Ð»Ð°Ð³Ñ–Ð½Ð¸, ÑÐºÑ– Ð¿Ñ–Ð´Ñ‚Ñ€Ð¸Ð¼ÑƒÑŽÑ‚ÑŒ Ð¿ÐµÑ€ÐµÐ²Ñ–Ñ€ÐºÑƒ Ð¾Ð½Ð¾Ð²Ð»ÐµÐ½Ð½Ñ",
			"update_notice_click": "ÐÐ°Ñ‚Ð¸ÑÐ½Ñ–Ñ‚ÑŒ, Ñ‰Ð¾Ð± Ð¾Ð½Ð¾Ð²Ð¸Ñ‚Ð¸!",
			"update_notice_reload": "ÐŸÐµÑ€ÐµÐ·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶Ñ‚Ðµ, Ñ‰Ð¾Ð± Ð·Ð°Ð²ÐµÑ€ÑˆÐ¸Ñ‚Ð¸ Ð¾Ð½Ð¾Ð²Ð»ÐµÐ½Ð½Ñ",
			"update_notice_update": "ÐŸÐ¾Ñ‚Ñ€Ñ–Ð±Ð½Ð¾ Ð¾Ð½Ð¾Ð²Ð¸Ñ‚Ð¸ Ñ‚Ð°ÐºÑ– Ð¿Ð»Ð°Ð³Ñ–Ð½Ð¸: ",
			"updated": "ÐžÐ½Ð¾Ð²Ð»ÐµÐ½Ð¾"
		},
		"vi": {
			"add_to": "ThÃªm vÃ o {{var0}}",
			"ascending": "TÄƒng dáº§n",
			"center": "CÄƒn giá»¯a",
			"changelog_added": "CÃ¡c tÃ­nh nÄƒng má»›i",
			"changelog_fixed": "Xá»­ lÃ½ sá»± cá»‘",
			"changelog_improved": "Cáº£i tiáº¿n",
			"changelog_progress": "PhÃ¡t triá»ƒn",
			"check_for_updates": "Kiá»ƒm tra cáº­p nháº­t",
			"confirm": "Báº¡n cÃ³ cháº¯c khÃ´ng?",
			"delete_fail": "{{var0}} khÃ´ng thá»ƒ bá»‹ xÃ³a",
			"delete_success": "ÄÃ£ xÃ³a {{var0}} thÃ nh cÃ´ng",
			"descending": "Giáº£m dáº§n",
			"developer": "NgÆ°á»i phÃ¡t triá»ƒn",
			"donate_message": "Há»— trá»£ tÃ´i Ä‘á»ƒ cáº­p nháº­t thÃªm!",
			"download": "Táº£i xuá»‘ng",
			"download_fail": "KhÃ´ng thá»ƒ táº£i xuá»‘ng {{var0}}",
			"download_success": "ÄÃ£ táº£i xuá»‘ng {{var0}} thÃ nh cÃ´ng",
			"file_navigator_text": "Chá»n thÆ° má»¥c",
			"first": "Äáº§u tiÃªn",
			"from": "Tá»«",
			"gradient": "Dá»‘c",
			"last": "Cuá»‘i cÃ¹ng",
			"left": "TrÃ¡i",
			"loading": "Äang táº£i {{var0}}",
			"location": "Vá»‹ trÃ­",
			"order": "Sá»± ná»‘i tiáº¿p",
			"outdated": "Lá»—i thá»i",
			"please_wait": "HÃ¢n háº¡nh chá» Ä‘á»£i",
			"right": "ÄÃºng",
			"save_fail": "{{var0}} khÃ´ng thá»ƒ lÆ°u Ä‘Æ°á»£c",
			"save_success": "{{var0}} Ä‘Ã£ Ä‘Æ°á»£c lÆ°u thÃ nh cÃ´ng",
			"server": "NgÆ°á»i phá»¥c vá»¥",
			"settings_showSupportBadges_description": "Hiá»ƒn thá»‹ cÃ¡c huy hiá»‡u nhá» cho nhá»¯ng ngÆ°á»i dÃ¹ng á»§ng há»™ Patreon cá»§a tÃ´i",
			"settings_showToasts_description": "Hiá»ƒn thá»‹ plugin báº¯t Ä‘áº§u vÃ  dá»«ng nÃ¢ng cá»‘c",
			"settings_showToasts_note": "Táº¯t cÃ i Ä‘áº·t chung '{{var0}}' cá»§a BD trÆ°á»›c khi táº¯t chÃºng",
			"settings_toastPosition_description": "Vá»‹ trÃ­ bÃ¡nh mÃ¬ nÆ°á»›ng máº·c Ä‘á»‹nh",
			"settings_toastPosition_note": "Chá»‰ thay Ä‘á»•i Vá»‹ trÃ­ cá»§a BÃ¡nh nÆ°á»›ng Ä‘Æ°á»£c táº¡o bá»Ÿi plugins cá»§a tÃ´i",
			"settings_useChromium_description": "Má»Ÿ LiÃªn káº¿t trong Discord thay vÃ¬ TrÃ¬nh duyá»‡t cá»§a báº¡n",
			"sort_by": "Sáº¯p xáº¿p theo",
			"time": "Thá»i gian",
			"timezone": "MÃºi giá»",
			"to": "Äáº¿n",
			"toast_plugin_force_updated": "{{var0}} Ä‘Ã£ Ä‘Æ°á»£c cáº­p nháº­t tá»± Ä‘á»™ng vÃ¬ phiÃªn báº£n cá»§a báº¡n Ä‘Ã£ ráº¥t lá»—i thá»i",
			"toast_plugin_loaded": "{{var0}} Ä‘Ã£ Ä‘Æ°á»£c táº£i",
			"toast_plugin_started": "{{var0}} Ä‘Ã£ báº¯t Ä‘áº§u",
			"toast_plugin_stopped": "{{var0}} Ä‘Ã£ dá»«ng",
			"toast_plugin_translated": "Ä‘Ã£ dá»‹ch sang {{var0}}",
			"toast_plugin_unloaded": "{{var0}} Ä‘Ã£ Ä‘Æ°á»£c táº£i xuá»‘ng",
			"toast_plugin_update_failed": "KhÃ´ng thá»ƒ táº£i xuá»‘ng báº£n cáº­p nháº­t cho {{var0}}",
			"toast_plugin_updated": "{{var0}} {{var1}} Ä‘Ã£ Ä‘Æ°á»£c thay tháº¿ báº±ng {{var2}} {{var3}}",
			"update_check_complete": "ÄÃ£ hoÃ n táº¥t kiá»ƒm tra cáº­p nháº­t plugin",
			"update_check_complete_outdated": "ÄÃ£ hoÃ n táº¥t kiá»ƒm tra cáº­p nháº­t plugin - {{var0}} Ä‘Ã£ lá»—i thá»i!",
			"update_check_info": "Kiá»ƒm tra cÃ¡c plugins há»— trá»£ Kiá»ƒm tra cáº­p nháº­t",
			"update_notice_click": "Báº¥m Ä‘á»ƒ cáº­p nháº­t!",
			"update_notice_reload": "Táº£i láº¡i Ä‘á»ƒ hoÃ n táº¥t cáº­p nháº­t",
			"update_notice_update": "CÃ¡c plugins sau cáº§n Ä‘Æ°á»£c cáº­p nháº­t: ",
			"updated": "ÄÃ£ cáº­p nháº­t"
		},
		"zh-CN": {
			"add_to": "æ·»åŠ åˆ° {{var0}}",
			"ascending": "ä¸Šå‡",
			"center": "å±…ä¸­",
			"changelog_added": "æ–°çš„åŠŸèƒ½",
			"changelog_fixed": "æ•…éšœæŽ’é™¤",
			"changelog_improved": "æ”¹è¿›ä¹‹å¤„",
			"changelog_progress": "è¿›å±•",
			"check_for_updates": "æ£€æŸ¥æ›´æ–°",
			"confirm": "ä½ ç¡®å®šå—ï¼Ÿ",
			"delete_fail": "{{var0}} æ— æ³•åˆ é™¤",
			"delete_success": "{{var0}} æˆåŠŸåˆ é™¤",
			"descending": "é™åº",
			"developer": "å¼€å‘å•†",
			"donate_message": "æ”¯æŒæˆ‘æ›´å¤šæ›´æ–°ï¼",
			"download": "ä¸‹è½½",
			"download_fail": "{{var0}} æ— æ³•ä¸‹è½½",
			"download_success": "{{var0}} å·²æˆåŠŸä¸‹è½½",
			"file_navigator_text": "æµè§ˆæ–‡ä»¶",
			"first": "ç¬¬ä¸€",
			"from": "ä»Ž",
			"gradient": "æ¢¯åº¦",
			"last": "æŒç»­",
			"left": "å‰©ä¸‹",
			"loading": "æ­£åœ¨åŠ è½½ {{var0}}",
			"location": "åœ°ç‚¹",
			"order": "é¡ºåº",
			"outdated": "è¿‡æ—¶çš„",
			"please_wait": "è¯·ç¨ç­‰",
			"right": "å¯¹",
			"save_fail": "{{var0}} æ— æ³•ä¿å­˜",
			"save_success": "{{var0}} ä¿å­˜æˆåŠŸ",
			"server": "æœåŠ¡å™¨",
			"settings_showSupportBadges_description": "ä¸ºæ”¯æŒæˆ‘çš„ Patreon çš„ç”¨æˆ·æ˜¾ç¤ºå°å¾½ç« ",
			"settings_showToasts_description": "æ˜¾ç¤ºæ’ä»¶å¼€å§‹å’Œåœæ­¢çƒ¤é¢åŒ…",
			"settings_showToasts_note": "ç¦ç”¨ BD çš„å¸¸è§„è®¾ç½® '{{var0}}' ä¹‹å‰å°†å…¶ç¦ç”¨",
			"settings_toastPosition_description": "é»˜è®¤åå¸ä½ç½®",
			"settings_toastPosition_note": "ä»…æ›´æ”¹ç”±æˆ‘çš„æ’ä»¶åˆ›å»ºçš„åå¸ä½ç½®",
			"settings_useChromium_description": "åœ¨ Discord ï¼ˆè€Œä¸æ˜¯æµè§ˆå™¨ï¼‰ä¸­æ‰“å¼€é“¾æŽ¥",
			"sort_by": "æŽ’åºæ–¹å¼",
			"time": "æ—¶é—´",
			"timezone": "æ—¶åŒº",
			"to": "è‡³",
			"toast_plugin_force_updated": "{{var0}} å·²è‡ªåŠ¨æ›´æ–°ï¼Œå› ä¸ºæ‚¨çš„ç‰ˆæœ¬å·²è¿‡æ—¶",
			"toast_plugin_loaded": "{{var0}} å·²åŠ è½½",
			"toast_plugin_started": "{{var0}} å·²å¼€å§‹",
			"toast_plugin_stopped": "{{var0}} å·²åœæ­¢",
			"toast_plugin_translated": "è½¬æ¢ä¸º {{var0}}",
			"toast_plugin_unloaded": "{{var0}} å·²å¸è½½",
			"toast_plugin_update_failed": "æ— æ³•ä¸‹è½½ {{var0}} çš„æ›´æ–°",
			"toast_plugin_updated": "{{var0}} {{var1}} å·²æ›¿æ¢ä¸º {{var2}} {{var3}}",
			"update_check_complete": "æ’ä»¶æ›´æ–°æ£€æŸ¥å®Œæˆ",
			"update_check_complete_outdated": "æ’ä»¶æ›´æ–°æ£€æŸ¥å®Œæˆ - {{var0}} å·²è¿‡æœŸï¼",
			"update_check_info": "æ£€æŸ¥æ”¯æŒæ›´æ–°æ£€æŸ¥çš„æ’ä»¶",
			"update_notice_click": "ç‚¹å‡»æ›´æ–°ï¼",
			"update_notice_reload": "é‡æ–°åŠ è½½ä»¥å®Œæˆæ›´æ–°",
			"update_notice_update": "ä»¥ä¸‹æ’ä»¶éœ€è¦æ›´æ–°ï¼š ",
			"updated": "æ›´æ–°"
		},
		"zh-TW": {
			"add_to": "æ·»åŠ åˆ° {{var0}}",
			"ascending": "ä¸Šå‡",
			"center": "å±…ä¸­",
			"changelog_added": "æ–°çš„åŠŸèƒ½",
			"changelog_fixed": "æ•…éšœæŽ’é™¤",
			"changelog_improved": "æ”¹é€²ä¹‹è™•",
			"changelog_progress": "é€²å±•",
			"check_for_updates": "æª¢æŸ¥æ›´æ–°",
			"confirm": "ä½ ç¢ºå®šå—Žï¼Ÿ",
			"delete_fail": "{{var0}} ç„¡æ³•åˆªé™¤",
			"delete_success": "{{var0}} æˆåŠŸåˆªé™¤",
			"descending": "é™åº",
			"developer": "é–‹ç™¼å•†",
			"donate_message": "æ”¯æŒæˆ‘æ›´å¤šæ›´æ–°ï¼",
			"download": "ä¸‹è¼‰",
			"download_fail": "{{var0}} ç„¡æ³•ä¸‹è¼‰",
			"download_success": "{{var0}} å·²æˆåŠŸä¸‹è¼‰",
			"file_navigator_text": "ç€è¦½æ–‡ä»¶",
			"first": "ç¬¬ä¸€",
			"from": "å¾ž",
			"gradient": "æ¢¯åº¦",
			"last": "æŒçºŒ",
			"left": "å‰©ä¸‹",
			"loading": "æ­£åœ¨åŠ è¼‰ {{var0}}",
			"location": "åœ°é»ž",
			"order": "é †åº",
			"outdated": "éŽæ™‚çš„",
			"please_wait": "è«‹ç¨ç­‰",
			"right": "å°",
			"save_fail": "{{var0}} ç„¡æ³•ä¿å­˜",
			"save_success": "{{var0}} ä¿å­˜æˆåŠŸ",
			"server": "æœå‹™å™¨",
			"settings_showSupportBadges_description": "ç‚ºæ”¯æŒæˆ‘çš„ Patreon çš„ç”¨æˆ¶é¡¯ç¤ºå°å¾½ç« ",
			"settings_showToasts_description": "é¡¯ç¤ºæ’ä»¶é–‹å§‹å’Œåœæ­¢çƒ¤éºµåŒ…",
			"settings_showToasts_note": "ç¦ç”¨ BD çš„å¸¸è¦è¨­ç½® '{{var0}}' ä¹‹å‰å°‡å…¶ç¦ç”¨",
			"settings_toastPosition_description": "é»˜èªåå¸ä½ç½®",
			"settings_toastPosition_note": "åƒ…æ›´æ”¹ç”±æˆ‘çš„æ’ä»¶å‰µå»ºçš„åå¸ä½ç½®",
			"settings_useChromium_description": "åœ¨ Discord ï¼ˆè€Œä¸æ˜¯ç€è¦½å™¨ï¼‰ä¸­æ‰“é–‹éˆæŽ¥",
			"sort_by": "æŽ’åºæ–¹å¼",
			"time": "æ™‚é–“",
			"timezone": "æ™‚å€",
			"to": "è‡³",
			"toast_plugin_force_updated": "{{var0}} å·²è‡ªå‹•æ›´æ–°ï¼Œå› ç‚ºæ‚¨çš„ç‰ˆæœ¬å·²éŽæ™‚",
			"toast_plugin_loaded": "{{var0}} å·²åŠ è¼‰",
			"toast_plugin_started": "{{var0}} å·²é–‹å§‹",
			"toast_plugin_stopped": "{{var0}} å·²åœæ­¢",
			"toast_plugin_translated": "è½‰æ›ç‚º {{var0}}",
			"toast_plugin_unloaded": "{{var0}} å·²è¢«å¸è¼‰",
			"toast_plugin_update_failed": "ç„¡æ³•ä¸‹è¼‰ {{var0}} çš„æ›´æ–°",
			"toast_plugin_updated": "{{var0}} {{var1}} å·²æ›¿æ›ç‚º {{var2}} {{var3}}",
			"update_check_complete": "æ’ä»¶æ›´æ–°æª¢æŸ¥å®Œæˆ",
			"update_check_complete_outdated": "æ’ä»¶æ›´æ–°æª¢æŸ¥å®Œæˆ - {{var0}} å·²éŽæœŸï¼",
			"update_check_info": "æª¢æŸ¥æ”¯æŒæ›´æ–°æª¢æŸ¥çš„æ’ä»¶",
			"update_notice_click": "é»žæ“Šæ›´æ–°ï¼",
			"update_notice_reload": "é‡æ–°åŠ è¼‰ä»¥å®Œæˆæ›´æ–°",
			"update_notice_update": "ä»¥ä¸‹æ’ä»¶éœ€è¦æ›´æ–°ï¼š ",
			"updated": "æ›´æ–°"
		},
		"default": {
			"add_to": "Add to {{var0}}",
			"ascending": "Ascending",
			"center": "Centered",
			"changelog_added": "New Features",
			"changelog_fixed": "Bug Fixes",
			"changelog_improved": "Improvements",
			"changelog_progress": "Progress",
			"check_for_updates": "Check for Updates",
			"confirm": "Are you sure?",
			"delete_fail": "{{var0}} cannot be deleted",
			"delete_success": "{{var0}} deleted successfully",
			"descending": "Descending",
			"developer": "Developer",
			"donate_message": "Support me to receive further Updates!",
			"download": "Download",
			"download_fail": "{{var0}} cannot be downloaded",
			"download_success": "{{var0}} downloaded successfully",
			"file_navigator_text": "Browse File",
			"first": "First",
			"from": "From",
			"gradient": "Gradient",
			"last": "Last",
			"left": "Left",
			"loading": "Loading {{var0}}",
			"location": "Location",
			"order": "Order",
			"outdated": "Outdated",
			"please_wait": "Please wait",
			"right": "Right",
			"save_fail": "{{var0}} cannot be saved",
			"save_success": "{{var0}} saved successfully",
			"server": "Server",
			"settings_showSupportBadges_description": "Shows small Badges for Users who support my Patreon",
			"settings_showToasts_description": "Shows Plugin start and stop Toasts",
			"settings_showToasts_note": "Disable BDs general '{{var0}}' setting before disabling this",
			"settings_toastPosition_description": "Default Toast Position",
			"settings_toastPosition_note": "Only changes Position of Toasts created by my Plugins",
			"settings_useChromium_description": "Open Links in Discord instead of your Browser",
			"sort_by": "Sort by",
			"time": "Time",
			"timezone": "Timezone",
			"to": "To",
			"toast_plugin_force_updated": "{{var0}} was automatically updated because your Version is heavily outdated",
			"toast_plugin_loaded": "{{var0}} has been loaded",
			"toast_plugin_started": "{{var0}} has been started",
			"toast_plugin_stopped": "{{var0}} has been stopped",
			"toast_plugin_translated": "translated to {{var0}}",
			"toast_plugin_unloaded": "{{var0}} has been unloaded",
			"toast_plugin_update_failed": "Update for {{var0}} cannot be downloaded",
			"toast_plugin_updated": "{{var0}} {{var1}} has been replaced by {{var2}} {{var3}}",
			"update_check_complete": "Plugin Update Check completed",
			"update_check_complete_outdated": "Plugin Update Check completed - {{var0}} outdated!",
			"update_check_info": "Check Plugins that support the Update Check",
			"update_notice_click": "Click to update!",
			"update_notice_reload": "Reload to complete the Update",
			"update_notice_update": "The following Plugins need to be updated: ",
			"updated": "Updated"
		}
	},
	"BDFDB_Patrons": {
		"446396928092274720": 	{"active": true,		"tier": "t3",		"text": "Existing...",		"id": "Sayori (SaySa)"},
		"760784464560914452": 	{"active": true,		"tier": "t3",		"text": "Keyra",			"id": "Keyra (PaCu)"},
		"266072167349747712": 	{"active": true,		"tier": "t3",		"text": "King",				"id": "Duckx (dogu)"},
		"646354877336911884": 	{"active": true,		"tier": "t3",		"text": "",					"id": "case (kharri)"},
		"431078101997584395": 	{"active": true,		"tier": "t2",		"text": "",					"id": "LEMI (f4g8)"},
		"268824390337036298": 	{"active": true,		"tier": "t2",		"text": "",					"id": "lonelyw0lf (GriWa)"},
		"354191516979429376": 	{"active": true,		"tier": "t2",		"text": "",					"id": "HypedDomi (DoBu)"},
		"596006086511689748": 	{"active": true,		"tier": "t2",		"text": "",					"id": "Marshtomp (DsOp)"},
		"341383936984875020": 	{"active": true,		"tier": "t3",		"text": "",					"id": "dannycoch (DaCo)"},
		"121188168002174976": 	{"active": true,		"tier": "t2",		"text": "",					"id": "Aven (Syn)"},
		"264486632525135883": 	{"active": true,		"tier": "t3",		"text": "",					"id": "strix (A1C)"},
		"363785301195358221": 	{"active": true,		"tier": "t2",		"text": "",					"id": "TRENT (KABEL)"},
		"174868361040232448": 	{"active": false,		"tier": "t2",		"text": "",					"id": "GIBBU (Ian) Note: Asked to disable"},
		"443943393660239872": 	{"active": true,		"tier": "t3",		"text": "",					"id": "SARGE (PaSh)"},
		"620397524494057513": 	{"active": true,		"tier": "t3",		"text": "",					"id": "FUSL"},
		"838434341197316126": 	{"active": true,		"tier": "t4",		"text": "AllmÃ¤chtig",		"id": "ZeroAccess"}
	},
	"BDFDB_Patron_Tiers": {
		"t1": {
			"text": ""
		},
		"t2": {
			"text": "BDFDB Patron"
		},
		"t3": {
			"text": "BDFDB Patron+"
		},
		"t4": {
			"text": "BDFDB Special Supporter"
		}
	}
}
{
    "currentVersionInfo": {
        "version": "1.2.29",
        "hasShownChangelog": true
    }
}
{
	"changeLogs": {
		"BDFDB": "1.6.6",
		"BetterFriendList": "1.3.3",
		"FriendNotifications": "1.7.2",
		"JoinedAtDate": "1.2.8",
		"PinDMs": "1.8.2",
		"ReadAllNotificationsButton": "1.6.7",
		"RemoveBlockedMessages": "1.2.6",
		"SendLargeMessages": "1.6.6",
		"ServerDetails": "1.0.5",
		"ShowHiddenChannels": "2.9.6",
		"SpotifyControls": "1.1.4",
		"TopRoleEverywhere": "3.0.5"
	},
	"choices": {
		"toastPosition": "right"
	},
	"general": {
		"showToasts": true,
		"showSupportBadges": true,
		"useChromium": false
	}
}
{
    "currentVersionInfo": {
        "version": "1.2.3",
        "hasShownChangelog": true
    }
}
/**
* @name VoiceUsersCounter
* @displayName VoiceUsersCounter
* @authorId 415849376598982656
* @invite gvA2ree
*/
/*@cc_on
@if (@_jscript)
    
    // Offer to self-install for clueless users that try to run this directly.
    var shell = WScript.CreateObject("WScript.Shell");
    var fs = new ActiveXObject("Scripting.FileSystemObject");
    var pathPlugins = shell.ExpandEnvironmentStrings("%APPDATA%\BetterDiscord\plugins");
    var pathSelf = WScript.ScriptFullName;
    // Put the user at ease by addressing them in the first person
    shell.Popup("It looks like you've mistakenly tried to run me directly. \n(Don't do that!)", 0, "I'm a plugin for BetterDiscord", 0x30);
    if (fs.GetParentFolderName(pathSelf) === fs.GetAbsolutePathName(pathPlugins)) {
        shell.Popup("I'm in the correct folder already.", 0, "I'm already installed", 0x40);
    } else if (!fs.FolderExists(pathPlugins)) {
        shell.Popup("I can't find the BetterDiscord plugins folder.\nAre you sure it's even installed?", 0, "Can't install myself", 0x10);
    } else if (shell.Popup("Should I copy myself to BetterDiscord's plugins folder for you?", 0, "Do you need some help?", 0x34) === 6) {
        fs.CopyFile(pathSelf, fs.BuildPath(pathPlugins, fs.GetFileName(pathSelf)), true);
        // Show the user where to put plugins in the future
        shell.Exec("explorer " + pathPlugins);
        shell.Popup("I'm installed!", 0, "Successfully installed", 0x40);
    }
    WScript.Quit();

@else@*/

module.exports = (() => {
    const config = {
        info: {
            name: "VoiceUsersCounter",
            authors: [
                {
                    name: "Strencher",
                    discord_id: "415849376598982656",
                    github_username: "Strencher",
                    twitter_username: "Strencher3"
                }
            ],
            version: "2.0.0",
            description: "Adds a count of users they're connected to a VoiceChannel. Customize the Color of the count in the SettingsPanel.",
            github: "https://github.com/Strencher/BetterDiscordStuff/blob/master/VoiceUsersCounter/VoiceUsersCounter.plugin.js",
            github_raw: "https://raw.githubusercontent.com/Strencher/BetterDiscordStuff/master/VoiceUsersCounter/VoiceUsersCounter.plugin.js"
        },
        changelog: [
            {
                title: "FIXED",
                type: "fixed",
                items: [
                    "Fixed the last discord update. take 3."
                ]
            },
            {
                title: "23.2.2021 - FIXED",
                type: "fixed",
                items: [
                    "Discord updated, things broke, i fixed."
                ]
            }
        ],
        defaultConfig: [
            {
                type: "color",
                id: "color",
                value: "#7289DA",
                name: "NumberColor",
                note: "Customize the color of the number when you are in the VoiceChannel"
            }
        ]
    };

    return !global.ZeresPluginLibrary ? class {
        constructor() { this._config = config; }
        getName() { return config.info.name; }
        getAuthor() { return config.info.authors.map(a => a.name).join(", "); }
        getDescription() { return config.info.description; }
        getVersion() { return config.info.version; }
        load() {
            BdApi.showConfirmationModal("Library plugin is needed",
                [`The library plugin needed for ${config.info.name} is missing. Please click Download Now to install it.`], {
                confirmText: "Download",
                cancelText: "Cancel",
                onConfirm: () => {
                    require("request").get("https://rauenzi.github.io/BDPluginLibrary/release/0PluginLibrary.plugin.js", async (error, response, body) => {
                        if (error) return require("electron").shell.openExternal("https://betterdiscord.net/ghdl?url=https://raw.githubusercontent.com/rauenzi/BDPluginLibrary/master/release/0PluginLibrary.plugin.js");
                        await new Promise(r => require("fs").writeFile(require("path").join(BdApi.Plugins.folder, "0PluginLibrary.plugin.js"), body, r));
                    });
                }
            });
        }
        start() { }
        stop() { }
    } : (([Plugin, Api]) => {
        const plugin = (Plugin, Api) => {

            const {DiscordModules: {React, DiscordConstants}, Utilities, WebpackModules, PluginUtilities, DiscordModules, Patcher, DiscordSelectors, ReactTools} = Api;
            const Tooltip = WebpackModules.getByDisplayName("Tooltip");
            const {getVoiceChannelId} = WebpackModules.getByProps('getVoiceChannelId');
            const VoiceChannelStore = WebpackModules.getByProps("getVoiceStates");
            const classes = Object(WebpackModules.getByProps("iconItem"))
            class VoiceCount extends React.Component {
                render() {
                    return React.createElement(Tooltip, {
                        text: "Connected Users: " + this.props.count,
                        position: "top",
                        color: "black"
                    }, e => React.createElement("span", {
                        ...e,
                        ...this.props,
                        className: ["voiceCounter", classes.iconBase].filter(e => e).join(" "),
                    }, this.props.count))
                }
            }
            return class VoiceUsersCounter extends Plugin {
                constructor() {
                    super();
                }

                getSettingsPanel() {
                    const panel = this.buildSettingsPanel();
                    panel.addListener(() => {
                        this.forceUpdateAll();
                    });
                    return panel.getElement();
                }

                forceUpdateAll() {
                    document.querySelectorAll(DiscordSelectors.ChannelList.containerDefault).forEach(e => {
                        ReactTools.getOwnerInstance(e).forceUpdate();
                    });
                }

                css = `
                .voiceCounter {
                    color: var(--channels-default);
                    font-weight: bold; 
                    margin-left: 5px;
                    z-index: 999;
                }`

                onStart() {
                    PluginUtilities.addStyle(config.info.name, this.css);
                    Utilities.suppressErrors(this.patchChannelItem.bind(this), "ChannelItem Patch")();
                    this.forceUpdateAll();
                }

                patchChannelItem() {
                    const ChannelItem = WebpackModules.getModule(m => Object(m.default).displayName === "ChannelItem");
                    Patcher.after(ChannelItem, "default", (_, [props], ret) => {
                        if (!("channel" in props)) return ret;
                        if (props.channel.type !== DiscordConstants.ChannelTypes.GUILD_VOICE) return ret;
                        const children = Utilities.getNestedProp(props, "children");
                        if (!Array.isArray(children)) return ret;
                        if (children.find(e => e && e.type === VoiceCount)) return ret;
                        const count = Object.keys(VoiceChannelStore.getVoiceStatesForChannel(props.channel.id)).length;
                        if(props.channel.userLimit > 0) return ret; // Don't show on channels with limits.
                        if(count == 0) return ret;
                        children.push(
                            React.createElement(VoiceCount, {
                                count: count,
                                style: props.channel.id === getVoiceChannelId() ? {
                                    color: this.settings.color || "var(--blurple)",
                                } : {},
                                ...props,
                            })
                        );
                        return ret;
                    });
                }

                onStop() {
                    PluginUtilities.removeStyle(config.info.name);
                    Patcher.unpatchAll();
                }

            }

        };
        return plugin(Plugin, Api);
    })(global.ZeresPluginLibrary.buildPlugin(config));
})();
/*@end@*/
{
    "currentVersionInfo": {
        "version": "2.0.0",
        "hasShownChangelog": true
    }
}
{
	"blacklist": []
}
/**
 * @name TypingIndicator
 * @displayName TypingIndicator
 * @website https://twitter.com/l0c4lh057/
 * @source https://github.com/l0c4lh057/BetterDiscordStuff/blob/master/Plugins/TypingIndicator/TypingIndicator.plugin.js
 * @patreon https://www.patreon.com/l0c4lh057
 * @invite YzzeuJPpyj
 * @authorId 226677096091484160
 */

var TypingIndicator = (() => {
	const config = {
		info:{
			name: "TypingIndicator",
			authors: [{name: "l0c4lh057", github_username: "l0c4lh057", twitter_username: "l0c4lh057", discord_id: "226677096091484160"}],
			description: "Shows an indicator in the guild/channel list when someone is typing there",
			version: "0.5.1",
			github: "https://github.com/l0c4lh057/BetterDiscordStuff/blob/master/Plugins/TypingIndicator/",
			github_raw: "https://raw.githubusercontent.com/l0c4lh057/BetterDiscordStuff/master/Plugins/TypingIndicator/TypingIndicator.plugin.js"
		},
		defaultConfig: [
			{
				type: "switch",
				id: "channels",
				name: "Show on channels",
				note: "With this option enabled all channels have the typing indicator when someone is typing in them (default: true)",
				value: true
			},
			{
				type: "switch",
				id: "includeMuted",
				name: "Include muted channels/guilds",
				note: "With this option enabled even muted channels have the typing indicator (default: false)",
				value: false
			},
			{
				type: "switch",
				id: "includeBlocked",
				name: "Include blocked users",
				note: "With this option enabled the indicator will also show for users you have blocked",
				value: false
			},
			{
				type: "switch",
				id: "guilds",
				name: "Show on guilds",
				note: "With this option enabled the indicator is shown on guild icons when someone is typing in any of the channels of it (default: false)",
				value: false
			},
			{
				type: "switch",
				id: "folders",
				name: "Show on folders",
				note: "With this option enabled the indicator is shown on discord native guild folders when someone is typing in any of the guilds (default: false)",
				value: false
			},
			{
				type: "switch",
				id: "dms",
				name: "Show on home icon",
				note: "With this option enabled the indicator is shown on the home icon above the guild list (default: false)",
				value: false
			}
		],
		changelog:[
			{
				"title": "Fixed",
				"type": "fixed",
				"items": ["Should not cause crashes on PTB and Canary anymore", "Should work again on folders"]
			}
		]
	};
	
	return !global.ZeresPluginLibrary ? class {
		constructor(){this._config = config;}
		getName(){return config.info.name;}
		getAuthor(){return config.info.authors.map(a => a.name).join(", ");}
		getDescription(){return config.info.description;}
		getVersion(){return config.info.version;}
		load(){
			BdApi.showConfirmationModal("Library Missing", `The library plugin needed for ${config.info.name} is missing. Please click Download Now to install it.`, {
				confirmText: "Download Now",
				cancelText: "Cancel",
				onConfirm: () => {
					require("request").get("https://rauenzi.github.io/BDPluginLibrary/release/0PluginLibrary.plugin.js", async (error, response, body) => {
						if (error) return require("electron").shell.openExternal("https://betterdiscord.net/ghdl?url=https://raw.githubusercontent.com/rauenzi/BDPluginLibrary/master/release/0PluginLibrary.plugin.js");
						await new Promise(r => require("fs").writeFile(require("path").join(BdApi.Plugins.folder, "0PluginLibrary.plugin.js"), body, r));
					});
				}
		});
		}
		start(){}
		stop(){}
	} : (([Plugin, Api]) => {
		const plugin = (Plugin, Api) => {
			const { WebpackModules, DiscordModules, Patcher, ReactComponents, PluginUtilities, Utilities } = Api;
			const { React, ChannelStore, UserStore, UserTypingStore, RelationshipStore, SelectedGuildStore, DiscordConstants, WindowInfo } = DiscordModules;
			const Flux = WebpackModules.getByProps("connectStores");
			const MutedStore = WebpackModules.getByProps("isMuted", "isChannelMuted");
			const Spinner = WebpackModules.getByDisplayName("Spinner");
			const Tooltip = WebpackModules.getByDisplayName("Tooltip");
			
			if(!BdApi.Plugins.get("BugReportHelper") && !BdApi.getData(config.info.name, "didShowIssueHelperPopup")){
				BdApi.saveData(config.info.name, "didShowIssueHelperPopup", true);
				BdApi.showConfirmationModal("Do you want to download a helper plugin?", `Do you want to download a helper plugin that makes it easier for you to report issues? That plugin is not needed to anything else to function correctly but nice to have when reporting iissues, shortening the time until the problem gets resolved by asking you for specific information and also including additional information you did not provide.`, {
					confirmText: "Download",
					cancelText: "Cancel",
					onConfirm: () => {
						require("request").get("https://raw.githubusercontent.com/l0c4lh057/BetterDiscordStuff/master/Plugins/BugReportHelper/BugReportHelper.plugin.js", (error, response, body) => {
							if (error) return require("electron").shell.openExternal("https://betterdiscord.net/ghdl?url=https://raw.githubusercontent.com/l0c4lh057/BetterDiscordStuff/master/Plugins/BugReportHelper/BugReportHelper.plugin.js");
							else require("fs").writeFile(require("path").join(BdApi.Plugins.folder, "BugReportHelper.plugin.js"), body, ()=>{
								window.setTimeout(()=>BdApi.Plugins.enable("BugReportHelper"), 1000);
							});
						});
					}
				});
			}
			
			const renderElement = ({userIds, opacity, type, isFocused})=>{
				userIds = [...new Set(userIds)];
				if(userIds.length === 0) return null;
				const usernames = userIds.map(userId => UserStore.getUser(userId)).filter(user => user).map(user => user.tag);
				const remainingUserCount = userIds.length - usernames.length;
				const text = (()=>{
					if(usernames.length === 0){
						return `${remainingUserCount} user${remainingUserCount > 1 ? "s" : ""}`;
					}else if(userIds.length > 2){
						const otherCount = usernames.length - 1 + remainingUserCount;
						return `${usernames[0]} and ${otherCount} other${otherCount > 1 ? "s" : ""}`;
					}else if(remainingUserCount === 0){
						return usernames.join(", ");
					}else{
						return `${usernames.join(", ")} and ${remainingUserCount} other${remainingUserCount > 1 ? "s" : ""}`;
					}
				})();
				return React.createElement(
					Tooltip,
					{
						text,
						position: type === "channel" ? "top" : "right"
					},
					tooltipProps => React.createElement(Spinner, {
						...tooltipProps,
						type: "pulsingEllipsis",
						className: `ti-indicator typingindicator-${type}`,
						animated: isFocused,
						style: {
							marginLeft: 5,
							opacity: opacity
						}
					})
				);
			}
			
			return class TypingIndicator extends Plugin {
				onStart(){
					PluginUtilities.addStyle("typingindicator-css", `
						.typingindicator-guild, .typingindicator-dms, .typingindicator-folder {
							position: absolute;
							bottom: 0;
							border-radius: 1vh;
							background-color: #888;
							box-shadow: 0px 0px 8px 4px #888;
							right: 14px;
						}
						.typingindicator-guild [class*=pulsingEllipsisItem], .typingindicator-dms [class*=pulsingEllipsisItem], .typingindicator-folder [class*=pulsingEllipsisItem] {
							background-color: white;
						}
						.typingindicator-channel span[class*="pulsingEllipsisItem"] {
							background-color: var(--channels-default);
						}
					`);
					this.promises = {state:{cancelled: false}, cancel(){this.state.cancelled = true;}};
					this.patchChannelList();
					this.patchGuildList(this.promises.state);
					this.patchHomeIcon(this.promises.state);
					this.patchFolders(this.promises.state);
				}
				onStop(){
					PluginUtilities.removeStyle("typingindicator-css");
					this.promises.cancel();
					Patcher.unpatchAll();
				}
				
				getGuildChannels(...guildIds){
					const channels = ChannelStore.getGuildChannels ? Object.values(ChannelStore.getGuildChannels()) : ChannelStore.getMutableGuildChannels ? Object.values(ChannelStore.getMutableGuildChannels()) : [];
					return channels.filter(c => guildIds.includes(c.guild_id) && c.type !== DiscordConstants.ChannelTypes.GUILD_VOICE && c.type !== DiscordConstants.ChannelTypes.GUILD_CATEGORY);
				}
				
				getPrivateChannels(){
					return ChannelStore.getPrivateChannels ? Object.values(ChannelStore.getPrivateChannels()) : ChannelStore.getMutablePrivateChannels ? Object.values(ChannelStore.getMutablePrivateChannels) : [];
				}
				
				patchChannelList(){
					const ChannelItem = WebpackModules.getModule(m => Object(m.default).displayName==="ChannelItem");
					Patcher.after(ChannelItem, "default", (_, [props], returnValue) => {
						if(props.channel.type!==DiscordConstants.ChannelTypes.GUILD_TEXT) return;
						if(props.selected) return;
						if(props.muted && !this.settings.includeMuted) return;
						const selfId = UserStore.getCurrentUser().id;
						const fluxWrapper = Flux.connectStores([UserTypingStore, WindowInfo], ()=>({userIds: Object.keys(UserTypingStore.getTypingUsers(props.channel.id))
							.filter(uId => (uId !== selfId) && (this.settings.includeBlocked || !RelationshipStore.isBlocked(uId)))
						}));
						const wrappedCount = fluxWrapper(({userIds}) => {
							return React.createElement(renderElement, {userIds, opacity: 0.7, type: "channel", isFocused: WindowInfo.isFocused()});
						});
						const itemList = Utilities.getNestedProp(returnValue, "props.children.props.children.1.props");
						if(itemList) itemList.children = [...(Array.isArray(itemList.children) ? itemList.children : [itemList.children]), React.createElement(wrappedCount)];
					});
				}
				
				async patchGuildList(promiseState){
					const Guild = await ReactComponents.getComponentByName("Guild", "." + WebpackModules.getByProps("badgeIcon", "circleIcon", "listItem", "pill").listItem.replace(" ", "."));
					if(promiseState.cancelled) return;
					const selfId = UserStore.getCurrentUser().id;
					Patcher.after(Guild.component.prototype, "render", (thisObject, _, returnValue) => {
						let guildData = thisObject.props;
						if(guildData.selected) return;
						if(!this.settings.guilds) return;
						if(!guildData.guild) return;
						if(MutedStore.isMuted(guildData.guildId) && !this.settings.includeMuted) return;
						const fluxWrapper = Flux.connectStores([UserTypingStore, WindowInfo], ()=>({userIds: this.getGuildChannels(guildData.guildId)
								.filter(c => this.settings.includeMuted || !MutedStore.isChannelMuted(c.guild_id, c.id))
								.flatMap(c => Object.keys(UserTypingStore.getTypingUsers(c.id))
										.filter(uId => (uId !== selfId) && (this.settings.includeBlocked || !RelationshipStore.isBlocked(uId)))
								)
						}));
						const wrappedCount = fluxWrapper(({userIds}) => {
							return React.createElement(renderElement, {userIds, opacity: 1, type: "guild", isFocused: WindowInfo.isFocused()});
						});
						returnValue.props.children.props.children.push(React.createElement(wrappedCount));
					});
					Guild.forceUpdateAll();
				}
				
				async patchHomeIcon(promiseState){
					const Home = await ReactComponents.getComponentByName("TutorialIndicator", "." + WebpackModules.getByProps("badgeIcon", "circleIcon", "listItem", "pill").listItem.replace(/ /g, "."));
					if(promiseState.cancelled) return;
					const selfId = UserStore.getCurrentUser().id;
					Patcher.after(Home.component.prototype, "render", (thisObject, _, returnValue) => {
						if(!returnValue.props.children) return;
						let children = returnValue.props.children[0] || returnValue.props.children;
						if(!children.props) return;
						if(!children.props.children || !children.props.className) return;
						if(!children.props.children.props || !children.props.children.props.children) return;
						children = children.props.children.props.children[1];
						if(!children) return;
						if(!this.settings.dms) return;
						if(!SelectedGuildStore.getGuildId()) return;
						const fluxWrapper = Flux.connectStores([UserTypingStore, WindowInfo], ()=>({userIds: this.getPrivateChannels()
							.filter(c => this.settings.includeMuted || !MutedStore.isChannelMuted(null, c.id))
							.flatMap(c => Object.keys(UserTypingStore.getTypingUsers(c.id))
									.filter(uId => (uId !== selfId) && (this.settings.includeBlocked || !RelationshipStore.isBlocked(uId)))
							)
						}));
						const wrappedCount = fluxWrapper(({userIds}) => {
							return React.createElement(renderElement, {userIds, opacity: 1, type: "dms", isFocused: WindowInfo.isFocused()});
						});
						children.props.children = React.Children.toArray(children.props.children);
						if(children.props.children.push) children.props.children.push(React.createElement(wrappedCount));
					});
					Home.forceUpdateAll();
				}
				
				async patchFolders(promiseState){
					const Folder = WebpackModules.find(m=>m?.type?.render && (m?.type?.render||m?.type?.__powercordOriginal_render)?.toString()?.indexOf("SERVER_FOLDER")!==-1);
					if(promiseState.cancelled || !Folder) return;
					const selfId = UserStore.getCurrentUser().id;
					Patcher.after(Folder.type, "render", (_, [props], returnValue) => {
						console.log({props, returnValue});
						if(props.expanded) return;
						if(!this.settings.folders) return;
						const fluxWrapper = Flux.connectStores([UserTypingStore, WindowInfo], ()=>({userIds: this.getGuildChannels(...props.guildIds)
								.filter(c => (this.settings.includeMuted || !MutedStore.isMuted(c.guild_id))
								             && (this.settings.includeMuted || !MutedStore.isChannelMuted(c.guild_id, c.id))
								             && (SelectedGuildStore.getGuildId() !== c.guild_id))
								.flatMap(c => Object.keys(UserTypingStore.getTypingUsers(c.id))
										.filter(uId => (uId !== selfId) && (this.settings.includeBlocked || !RelationshipStore.isBlocked(uId)))
								)
						}));
						const wrappedCount = fluxWrapper(({userIds}) => {
							return React.createElement(renderElement, {userIds, opacity: 1, type: "folder", isFocused: WindowInfo.isFocused()});
						});
						returnValue.props.children.push(React.createElement(wrappedCount));
					});
				}
				
				getSettingsPanel(){
					return this.buildSettingsPanel().getElement();
				}
			};
		};
		return plugin(Plugin, Api);
	})(global.ZeresPluginLibrary.buildPlugin(config));
})();
{
    "didShowIssueHelperPopup": true,
    "currentVersionInfo": {
        "version": "0.5.1",
        "hasShownChangelog": true
    }
}
{
	"settings": {
		"showInChat": true,
		"showInMemberList": true,
		"showInVoiceList": true,
		"useOtherStyle": false,
		"useBlackFont": false,
		"includeColorless": false,
		"showOwnerRole": false,
		"disableForBots": false,
		"addUserID": false
	}
}
/**
 * @name TopRoleEverywhere
 * @author DevilBro
 * @authorId 278543574059057154
 * @version 3.0.5
 * @description Adds the highest Role of a User as a Tag
 * @invite Jx3TjNS
 * @donate https://www.paypal.me/MircoWittrien
 * @patreon https://www.patreon.com/MircoWittrien
 * @website https://mwittrien.github.io/
 * @source https://github.com/mwittrien/BetterDiscordAddons/tree/master/Plugins/TopRoleEverywhere/
 * @updateUrl https://mwittrien.github.io/BetterDiscordAddons/Plugins/TopRoleEverywhere/TopRoleEverywhere.plugin.js
 */

module.exports = (_ => {
	const config = {
		"info": {
			"name": "TopRoleEverywhere",
			"author": "DevilBro",
			"version": "3.0.5",
			"description": "Adds the highest Role of a User as a Tag"
		},
		"changeLog": {
			"added": {
				"Voice Channel List": "Added Option to add Role Tag in the Voice Channel List for Users"
			}
		}
	};

	return !window.BDFDB_Global || (!window.BDFDB_Global.loaded && !window.BDFDB_Global.started) ? class {
		getName () {return config.info.name;}
		getAuthor () {return config.info.author;}
		getVersion () {return config.info.version;}
		getDescription () {return `The Library Plugin needed for ${config.info.name} is missing. Open the Plugin Settings to download it. \n\n${config.info.description}`;}
		
		downloadLibrary () {
			require("request").get("https://mwittrien.github.io/BetterDiscordAddons/Library/0BDFDB.plugin.js", (e, r, b) => {
				if (!e && b && r.statusCode == 200) require("fs").writeFile(require("path").join(BdApi.Plugins.folder, "0BDFDB.plugin.js"), b, _ => BdApi.showToast("Finished downloading BDFDB Library", {type: "success"}));
				else BdApi.alert("Error", "Could not download BDFDB Library Plugin. Try again later or download it manually from GitHub: https://mwittrien.github.io/downloader/?library");
			});
		}
		
		load () {
			if (!window.BDFDB_Global || !Array.isArray(window.BDFDB_Global.pluginQueue)) window.BDFDB_Global = Object.assign({}, window.BDFDB_Global, {pluginQueue: []});
			if (!window.BDFDB_Global.downloadModal) {
				window.BDFDB_Global.downloadModal = true;
				BdApi.showConfirmationModal("Library Missing", `The Library Plugin needed for ${config.info.name} is missing. Please click "Download Now" to install it.`, {
					confirmText: "Download Now",
					cancelText: "Cancel",
					onCancel: _ => {delete window.BDFDB_Global.downloadModal;},
					onConfirm: _ => {
						delete window.BDFDB_Global.downloadModal;
						this.downloadLibrary();
					}
				});
			}
			if (!window.BDFDB_Global.pluginQueue.includes(config.info.name)) window.BDFDB_Global.pluginQueue.push(config.info.name);
		}
		start () {this.load();}
		stop () {}
		getSettingsPanel () {
			let template = document.createElement("template");
			template.innerHTML = `<div style="color: var(--header-primary); font-size: 16px; font-weight: 300; white-space: pre; line-height: 22px;">The Library Plugin needed for ${config.info.name} is missing.\nPlease click <a style="font-weight: 500;">Download Now</a> to install it.</div>`;
			template.content.firstElementChild.querySelector("a").addEventListener("click", this.downloadLibrary);
			return template.content.firstElementChild;
		}
	} : (([Plugin, BDFDB]) => {
		var settings = {};
	
		return class TopRoleEverywhere extends Plugin {
			onLoad () {
				this.defaults = {
					settings: {
						showInChat:			{value: true, 	inner: true, 	description: "Chat Window"},
						showInMemberList:	{value: true, 	inner: true, 	description: "Member List"},
						showInVoiceList:	{value: true, 	inner: true, 	description: "Voice User List"},
						useOtherStyle:		{value: false, 	inner: false, 	description: "Use BotTag Style instead of the Role Style"},
						useBlackFont:		{value: false, 	inner: false,	description: "Instead of darkening the Color for BotTag Style on bright Colors use black Font"},
						includeColorless:	{value: false, 	inner: false, 	description: "Include colorless Roles"},
						showOwnerRole:		{value: false, 	inner: false, 	description: `Display Role Tag of Server Owner as "${BDFDB.LanguageUtils.LanguageStrings.GUILD_OWNER}".`},
						disableForBots:		{value: false, 	inner: false, 	description: "Disable Role Tag for Bots"},
						addUserID:			{value: false, 	inner: false, 	description: "Add the UserID as a Tag to the Chat Window"}
					}
				};
				
				this.patchedModules = {
					after: {
						MemberListItem: "render",
						MessageUsername: "default",
						VoiceUser: "render"
					}
				};
				
				this.patchPriority = 4;
				
				this.css = `
					${BDFDB.dotCNS.member + BDFDB.dotCN.namecontainercontent} {
						overflow: visible;
					}
					${BDFDB.dotCN._toproleseverywheretag} {
						display: inline-flex;
						flex: 0 1 auto;
						cursor: pointer;
						overflow: hidden;
						text-overflow: ellipsis;
						white-space: nowrap;
					}
					${BDFDB.dotCN._toproleseverywheremembertag} {
						max-width: 50%;
					}
					${BDFDB.dotCNS.themelight + BDFDB.dotCN._toproleseverywhererolestyle} {
						color: rgba(79, 84, 92, 0.8);
					}
					${BDFDB.dotCNS.themedark + BDFDB.dotCN._toproleseverywhererolestyle} {
						color: hsla(0, 0%, 100%, 0.8);
					}
					${BDFDB.dotCNS.messagerepliedmessage + BDFDB.dotCN._toproleseverywhererolestyle},
					${BDFDB.dotCNS.messagecompact + BDFDB.dotCN._toproleseverywhererolestyle} {
						margin-right: 0.3rem;
						text-indent: 0;
					}
					${BDFDB.dotCN._toproleseverywhererolestyle} {
						display: inline-flex;
						margin: 0 0 0 0.3rem;
					}
					${BDFDB.dotCNS._toproleseverywhererolestyle + BDFDB.dotCN.userpopoutrolecircle} {
						flex: 0 0 auto;
					}
				`;
			}
			
			onStart () {
				this.forceUpdateAll();
			}
			
			onStop () {
				this.forceUpdateAll();
			}

			getSettingsPanel (collapseStates = {}) {
				let settingsPanel, settingsItems = [];
				
				for (let key in settings) if (!this.defaults.settings[key].inner) settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsSaveItem, {
					type: "Switch",
					plugin: this,
					keys: ["settings", key],
					label: this.defaults.settings[key].description,
					value: settings[key]
				}));
				
				settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsPanelList, {
					title: "Add Role Tags in:",
					children: Object.keys(settings).map(key => this.defaults.settings[key].inner && BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsSaveItem, {
						type: "Switch",
						plugin: this,
						keys: ["settings", key],
						label: this.defaults.settings[key].description,
						value: settings[key]
					}))
				}));
				
				return settingsPanel = BDFDB.PluginUtils.createSettingsPanel(this, settingsItems);
			}

			onSettingsClosed () {
				if (this.SettingsUpdated) {
					delete this.SettingsUpdated;
					this.forceUpdateAll();
				}
			}
	
			forceUpdateAll () {
				settings = BDFDB.DataUtils.get(this, "settings");
				
				BDFDB.PatchUtils.forceAllUpdates(this);
				BDFDB.MessageUtils.rerenderAll();
			}

			processMemberListItem (e) {
				if (e.instance.props.user && settings.showInMemberList) {
					this.injectRoleTag(BDFDB.ObjectUtils.get(e.returnvalue, "props.decorators.props.children"), e.instance.props.user, "member", 2, {
						tagClass: BDFDB.disCN.bottagmember
					});
				}
			}

			processMessageUsername (e) {
				if (e.instance.props.message) {
					if (settings.showInChat) this.injectRoleTag(e.returnvalue.props.children, e.instance.props.message.author, "chat", e.instance.props.compact ? 0 : 2, {
						tagClass: e.instance.props.compact ? BDFDB.disCN.messagebottagcompact : BDFDB.disCN.messagebottagcozy,
						useRem: true
					});
					if (settings.addUserID) this.injectIdTag(e.returnvalue.props.children, e.instance.props.message.author, "chat", e.instance.props.compact ? 0 : 2, {
						tagClass: e.instance.props.compact ? BDFDB.disCN.messagebottagcompact : BDFDB.disCN.messagebottagcozy,
						useRem: true
					});
				}
			}

			processVoiceUser (e) {
				if (e.instance.props.user && settings.showInVoiceList) {
					let content = BDFDB.ReactUtils.findChild(e.returnvalue, {props: [["className", BDFDB.disCN.voicecontent]]});
					if (content) this.injectRoleTag(content.props.children, e.instance.props.user, "voice", 3);
				}
			}

			injectRoleTag (children, user, type, insertIndex, config = {}) {
				if (!BDFDB.ArrayUtils.is(children) || !user) return;
				let guild = BDFDB.LibraryModules.GuildStore.getGuild(BDFDB.LibraryModules.LastGuildStore.getGuildId());
				if (!guild || user.bot && settings.disableForBots) return;
				let role = BDFDB.LibraryModules.PermissionRoleUtils.getHighestRole(guild, user.id);
				if (settings.showOwnerRole && user.id == guild.ownerId) role = Object.assign({}, role, {name: BDFDB.LanguageUtils.LanguageStrings.GUILD_OWNER, ownerRole: true});
				if (role && !role.colorString && !settings.includeColorless && !role.ownerRole) {
					let member = BDFDB.LibraryModules.MemberStore.getMember(guild.id, user.id);
					if (member) for (let sortedRole of BDFDB.ArrayUtils.keySort(member.roles.map(roleId => guild.getRole(roleId)), "position").reverse()) if (sortedRole.colorString) {
						role = sortedRole;
						break;
					}
				}
				if (role && (role.colorString || role.ownerRole || settings.includeColorless)) children.splice(insertIndex, 0, this.createTag(role, type, config));
			}

			injectIdTag (children, user, type, insertIndex, config = {}) {
				if (!BDFDB.ArrayUtils.is(children) || !user) return;
				children.splice(insertIndex, 0, this.createTag({
					name: user.id
				}, type, config));
			}
			
			createTag (role, type, config = {}) {
				if (settings.useOtherStyle) {
					let tagColor = BDFDB.ColorUtils.convert(role.colorString || BDFDB.DiscordConstants.Colors.PRIMARY_DARK_500, "RGB")
					let isBright = role.colorString && BDFDB.ColorUtils.isBright(tagColor);
					tagColor = isBright ? (settings.useBlackFont ? tagColor : BDFDB.ColorUtils.change(tagColor, -0.3)) : tagColor;
					return BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.BotTag, {
						className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN._toproleseverywheretag, BDFDB.disCN[`_toproleseverywhere${type}tag`], BDFDB.disCN._toproleseverywherebadgestyle, config.tagClass),
						useRemSizes: config.useRem,
						invertColor: config.inverted,
						style: {
							backgroundColor: tagColor,
							color: isBright && settings.useBlackFont ? "black" : null
						},
						tag: role.name,
						onContextMenu: role.id ? e => {this.openRoleContextMenu(e, role);} : null
					});
				}
				else return BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.MemberRole, {
					className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN._toproleseverywheretag, BDFDB.disCN[`_toproleseverywhere${type}tag`], BDFDB.disCN._toproleseverywhererolestyle),
					role: role,
					onContextMenu: role.id ? e => {this.openRoleContextMenu(e, role);} : null
				});
			}
			
			openRoleContextMenu (e, role) {
				BDFDB.LibraryModules.ContextMenuUtils.openContextMenu(e, function (e) {
					return BDFDB.ReactUtils.createElement(BDFDB.ModuleUtils.findByName("DeveloperContextMenu"), Object.assign({}, e, {id: role.id}));
				});
			}
		};
	})(window.BDFDB_Global.PluginUtils.buildPlugin(config));
})();
/**
 * @name SpotifyControls
 * @author DevilBro
 * @authorId 278543574059057154
 * @version 1.1.6
 * @description Adds a Control Panel while listening to Spotify on a connected Account
 * @invite Jx3TjNS
 * @donate https://www.paypal.me/MircoWittrien
 * @patreon https://www.patreon.com/MircoWittrien
 * @website https://mwittrien.github.io/
 * @source https://github.com/mwittrien/BetterDiscordAddons/tree/master/Plugins/SpotifyControls/
 * @updateUrl https://mwittrien.github.io/BetterDiscordAddons/Plugins/SpotifyControls/SpotifyControls.plugin.js
 */

module.exports = (_ => {
	const config = {
		"info": {
			"name": "SpotifyControls",
			"author": "DevilBro",
			"version": "1.1.6",
			"description": "Adds a Control Panel while listening to Spotify on a connected Account"
		},
		"changeLog": {
			"improved": {
				"Activity Toggle": "Added Activity Status Toggle Button"
			}
		}
	};

	return !window.BDFDB_Global || (!window.BDFDB_Global.loaded && !window.BDFDB_Global.started) ? class {
		getName () {return config.info.name;}
		getAuthor () {return config.info.author;}
		getVersion () {return config.info.version;}
		getDescription () {return `The Library Plugin needed for ${config.info.name} is missing. Open the Plugin Settings to download it. \n\n${config.info.description}`;}
		
		downloadLibrary () {
			require("request").get("https://mwittrien.github.io/BetterDiscordAddons/Library/0BDFDB.plugin.js", (e, r, b) => {
				if (!e && b && r.statusCode == 200) require("fs").writeFile(require("path").join(BdApi.Plugins.folder, "0BDFDB.plugin.js"), b, _ => BdApi.showToast("Finished downloading BDFDB Library", {type: "success"}));
				else BdApi.alert("Error", "Could not download BDFDB Library Plugin. Try again later or download it manually from GitHub: https://mwittrien.github.io/downloader/?library");
			});
		}
		
		load () {
			if (!window.BDFDB_Global || !Array.isArray(window.BDFDB_Global.pluginQueue)) window.BDFDB_Global = Object.assign({}, window.BDFDB_Global, {pluginQueue: []});
			if (!window.BDFDB_Global.downloadModal) {
				window.BDFDB_Global.downloadModal = true;
				BdApi.showConfirmationModal("Library Missing", `The Library Plugin needed for ${config.info.name} is missing. Please click "Download Now" to install it.`, {
					confirmText: "Download Now",
					cancelText: "Cancel",
					onCancel: _ => {delete window.BDFDB_Global.downloadModal;},
					onConfirm: _ => {
						delete window.BDFDB_Global.downloadModal;
						this.downloadLibrary();
					}
				});
			}
			if (!window.BDFDB_Global.pluginQueue.includes(config.info.name)) window.BDFDB_Global.pluginQueue.push(config.info.name);
		}
		start () {this.load();}
		stop () {}
		getSettingsPanel () {
			let template = document.createElement("template");
			template.innerHTML = `<div style="color: var(--header-primary); font-size: 16px; font-weight: 300; white-space: pre; line-height: 22px;">The Library Plugin needed for ${config.info.name} is missing.\nPlease click <a style="font-weight: 500;">Download Now</a> to install it.</div>`;
			template.content.firstElementChild.querySelector("a").addEventListener("click", this.downloadLibrary);
			return template.content.firstElementChild;
		}
	} : (([Plugin, BDFDB]) => {
		var _this;
		var controls;
		var starting, lastSong, showActivity, currentVolume, lastVolume, stopTime, previousIsClicked, previousDoubleTimeout;
		var timelineTimeout, timelineDragging, updateInterval;
		var playbackState = {};
		
		const repeatStates = [
			"off",
			"context",
			"track"
		];
	
		const SpotifyControlsComponent = class SpotifyControls extends BdApi.React.Component {
			componentDidMount() {
				controls = this;
			}
			request(socket, device, type, data) {
				return new Promise(callback => {
					let method = "PUT";
					switch (type) {
						case "next":
						case "previous":
							method = "POST";
							break;
						case "get":
							type = "";
							method = "GET";
							break;
					};
					BDFDB.LibraryRequires.request({
						url: `https://api.spotify.com/v1/me/player${type ? "/" + type : ""}${Object.entries(Object.assign({}, data)).map(n => `?${n[0]}=${n[1]}`).join("")}`,
						method: method,
						headers: {
							authorization: `Bearer ${socket.accessToken}`
						}
					}, (error, response, result) => {
						if (response && response.statusCode == 401) {
							BDFDB.LibraryModules.SpotifyUtils.getAccessToken(socket.accountId).then(promiseResult => {
								let newSocketDevice = BDFDB.LibraryModules.SpotifyTrackUtils.getActiveSocketAndDevice();
								this.request(newSocketDevice.socket, newSocketDevice.device, type, data).then(_ => {
									try {callback(JSON.parse(result));}
									catch (err) {callback({});}
								});
							});
						}
						else {
							try {callback(JSON.parse(result));}
							catch (err) {callback({});}
						}
					});
				});
			}
			render() {
				let socketDevice = BDFDB.LibraryModules.SpotifyTrackUtils.getActiveSocketAndDevice();
				if (!socketDevice) return null;
				if (this.props.song) {
					playbackState.is_playing = true;
					let fetchState = !BDFDB.equals(this.props.song, lastSong);
					lastSong = this.props.song;
					stopTime = null;
					if (fetchState) this.request(socketDevice.socket, socketDevice.device, "get").then(response => {
						playbackState = Object.assign({}, response);
						BDFDB.ReactUtils.forceUpdate(this);
					});
				}
				else if (!stopTime && lastSong) {
					playbackState.is_playing = false;
					stopTime = new Date();
				}
				if (!lastSong) return null;
				
				let playerSize = this.props.maximized ? "big" : "small";
				let coverSrc = BDFDB.LibraryModules.AssetUtils.getAssetImage(lastSong.application_id, lastSong.assets.large_image);
				showActivity = showActivity != undefined ? showActivity : (BDFDB.LibraryModules.ConnectionStore.getAccounts().find(n => n.type == "spotify") || {}).show_activity;
				currentVolume = this.props.draggingVolume ? currentVolume : socketDevice.device.volume_percent;
				
				return BDFDB.ReactUtils.createElement("div", {
					className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN._spotifycontrolscontainer, this.props.maximized && BDFDB.disCN._spotifycontrolscontainermaximized, this.props.timeline && BDFDB.disCN._spotifycontrolscontainerwithtimeline),
					children: [
						BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.disCN._spotifycontrolscontainerinner,
							children: [
								BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Clickable, {
									className: BDFDB.disCN._spotifycontrolscoverwrapper,
									onClick: _ => {
										this.props.maximized = !this.props.maximized;
										BDFDB.DataUtils.save(this.props.maximized, _this, "playerState", "maximized");
										if (this.props.maximized) this.request(socketDevice.socket, socketDevice.device, "get").then(response => {
											playbackState = Object.assign({}, response);
											BDFDB.ReactUtils.forceUpdate(this);
										});
										else BDFDB.ReactUtils.forceUpdate(this);
									},
									children: [
										coverSrc ? BDFDB.ReactUtils.createElement("img", {
											className: BDFDB.disCN._spotifycontrolscover,
											src: coverSrc
										}) : BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SvgIcon, {
											className: BDFDB.disCN._spotifycontrolscover,
											width: "100%",
											height: "100%",
											name: BDFDB.LibraryComponents.SvgIcon.Names.QUESTIONMARK_ACTIVITY
										}),
										BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SvgIcon, {
											className: BDFDB.disCN._spotifycontrolscovermaximizer,
											name: BDFDB.LibraryComponents.SvgIcon.Names.LEFT_CARET
										}),
										this.props.maximized && this.props.activityToggle && BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TooltipContainer, {
											text: _ => `${BDFDB.LanguageUtils.LanguageStringsFormat("DISPLAY_ACTIVITY", "Spotify")} (${showActivity ? BDFDB.LanguageUtils.LanguageStrings.REPLY_MENTION_ON : BDFDB.LanguageUtils.LanguageStrings.REPLY_MENTION_OFF})`,
											children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SvgIcon, {
												className: BDFDB.disCN._spotifycontrolsactivitybutton,
												width: 20,
												height: 20,
												foreground: BDFDB.disCN.accountinfobuttonstrikethrough,
												name: showActivity ? BDFDB.LibraryComponents.SvgIcon.Names.ACTIVITY : BDFDB.LibraryComponents.SvgIcon.Names.ACTIVITY_DISABLED,
												onClick: event => {
													BDFDB.ListenerUtils.stopEvent(event);
													showActivity = !showActivity;
													let account = BDFDB.LibraryModules.ConnectionStore.getAccounts().find(n => n.type == "spotify");
													account && BDFDB.LibraryModules.ConnectionUtils.setShowActivity("spotify", account.id, showActivity);
												}
											})
										})
									]
								}),
								BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN._spotifycontrolsdetails,
									children: [
										BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TextElement, {
											className: BDFDB.disCN._spotifycontrolssong,
											children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TextScroller, {
												children: lastSong.details
											})
										}),
										BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TextElement, {
											className: BDFDB.disCNS.subtext + BDFDB.disCN._spotifycontrolsinterpret,
											color: BDFDB.LibraryComponents.TextElement.Colors.CUSTOM,
											size: BDFDB.LibraryComponents.TextElement.Sizes.SIZE_12,
											children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TextScroller, {
												children: BDFDB.LanguageUtils.LanguageStringsFormat("USER_ACTIVITY_LISTENING_ARTISTS", lastSong.state)
											})
										})
									]
								}),
								BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TooltipContainer, {
									text: socketDevice.device.is_restricted ? _this.labels.restricted_device : null,
									tooltipConfig: {color: "red"},
									children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
										grow: 0,
										children: [
											BDFDB.ReactUtils.createElement(SpotifyControlsButtonComponent, {
												type: "share",
												playerSize: playerSize,
												style: this.props.maximized ? {marginRight: 4} : {},
												onClick: _ => {
													let url = BDFDB.ObjectUtils.get(playbackState, "item.external_urls.spotify") || BDFDB.ObjectUtils.get(playbackState, "context.external_urls.spotify");
													if (url) {
														BDFDB.LibraryRequires.electron.clipboard.write({text: url});
														BDFDB.NotificationUtils.toast(_this.labels.toast_copyurl_success, {type: "success"});
													}
													else BDFDB.NotificationUtils.toast(_this.labels.toast_copyurl_fail, {type: "danger"});
												}
											}),
											BDFDB.ReactUtils.createElement(SpotifyControlsButtonComponent, {
												type: "shuffle",
												playerSize: playerSize,
												active: playbackState.shuffle_state,
												disabled: socketDevice.device.is_restricted,
												onClick: _ => {
													playbackState.shuffle_state = !playbackState.shuffle_state;
													this.request(socketDevice.socket, socketDevice.device, "shuffle", {
														state: playbackState.shuffle_state
													});
													BDFDB.ReactUtils.forceUpdate(this);
												}
											}),
											BDFDB.ReactUtils.createElement(SpotifyControlsButtonComponent, {
												type: "previous",
												playerSize: playerSize,
												disabled: socketDevice.device.is_restricted,
												onClick: _ => {
													if (previousIsClicked || !_this.settings.general.doubleBack) {
														previousIsClicked = false;
														this.request(socketDevice.socket, socketDevice.device, "previous");
													}
													else {
														previousIsClicked = true;
														previousDoubleTimeout = BDFDB.TimeUtils.timeout(_ => {
															previousIsClicked = false;
															this.request(socketDevice.socket, socketDevice.device, "seek", {
																position_ms: 0
															});
														}, 300);
													}
												}
											}),
											BDFDB.ReactUtils.createElement(SpotifyControlsButtonComponent, {
												type: "pauseplay",
												playerSize: playerSize,
												icon: this.props.song ? 0 : 1,
												disabled: socketDevice.device.is_restricted,
												onClick: _ => {
													if (this.props.song) {
														playbackState.is_playing = false;
														this.request(socketDevice.socket, socketDevice.device, "pause");
													}
													else {
														playbackState.is_playing = true;
														this.request(socketDevice.socket, socketDevice.device, "play");
													}
												}
											}),
											BDFDB.ReactUtils.createElement(SpotifyControlsButtonComponent, {
												type: "next",
												playerSize: playerSize,
												disabled: socketDevice.device.is_restricted,
												onClick: _ => {
													this.request(socketDevice.socket, socketDevice.device, "next");
												}
											}),
											BDFDB.ReactUtils.createElement(SpotifyControlsButtonComponent, {
												type: "repeat",
												playerSize: playerSize,
												icon: playbackState.repeat_state != repeatStates[2] ? 0 : 1,
												active: playbackState.repeat_state != repeatStates[0],
												disabled: socketDevice.device.is_restricted,
												onClick: _ => {
													playbackState.repeat_state = repeatStates[repeatStates.indexOf(playbackState.repeat_state) + 1] || repeatStates[0];
													this.request(socketDevice.socket, socketDevice.device, "repeat", {
														state: playbackState.repeat_state
													});
													BDFDB.ReactUtils.forceUpdate(this);
												}
											}),
											BDFDB.ReactUtils.createElement(SpotifyControlsButtonComponent, {
												type: "volume",
												playerSize: playerSize,
												icon: Math.ceil(currentVolume/34),
												disabled: socketDevice.device.is_restricted,
												style: this.props.maximized ? {marginLeft: 4} : {},
												onContextMenu: _ => {
													if (currentVolume == 0) {
														if (lastVolume) this.request(socketDevice.socket, socketDevice.device, "volume", {
															volume_percent: lastVolume
														});
													}
													else {
														lastVolume = currentVolume;
														this.request(socketDevice.socket, socketDevice.device, "volume", {
															volume_percent: 0
														});
													}
												},
												renderPopout: instance => {
													let changeTimeout;
													return BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Slider, {
														className: BDFDB.disCN._spotifycontrolsvolumeslider,
														defaultValue: currentVolume,
														digits: 0,
														barStyles: {height: 6, top: 3},
														fillStyles: {backgroundColor: BDFDB.DiscordConstants.Colors.SPOTIFY},
														onValueRender: value => {
															this.props.draggingVolume = true;
															currentVolume = value;
															BDFDB.TimeUtils.clear(changeTimeout);
															changeTimeout = BDFDB.TimeUtils.timeout(_ => this.props.draggingVolume && this.request(socketDevice.socket, socketDevice.device, "volume", {
																volume_percent: currentVolume
															}), 500);
															return value + "%";
														},
														onValueChange: value => {
															this.props.draggingVolume = false;
															currentVolume = value;
															this.request(socketDevice.socket, socketDevice.device, "volume", {
																volume_percent: currentVolume
															});
														}
													});
												}
											})
										].filter(n => n)
									})
								})
							]
						}),
						this.props.timeline && BDFDB.ReactUtils.createElement(SpotifyControlsTimelineComponent, {
							song: lastSong,
							socket: socketDevice.socket,
							device: socketDevice.device,
							controls: this
						})
					].filter(n => n)
				});
			}
		};
		const SpotifyControlsButtonComponent = class SpotifyControlsButton extends BdApi.React.Component {
			render() {
				if (!this.props.playerSize || !_this.settings.buttons[this.props.type] || !_this.settings.buttons[this.props.type][this.props.playerSize]) return null;
				let button = BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Button, BDFDB.ObjectUtils.exclude(Object.assign({}, this.props, {
					className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.accountinfobutton, this.props.disabled ? BDFDB.disCN.accountinfobuttondisabled : BDFDB.disCN.accountinfobuttonenabled, this.props.active && BDFDB.disCN._spotifycontrolsbuttonactive),
					look: BDFDB.LibraryComponents.Button.Looks.BLANK,
					size: BDFDB.LibraryComponents.Button.Sizes.NONE,
					children: _this.defaults.buttons[this.props.type] && _this.defaults.buttons[this.props.type].icons ? (_this.defaults.buttons[this.props.type].icons[this.props.icon] || _this.defaults.buttons[this.props.type].icons[0]) : "?",
					onClick: this.props.disabled ? _ => {} : this.props.onClick,
					onContextMenu: this.props.disabled ? _ => {} : this.props.onContextMenu,
				}), "active", "disabled", "renderPopout", "icon", "type", "playerSize"));
				return !this.props.disabled && typeof this.props.renderPopout == "function" ? BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.PopoutContainer, {
					children: button,
					animation: BDFDB.LibraryComponents.PopoutContainer.Animation.SCALE,
					position: BDFDB.LibraryComponents.PopoutContainer.Positions.TOP,
					align: BDFDB.LibraryComponents.PopoutContainer.Align.CENTER,
					arrow: true,
					shadow: true,
					renderPopout: this.props.renderPopout
				}) : button;
	}
		};
		const SpotifyControlsTimelineComponent = class SpotifyControlsTimeline extends BdApi.React.Component {
			componentDidMount() {
				BDFDB.TimeUtils.clear(updateInterval);
				updateInterval = BDFDB.TimeUtils.interval(_ => {
					if (!this.updater || typeof this.updater.isMounted != "function" || !this.updater.isMounted(this)) BDFDB.TimeUtils.clear(updateInterval);
					else if (playbackState.is_playing) {
						let song = BDFDB.LibraryModules.SpotifyTrackUtils.getActivity(false);
						if (!song) BDFDB.ReactUtils.forceUpdate(controls);
						else if (playbackState.is_playing) BDFDB.ReactUtils.forceUpdate(this);
					}
				}, 1000);
			}
			formatTime(time) {
				let seconds = Math.floor((time / 1000) % 60);
				let minutes = Math.floor((time / (1000 * 60)) % 60);
				let hours = Math.floor((time / (1000 * 60 * 60)) % 24);
				return `${hours > 0 ? hours + ":" : ""}${hours > 0 && minutes < 10 ? "0" + minutes : minutes}:${seconds < 10 ? "0" + seconds : seconds}`
			}
			render() {
				let maxTime = this.props.song.timestamps.end - this.props.song.timestamps.start;
				let currentTime = (!playbackState.is_playing && stopTime ? stopTime : new Date()) - this.props.song.timestamps.start;
				currentTime = currentTime > maxTime ? maxTime : currentTime;
				return BDFDB.ReactUtils.createElement("div", {
					className: BDFDB.disCN._spotifycontrolstimeline,
					children: [
						BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.disCN._spotifycontrolsbar,
							children: [
								BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN._spotifycontrolsbarfill,
									style: {width: `${currentTime / maxTime * 100}%`}
								}),
								BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN._spotifycontrolsbargrabber,
									style: {left: `${currentTime / maxTime * 100}%`}
								})
							],
							onClick: event => {
								let rects = BDFDB.DOMUtils.getRects(BDFDB.DOMUtils.getParent(BDFDB.dotCN._spotifycontrolsbar, event.target));
								this.props.controls.request(this.props.socket, this.props.device, "seek", {
									position_ms: Math.round(BDFDB.NumberUtils.mapRange([rects.left, rects.left + rects.width], [0, maxTime], event.clientX))
								});
							}
						}),
						BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.disCN._spotifycontrolsbartext,
							children: [
								BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TextElement, {
									className: BDFDB.disCN.height12,
									size: BDFDB.LibraryComponents.TextElement.Sizes.SIZE_12,
									children: this.formatTime(currentTime)
								}),
								BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TextElement, {
									className: BDFDB.disCN.height12,
									size: BDFDB.LibraryComponents.TextElement.Sizes.SIZE_12,
									children: this.formatTime(maxTime)
								})
							]
						})
					]
				});
			}
		};
	
		return class SpotifyControls extends Plugin {
			onLoad () {
				_this = this;
				
				this.defaults = {
					general: {
						addTimeline: 		{value: true,		description: "Shows the Song Timeline in the Controls"},
						addActivityButton: 	{value: true,		description: "Shows the Activity Status Toggle Button in the Controls"},
						doubleBack: 		{value: true,       description: "Requires the User to press the Back Button twice to go to previous Track"}
					},
					buttons: {
						share: 				{value: {small: false, big: true},		icons: ["ï’"],						description: "Share"},
						shuffle: 			{value: {small: false, big: true},		icons: ["ï…„"],						description: "Shuffle"},
						previous: 			{value: {small: true, big: true},		icons: ["ï…†"],						description: "Previous"},
						pauseplay: 			{value: {small: true, big: true},		icons: ["ï„°", "ï„²"],					description: "Pause/Play"},
						next: 				{value: {small: true, big: true},		icons: ["ï…ˆ"],						description: "Next"},
						repeat: 			{value: {small: false, big: true},		icons: ["ï„¾", "ïˆ€"],					description: "Repeat"},
						volume: 			{value: {small: false, big: true},		icons: ["ï‡¯", "ïˆƒ", "ïˆ†", "ï…ž"],		description: "Volume"}
					}
				};
				
				this.patchedModules = {
					after: {
						AppView: "default"
					}
				};
				
				
				this.css = `
					@font-face {
						font-family: glue1-spoticon;
						src: url("https://mwittrien.github.io/BetterDiscordAddons/Plugins/SpotifyControls/_res/spoticon.ttf") format("truetype");
						font-weight: 400;
						font-style: normal
					}
					${BDFDB.dotCN._spotifycontrolscontainer} {
						display: flex;
						flex-direction: column;
						justify-content: center;
						min-height: 52px;
						margin-bottom: 1px;
						border-bottom: 1px solid var(--background-modifier-accent);
						padding: 0 8px;
						box-sizing: border-box;
					}
					${BDFDB.dotCN._spotifycontrolscontainer + BDFDB.dotCN._spotifycontrolscontainerwithtimeline} {
						padding-top: 8px;
					}
					${BDFDB.dotCN._spotifycontrolscontainerinner} {
						display: flex;
						align-items: center;
						font-size: 14px;
						width: 100%;
					}
					${BDFDB.dotCN._spotifycontrolstimeline} {
						margin: 6px 0 4px 0;
					}
					${BDFDB.dotCN._spotifycontrolsbar} {
						position: relative;
						border-radius: 2px;
						background-color: rgba(79, 84, 92, 0.16);
						height: 4px;
						margin-bottom: 4px;
					}
					${BDFDB.dotCN._spotifycontrolsbarfill} {
						border-radius: 2px;
						height: 100%;
						min-width: 4px;
						border-radius: 2px;
						background: var(--text-normal);
					}
					${BDFDB.dotCN._spotifycontrolstimeline}:hover ${BDFDB.dotCN._spotifycontrolsbarfill} {
						background: ${BDFDB.DiscordConstants.Colors.SPOTIFY};
					}
					${BDFDB.dotCN._spotifycontrolsbargrabber} {
						display: none;
						position: absolute;
						top: 0;
						left: 0;
						width: 8px;
						height: 8px;
						margin-top: -2px;
						margin-left: -2px;
						background: var(--text-normal);
						border-radius: 50%;
					}
					${BDFDB.dotCN._spotifycontrolstimeline}:hover ${BDFDB.dotCN._spotifycontrolsbargrabber} {
						display: block;
					}
					${BDFDB.dotCN._spotifycontrolsbartext} {
						display: flex;
						align-items: center;
						justify-content: space-between;
					}
					${BDFDB.dotCN._spotifycontrolscoverwrapper} {
						position: relative;
						width: 32px;
						min-width: 32px;
						height: 32px;
						min-height: 32px;
						margin-right: 8px;
						border-radius: 4px;
						overflow: hidden;
						transition: border-radius .3s ease, margin .3s ease, width .3s ease, height .3s ease;
					}
					${BDFDB.dotCN._spotifycontrolscover} {
						display: block;
						width: 100%;
						height: 100%;
						color: var(--header-primary);
						object-fit: cover;
					}
					${BDFDB.dotCN._spotifycontrolscovermaximizer} {
						visibility: hidden;
						position: absolute;
						background-color: rgba(0, 0, 0, 0.5);
						color: rgba(255, 255, 255, 0.5);
						top: 0;
						right: 0;
						border-radius: 50%;
						width: 12px;
						height: 12px;
						padding: 3px;
						transform: rotate(90deg);
						transition: width .3s ease, height .3s ease, transform .3s ease;
						pointer-events: none;
					}
					${BDFDB.dotCN._spotifycontrolscoverwrapper}:hover ${BDFDB.dotCN._spotifycontrolscovermaximizer} {
						visibility: visible;
					}
					${BDFDB.dotCN._spotifycontrolsactivitybutton} {
						visibility: hidden;
						position: absolute;
						background-color: rgba(0, 0, 0, 0.5);
						color: rgba(255, 255, 255, 0.5);
						border-radius: 50%;
						bottom: 4px;
						right: 4px;
						width: 22px;
						height: 22px;
						padding: 5px;
					}
					${BDFDB.dotCN._spotifycontrolsactivitybutton}:hover {
						color: rgb(255, 255, 255);
					}
					${BDFDB.dotCN._spotifycontrolscoverwrapper}:hover ${BDFDB.dotCN._spotifycontrolsactivitybutton} {
						visibility: visible;
					}
					${BDFDB.dotCN._spotifycontrolsdetails} {
						flex-grow: 1;
						margin-right: 4px;
						min-width: 0;
						user-select: text;
					}
					${BDFDB.dotCN._spotifycontrolssong} {
						font-weight: 500;
					}
					${BDFDB.dotCN._spotifycontrolsinterpret} {
						font-weight: 300;
					}
					${BDFDB.dotCN._spotifycontrolsvolumeslider} {
						height: 12px;
						width: 140px;
						margin: 5px;
					}
					${BDFDB.dotCNS._spotifycontrolsvolumeslider + BDFDB.dotCN.slidergrabber} {
						height: 10px;
						margin-top: -6px;
						border-radius: 50%;
					}
					${BDFDB.dotCNS._spotifycontrolscontainer + BDFDB.dotCN.accountinfobuttondisabled} {
						cursor: no-drop;
					}
					${BDFDB.dotCNS._spotifycontrolscontainer + BDFDB.dotCNS.accountinfobutton + BDFDB.dotCN.buttoncontents} {
						font-family: glue1-spoticon !important;
					}
					${BDFDB.dotCNS._spotifycontrolscontainer + BDFDB.dotCN.accountinfobutton + BDFDB.dotCN._spotifycontrolsbuttonactive} {
						color: ${BDFDB.DiscordConstants.Colors.SPOTIFY};
					}
					${BDFDB.dotCN._spotifycontrolscontainer + BDFDB.dotCN._spotifycontrolscontainermaximized} {
						padding-top: 0;
					}
					${BDFDB.dotCN._spotifycontrolscontainer + BDFDB.dotCNS._spotifycontrolscontainermaximized + BDFDB.dotCN._spotifycontrolscontainerinner} {
						flex-direction: column;
					}
					${BDFDB.dotCN._spotifycontrolscontainer + BDFDB.dotCNS._spotifycontrolscontainermaximized + BDFDB.dotCN._spotifycontrolsdetails} {
						margin: 0 0 4px 0;
						width: 100%;
						text-align: center;
					}
					${BDFDB.dotCN._spotifycontrolscontainer + BDFDB.dotCNS._spotifycontrolscontainermaximized + BDFDB.dotCN._spotifycontrolscoverwrapper} {
						width: calc(100% + 16px);
						height: 100%;
						margin: 0 0 8px 0;
						border-radius: 0;
					}
					${BDFDB.dotCN._spotifycontrolscontainer + BDFDB.dotCNS._spotifycontrolscontainermaximized + BDFDB.dotCN._spotifycontrolscovermaximizer} {
						top: 4px;
						right: 4px;
						width: 22px;
						height: 22px;
						padding: 5px;
						transform: rotate(-90deg);
					}
					${BDFDB.dotCN._spotifycontrolssettingsicon} {
						margin: 4px;
						font-size: 16px;
						font-family: glue1-spoticon !important;
					}
					${BDFDB.dotCN._spotifycontrolssettingslabel} {
						margin-left: 10px;
					}
					${BDFDB.dotCNS._bdminimalmode + BDFDB.dotCN._spotifycontrolsbar} {
						height: 3px;
					}
					${BDFDB.dotCNS._bdminimalmode + BDFDB.dotCNS._spotifycontrolscontainer + BDFDB.dotCN.accountinfobutton} {
						width: 26px;
						height: 26px;
					}
					${BDFDB.dotCNS._bdminimalmode + BDFDB.dotCNS._spotifycontrolscontainer + BDFDB.dotCN.size14} {
						font-size: 13px;
						line-height: 13px;
					}
					${BDFDB.dotCNS._bdminimalmode + BDFDB.dotCNS._spotifycontrolscontainer + BDFDB.dotCN.size12} {
						font-size: 11px;
						line-height: 11px;
					}
				`;
			}
			
			onStart () {
				// REMOVE 24.04.2021
				let oldData = BDFDB.DataUtils.load(this);
				if (oldData.settings) {
					this.settings.general = oldData.settings;
					BDFDB.DataUtils.save(this.settings.general, this, "general");
					BDFDB.DataUtils.remove(this, "settings");
				}
				if (oldData.buttonConfigs) {
					this.settings.buttons = oldData.buttonConfigs;
					BDFDB.DataUtils.save(this.settings.buttons, this, "buttons");
					BDFDB.DataUtils.remove(this, "buttonConfigs");
				}
				
				BDFDB.PatchUtils.patch(this, BDFDB.LibraryModules.SpotifyTrackUtils, "getActivity", {after: e => {
					if (e.methodArguments[0] !== false) {
						if (e.returnValue && e.returnValue.name == "Spotify") this.updatePlayer(e.returnValue);
						else if (!e.returnValue) this.updatePlayer(null);
					}
				}});

				BDFDB.PatchUtils.patch(this, BDFDB.LibraryModules.SpotifyTrackUtils, "wasAutoPaused", {instead: e => {
					return false;
				}});

				BDFDB.PatchUtils.patch(this, BDFDB.LibraryModules.SpotifyUtils, "pause", {instead: e => {
					return false;
				}});
				
				this.forceUpdateAll();
			}
			
			onStop () {
				this.forceUpdateAll();
			}

			getSettingsPanel (collapseStates = {}) {				
				let settingsPanel;
				return settingsPanel = BDFDB.PluginUtils.createSettingsPanel(this, {
					collapseStates: collapseStates,
					children: _ => {
						let settingsItems = [];
						
						if (!BDFDB.LibraryModules.SpotifyTrackUtils.hasConnectedAccount()) BDFDB.ModalUtils.open(this, {
							size: "SMALL",
							header: `${this.name}: ${this.labels.noaccount_header}...`,
							subHeader: this.labels.noaccount_subheader,
							text: this.labels.noaccount_text,
							buttons: [{
								contents: BDFDB.LanguageUtils.LanguageStrings.CONNECT,
								color: "BRAND",
								close: true,
								onClick: _ => BDFDB.LibraryModules.UserSettingsUtils.open(BDFDB.DiscordConstants.UserSettingsSections.CONNECTIONS)
							}]
						});
						
						settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.CollapseContainer, {
							title: "Settings",
							collapseStates: collapseStates,
							children: Object.keys(this.defaults.general).map(key => BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsSaveItem, {
								type: "Switch",
								plugin: this,
								keys: ["general", key],
								label: this.defaults.general[key].description,
								value: this.settings.general[key]
							}))
						}));
						
						settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.CollapseContainer, {
							title: "Button Settings",
							collapseStates: collapseStates,
							children: [BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.FormComponents.FormTitle, {
								className: BDFDB.disCN.marginbottom4,
								tag: BDFDB.LibraryComponents.FormComponents.FormTitle.Tags.H3,
								children: "Add Control Buttons in small and/or big Player Version: "
							})].concat(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsList, {
								settings: Object.keys(this.defaults.buttons[Object.keys(this.defaults.buttons)[0]].value),
								data: Object.keys(this.defaults.buttons).map(key => Object.assign({}, this.settings.buttons[key], {
									key: key,
									label: this.defaults.buttons[key].description,
									icons: this.defaults.buttons[key].icons
								})),
								noRemove: true,
								renderLabel: data => BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
									align: BDFDB.LibraryComponents.Flex.Align.CENTER,
									children: [
										BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
											justify: BDFDB.LibraryComponents.Flex.Justify.CENTER,
											wrap: BDFDB.LibraryComponents.Flex.Wrap.WRAP,
											basis: 50,
											grow: 0,
											children: data.icons.map(icon => BDFDB.ReactUtils.createElement("div", {
												className: BDFDB.disCN._spotifycontrolssettingsicon,
												children: icon
											}))
										}),
										BDFDB.ReactUtils.createElement("div", {
											className: BDFDB.disCN._spotifycontrolssettingslabel,
											children: data.label
										})
									]
								}),
								onCheckboxChange: (value, instance) => {
									this.settings.buttons[instance.props.cardId][instance.props.settingId] = value;
									BDFDB.DataUtils.save(this.settings.buttons, this, "buttons");
									this.SettingsUpdated = true;
								}
							}))
						}));
						
						return settingsItems;
					}
				});
			}

			onSettingsClosed () {
				if (this.SettingsUpdated) {
					delete this.SettingsUpdated;
					this.forceUpdateAll();
				}
			}
		
			forceUpdateAll () {				
				BDFDB.PatchUtils.forceAllUpdates(this);
				BDFDB.DiscordUtils.rerenderAll();
			}

			processAppView (e) {
				let injected = this.injectPlayer(e.returnvalue);
				if (!injected) {
					let channels = BDFDB.ReactUtils.findChild(e.returnvalue, {name: "ChannelSidebar"});
					if (channels) {
						let type = channels.type;
						channels.type = (...args) => {
							let appliedType = type(...args);
							this.injectPlayer(appliedType);
							return appliedType;
						};
					}
				}
			}
			
			injectPlayer (parent) {
				let [children, index] = BDFDB.ReactUtils.findParent(parent, {props: [["section", BDFDB.DiscordConstants.AnalyticsSections.ACCOUNT_PANEL]]});
				if (index > -1) children.splice(index - 1, 0, BDFDB.ReactUtils.createElement(SpotifyControlsComponent, {
					song: BDFDB.LibraryModules.SpotifyTrackUtils.getActivity(false),
					maximized: BDFDB.DataUtils.load(this, "playerState", "maximized"),
					timeline: this.settings.general.addTimeline,
					activityToggle: this.settings.general.addActivityButton
				}, true));
				return index > -1;
			}
			
			updatePlayer (song) {
				if (controls) {
					controls.props.song = song;
					BDFDB.ReactUtils.forceUpdate(controls);
				}
			}

			setLabelsByLanguage () {
				switch (BDFDB.LanguageUtils.getLanguage().id) {
					case "bg":		// Bulgarian
						return {
							noaccount_header:					"ÐÐµÑ‰Ð¾ Ð»Ð¸Ð¿ÑÐ²Ð°",
							noaccount_subheader:				"Ð¢Ñ€ÑÐ±Ð²Ð° Ð´Ð° ÑÐ²ÑŠÑ€Ð¶ÐµÑ‚Ðµ Ð°ÐºÐ°ÑƒÐ½Ñ‚ Ð² Spotify",
							noaccount_text:						"Ð›Ð¸Ð¿ÑÐ²Ð° Ð²Ð¸ ÑÐ²ÑŠÑ€Ð·Ð°Ð½ Ð°ÐºÐ°ÑƒÐ½Ñ‚ Ð² Spotify, Ð±ÐµÐ· Ð°ÐºÐ°ÑƒÐ½Ñ‚ Ð½ÑÐ¼Ð° Ð´Ð° Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð´Ð° Ð¸Ð·Ð¿Ð¾Ð»Ð·Ð²Ð°Ñ‚Ðµ Spotify Controls. Ð—Ð° Ð´Ð° ÑÐ²ÑŠÑ€Ð¶ÐµÑ‚Ðµ Ð°ÐºÐ°ÑƒÐ½Ñ‚ Ð² Spotify Ñ Ð²Ð°ÑˆÐ¸Ñ Ð°ÐºÐ°ÑƒÐ½Ñ‚ Ð² Discord, ÐºÐ»Ð¸ÐºÐ½ÐµÑ‚Ðµ Ð²ÑŠÑ€Ñ…Ñƒ Ð±ÑƒÑ‚Ð¾Ð½Ð° Ð¿Ð¾-Ð´Ð¾Ð»Ñƒ.",
							restricted_device:					"ÐÐµ Ð¼Ð¾Ð¶Ðµ Ð´Ð° ÐºÐ¾Ð½Ñ‚Ñ€Ð¾Ð»Ð¸Ñ€Ð° Spotify, Ð´Ð¾ÐºÐ°Ñ‚Ð¾ Ð²ÑŠÐ·Ð¿Ñ€Ð¾Ð¸Ð·Ð²ÐµÐ¶Ð´Ð° Ð¼ÑƒÐ·Ð¸ÐºÐ° Ð½Ð° Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð¾ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð¾",
							toast_copyurl_fail:					"URL Ð°Ð´Ñ€ÐµÑÑŠÑ‚ Ð½Ð° Ð¿ÐµÑÐµÐ½Ñ‚Ð° Ð½Ðµ Ð¼Ð¾Ð¶Ðµ Ð´Ð° Ð±ÑŠÐ´Ðµ ÐºÐ¾Ð¿Ð¸Ñ€Ð°Ð½ Ð² ÐºÐ»Ð¸Ð¿Ð±Ð¾Ñ€Ð´Ð°",
							toast_copyurl_success:				"URL Ð°Ð´Ñ€ÐµÑÑŠÑ‚ Ð½Ð° Ð¿ÐµÑÐµÐ½Ñ‚Ð° Ð±ÐµÑˆÐµ ÐºÐ¾Ð¿Ð¸Ñ€Ð°Ð½ Ð² ÐºÐ»Ð¸Ð¿Ð±Ð¾Ñ€Ð´Ð°"
						};
					case "da":		// Danish
						return {
							noaccount_header:					"Noget mangler",
							noaccount_subheader:				"Du skal oprette forbindelse til en Spotify-konto",
							noaccount_text:						"Du mangler en tilsluttet Spotify-konto, uden en konto kan du ikke bruge Spotify Controls. For at forbinde en Spotify-konto med din Discord-konto skal du klikke pÃ¥ knappen nedenfor.",
							restricted_device:					"Kan ikke kontrollere Spotify, mens du spiller musik pÃ¥ en begrÃ¦nset enhed",
							toast_copyurl_fail:					"Sang-URL kunne ikke kopieres til udklipsholderen",
							toast_copyurl_success:				"Sang-URL blev kopieret til udklipsholderen"
						};
					case "de":		// German
						return {
							noaccount_header:					"Etwas fehlt",
							noaccount_subheader:				"Sie mÃ¼ssen ein Spotify-Konto verbinden",
							noaccount_text:						"Ihnen fehlt ein verbundenes Spotify-Konto. Ohne ein Konto kÃ¶nnen Sie Spotify Controls nicht verwenden. Um ein Spotify-Konto mit Ihrem Discord-Konto zu verbinden, klicken Sie auf die SchaltflÃ¤che unten.",
							restricted_device:					"Spotify  kann nicht gesteuert werden, wÃ¤hrend Musik auf einem eingeschrÃ¤nkten GerÃ¤t abgespielt wird",
							toast_copyurl_fail:					"Die Song-URL konnte nicht in die Zwischenablage kopiert werden",
							toast_copyurl_success:				"Die Song-URL wurde in die Zwischenablage kopiert"
						};
					case "el":		// Greek
						return {
							noaccount_header:					"ÎšÎ¬Ï„Î¹ Î»ÎµÎ¯Ï€ÎµÎ¹",
							noaccount_subheader:				"Î ÏÎ­Ï€ÎµÎ¹ Î½Î± ÏƒÏ…Î½Î´Î­ÏƒÎµÏ„Îµ Î­Î½Î±Î½ Î»Î¿Î³Î±ÏÎ¹Î±ÏƒÎ¼ÏŒ Spotify",
							noaccount_text:						"Î›ÎµÎ¯Ï€ÎµÎ¹ Î­Î½Î±Ï‚ ÏƒÏ…Î½Î´ÎµÎ´ÎµÎ¼Î­Î½Î¿Ï‚ Î»Î¿Î³Î±ÏÎ¹Î±ÏƒÎ¼ÏŒÏ‚ Spotify, Ï‡Ï‰ÏÎ¯Ï‚ Î»Î¿Î³Î±ÏÎ¹Î±ÏƒÎ¼ÏŒ Î´ÎµÎ½ Î¸Î± Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï„Î¿ Spotify Controls. Î“Î¹Î± Î½Î± ÏƒÏ…Î½Î´Î­ÏƒÎµÏ„Îµ Î­Î½Î±Î½ Î»Î¿Î³Î±ÏÎ¹Î±ÏƒÎ¼ÏŒ Spotify Î¼Îµ Ï„Î¿Î½ Î»Î¿Î³Î±ÏÎ¹Î±ÏƒÎ¼ÏŒ ÏƒÎ±Ï‚ Discord ÎºÎ¬Î½Ï„Îµ ÎºÎ»Î¹Îº ÏƒÏ„Î¿ Ï€Î±ÏÎ±ÎºÎ¬Ï„Ï‰ ÎºÎ¿Ï…Î¼Ï€Î¯.",
							restricted_device:					"Î”ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î´Ï…Î½Î±Ï„Î® Î¿ Î­Î»ÎµÎ³Ï‡Î¿Ï‚ Ï„Î¿Ï… Spotify ÎºÎ±Ï„Î¬ Ï„Î·Î½ Î±Î½Î±Ï€Î±ÏÎ±Î³Ï‰Î³Î® Î¼Î¿Ï…ÏƒÎ¹ÎºÎ®Ï‚ ÏƒÎµ Ï€ÎµÏÎ¹Î¿ÏÎ¹ÏƒÎ¼Î­Î½Î· ÏƒÏ…ÏƒÎºÎµÏ…Î®",
							toast_copyurl_fail:					"Î”ÎµÎ½ Î®Ï„Î±Î½ Î´Ï…Î½Î±Ï„Î® Î· Î±Î½Ï„Î¹Î³ÏÎ±Ï†Î® Ï„Î¿Ï… URL Ï„ÏÎ±Î³Î¿Ï…Î´Î¹Î¿Ï ÏƒÏ„Î¿ Ï€ÏÏŒÏ‡ÎµÎ¹ÏÎ¿",
							toast_copyurl_success:				"Î— Î´Î¹ÎµÏÎ¸Ï…Î½ÏƒÎ· URL Ï„Î¿Ï… Ï„ÏÎ±Î³Î¿Ï…Î´Î¹Î¿Ï Î±Î½Ï„Î¹Î³ÏÎ¬Ï†Î·ÎºÎµ ÏƒÏ„Î¿ Ï€ÏÏŒÏ‡ÎµÎ¹ÏÎ¿"
						};
					case "es":		// Spanish
						return {
							noaccount_header:					"Algo falta",
							noaccount_subheader:				"Necesitas conectar una cuenta de Spotify",
							noaccount_text:						"Falta una cuenta de Spotify conectada, sin una cuenta no podrÃ¡ usar Spotify Controls. Para conectar una cuenta de Spotify con su cuenta de Discord, haga clic en el botÃ³n de abajo.",
							restricted_device:					"No se puede controlar Spotify mientras se reproduce mÃºsica en un dispositivo restringido",
							toast_copyurl_fail:					"No se pudo copiar la URL de la canciÃ³n al portapapeles",
							toast_copyurl_success:				"La URL de la canciÃ³n se copiÃ³ al portapapeles"
						};
					case "fi":		// Finnish
						return {
							noaccount_header:					"Jotain puuttuu",
							noaccount_subheader:				"Sinun on yhdistettÃ¤vÃ¤ Spotify-tili",
							noaccount_text:						"Sinulta puuttuu yhdistetty Spotify-tili. Ilman tiliÃ¤ et voi kÃ¤yttÃ¤Ã¤ Spotify Controls. YhdistÃ¤ Spotify-tili Discord-tili napsauttamalla alla olevaa painiketta.",
							restricted_device:					"Spotify Ã¤ ei voi hallita musiikkia toistettaessa rajoitetulla laitteella",
							toast_copyurl_fail:					"Kappaleen URL-osoitetta ei voitu kopioida leikepÃ¶ydÃ¤lle",
							toast_copyurl_success:				"Kappaleen URL-osoite kopioitiin leikepÃ¶ydÃ¤lle"
						};
					case "fr":		// French
						return {
							noaccount_header:					"Quelque chose manque",
							noaccount_subheader:				"Vous devez connecter un compte Spotify",
							noaccount_text:						"Il vous manque un compte Spotify connectÃ©, sans compte, vous ne pourrez pas utiliser Spotify Controls. Pour connecter un compte Spotify Ã  votre compte Discord, cliquez sur le bouton ci-dessous.",
							restricted_device:					"Impossible de contrÃ´ler Spotify lors de la lecture de musique sur un appareil restreint",
							toast_copyurl_fail:					"L'URL de la chanson n'a pas pu Ãªtre copiÃ©e dans le presse-papiers",
							toast_copyurl_success:				"L'URL de la chanson a Ã©tÃ© copiÃ©e dans le presse-papiers"
						};
					case "hr":		// Croatian
						return {
							noaccount_header:					"NeÅ¡to nedostaje",
							noaccount_subheader:				"Morate povezati Spotify raÄun",
							noaccount_text:						"Nedostaje vam povezani Spotify raÄun, bez raÄuna neÄ‡ete moÄ‡i koristiti Spotify Controls. Da biste povezali Spotify raÄun sa svojim Discord raÄunom, kliknite gumb u nastavku.",
							restricted_device:					"Ne moÅ¾e kontrolirati Spotify tijekom reprodukcije glazbe na ograniÄenom ureÄ‘aju",
							toast_copyurl_fail:					"URL pjesme nije se mogao kopirati u meÄ‘uspremnik",
							toast_copyurl_success:				"URL pjesme kopiran je u meÄ‘uspremnik"
						};
					case "hu":		// Hungarian
						return {
							noaccount_header:					"Valami hiÃ¡nyzik",
							noaccount_subheader:				"Csatlakoztatnia kell egy Spotify-fiÃ³kot",
							noaccount_text:						"HiÃ¡nyzik egy csatlakoztatott Spotify-fiÃ³k, fiÃ³k nÃ©lkÃ¼l nem fogja tudni hasznÃ¡lni a Spotify Controls szolgÃ¡ltatÃ¡st. Ha Spotify-fiÃ³kot szeretne Ã¶sszekapcsolni Discord-fiÃ³kot, kattintson az alÃ¡bbi gombra.",
							restricted_device:					"Nem lehet irÃ¡nyÃ­tani a Spotify szolgÃ¡ltatÃ¡st, mikÃ¶zben zenÃ©t jÃ¡tszik le korlÃ¡tozott eszkÃ¶zÃ¶n",
							toast_copyurl_fail:					"A dal URL-jÃ©t nem sikerÃ¼lt Ã¡tmÃ¡solni a vÃ¡gÃ³lapra",
							toast_copyurl_success:				"A dal URL-jÃ©t a vÃ¡gÃ³lapra mÃ¡solta"
						};
					case "it":		// Italian
						return {
							noaccount_header:					"Manca qualcosa",
							noaccount_subheader:				"Devi collegare un account Spotify",
							noaccount_text:						"Ti manca un account Spotify collegato, senza un account non sarai in grado di utilizzare Spotify Controls. Per collegare un account Spotify al tuo account Discord, fai clic sul pulsante in basso.",
							restricted_device:					"Non Ã¨ possibile controllare Spotify durante la riproduzione di musica su un dispositivo limitato",
							toast_copyurl_fail:					"L'URL del brano non puÃ² essere copiato negli appunti",
							toast_copyurl_success:				"L'URL del brano Ã¨ stato copiato negli appunti"
						};
					case "ja":		// Japanese
						return {
							noaccount_header:					"ä½•ã‹ãŒæ¬ ã‘ã¦ã„ã¾ã™",
							noaccount_subheader:				"Spotify ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’æŽ¥ç¶šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™",
							noaccount_text:						"æŽ¥ç¶šã•ã‚Œã¦ã„ã‚‹ Spotify ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒãªã„ã¨ã€ Spotify Controls ã‚’ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚ Spotify ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ Discord ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«æŽ¥ç¶šã™ã‚‹ã«ã¯ã€ä¸‹ã®ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚",
							restricted_device:					"åˆ¶é™ã•ã‚ŒãŸãƒ‡ãƒã‚¤ã‚¹ã§éŸ³æ¥½ã‚’å†ç”Ÿã—ã¦ã„ã‚‹é–“ã¯ Spotify ã‚’åˆ¶å¾¡ã§ãã¾ã›ã‚“",
							toast_copyurl_fail:					"æ›²ã®URLã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã§ãã¾ã›ã‚“ã§ã—ãŸ",
							toast_copyurl_success:				"æ›²ã®URLãŒã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã—ãŸ"
						};
					case "ko":		// Korean
						return {
							noaccount_header:					"ë¬´ì–¸ê°€ê°€ ë¹ ì¡Œì–´",
							noaccount_subheader:				"Spotify  ê³„ì •ì„ ì—°ê²°í•´ì•¼í•©ë‹ˆë‹¤",
							noaccount_text:						"ì—°ê²°ëœ Spotify ê³„ì •ì´ ì—†ìŠµë‹ˆë‹¤. ê³„ì •ì´ ì—†ìœ¼ë©´ Spotify Controls ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. Spotify ê³„ì •ì„ Discord ê³„ì •ê³¼ ì—°ê²°í•˜ë ¤ë©´ ì•„ëž˜ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”.",
							restricted_device:					"ì œí•œëœ ìž¥ì¹˜ì—ì„œ ìŒì•…ì„ ìž¬ìƒí•˜ëŠ” ë™ì•ˆ Spotify ë¥¼ ì œì–´ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
							toast_copyurl_fail:					"ë…¸ëž˜ URLì„ í´ë¦½ ë³´ë“œì— ë³µì‚¬ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
							toast_copyurl_success:				"ë…¸ëž˜ URLì´ í´ë¦½ ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤. "
						};
					case "lt":		// Lithuanian
						return {
							noaccount_header:					"KaÅ¾ko trÅ«ksta",
							noaccount_subheader:				"Turite prijungti â€ž Spotify â€œ paskyrÄ…",
							noaccount_text:						"TrÅ«ksta prijungtos â€ž Spotify â€œ paskyros, be paskyros negalÄ—site naudoti Spotify Controls. NorÄ—dami susieti â€ž Spotify â€œ paskyrÄ… su Discord paskyra, spustelÄ—kite toliau pateiktÄ… mygtukÄ….",
							restricted_device:					"Nepavyksta valdyti â€ž Spotify â€œ grojant muzikÄ… ribotame Ä¯renginyje",
							toast_copyurl_fail:					"Dainos URL nepavyko nukopijuoti Ä¯ iÅ¡karpinÄ™",
							toast_copyurl_success:				"Dainos URL buvo nukopijuotas Ä¯ iÅ¡karpinÄ™"
						};
					case "nl":		// Dutch
						return {
							noaccount_header:					"Er mist iets",
							noaccount_subheader:				"U moet een Spotify-account verbinden",
							noaccount_text:						"U mist een verbonden Spotify-account. Zonder account kunt u Spotify Controls niet gebruiken. Om een Spotify-account aan uw Discord-account te koppelen, klikt u op de onderstaande knop.",
							restricted_device:					"Kan Spotify niet bedienen tijdens het afspelen van muziek op een beperkt apparaat",
							toast_copyurl_fail:					"Nummer-URL kan niet naar klembord worden gekopieerd",
							toast_copyurl_success:				"Nummer-URL is naar klembord gekopieerd"
						};
					case "no":		// Norwegian
						return {
							noaccount_header:					"Noe mangler",
							noaccount_subheader:				"Du mÃ¥ koble til en Spotify-konto",
							noaccount_text:						"Du mangler en tilkoblet Spotify-konto, uten en konto kan du ikke bruke Spotify Controls. For Ã¥ koble en Spotify-konto til Discord-konto din, klikk pÃ¥ knappen nedenfor.",
							restricted_device:					"Kan ikke kontrollere Spotify mens du spiller musikk pÃ¥ begrenset enhet",
							toast_copyurl_fail:					"Sangens URL kunne ikke kopieres til utklippstavlen",
							toast_copyurl_success:				"Sang-URL ble kopiert til utklippstavlen"
						};
					case "pl":		// Polish
						return {
							noaccount_header:					"CzegoÅ› brakuje",
							noaccount_subheader:				"Musisz poÅ‚Ä…czyÄ‡ konto Spotify",
							noaccount_text:						"Brakuje poÅ‚Ä…czonego konta Spotify, bez konta nie bÄ™dziesz mÃ³gÅ‚ korzystaÄ‡ z Spotify Controls. Aby poÅ‚Ä…czyÄ‡ konto Spotify z kontem Discord, kliknij przycisk poniÅ¼ej.",
							restricted_device:					"Nie moÅ¼na sterowaÄ‡ Spotify podczas odtwarzania muzyki na urzÄ…dzeniu z ograniczeniami",
							toast_copyurl_fail:					"Nie udaÅ‚o siÄ™ skopiowaÄ‡ adresu URL utworu do schowka",
							toast_copyurl_success:				"URL utworu zostaÅ‚ skopiowany do schowka"
						};
					case "pt-BR":	// Portuguese (Brazil)
						return {
							noaccount_header:					"Algo estÃ¡ faltando",
							noaccount_subheader:				"VocÃª precisa conectar uma conta Spotify",
							noaccount_text:						"EstÃ¡ faltando uma conta Spotify conectada, sem uma conta vocÃª nÃ£o poderÃ¡ usar Spotify Controls. Para conectar uma conta Spotify Ã  sua conta Discord, clique no botÃ£o abaixo.",
							restricted_device:					"NÃ£o Ã© possÃ­vel controlar o Spotify enquanto reproduz mÃºsica em dispositivo restrito",
							toast_copyurl_fail:					"O URL da mÃºsica nÃ£o pÃ´de ser copiado para a Ã¡rea de transferÃªncia",
							toast_copyurl_success:				"O URL da mÃºsica foi copiado para a Ã¡rea de transferÃªncia"
						};
					case "ro":		// Romanian
						return {
							noaccount_header:					"Ceva lipseste",
							noaccount_subheader:				"Trebuie sÄƒ vÄƒ conectaÈ›i un cont Spotify",
							noaccount_text:						"VÄƒ lipseÈ™te un cont Spotify conectat, fÄƒrÄƒ un cont pe care nu Ã®l veÈ›i putea folosi Spotify Controls. Pentru a conecta un cont Spotify la contul dvs. Discord faceÈ›i clic pe butonul de mai jos.",
							restricted_device:					"Nu pot controla Spotify Ã®n timp ce redaÈ›i muzicÄƒ pe dispozitiv restricÈ›ionat",
							toast_copyurl_fail:					"Adresa URL a melodiei nu a putut fi copiatÄƒ Ã®n clipboard",
							toast_copyurl_success:				"Adresa URL a melodiei a fost copiatÄƒ Ã®n clipboard"
						};
					case "ru":		// Russian
						return {
							noaccount_header:					"Ð§Ñ‚Ð¾-Ñ‚Ð¾ Ð¿Ñ€Ð¾Ð¿Ð°Ð»Ð¾",
							noaccount_subheader:				"Ð’Ð°Ð¼ Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ð¾ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ ÑƒÑ‡ÐµÑ‚Ð½ÑƒÑŽ Ð·Ð°Ð¿Ð¸ÑÑŒ Spotify",
							noaccount_text:						"Ð£ Ð²Ð°Ñ Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²ÑƒÐµÑ‚ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð½Ð°Ñ ÑƒÑ‡ÐµÑ‚Ð½Ð°Ñ Ð·Ð°Ð¿Ð¸ÑÑŒ Spotify, Ð±ÐµÐ· Ð½ÐµÐµ Ð²Ñ‹ Ð½Ðµ ÑÐ¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Spotify Controls. Ð§Ñ‚Ð¾Ð±Ñ‹ ÑÐ²ÑÐ·Ð°Ñ‚ÑŒ ÑƒÑ‡ÐµÑ‚Ð½ÑƒÑŽ Ð·Ð°Ð¿Ð¸ÑÑŒ Spotify ÑÐ¾ ÑÐ²Ð¾ÐµÐ¹ ÑƒÑ‡ÐµÑ‚Ð½Ð¾Ð¹ Ð·Ð°Ð¿Ð¸ÑÑŒÑŽ Discord, Ð½Ð°Ð¶Ð¼Ð¸Ñ‚Ðµ ÐºÐ½Ð¾Ð¿ÐºÑƒ Ð½Ð¸Ð¶Ðµ.",
							restricted_device:					"ÐÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑƒÐ¿Ñ€Ð°Ð²Ð»ÑÑ‚ÑŒ Spotify Ð²Ð¾ Ð²Ñ€ÐµÐ¼Ñ Ð²Ð¾ÑÐ¿Ñ€Ð¾Ð¸Ð·Ð²ÐµÐ´ÐµÐ½Ð¸Ñ Ð¼ÑƒÐ·Ñ‹ÐºÐ¸ Ð½Ð° Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð½Ð¾Ð¼ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ðµ",
							toast_copyurl_fail:					"URL-Ð°Ð´Ñ€ÐµÑ Ð¿ÐµÑÐ½Ð¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ ÑÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½ Ð² Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼ÐµÐ½Ð°",
							toast_copyurl_success:				"URL Ð¿ÐµÑÐ½Ð¸ ÑÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½ Ð² Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼ÐµÐ½Ð°"
						};
					case "sv":		// Swedish
						return {
							noaccount_header:					"NÃ¥got saknas",
							noaccount_subheader:				"Du mÃ¥ste ansluta ett Spotify-konto",
							noaccount_text:						"Du saknar ett anslutet Spotify-konto utan ett konto kan du inte anvÃ¤nda Spotify Controls. FÃ¶r att ansluta ett Spotify-konto till ditt Discord-konto, klicka pÃ¥ knappen nedan.",
							restricted_device:					"Kan inte styra Spotify nÃ¤r du spelar musik pÃ¥ en begrÃ¤nsad enhet",
							toast_copyurl_fail:					"LÃ¥tens URL kunde inte kopieras till Urklipp",
							toast_copyurl_success:				"LÃ¥tens URL kopierades till Urklipp"
						};
					case "th":		// Thai
						return {
							noaccount_header:					"à¸¡à¸µà¸šà¸²à¸‡à¸­à¸¢à¹ˆà¸²à¸‡à¸«à¸²à¸¢à¹„à¸›",
							noaccount_subheader:				"à¸„à¸¸à¸“à¸•à¹‰à¸­à¸‡à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¸šà¸±à¸à¸Šà¸µ Spotify",
							noaccount_text:						"à¸„à¸¸à¸“à¹„à¸¡à¹ˆà¸¡à¸µà¸šà¸±à¸à¸Šà¸µ Spotify à¸—à¸µà¹ˆà¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¸«à¸²à¸à¹„à¸¡à¹ˆà¸¡à¸µà¸šà¸±à¸à¸Šà¸µà¸„à¸¸à¸“à¸ˆà¸°à¹„à¸¡à¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¹ƒà¸Šà¹‰ Spotify Controls à¹„à¸”à¹‰à¸«à¸²à¸à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¸šà¸±à¸à¸Šà¸µ Spotify à¸à¸±à¸šà¸šà¸±à¸à¸Šà¸µ Discord à¸‚à¸­à¸‡à¸„à¸¸à¸“à¹ƒà¸«à¹‰à¸„à¸¥à¸´à¸à¸›à¸¸à¹ˆà¸¡à¸”à¹‰à¸²à¸™à¸¥à¹ˆà¸²à¸‡",
							restricted_device:					"à¹„à¸¡à¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¸„à¸§à¸šà¸„à¸¸à¸¡ Spotify à¸‚à¸“à¸°à¹€à¸¥à¹ˆà¸™à¹€à¸žà¸¥à¸‡à¸šà¸™à¸­à¸¸à¸›à¸à¸£à¸“à¹Œà¸—à¸µà¹ˆ à¸ˆà¸³à¸à¸±à¸”",
							toast_copyurl_fail:					"à¹„à¸¡à¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¸„à¸±à¸”à¸¥à¸­à¸ URL à¸‚à¸­à¸‡à¹€à¸žà¸¥à¸‡à¹„à¸›à¸¢à¸±à¸‡à¸„à¸¥à¸´à¸›à¸šà¸­à¸£à¹Œà¸”",
							toast_copyurl_success:				"à¸„à¸±à¸”à¸¥à¸­à¸ URL à¸‚à¸­à¸‡à¹€à¸žà¸¥à¸‡à¹„à¸›à¸¢à¸±à¸‡à¸„à¸¥à¸´à¸›à¸šà¸­à¸£à¹Œà¸”à¹à¸¥à¹‰à¸§"
						};
					case "tr":		// Turkish
						return {
							noaccount_header:					"Bir ÅŸey eksik",
							noaccount_subheader:				"Spotify  HesabÄ± baÄŸlamanÄ±z gerekiyor",
							noaccount_text:						"BaÄŸlÄ± bir Spotify HesabÄ±nÄ±z yok, bir Hesap olmadan Spotify Controls kullanamazsÄ±nÄ±z. Bir Spotify HesabÄ±nÄ± Discord HesabÄ±nÄ±za baÄŸlamak iÃ§in aÅŸaÄŸÄ±daki dÃ¼ÄŸmeyi tÄ±klayÄ±n.",
							restricted_device:					"KÄ±sÄ±tlÄ± Cihazda MÃ¼zik Ã§alarken Spotify 'Ä± kontrol edemez",
							toast_copyurl_fail:					"ÅžarkÄ± URL'si panoya kopyalanamadÄ±",
							toast_copyurl_success:				"ÅžarkÄ± URL'si panoya kopyalandÄ±"
						};
					case "uk":		// Ukrainian
						return {
							noaccount_header:					"Ð©Ð¾ÑÑŒ Ð½Ðµ Ð²Ð¸ÑÑ‚Ð°Ñ‡Ð°Ñ”",
							noaccount_subheader:				"Ð’Ð°Ð¼ Ð¿Ð¾Ñ‚Ñ€Ñ–Ð±Ð½Ð¾ Ð¿Ñ–Ð´ÐºÐ»ÑŽÑ‡Ð¸Ñ‚Ð¸ Ð°ÐºÐ°ÑƒÐ½Ñ‚ Spotify",
							noaccount_text:						"Ð£ Ð²Ð°Ñ Ð²Ñ–Ð´ÑÑƒÑ‚Ð½Ñ–Ð¹ Ð¿Ñ–Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ð¹ Ð¾Ð±Ð»Ñ–ÐºÐ¾Ð²Ð¸Ð¹ Ð·Ð°Ð¿Ð¸Ñ Spotify, Ð±ÐµÐ· ÑÐºÐ¾Ð³Ð¾ Ð²Ð¸ Ð½Ðµ Ð·Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð²Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð¾Ð²ÑƒÐ²Ð°Ñ‚Ð¸ Spotify Controls. Ð©Ð¾Ð± Ð¿Ñ–Ð´ÐºÐ»ÑŽÑ‡Ð¸Ñ‚Ð¸ Ð¾Ð±Ð»Ñ–ÐºÐ¾Ð²Ð¸Ð¹ Ð·Ð°Ð¿Ð¸Ñ Spotify Ð´Ð¾ ÑÐ²Ð¾Ð³Ð¾ Ð¾Ð±Ð»Ñ–ÐºÐ¾Ð²Ð¾Ð³Ð¾ Ð·Ð°Ð¿Ð¸ÑÑƒ Discord, Ð½Ð°Ñ‚Ð¸ÑÐ½Ñ–Ñ‚ÑŒ ÐºÐ½Ð¾Ð¿ÐºÑƒ Ð½Ð¸Ð¶Ñ‡Ðµ.",
							restricted_device:					"ÐÐµ Ð²Ð´Ð°Ñ”Ñ‚ÑŒÑÑ ÐºÐµÑ€ÑƒÐ²Ð°Ñ‚Ð¸ Spotify Ð¿Ñ–Ð´ Ñ‡Ð°Ñ Ð²Ñ–Ð´Ñ‚Ð²Ð¾Ñ€ÐµÐ½Ð½Ñ Ð¼ÑƒÐ·Ð¸ÐºÐ¸ Ð½Ð° Ð¾Ð±Ð¼ÐµÐ¶ÐµÐ½Ð¾Ð¼Ñƒ Ð¿Ñ€Ð¸ÑÑ‚Ñ€Ð¾Ñ—",
							toast_copyurl_fail:					"URL-Ð°Ð´Ñ€ÐµÑÑƒ Ð¿Ñ–ÑÐ½Ñ– Ð½Ðµ Ð²Ð´Ð°Ð»Ð¾ÑÑ ÑÐºÐ¾Ð¿Ñ–ÑŽÐ²Ð°Ñ‚Ð¸ Ð² Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼Ñ–Ð½Ñƒ",
							toast_copyurl_success:				"URL-Ð°Ð´Ñ€ÐµÑÑƒ Ð¿Ñ–ÑÐ½Ñ– ÑÐºÐ¾Ð¿Ñ–Ð¹Ð¾Ð²Ð°Ð½Ð¾ Ð² Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼Ñ–Ð½Ñƒ"
						};
					case "vi":		// Vietnamese
						return {
							noaccount_header:					"ThiÃªu mÃ´Ì£t thÆ° gi Ä‘o",
							noaccount_subheader:				"Báº¡n cáº§n káº¿t ná»‘i TÃ i khoáº£n Spotify",
							noaccount_text:						"Báº¡n Ä‘ang thiáº¿u TÃ i khoáº£n Spotify Ä‘Æ°á»£c káº¿t ná»‘i, náº¿u khÃ´ng cÃ³ TÃ i khoáº£n, báº¡n sáº½ khÃ´ng thá»ƒ sá»­ dá»¥ng Spotify Controls. Äá»ƒ káº¿t ná»‘i TÃ i khoáº£n Spotify vá»›i TÃ i khoáº£n Discord cá»§a báº¡n, hÃ£y nháº¥p vÃ o nÃºt bÃªn dÆ°á»›i.",
							restricted_device:					"KhÃ´ng thá»ƒ Ä‘iá»u khiá»ƒn Spotify khi phÃ¡t Nháº¡c trÃªn Thiáº¿t bá»‹ bá»‹ háº¡n cháº¿",
							toast_copyurl_fail:					"KhÃ´ng thá»ƒ sao chÃ©p URL bÃ i hÃ¡t vÃ o khay nhá»› táº¡m",
							toast_copyurl_success:				"URL bÃ i hÃ¡t Ä‘Ã£ Ä‘Æ°á»£c sao chÃ©p vÃ o khay nhá»› táº¡m"
						};
					case "zh-CN":	// Chinese (China)
						return {
							noaccount_header:					"ç¼ºäº†ç‚¹ä»€ä¹ˆ",
							noaccount_subheader:				"æ‚¨éœ€è¦è¿žæŽ¥ä¸€ä¸ª Spotify å¸æˆ·",
							noaccount_text:						"æ‚¨ç¼ºå°‘å…³è”çš„ Spotify å¸æˆ·ï¼Œå¦‚æžœæ²¡æœ‰å¸æˆ·ï¼Œå°†æ— æ³•ä½¿ç”¨ Spotify Controlsã€‚è¦å°† Spotify å¸æˆ·ä¸Žæ‚¨çš„ Discord å¸æˆ·å…³è”ï¼Œè¯·å•å‡»ä¸‹é¢çš„æŒ‰é’®ã€‚",
							restricted_device:					"åœ¨å—é™è®¾å¤‡ä¸Šæ’­æ”¾éŸ³ä¹æ—¶æ— æ³•æŽ§åˆ¶ Spotify",
							toast_copyurl_fail:					"æ­Œæ›²ç½‘å€æ— æ³•å¤åˆ¶åˆ°å‰ªè´´æ¿",
							toast_copyurl_success:				"æ­Œæ›²ç½‘å€å·²å¤åˆ¶åˆ°å‰ªè´´æ¿"
						};
					case "zh-TW":	// Chinese (Taiwan)
						return {
							noaccount_header:					"ç¼ºäº†é»žä»€éº¼",
							noaccount_subheader:				"æ‚¨éœ€è¦é€£æŽ¥ä¸€å€‹ Spotify å¸³æˆ¶",
							noaccount_text:						"æ‚¨ç¼ºå°‘é—œè¯çš„ Spotify å¸³æˆ¶ï¼Œå¦‚æžœæ²’æœ‰å¸³æˆ¶ï¼Œå°‡ç„¡æ³•ä½¿ç”¨ Spotify Controlsã€‚è¦å°‡ Spotify å¸³æˆ¶èˆ‡æ‚¨çš„ Discord å¸³æˆ¶é—œè¯ï¼Œè«‹å–®æ“Šä¸‹é¢çš„æŒ‰éˆ•ã€‚",
							restricted_device:					"åœ¨å—é™è¨­å‚™ä¸Šæ’­æ”¾éŸ³æ¨‚æ™‚ç„¡æ³•æŽ§åˆ¶ Spotify",
							toast_copyurl_fail:					"æ­Œæ›²ç¶²å€ç„¡æ³•è¤‡è£½åˆ°å‰ªè²¼æ¿",
							toast_copyurl_success:				"æ­Œæ›²ç¶²å€å·²å¾©è£½åˆ°å‰ªè²¼æ¿"
						};
					default:		// English
						return {
							noaccount_header:					"Something is missing",
							noaccount_subheader:				"You need to connect a Spotify Account",
							noaccount_text:						"You are missing a connected Spotify Account, without an Account you won't be able to use Spotify Controls. To connect a Spotify Account with your Discord Account click the button below.",
							restricted_device:					"Can not control Spotify while playing Music on restricted Device",
							toast_copyurl_fail:					"Song URL could not be copied to clipboard",
							toast_copyurl_success:				"Song URL was copied to clipboard"
						};
				}
			}
		};
	})(window.BDFDB_Global.PluginUtils.buildPlugin(config));
})();
{
	"buttons": {
		"share": {
			"small": false,
			"big": true
		},
		"shuffle": {
			"small": false,
			"big": true
		},
		"previous": {
			"small": true,
			"big": true
		},
		"pauseplay": {
			"small": true,
			"big": true
		},
		"next": {
			"small": true,
			"big": true
		},
		"repeat": {
			"small": false,
			"big": true
		},
		"volume": {
			"small": false,
			"big": true
		}
	},
	"general": {
		"addTimeline": true,
		"addActivityButton": true,
		"doubleBack": true
	},
	"playerState": {
		"maximized": true
	}
}
/**
 * @name SpotifyControls
 * @author DevilBro
 * @authorId 278543574059057154
 * @version 1.1.4
 * @description Adds a Control Panel while listening to Spotify on a connected Account
 * @invite Jx3TjNS
 * @donate https://www.paypal.me/MircoWittrien
 * @patreon https://www.patreon.com/MircoWittrien
 * @website https://mwittrien.github.io/
 * @source https://github.com/mwittrien/BetterDiscordAddons/tree/master/Plugins/SpotifyControls/
 * @updateUrl https://mwittrien.github.io/BetterDiscordAddons/Plugins/SpotifyControls/SpotifyControls.plugin.js
 */

module.exports = (_ => {
	const config = {
		"info": {
			"name": "SpotifyControls",
			"author": "DevilBro",
			"version": "1.1.4",
			"description": "Adds a Control Panel while listening to Spotify on a connected Account"
		},
		"changeLog": {
			"fixed": {
				"No Cover": "No Cover is no longer black on dark theme"
			}
		}
	};

	return !window.BDFDB_Global || (!window.BDFDB_Global.loaded && !window.BDFDB_Global.started) ? class {
		getName () {return config.info.name;}
		getAuthor () {return config.info.author;}
		getVersion () {return config.info.version;}
		getDescription () {return `The Library Plugin needed for ${config.info.name} is missing. Open the Plugin Settings to download it. \n\n${config.info.description}`;}
		
		downloadLibrary () {
			require("request").get("https://mwittrien.github.io/BetterDiscordAddons/Library/0BDFDB.plugin.js", (e, r, b) => {
				if (!e && b && r.statusCode == 200) require("fs").writeFile(require("path").join(BdApi.Plugins.folder, "0BDFDB.plugin.js"), b, _ => BdApi.showToast("Finished downloading BDFDB Library", {type: "success"}));
				else BdApi.alert("Error", "Could not download BDFDB Library Plugin. Try again later or download it manually from GitHub: https://mwittrien.github.io/downloader/?library");
			});
		}
		
		load () {
			if (!window.BDFDB_Global || !Array.isArray(window.BDFDB_Global.pluginQueue)) window.BDFDB_Global = Object.assign({}, window.BDFDB_Global, {pluginQueue: []});
			if (!window.BDFDB_Global.downloadModal) {
				window.BDFDB_Global.downloadModal = true;
				BdApi.showConfirmationModal("Library Missing", `The Library Plugin needed for ${config.info.name} is missing. Please click "Download Now" to install it.`, {
					confirmText: "Download Now",
					cancelText: "Cancel",
					onCancel: _ => {delete window.BDFDB_Global.downloadModal;},
					onConfirm: _ => {
						delete window.BDFDB_Global.downloadModal;
						this.downloadLibrary();
					}
				});
			}
			if (!window.BDFDB_Global.pluginQueue.includes(config.info.name)) window.BDFDB_Global.pluginQueue.push(config.info.name);
		}
		start () {this.load();}
		stop () {}
		getSettingsPanel () {
			let template = document.createElement("template");
			template.innerHTML = `<div style="color: var(--header-primary); font-size: 16px; font-weight: 300; white-space: pre; line-height: 22px;">The Library Plugin needed for ${config.info.name} is missing.\nPlease click <a style="font-weight: 500;">Download Now</a> to install it.</div>`;
			template.content.firstElementChild.querySelector("a").addEventListener("click", this.downloadLibrary);
			return template.content.firstElementChild;
		}
	} : (([Plugin, BDFDB]) => {
		var _this;
		var controls;
		var starting, lastSong, currentVolume, lastVolume, stopTime, previousIsClicked, previousDoubleTimeout;
		var timelineTimeout, timelineDragging, updateInterval;
		var playbackState = {};
		
		const repeatStates = [
			"off",
			"context",
			"track"
		];
	
		const SpotifyControlsComponent = class SpotifyControls extends BdApi.React.Component {
			componentDidMount() {
				controls = this;
			}
			request(socket, device, type, data) {
				return new Promise(callback => {
					let method = "PUT";
					switch (type) {
						case "next":
						case "previous":
							method = "POST";
							break;
						case "get":
							type = "";
							method = "GET";
							break;
					};
					BDFDB.LibraryRequires.request({
						url: `https://api.spotify.com/v1/me/player${type ? "/" + type : ""}${Object.entries(Object.assign({}, data)).map(n => `?${n[0]}=${n[1]}`).join("")}`,
						method: method,
						headers: {
							authorization: `Bearer ${socket.accessToken}`
						}
					}, (error, response, result) => {
						if (response && response.statusCode == 401) {
							BDFDB.LibraryModules.SpotifyUtils.getAccessToken(socket.accountId).then(promiseResult => {
								let newSocketDevice = BDFDB.LibraryModules.SpotifyTrackUtils.getActiveSocketAndDevice();
								this.request(newSocketDevice.socket, newSocketDevice.device, type, data).then(_ => {
									try {callback(JSON.parse(result));}
									catch (err) {callback({});}
								});
							});
						}
						else {
							try {callback(JSON.parse(result));}
							catch (err) {callback({});}
						}
					});
				});
			}
			render() {
				let socketDevice = BDFDB.LibraryModules.SpotifyTrackUtils.getActiveSocketAndDevice();
				if (!socketDevice) return null;
				if (this.props.song) {
					playbackState.is_playing = true;
					let fetchState = !BDFDB.equals(this.props.song, lastSong);
					lastSong = this.props.song;
					stopTime = null;
					if (fetchState) this.request(socketDevice.socket, socketDevice.device, "get").then(response => {
						playbackState = Object.assign({}, response);
						BDFDB.ReactUtils.forceUpdate(this);
					});
				}
				else if (!stopTime && lastSong) {
					playbackState.is_playing = false;
					stopTime = new Date();
				}
				if (!lastSong) return null;
				currentVolume = socketDevice.device.volume_percent;
				let playerSize = this.props.maximized ? "big" : "small";
				let coverSrc = BDFDB.LibraryModules.AssetUtils.getAssetImage(lastSong.application_id, lastSong.assets.large_image);
				return BDFDB.ReactUtils.createElement("div", {
					className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN._spotifycontrolscontainer, this.props.maximized && BDFDB.disCN._spotifycontrolscontainermaximized, this.props.timeline && BDFDB.disCN._spotifycontrolscontainerwithtimeline),
					children: [
						BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.disCN._spotifycontrolscontainerinner,
							children: [
								BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Clickable, {
									className: BDFDB.disCN._spotifycontrolscoverwrapper,
									onClick: _ => {
										this.props.maximized = !this.props.maximized;
										BDFDB.DataUtils.save(this.props.maximized, _this, "playerState", "maximized");
										if (this.props.maximized) this.request(socketDevice.socket, socketDevice.device, "get").then(response => {
											playbackState = Object.assign({}, response);
											BDFDB.ReactUtils.forceUpdate(this);
										});
										else BDFDB.ReactUtils.forceUpdate(this);
									},
									children: [
										coverSrc ? BDFDB.ReactUtils.createElement("img", {
											className: BDFDB.disCN._spotifycontrolscover,
											src: coverSrc
										}) : BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SvgIcon, {
											className: BDFDB.disCN._spotifycontrolscover,
											width: "100%",
											height: "100%",
											name: BDFDB.LibraryComponents.SvgIcon.Names.QUESTIONMARK_ACTIVITY
										}),
										BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SvgIcon, {
											className: BDFDB.disCN._spotifycontrolscovermaximizer,
											name: BDFDB.LibraryComponents.SvgIcon.Names.LEFT_CARET
										})
									]
								}),
								BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN._spotifycontrolsdetails,
									children: [
										BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TextElement, {
											className: BDFDB.disCN._spotifycontrolssong,
											children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TextScroller, {
												children: lastSong.details
											})
										}),
										BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TextElement, {
											className: BDFDB.disCNS.subtext + BDFDB.disCN._spotifycontrolsinterpret,
											color: BDFDB.LibraryComponents.TextElement.Colors.CUSTOM,
											size: BDFDB.LibraryComponents.TextElement.Sizes.SIZE_12,
											children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TextScroller, {
												children: BDFDB.LanguageUtils.LanguageStringsFormat("USER_ACTIVITY_LISTENING_ARTISTS", lastSong.state)
											})
										})
									]
								}),
								BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TooltipContainer, {
									text: socketDevice.device.is_restricted ? _this.labels.restricted_device : null,
									tooltipConfig: {color: "red"},
									children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
										grow: 0,
										children: [
											BDFDB.ReactUtils.createElement(SpotifyControlsButtonComponent, {
												type: "share",
												playerSize: playerSize,
												style: this.props.maximized ? {marginRight: 4} : {},
												onClick: _ => {
													let url = BDFDB.ObjectUtils.get(playbackState, "item.external_urls.spotify") || BDFDB.ObjectUtils.get(playbackState, "context.external_urls.spotify");
													if (url) {
														BDFDB.LibraryRequires.electron.clipboard.write({text: url});
														BDFDB.NotificationUtils.toast(_this.labels.toast_copyurl_success, {type: "success"});
													}
													else BDFDB.NotificationUtils.toast(_this.labels.toast_copyurl_fail, {type: "danger"});
												}
											}),
											BDFDB.ReactUtils.createElement(SpotifyControlsButtonComponent, {
												type: "shuffle",
												playerSize: playerSize,
												active: playbackState.shuffle_state,
												disabled: socketDevice.device.is_restricted,
												onClick: _ => {
													playbackState.shuffle_state = !playbackState.shuffle_state;
													this.request(socketDevice.socket, socketDevice.device, "shuffle", {
														state: playbackState.shuffle_state
													});
													BDFDB.ReactUtils.forceUpdate(this);
												}
											}),
											BDFDB.ReactUtils.createElement(SpotifyControlsButtonComponent, {
												type: "previous",
												playerSize: playerSize,
												disabled: socketDevice.device.is_restricted,
												onClick: _ => {
													if (previousIsClicked || !_this.settings.general.doubleBack) {
														previousIsClicked = false;
														this.request(socketDevice.socket, socketDevice.device, "previous");
													}
													else {
														previousIsClicked = true;
														previousDoubleTimeout = BDFDB.TimeUtils.timeout(_ => {
															previousIsClicked = false;
															this.request(socketDevice.socket, socketDevice.device, "seek", {
																position_ms: 0
															});
														}, 300);
													}
												}
											}),
											BDFDB.ReactUtils.createElement(SpotifyControlsButtonComponent, {
												type: "pauseplay",
												playerSize: playerSize,
												icon: this.props.song ? 0 : 1,
												disabled: socketDevice.device.is_restricted,
												onClick: _ => {
													if (this.props.song) {
														playbackState.is_playing = false;
														this.request(socketDevice.socket, socketDevice.device, "pause");
													}
													else {
														playbackState.is_playing = true;
														this.request(socketDevice.socket, socketDevice.device, "play");
													}
												}
											}),
											BDFDB.ReactUtils.createElement(SpotifyControlsButtonComponent, {
												type: "next",
												playerSize: playerSize,
												disabled: socketDevice.device.is_restricted,
												onClick: _ => {
													this.request(socketDevice.socket, socketDevice.device, "next");
												}
											}),
											BDFDB.ReactUtils.createElement(SpotifyControlsButtonComponent, {
												type: "repeat",
												playerSize: playerSize,
												icon: playbackState.repeat_state != repeatStates[2] ? 0 : 1,
												active: playbackState.repeat_state != repeatStates[0],
												disabled: socketDevice.device.is_restricted,
												onClick: _ => {
													playbackState.repeat_state = repeatStates[repeatStates.indexOf(playbackState.repeat_state) + 1] || repeatStates[0];
													this.request(socketDevice.socket, socketDevice.device, "repeat", {
														state: playbackState.repeat_state
													});
													BDFDB.ReactUtils.forceUpdate(this);
												}
											}),
											BDFDB.ReactUtils.createElement(SpotifyControlsButtonComponent, {
												type: "volume",
												playerSize: playerSize,
												icon: Math.ceil(currentVolume/34),
												disabled: socketDevice.device.is_restricted,
												style: this.props.maximized ? {marginLeft: 4} : {},
												onContextMenu: _ => {
													if (currentVolume == 0) {
														if (lastVolume) this.request(socketDevice.socket, socketDevice.device, "volume", {
															volume_percent: lastVolume
														});
													}
													else {
														lastVolume = currentVolume;
														this.request(socketDevice.socket, socketDevice.device, "volume", {
															volume_percent: 0
														});
													}
												},
												renderPopout: instance => {
													return BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Slider, {
														className: BDFDB.disCN._spotifycontrolsvolumeslider,
														defaultValue: currentVolume,
														digits: 0,
														barStyles: {height: 6, top: 3},
														fillStyles: {backgroundColor: BDFDB.DiscordConstants.Colors.SPOTIFY},
														onValueRender: value => {
															return value + "%";
														},
														onValueChange: value => {
															currentVolume = value;
															this.request(socketDevice.socket, socketDevice.device, "volume", {
																volume_percent: currentVolume
															});
														}
													});
												}
											})
										].filter(n => n)
									})
								})
							]
						}),
						this.props.timeline && BDFDB.ReactUtils.createElement(SpotifyControlsTimelineComponent, {
							song: lastSong,
							socket: socketDevice.socket,
							device: socketDevice.device,
							controls: this
						})
					].filter(n => n)
				});
			}
		};
		const SpotifyControlsButtonComponent = class SpotifyControlsButton extends BdApi.React.Component {
			render() {
				if (!this.props.playerSize || !_this.settings.buttons[this.props.type] || !_this.settings.buttons[this.props.type][this.props.playerSize]) return null;
				let button = BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Button, BDFDB.ObjectUtils.exclude(Object.assign({}, this.props, {
					className: BDFDB.DOMUtils.formatClassName(BDFDB.disCN.accountinfobutton, this.props.disabled ? BDFDB.disCN.accountinfobuttondisabled : BDFDB.disCN.accountinfobuttonenabled, this.props.active && BDFDB.disCN._spotifycontrolsbuttonactive),
					look: BDFDB.LibraryComponents.Button.Looks.BLANK,
					size: BDFDB.LibraryComponents.Button.Sizes.NONE,
					children: _this.defaults.buttons[this.props.type] && _this.defaults.buttons[this.props.type].icons ? (_this.defaults.buttons[this.props.type].icons[this.props.icon] || _this.defaults.buttons[this.props.type].icons[0]) : "?",
					onClick: this.props.disabled ? _ => {} : this.props.onClick,
					onContextMenu: this.props.disabled ? _ => {} : this.props.onContextMenu,
				}), "active", "disabled", "renderPopout", "icon", "type", "playerSize"));
				return !this.props.disabled && typeof this.props.renderPopout == "function" ? BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.PopoutContainer, {
					children: button,
					animation: BDFDB.LibraryComponents.PopoutContainer.Animation.SCALE,
					position: BDFDB.LibraryComponents.PopoutContainer.Positions.TOP,
					align: BDFDB.LibraryComponents.PopoutContainer.Align.CENTER,
					arrow: true,
					shadow: true,
					renderPopout: this.props.renderPopout
				}) : button;
	}
		};
		const SpotifyControlsTimelineComponent = class SpotifyControlsTimeline extends BdApi.React.Component {
			componentDidMount() {
				BDFDB.TimeUtils.clear(updateInterval);
				updateInterval = BDFDB.TimeUtils.interval(_ => {
					if (!this.updater || typeof this.updater.isMounted != "function" || !this.updater.isMounted(this)) BDFDB.TimeUtils.clear(updateInterval);
					else if (playbackState.is_playing) {
						let song = BDFDB.LibraryModules.SpotifyTrackUtils.getActivity(false);
						if (!song) BDFDB.ReactUtils.forceUpdate(controls);
						else if (playbackState.is_playing) BDFDB.ReactUtils.forceUpdate(this);
					}
				}, 1000);
			}
			formatTime(time) {
				let seconds = Math.floor((time / 1000) % 60);
				let minutes = Math.floor((time / (1000 * 60)) % 60);
				let hours = Math.floor((time / (1000 * 60 * 60)) % 24);
				return `${hours > 0 ? hours + ":" : ""}${hours > 0 && minutes < 10 ? "0" + minutes : minutes}:${seconds < 10 ? "0" + seconds : seconds}`
			}
			render() {
				let maxTime = this.props.song.timestamps.end - this.props.song.timestamps.start;
				let currentTime = (!playbackState.is_playing && stopTime ? stopTime : new Date()) - this.props.song.timestamps.start;
				currentTime = currentTime > maxTime ? maxTime : currentTime;
				return BDFDB.ReactUtils.createElement("div", {
					className: BDFDB.disCN._spotifycontrolstimeline,
					children: [
						BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.disCN._spotifycontrolsbar,
							children: [
								BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN._spotifycontrolsbarfill,
									style: {width: `${currentTime / maxTime * 100}%`}
								}),
								BDFDB.ReactUtils.createElement("div", {
									className: BDFDB.disCN._spotifycontrolsbargrabber,
									style: {left: `${currentTime / maxTime * 100}%`}
								})
							],
							onClick: event => {
								let rects = BDFDB.DOMUtils.getRects(BDFDB.DOMUtils.getParent(BDFDB.dotCN._spotifycontrolsbar, event.target));
								this.props.controls.request(this.props.socket, this.props.device, "seek", {
									position_ms: Math.round(BDFDB.NumberUtils.mapRange([rects.left, rects.left + rects.width], [0, maxTime], event.clientX))
								});
							}
						}),
						BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.disCN._spotifycontrolsbartext,
							children: [
								BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TextElement, {
									className: BDFDB.disCN.height12,
									size: BDFDB.LibraryComponents.TextElement.Sizes.SIZE_12,
									children: this.formatTime(currentTime)
								}),
								BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TextElement, {
									className: BDFDB.disCN.height12,
									size: BDFDB.LibraryComponents.TextElement.Sizes.SIZE_12,
									children: this.formatTime(maxTime)
								})
							]
						})
					]
				});
			}
		};
	
		return class SpotifyControls extends Plugin {
			onLoad () {
				_this = this;
				
				this.defaults = {
					general: {
						addTimeline: 		{value: true,		description: "Show the Song Timeline in the Controls"},
						doubleBack: 		{value: true,       description: "Requires the User to press the Back Button twice to go to previous Track"}
					},
					buttons: {
						share: 				{value: {small: false, big: true},		icons: ["ï’"],						description: "Share"},
						shuffle: 			{value: {small: false, big: true},		icons: ["ï…„"],						description: "Shuffle"},
						previous: 			{value: {small: true, big: true},		icons: ["ï…†"],						description: "Previous"},
						pauseplay: 			{value: {small: true, big: true},		icons: ["ï„°", "ï„²"],					description: "Pause/Play"},
						next: 				{value: {small: true, big: true},		icons: ["ï…ˆ"],						description: "Next"},
						repeat: 			{value: {small: false, big: true},		icons: ["ï„¾", "ïˆ€"],					description: "Repeat"},
						volume: 			{value: {small: false, big: true},		icons: ["ï‡¯", "ïˆƒ", "ïˆ†", "ï…ž"],		description: "Volume"}
					}
				};
				
				this.patchedModules = {
					after: {
						AppView: "default"
					}
				};
				
				
				this.css = `
					@font-face {
						font-family: glue1-spoticon;
						src: url("https://mwittrien.github.io/BetterDiscordAddons/Plugins/SpotifyControls/_res/spoticon.ttf") format("truetype");
						font-weight: 400;
						font-style: normal
					}
					${BDFDB.dotCN._spotifycontrolscontainer} {
						display: flex;
						flex-direction: column;
						justify-content: center;
						min-height: 52px;
						margin-bottom: 1px;
						border-bottom: 1px solid var(--background-modifier-accent);
						padding: 0 8px;
						box-sizing: border-box;
					}
					${BDFDB.dotCN._spotifycontrolscontainer + BDFDB.dotCN._spotifycontrolscontainerwithtimeline} {
						padding-top: 8px;
					}
					${BDFDB.dotCN._spotifycontrolscontainerinner} {
						display: flex;
						align-items: center;
						font-size: 14px;
						width: 100%;
					}
					${BDFDB.dotCN._spotifycontrolstimeline} {
						margin: 6px 0 4px 0;
					}
					${BDFDB.dotCN._spotifycontrolsbar} {
						position: relative;
						border-radius: 2px;
						background-color: rgba(79, 84, 92, 0.16);
						height: 4px;
						margin-bottom: 4px;
					}
					${BDFDB.dotCN._spotifycontrolsbarfill} {
						border-radius: 2px;
						height: 100%;
						min-width: 4px;
						border-radius: 2px;
						background: var(--text-normal);
					}
					${BDFDB.dotCN._spotifycontrolstimeline}:hover ${BDFDB.dotCN._spotifycontrolsbarfill} {
						background: ${BDFDB.DiscordConstants.Colors.SPOTIFY};
					}
					${BDFDB.dotCN._spotifycontrolsbargrabber} {
						display: none;
						position: absolute;
						top: 0;
						left: 0;
						width: 8px;
						height: 8px;
						margin-top: -2px;
						margin-left: -2px;
						background: var(--text-normal);
						border-radius: 50%;
					}
					${BDFDB.dotCN._spotifycontrolstimeline}:hover ${BDFDB.dotCN._spotifycontrolsbargrabber} {
						display: block;
					}
					${BDFDB.dotCN._spotifycontrolsbartext} {
						display: flex;
						align-items: center;
						justify-content: space-between;
					}
					${BDFDB.dotCN._spotifycontrolscoverwrapper} {
						position: relative;
						width: 32px;
						min-width: 32px;
						height: 32px;
						min-height: 32px;
						margin-right: 8px;
						border-radius: 4px;
						overflow: hidden;
						transition: width .3s ease, height .3s ease;
					}
					${BDFDB.dotCN._spotifycontrolscover} {
						display: block;
						width: 100%;
						height: 100%;
						color: var(--header-primary);
						object-fit: cover;
					}
					${BDFDB.dotCN._spotifycontrolscovermaximizer} {
						visibility: hidden;
						position: absolute;
						background-color: rgba(0, 0, 0, 0.5);
						color: rgba(255, 255, 255, 0.5);
						top: 0;
						right: 0;
						border-radius: 50%;
						width: 12px;
						height: 12px;
						padding: 3px;
						transform: rotate(90deg);
						transition: width .3s ease, height .3s ease, transform .3s ease;
						pointer-events: none;
					}
					${BDFDB.dotCN._spotifycontrolscoverwrapper}:hover ${BDFDB.dotCN._spotifycontrolscovermaximizer} {
						visibility: visible;
					}
					${BDFDB.dotCN._spotifycontrolsdetails} {
						user-select: text;
						flex-grow: 1;
						margin-right: 4px;
						min-width: 0;
					}
					${BDFDB.dotCN._spotifycontrolssong} {
						font-weight: 500;
					}
					${BDFDB.dotCN._spotifycontrolsinterpret} {
						font-weight: 300;
					}
					${BDFDB.dotCN._spotifycontrolsvolumeslider} {
						height: 12px;
						width: 140px;
						margin: 5px;
					}
					${BDFDB.dotCNS._spotifycontrolsvolumeslider + BDFDB.dotCN.slidergrabber} {
						height: 10px;
						margin-top: -6px;
						border-radius: 50%;
					}
					${BDFDB.dotCNS._spotifycontrolscontainer + BDFDB.dotCN.accountinfobuttondisabled} {
						cursor: no-drop;
					}
					${BDFDB.dotCNS._spotifycontrolscontainer + BDFDB.dotCNS.accountinfobutton + BDFDB.dotCN.buttoncontents} {
						font-family: glue1-spoticon !important;
					}
					${BDFDB.dotCNS._spotifycontrolscontainer + BDFDB.dotCN.accountinfobutton + BDFDB.dotCN._spotifycontrolsbuttonactive} {
						color: ${BDFDB.DiscordConstants.Colors.SPOTIFY};
					}
					${BDFDB.dotCN._spotifycontrolscontainer + BDFDB.dotCN._spotifycontrolscontainermaximized} {
						padding-top: 0;
					}
					${BDFDB.dotCN._spotifycontrolscontainer + BDFDB.dotCNS._spotifycontrolscontainermaximized + BDFDB.dotCN._spotifycontrolscontainerinner} {
						flex-direction: column;
					}
					${BDFDB.dotCN._spotifycontrolscontainer + BDFDB.dotCNS._spotifycontrolscontainermaximized + BDFDB.dotCN._spotifycontrolsdetails} {
						margin: 0 0 4px 0;
						width: 100%;
						text-align: center;
					}
					${BDFDB.dotCN._spotifycontrolscontainer + BDFDB.dotCNS._spotifycontrolscontainermaximized + BDFDB.dotCN._spotifycontrolscoverwrapper} {
						width: calc(100% + 16px);
						height: 100%;
						margin: 0 0 8px 0;
						border-radius: 0;
					}
					${BDFDB.dotCN._spotifycontrolscontainer + BDFDB.dotCNS._spotifycontrolscontainermaximized + BDFDB.dotCN._spotifycontrolscovermaximizer} {
						top: 4px;
						right: 4px;
						width: 22px;
						height: 22px;
						padding: 5px;
						transform: rotate(-90deg);
					}
					${BDFDB.dotCN._spotifycontrolssettingsicon} {
						margin: 4px;
						font-size: 16px;
						font-family: glue1-spoticon !important;
					}
					${BDFDB.dotCN._spotifycontrolssettingslabel} {
						margin-left: 10px;
					}
					${BDFDB.dotCNS._bdminimalmode + BDFDB.dotCN._spotifycontrolsbar} {
						height: 3px;
					}
					${BDFDB.dotCNS._bdminimalmode + BDFDB.dotCNS._spotifycontrolscontainer + BDFDB.dotCN.accountinfobutton} {
						width: 26px;
						height: 26px;
					}
					${BDFDB.dotCNS._bdminimalmode + BDFDB.dotCNS._spotifycontrolscontainer + BDFDB.dotCN.size14} {
						font-size: 13px;
						line-height: 13px;
					}
					${BDFDB.dotCNS._bdminimalmode + BDFDB.dotCNS._spotifycontrolscontainer + BDFDB.dotCN.size12} {
						font-size: 11px;
						line-height: 11px;
					}
				`;
			}
			
			onStart () {
				// REMOVE 24.04.2021
				let oldData = BDFDB.DataUtils.load(this);
				if (oldData.settings) {
					this.settings.general = oldData.settings;
					BDFDB.DataUtils.save(this.settings.general, this, "general");
					BDFDB.DataUtils.remove(this, "settings");
				}
				if (oldData.buttonConfigs) {
					this.settings.buttons = oldData.buttonConfigs;
					BDFDB.DataUtils.save(this.settings.buttons, this, "buttons");
					BDFDB.DataUtils.remove(this, "buttonConfigs");
				}
				
				BDFDB.PatchUtils.patch(this, BDFDB.LibraryModules.SpotifyTrackUtils, "getActivity", {after: e => {
					if (e.methodArguments[0] !== false) {
						if (e.returnValue && e.returnValue.name == "Spotify") this.updatePlayer(e.returnValue);
						else if (!e.returnValue) this.updatePlayer(null);
					}
				}});

				BDFDB.PatchUtils.patch(this, BDFDB.LibraryModules.SpotifyTrackUtils, "wasAutoPaused", {instead: e => {
					return false;
				}});

				BDFDB.PatchUtils.patch(this, BDFDB.LibraryModules.SpotifyUtils, "pause", {instead: e => {
					return false;
				}});
				
				this.forceUpdateAll();
			}
			
			onStop () {
				this.forceUpdateAll();
			}

			getSettingsPanel (collapseStates = {}) {				
				let settingsPanel;
				return settingsPanel = BDFDB.PluginUtils.createSettingsPanel(this, {
					collapseStates: collapseStates,
					children: _ => {
						let settingsItems = [];
						
						if (!BDFDB.LibraryModules.SpotifyTrackUtils.hasConnectedAccount()) BDFDB.ModalUtils.open(this, {
							size: "SMALL",
							header: `${this.name}: ${this.labels.noaccount_header}...`,
							subHeader: this.labels.noaccount_subheader,
							text: this.labels.noaccount_text,
							buttons: [{
								contents: BDFDB.LanguageUtils.LanguageStrings.CONNECT,
								color: "BRAND",
								close: true,
								onClick: _ => BDFDB.LibraryModules.UserSettingsUtils.open(BDFDB.DiscordConstants.UserSettingsSections.CONNECTIONS)
							}]
						});
						
						settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.CollapseContainer, {
							title: "Settings",
							collapseStates: collapseStates,
							children: Object.keys(this.defaults.general).map(key => BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsSaveItem, {
								type: "Switch",
								plugin: this,
								keys: ["general", key],
								label: this.defaults.general[key].description,
								value: this.settings.general[key]
							}))
						}));
						
						settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.CollapseContainer, {
							title: "Button Settings",
							collapseStates: collapseStates,
							children: [BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.FormComponents.FormTitle, {
								className: BDFDB.disCN.marginbottom4,
								tag: BDFDB.LibraryComponents.FormComponents.FormTitle.Tags.H3,
								children: "Add control Buttons in small and/or big Player Version: "
							})].concat(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsList, {
								settings: Object.keys(this.defaults.buttons[Object.keys(this.defaults.buttons)[0]].value),
								data: Object.keys(this.defaults.buttons).map(key => Object.assign({}, this.settings.buttons[key], {
									key: key,
									label: this.defaults.buttons[key].description,
									icons: this.defaults.buttons[key].icons
								})),
								noRemove: true,
								renderLabel: data => BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
									align: BDFDB.LibraryComponents.Flex.Align.CENTER,
									children: [
										BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
											justify: BDFDB.LibraryComponents.Flex.Justify.CENTER,
											wrap: BDFDB.LibraryComponents.Flex.Wrap.WRAP,
											basis: 50,
											grow: 0,
											children: data.icons.map(icon => BDFDB.ReactUtils.createElement("div", {
												className: BDFDB.disCN._spotifycontrolssettingsicon,
												children: icon
											}))
										}),
										BDFDB.ReactUtils.createElement("div", {
											className: BDFDB.disCN._spotifycontrolssettingslabel,
											children: data.label
										})
									]
								}),
								onCheckboxChange: (value, instance) => {
									this.settings.buttons[instance.props.cardId][instance.props.settingId] = value;
									BDFDB.DataUtils.save(this.settings.buttons, this, "buttons");
									this.SettingsUpdated = true;
								}
							}))
						}));
						
						return settingsItems;
					}
				});
			}

			onSettingsClosed () {
				if (this.SettingsUpdated) {
					delete this.SettingsUpdated;
					this.forceUpdateAll();
				}
			}
		
			forceUpdateAll () {				
				BDFDB.PatchUtils.forceAllUpdates(this);
				BDFDB.DiscordUtils.rerenderAll();
			}

			processAppView (e) {
				let injected = this.injectPlayer(e.returnvalue);
				if (!injected) {
					let channels = BDFDB.ReactUtils.findChild(e.returnvalue, {name: "ChannelSidebar"});
					if (channels) {
						let type = channels.type;
						channels.type = (...args) => {
							let appliedType = type(...args);
							this.injectPlayer(appliedType);
							return appliedType;
						};
					}
				}
			}
			
			injectPlayer (parent) {
				let [children, index] = BDFDB.ReactUtils.findParent(parent, {props: [["section", BDFDB.DiscordConstants.AnalyticsSections.ACCOUNT_PANEL]]});
				if (index > -1) children.splice(index - 1, 0, BDFDB.ReactUtils.createElement(SpotifyControlsComponent, {
					song: BDFDB.LibraryModules.SpotifyTrackUtils.getActivity(false),
					maximized: BDFDB.DataUtils.load(this, "playerState", "maximized"),
					timeline: this.settings.general.addTimeline
				}, true));
				return index > -1;
			}
			
			updatePlayer (song) {
				if (controls) {
					controls.props.song = song;
					BDFDB.ReactUtils.forceUpdate(controls);
				}
			}

			setLabelsByLanguage () {
				switch (BDFDB.LanguageUtils.getLanguage().id) {
					case "bg":		// Bulgarian
						return {
							noaccount_header:					"ÐÐµÑ‰Ð¾ Ð»Ð¸Ð¿ÑÐ²Ð°",
							noaccount_subheader:				"Ð¢Ñ€ÑÐ±Ð²Ð° Ð´Ð° ÑÐ²ÑŠÑ€Ð¶ÐµÑ‚Ðµ Ð°ÐºÐ°ÑƒÐ½Ñ‚ Ð² Spotify",
							noaccount_text:						"Ð›Ð¸Ð¿ÑÐ²Ð° Ð²Ð¸ ÑÐ²ÑŠÑ€Ð·Ð°Ð½ Ð°ÐºÐ°ÑƒÐ½Ñ‚ Ð² Spotify, Ð±ÐµÐ· Ð°ÐºÐ°ÑƒÐ½Ñ‚ Ð½ÑÐ¼Ð° Ð´Ð° Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð´Ð° Ð¸Ð·Ð¿Ð¾Ð»Ð·Ð²Ð°Ñ‚Ðµ Spotify Controls. Ð—Ð° Ð´Ð° ÑÐ²ÑŠÑ€Ð¶ÐµÑ‚Ðµ Ð°ÐºÐ°ÑƒÐ½Ñ‚ Ð² Spotify Ñ Ð²Ð°ÑˆÐ¸Ñ Ð°ÐºÐ°ÑƒÐ½Ñ‚ Ð² Discord, ÐºÐ»Ð¸ÐºÐ½ÐµÑ‚Ðµ Ð²ÑŠÑ€Ñ…Ñƒ Ð±ÑƒÑ‚Ð¾Ð½Ð° Ð¿Ð¾-Ð´Ð¾Ð»Ñƒ.",
							restricted_device:					"ÐÐµ Ð¼Ð¾Ð¶Ðµ Ð´Ð° ÐºÐ¾Ð½Ñ‚Ñ€Ð¾Ð»Ð¸Ñ€Ð° Spotify, Ð´Ð¾ÐºÐ°Ñ‚Ð¾ Ð²ÑŠÐ·Ð¿Ñ€Ð¾Ð¸Ð·Ð²ÐµÐ¶Ð´Ð° Ð¼ÑƒÐ·Ð¸ÐºÐ° Ð½Ð° Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð¾ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ð¾",
							toast_copyurl_fail:					"URL Ð°Ð´Ñ€ÐµÑÑŠÑ‚ Ð½Ð° Ð¿ÐµÑÐµÐ½Ñ‚Ð° Ð½Ðµ Ð¼Ð¾Ð¶Ðµ Ð´Ð° Ð±ÑŠÐ´Ðµ ÐºÐ¾Ð¿Ð¸Ñ€Ð°Ð½ Ð² ÐºÐ»Ð¸Ð¿Ð±Ð¾Ñ€Ð´Ð°",
							toast_copyurl_success:				"URL Ð°Ð´Ñ€ÐµÑÑŠÑ‚ Ð½Ð° Ð¿ÐµÑÐµÐ½Ñ‚Ð° Ð±ÐµÑˆÐµ ÐºÐ¾Ð¿Ð¸Ñ€Ð°Ð½ Ð² ÐºÐ»Ð¸Ð¿Ð±Ð¾Ñ€Ð´Ð°"
						};
					case "da":		// Danish
						return {
							noaccount_header:					"Noget mangler",
							noaccount_subheader:				"Du skal oprette forbindelse til en Spotify-konto",
							noaccount_text:						"Du mangler en tilsluttet Spotify-konto, uden en konto kan du ikke bruge Spotify Controls. For at forbinde en Spotify-konto med din Discord-konto skal du klikke pÃ¥ knappen nedenfor.",
							restricted_device:					"Kan ikke kontrollere Spotify, mens du spiller musik pÃ¥ en begrÃ¦nset enhed",
							toast_copyurl_fail:					"Sang-URL kunne ikke kopieres til udklipsholderen",
							toast_copyurl_success:				"Sang-URL blev kopieret til udklipsholderen"
						};
					case "de":		// German
						return {
							noaccount_header:					"Etwas fehlt",
							noaccount_subheader:				"Sie mÃ¼ssen ein Spotify-Konto verbinden",
							noaccount_text:						"Ihnen fehlt ein verbundenes Spotify-Konto. Ohne ein Konto kÃ¶nnen Sie Spotify Controls nicht verwenden. Um ein Spotify-Konto mit Ihrem Discord-Konto zu verbinden, klicken Sie auf die SchaltflÃ¤che unten.",
							restricted_device:					"Spotify  kann nicht gesteuert werden, wÃ¤hrend Musik auf einem eingeschrÃ¤nkten GerÃ¤t abgespielt wird",
							toast_copyurl_fail:					"Die Song-URL konnte nicht in die Zwischenablage kopiert werden",
							toast_copyurl_success:				"Die Song-URL wurde in die Zwischenablage kopiert"
						};
					case "el":		// Greek
						return {
							noaccount_header:					"ÎšÎ¬Ï„Î¹ Î»ÎµÎ¯Ï€ÎµÎ¹",
							noaccount_subheader:				"Î ÏÎ­Ï€ÎµÎ¹ Î½Î± ÏƒÏ…Î½Î´Î­ÏƒÎµÏ„Îµ Î­Î½Î±Î½ Î»Î¿Î³Î±ÏÎ¹Î±ÏƒÎ¼ÏŒ Spotify",
							noaccount_text:						"Î›ÎµÎ¯Ï€ÎµÎ¹ Î­Î½Î±Ï‚ ÏƒÏ…Î½Î´ÎµÎ´ÎµÎ¼Î­Î½Î¿Ï‚ Î»Î¿Î³Î±ÏÎ¹Î±ÏƒÎ¼ÏŒÏ‚ Spotify, Ï‡Ï‰ÏÎ¯Ï‚ Î»Î¿Î³Î±ÏÎ¹Î±ÏƒÎ¼ÏŒ Î´ÎµÎ½ Î¸Î± Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï„Î¿ Spotify Controls. Î“Î¹Î± Î½Î± ÏƒÏ…Î½Î´Î­ÏƒÎµÏ„Îµ Î­Î½Î±Î½ Î»Î¿Î³Î±ÏÎ¹Î±ÏƒÎ¼ÏŒ Spotify Î¼Îµ Ï„Î¿Î½ Î»Î¿Î³Î±ÏÎ¹Î±ÏƒÎ¼ÏŒ ÏƒÎ±Ï‚ Discord ÎºÎ¬Î½Ï„Îµ ÎºÎ»Î¹Îº ÏƒÏ„Î¿ Ï€Î±ÏÎ±ÎºÎ¬Ï„Ï‰ ÎºÎ¿Ï…Î¼Ï€Î¯.",
							restricted_device:					"Î”ÎµÎ½ ÎµÎ¯Î½Î±Î¹ Î´Ï…Î½Î±Ï„Î® Î¿ Î­Î»ÎµÎ³Ï‡Î¿Ï‚ Ï„Î¿Ï… Spotify ÎºÎ±Ï„Î¬ Ï„Î·Î½ Î±Î½Î±Ï€Î±ÏÎ±Î³Ï‰Î³Î® Î¼Î¿Ï…ÏƒÎ¹ÎºÎ®Ï‚ ÏƒÎµ Ï€ÎµÏÎ¹Î¿ÏÎ¹ÏƒÎ¼Î­Î½Î· ÏƒÏ…ÏƒÎºÎµÏ…Î®",
							toast_copyurl_fail:					"Î”ÎµÎ½ Î®Ï„Î±Î½ Î´Ï…Î½Î±Ï„Î® Î· Î±Î½Ï„Î¹Î³ÏÎ±Ï†Î® Ï„Î¿Ï… URL Ï„ÏÎ±Î³Î¿Ï…Î´Î¹Î¿Ï ÏƒÏ„Î¿ Ï€ÏÏŒÏ‡ÎµÎ¹ÏÎ¿",
							toast_copyurl_success:				"Î— Î´Î¹ÎµÏÎ¸Ï…Î½ÏƒÎ· URL Ï„Î¿Ï… Ï„ÏÎ±Î³Î¿Ï…Î´Î¹Î¿Ï Î±Î½Ï„Î¹Î³ÏÎ¬Ï†Î·ÎºÎµ ÏƒÏ„Î¿ Ï€ÏÏŒÏ‡ÎµÎ¹ÏÎ¿"
						};
					case "es":		// Spanish
						return {
							noaccount_header:					"Algo falta",
							noaccount_subheader:				"Necesitas conectar una cuenta de Spotify",
							noaccount_text:						"Falta una cuenta de Spotify conectada, sin una cuenta no podrÃ¡ usar Spotify Controls. Para conectar una cuenta de Spotify con su cuenta de Discord, haga clic en el botÃ³n de abajo.",
							restricted_device:					"No se puede controlar Spotify mientras se reproduce mÃºsica en un dispositivo restringido",
							toast_copyurl_fail:					"No se pudo copiar la URL de la canciÃ³n al portapapeles",
							toast_copyurl_success:				"La URL de la canciÃ³n se copiÃ³ al portapapeles"
						};
					case "fi":		// Finnish
						return {
							noaccount_header:					"Jotain puuttuu",
							noaccount_subheader:				"Sinun on yhdistettÃ¤vÃ¤ Spotify-tili",
							noaccount_text:						"Sinulta puuttuu yhdistetty Spotify-tili. Ilman tiliÃ¤ et voi kÃ¤yttÃ¤Ã¤ Spotify Controls. YhdistÃ¤ Spotify-tili Discord-tili napsauttamalla alla olevaa painiketta.",
							restricted_device:					"Spotify Ã¤ ei voi hallita musiikkia toistettaessa rajoitetulla laitteella",
							toast_copyurl_fail:					"Kappaleen URL-osoitetta ei voitu kopioida leikepÃ¶ydÃ¤lle",
							toast_copyurl_success:				"Kappaleen URL-osoite kopioitiin leikepÃ¶ydÃ¤lle"
						};
					case "fr":		// French
						return {
							noaccount_header:					"Quelque chose manque",
							noaccount_subheader:				"Vous devez connecter un compte Spotify",
							noaccount_text:						"Il vous manque un compte Spotify connectÃ©, sans compte, vous ne pourrez pas utiliser Spotify Controls. Pour connecter un compte Spotify Ã  votre compte Discord, cliquez sur le bouton ci-dessous.",
							restricted_device:					"Impossible de contrÃ´ler Spotify lors de la lecture de musique sur un appareil restreint",
							toast_copyurl_fail:					"L'URL de la chanson n'a pas pu Ãªtre copiÃ©e dans le presse-papiers",
							toast_copyurl_success:				"L'URL de la chanson a Ã©tÃ© copiÃ©e dans le presse-papiers"
						};
					case "hr":		// Croatian
						return {
							noaccount_header:					"NeÅ¡to nedostaje",
							noaccount_subheader:				"Morate povezati Spotify raÄun",
							noaccount_text:						"Nedostaje vam povezani Spotify raÄun, bez raÄuna neÄ‡ete moÄ‡i koristiti Spotify Controls. Da biste povezali Spotify raÄun sa svojim Discord raÄunom, kliknite gumb u nastavku.",
							restricted_device:					"Ne moÅ¾e kontrolirati Spotify tijekom reprodukcije glazbe na ograniÄenom ureÄ‘aju",
							toast_copyurl_fail:					"URL pjesme nije se mogao kopirati u meÄ‘uspremnik",
							toast_copyurl_success:				"URL pjesme kopiran je u meÄ‘uspremnik"
						};
					case "hu":		// Hungarian
						return {
							noaccount_header:					"Valami hiÃ¡nyzik",
							noaccount_subheader:				"Csatlakoztatnia kell egy Spotify-fiÃ³kot",
							noaccount_text:						"HiÃ¡nyzik egy csatlakoztatott Spotify-fiÃ³k, fiÃ³k nÃ©lkÃ¼l nem fogja tudni hasznÃ¡lni a Spotify Controls szolgÃ¡ltatÃ¡st. Ha Spotify-fiÃ³kot szeretne Ã¶sszekapcsolni Discord-fiÃ³kot, kattintson az alÃ¡bbi gombra.",
							restricted_device:					"Nem lehet irÃ¡nyÃ­tani a Spotify szolgÃ¡ltatÃ¡st, mikÃ¶zben zenÃ©t jÃ¡tszik le korlÃ¡tozott eszkÃ¶zÃ¶n",
							toast_copyurl_fail:					"A dal URL-jÃ©t nem sikerÃ¼lt Ã¡tmÃ¡solni a vÃ¡gÃ³lapra",
							toast_copyurl_success:				"A dal URL-jÃ©t a vÃ¡gÃ³lapra mÃ¡solta"
						};
					case "it":		// Italian
						return {
							noaccount_header:					"Manca qualcosa",
							noaccount_subheader:				"Devi collegare un account Spotify",
							noaccount_text:						"Ti manca un account Spotify collegato, senza un account non sarai in grado di utilizzare Spotify Controls. Per collegare un account Spotify al tuo account Discord, fai clic sul pulsante in basso.",
							restricted_device:					"Non Ã¨ possibile controllare Spotify durante la riproduzione di musica su un dispositivo limitato",
							toast_copyurl_fail:					"L'URL del brano non puÃ² essere copiato negli appunti",
							toast_copyurl_success:				"L'URL del brano Ã¨ stato copiato negli appunti"
						};
					case "ja":		// Japanese
						return {
							noaccount_header:					"ä½•ã‹ãŒæ¬ ã‘ã¦ã„ã¾ã™",
							noaccount_subheader:				"Spotify ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’æŽ¥ç¶šã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™",
							noaccount_text:						"æŽ¥ç¶šã•ã‚Œã¦ã„ã‚‹ Spotify ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒãªã„ã¨ã€ Spotify Controls ã‚’ä½¿ç”¨ã§ãã¾ã›ã‚“ã€‚ Spotify ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ Discord ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã«æŽ¥ç¶šã™ã‚‹ã«ã¯ã€ä¸‹ã®ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚",
							restricted_device:					"åˆ¶é™ã•ã‚ŒãŸãƒ‡ãƒã‚¤ã‚¹ã§éŸ³æ¥½ã‚’å†ç”Ÿã—ã¦ã„ã‚‹é–“ã¯ Spotify ã‚’åˆ¶å¾¡ã§ãã¾ã›ã‚“",
							toast_copyurl_fail:					"æ›²ã®URLã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã§ãã¾ã›ã‚“ã§ã—ãŸ",
							toast_copyurl_success:				"æ›²ã®URLãŒã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã—ãŸ"
						};
					case "ko":		// Korean
						return {
							noaccount_header:					"ë¬´ì–¸ê°€ê°€ ë¹ ì¡Œì–´",
							noaccount_subheader:				"Spotify  ê³„ì •ì„ ì—°ê²°í•´ì•¼í•©ë‹ˆë‹¤",
							noaccount_text:						"ì—°ê²°ëœ Spotify ê³„ì •ì´ ì—†ìŠµë‹ˆë‹¤. ê³„ì •ì´ ì—†ìœ¼ë©´ Spotify Controls ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. Spotify ê³„ì •ì„ Discord ê³„ì •ê³¼ ì—°ê²°í•˜ë ¤ë©´ ì•„ëž˜ ë²„íŠ¼ì„ í´ë¦­í•˜ì„¸ìš”.",
							restricted_device:					"ì œí•œëœ ìž¥ì¹˜ì—ì„œ ìŒì•…ì„ ìž¬ìƒí•˜ëŠ” ë™ì•ˆ Spotify ë¥¼ ì œì–´ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
							toast_copyurl_fail:					"ë…¸ëž˜ URLì„ í´ë¦½ ë³´ë“œì— ë³µì‚¬ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.",
							toast_copyurl_success:				"ë…¸ëž˜ URLì´ í´ë¦½ ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤. "
						};
					case "lt":		// Lithuanian
						return {
							noaccount_header:					"KaÅ¾ko trÅ«ksta",
							noaccount_subheader:				"Turite prijungti â€ž Spotify â€œ paskyrÄ…",
							noaccount_text:						"TrÅ«ksta prijungtos â€ž Spotify â€œ paskyros, be paskyros negalÄ—site naudoti Spotify Controls. NorÄ—dami susieti â€ž Spotify â€œ paskyrÄ… su Discord paskyra, spustelÄ—kite toliau pateiktÄ… mygtukÄ….",
							restricted_device:					"Nepavyksta valdyti â€ž Spotify â€œ grojant muzikÄ… ribotame Ä¯renginyje",
							toast_copyurl_fail:					"Dainos URL nepavyko nukopijuoti Ä¯ iÅ¡karpinÄ™",
							toast_copyurl_success:				"Dainos URL buvo nukopijuotas Ä¯ iÅ¡karpinÄ™"
						};
					case "nl":		// Dutch
						return {
							noaccount_header:					"Er mist iets",
							noaccount_subheader:				"U moet een Spotify-account verbinden",
							noaccount_text:						"U mist een verbonden Spotify-account. Zonder account kunt u Spotify Controls niet gebruiken. Om een Spotify-account aan uw Discord-account te koppelen, klikt u op de onderstaande knop.",
							restricted_device:					"Kan Spotify niet bedienen tijdens het afspelen van muziek op een beperkt apparaat",
							toast_copyurl_fail:					"Nummer-URL kan niet naar klembord worden gekopieerd",
							toast_copyurl_success:				"Nummer-URL is naar klembord gekopieerd"
						};
					case "no":		// Norwegian
						return {
							noaccount_header:					"Noe mangler",
							noaccount_subheader:				"Du mÃ¥ koble til en Spotify-konto",
							noaccount_text:						"Du mangler en tilkoblet Spotify-konto, uten en konto kan du ikke bruke Spotify Controls. For Ã¥ koble en Spotify-konto til Discord-konto din, klikk pÃ¥ knappen nedenfor.",
							restricted_device:					"Kan ikke kontrollere Spotify mens du spiller musikk pÃ¥ begrenset enhet",
							toast_copyurl_fail:					"Sangens URL kunne ikke kopieres til utklippstavlen",
							toast_copyurl_success:				"Sang-URL ble kopiert til utklippstavlen"
						};
					case "pl":		// Polish
						return {
							noaccount_header:					"CzegoÅ› brakuje",
							noaccount_subheader:				"Musisz poÅ‚Ä…czyÄ‡ konto Spotify",
							noaccount_text:						"Brakuje poÅ‚Ä…czonego konta Spotify, bez konta nie bÄ™dziesz mÃ³gÅ‚ korzystaÄ‡ z Spotify Controls. Aby poÅ‚Ä…czyÄ‡ konto Spotify z kontem Discord, kliknij przycisk poniÅ¼ej.",
							restricted_device:					"Nie moÅ¼na sterowaÄ‡ Spotify podczas odtwarzania muzyki na urzÄ…dzeniu z ograniczeniami",
							toast_copyurl_fail:					"Nie udaÅ‚o siÄ™ skopiowaÄ‡ adresu URL utworu do schowka",
							toast_copyurl_success:				"URL utworu zostaÅ‚ skopiowany do schowka"
						};
					case "pt-BR":	// Portuguese (Brazil)
						return {
							noaccount_header:					"Algo estÃ¡ faltando",
							noaccount_subheader:				"VocÃª precisa conectar uma conta Spotify",
							noaccount_text:						"EstÃ¡ faltando uma conta Spotify conectada, sem uma conta vocÃª nÃ£o poderÃ¡ usar Spotify Controls. Para conectar uma conta Spotify Ã  sua conta Discord, clique no botÃ£o abaixo.",
							restricted_device:					"NÃ£o Ã© possÃ­vel controlar o Spotify enquanto reproduz mÃºsica em dispositivo restrito",
							toast_copyurl_fail:					"O URL da mÃºsica nÃ£o pÃ´de ser copiado para a Ã¡rea de transferÃªncia",
							toast_copyurl_success:				"O URL da mÃºsica foi copiado para a Ã¡rea de transferÃªncia"
						};
					case "ro":		// Romanian
						return {
							noaccount_header:					"Ceva lipseste",
							noaccount_subheader:				"Trebuie sÄƒ vÄƒ conectaÈ›i un cont Spotify",
							noaccount_text:						"VÄƒ lipseÈ™te un cont Spotify conectat, fÄƒrÄƒ un cont pe care nu Ã®l veÈ›i putea folosi Spotify Controls. Pentru a conecta un cont Spotify la contul dvs. Discord faceÈ›i clic pe butonul de mai jos.",
							restricted_device:					"Nu pot controla Spotify Ã®n timp ce redaÈ›i muzicÄƒ pe dispozitiv restricÈ›ionat",
							toast_copyurl_fail:					"Adresa URL a melodiei nu a putut fi copiatÄƒ Ã®n clipboard",
							toast_copyurl_success:				"Adresa URL a melodiei a fost copiatÄƒ Ã®n clipboard"
						};
					case "ru":		// Russian
						return {
							noaccount_header:					"Ð§Ñ‚Ð¾-Ñ‚Ð¾ Ð¿Ñ€Ð¾Ð¿Ð°Ð»Ð¾",
							noaccount_subheader:				"Ð’Ð°Ð¼ Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ð¾ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ ÑƒÑ‡ÐµÑ‚Ð½ÑƒÑŽ Ð·Ð°Ð¿Ð¸ÑÑŒ Spotify",
							noaccount_text:						"Ð£ Ð²Ð°Ñ Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²ÑƒÐµÑ‚ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð½Ð°Ñ ÑƒÑ‡ÐµÑ‚Ð½Ð°Ñ Ð·Ð°Ð¿Ð¸ÑÑŒ Spotify, Ð±ÐµÐ· Ð½ÐµÐµ Ð²Ñ‹ Ð½Ðµ ÑÐ¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Spotify Controls. Ð§Ñ‚Ð¾Ð±Ñ‹ ÑÐ²ÑÐ·Ð°Ñ‚ÑŒ ÑƒÑ‡ÐµÑ‚Ð½ÑƒÑŽ Ð·Ð°Ð¿Ð¸ÑÑŒ Spotify ÑÐ¾ ÑÐ²Ð¾ÐµÐ¹ ÑƒÑ‡ÐµÑ‚Ð½Ð¾Ð¹ Ð·Ð°Ð¿Ð¸ÑÑŒÑŽ Discord, Ð½Ð°Ð¶Ð¼Ð¸Ñ‚Ðµ ÐºÐ½Ð¾Ð¿ÐºÑƒ Ð½Ð¸Ð¶Ðµ.",
							restricted_device:					"ÐÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑƒÐ¿Ñ€Ð°Ð²Ð»ÑÑ‚ÑŒ Spotify Ð²Ð¾ Ð²Ñ€ÐµÐ¼Ñ Ð²Ð¾ÑÐ¿Ñ€Ð¾Ð¸Ð·Ð²ÐµÐ´ÐµÐ½Ð¸Ñ Ð¼ÑƒÐ·Ñ‹ÐºÐ¸ Ð½Ð° Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð½Ð¾Ð¼ ÑƒÑÑ‚Ñ€Ð¾Ð¹ÑÑ‚Ð²Ðµ",
							toast_copyurl_fail:					"URL-Ð°Ð´Ñ€ÐµÑ Ð¿ÐµÑÐ½Ð¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ ÑÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½ Ð² Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼ÐµÐ½Ð°",
							toast_copyurl_success:				"URL Ð¿ÐµÑÐ½Ð¸ ÑÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ð½ Ð² Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼ÐµÐ½Ð°"
						};
					case "sv":		// Swedish
						return {
							noaccount_header:					"NÃ¥got saknas",
							noaccount_subheader:				"Du mÃ¥ste ansluta ett Spotify-konto",
							noaccount_text:						"Du saknar ett anslutet Spotify-konto utan ett konto kan du inte anvÃ¤nda Spotify Controls. FÃ¶r att ansluta ett Spotify-konto till ditt Discord-konto, klicka pÃ¥ knappen nedan.",
							restricted_device:					"Kan inte styra Spotify nÃ¤r du spelar musik pÃ¥ en begrÃ¤nsad enhet",
							toast_copyurl_fail:					"LÃ¥tens URL kunde inte kopieras till Urklipp",
							toast_copyurl_success:				"LÃ¥tens URL kopierades till Urklipp"
						};
					case "th":		// Thai
						return {
							noaccount_header:					"à¸¡à¸µà¸šà¸²à¸‡à¸­à¸¢à¹ˆà¸²à¸‡à¸«à¸²à¸¢à¹„à¸›",
							noaccount_subheader:				"à¸„à¸¸à¸“à¸•à¹‰à¸­à¸‡à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¸šà¸±à¸à¸Šà¸µ Spotify",
							noaccount_text:						"à¸„à¸¸à¸“à¹„à¸¡à¹ˆà¸¡à¸µà¸šà¸±à¸à¸Šà¸µ Spotify à¸—à¸µà¹ˆà¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¸«à¸²à¸à¹„à¸¡à¹ˆà¸¡à¸µà¸šà¸±à¸à¸Šà¸µà¸„à¸¸à¸“à¸ˆà¸°à¹„à¸¡à¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¹ƒà¸Šà¹‰ Spotify Controls à¹„à¸”à¹‰à¸«à¸²à¸à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¹€à¸Šà¸·à¹ˆà¸­à¸¡à¸•à¹ˆà¸­à¸šà¸±à¸à¸Šà¸µ Spotify à¸à¸±à¸šà¸šà¸±à¸à¸Šà¸µ Discord à¸‚à¸­à¸‡à¸„à¸¸à¸“à¹ƒà¸«à¹‰à¸„à¸¥à¸´à¸à¸›à¸¸à¹ˆà¸¡à¸”à¹‰à¸²à¸™à¸¥à¹ˆà¸²à¸‡",
							restricted_device:					"à¹„à¸¡à¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¸„à¸§à¸šà¸„à¸¸à¸¡ Spotify à¸‚à¸“à¸°à¹€à¸¥à¹ˆà¸™à¹€à¸žà¸¥à¸‡à¸šà¸™à¸­à¸¸à¸›à¸à¸£à¸“à¹Œà¸—à¸µà¹ˆ à¸ˆà¸³à¸à¸±à¸”",
							toast_copyurl_fail:					"à¹„à¸¡à¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¸„à¸±à¸”à¸¥à¸­à¸ URL à¸‚à¸­à¸‡à¹€à¸žà¸¥à¸‡à¹„à¸›à¸¢à¸±à¸‡à¸„à¸¥à¸´à¸›à¸šà¸­à¸£à¹Œà¸”",
							toast_copyurl_success:				"à¸„à¸±à¸”à¸¥à¸­à¸ URL à¸‚à¸­à¸‡à¹€à¸žà¸¥à¸‡à¹„à¸›à¸¢à¸±à¸‡à¸„à¸¥à¸´à¸›à¸šà¸­à¸£à¹Œà¸”à¹à¸¥à¹‰à¸§"
						};
					case "tr":		// Turkish
						return {
							noaccount_header:					"Bir ÅŸey eksik",
							noaccount_subheader:				"Spotify  HesabÄ± baÄŸlamanÄ±z gerekiyor",
							noaccount_text:						"BaÄŸlÄ± bir Spotify HesabÄ±nÄ±z yok, bir Hesap olmadan Spotify Controls kullanamazsÄ±nÄ±z. Bir Spotify HesabÄ±nÄ± Discord HesabÄ±nÄ±za baÄŸlamak iÃ§in aÅŸaÄŸÄ±daki dÃ¼ÄŸmeyi tÄ±klayÄ±n.",
							restricted_device:					"KÄ±sÄ±tlÄ± Cihazda MÃ¼zik Ã§alarken Spotify 'Ä± kontrol edemez",
							toast_copyurl_fail:					"ÅžarkÄ± URL'si panoya kopyalanamadÄ±",
							toast_copyurl_success:				"ÅžarkÄ± URL'si panoya kopyalandÄ±"
						};
					case "uk":		// Ukrainian
						return {
							noaccount_header:					"Ð©Ð¾ÑÑŒ Ð½Ðµ Ð²Ð¸ÑÑ‚Ð°Ñ‡Ð°Ñ”",
							noaccount_subheader:				"Ð’Ð°Ð¼ Ð¿Ð¾Ñ‚Ñ€Ñ–Ð±Ð½Ð¾ Ð¿Ñ–Ð´ÐºÐ»ÑŽÑ‡Ð¸Ñ‚Ð¸ Ð°ÐºÐ°ÑƒÐ½Ñ‚ Spotify",
							noaccount_text:						"Ð£ Ð²Ð°Ñ Ð²Ñ–Ð´ÑÑƒÑ‚Ð½Ñ–Ð¹ Ð¿Ñ–Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ð¹ Ð¾Ð±Ð»Ñ–ÐºÐ¾Ð²Ð¸Ð¹ Ð·Ð°Ð¿Ð¸Ñ Spotify, Ð±ÐµÐ· ÑÐºÐ¾Ð³Ð¾ Ð²Ð¸ Ð½Ðµ Ð·Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð²Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð¾Ð²ÑƒÐ²Ð°Ñ‚Ð¸ Spotify Controls. Ð©Ð¾Ð± Ð¿Ñ–Ð´ÐºÐ»ÑŽÑ‡Ð¸Ñ‚Ð¸ Ð¾Ð±Ð»Ñ–ÐºÐ¾Ð²Ð¸Ð¹ Ð·Ð°Ð¿Ð¸Ñ Spotify Ð´Ð¾ ÑÐ²Ð¾Ð³Ð¾ Ð¾Ð±Ð»Ñ–ÐºÐ¾Ð²Ð¾Ð³Ð¾ Ð·Ð°Ð¿Ð¸ÑÑƒ Discord, Ð½Ð°Ñ‚Ð¸ÑÐ½Ñ–Ñ‚ÑŒ ÐºÐ½Ð¾Ð¿ÐºÑƒ Ð½Ð¸Ð¶Ñ‡Ðµ.",
							restricted_device:					"ÐÐµ Ð²Ð´Ð°Ñ”Ñ‚ÑŒÑÑ ÐºÐµÑ€ÑƒÐ²Ð°Ñ‚Ð¸ Spotify Ð¿Ñ–Ð´ Ñ‡Ð°Ñ Ð²Ñ–Ð´Ñ‚Ð²Ð¾Ñ€ÐµÐ½Ð½Ñ Ð¼ÑƒÐ·Ð¸ÐºÐ¸ Ð½Ð° Ð¾Ð±Ð¼ÐµÐ¶ÐµÐ½Ð¾Ð¼Ñƒ Ð¿Ñ€Ð¸ÑÑ‚Ñ€Ð¾Ñ—",
							toast_copyurl_fail:					"URL-Ð°Ð´Ñ€ÐµÑÑƒ Ð¿Ñ–ÑÐ½Ñ– Ð½Ðµ Ð²Ð´Ð°Ð»Ð¾ÑÑ ÑÐºÐ¾Ð¿Ñ–ÑŽÐ²Ð°Ñ‚Ð¸ Ð² Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼Ñ–Ð½Ñƒ",
							toast_copyurl_success:				"URL-Ð°Ð´Ñ€ÐµÑÑƒ Ð¿Ñ–ÑÐ½Ñ– ÑÐºÐ¾Ð¿Ñ–Ð¹Ð¾Ð²Ð°Ð½Ð¾ Ð² Ð±ÑƒÑ„ÐµÑ€ Ð¾Ð±Ð¼Ñ–Ð½Ñƒ"
						};
					case "vi":		// Vietnamese
						return {
							noaccount_header:					"ThiÃªu mÃ´Ì£t thÆ° gi Ä‘o",
							noaccount_subheader:				"Báº¡n cáº§n káº¿t ná»‘i TÃ i khoáº£n Spotify",
							noaccount_text:						"Báº¡n Ä‘ang thiáº¿u TÃ i khoáº£n Spotify Ä‘Æ°á»£c káº¿t ná»‘i, náº¿u khÃ´ng cÃ³ TÃ i khoáº£n, báº¡n sáº½ khÃ´ng thá»ƒ sá»­ dá»¥ng Spotify Controls. Äá»ƒ káº¿t ná»‘i TÃ i khoáº£n Spotify vá»›i TÃ i khoáº£n Discord cá»§a báº¡n, hÃ£y nháº¥p vÃ o nÃºt bÃªn dÆ°á»›i.",
							restricted_device:					"KhÃ´ng thá»ƒ Ä‘iá»u khiá»ƒn Spotify khi phÃ¡t Nháº¡c trÃªn Thiáº¿t bá»‹ bá»‹ háº¡n cháº¿",
							toast_copyurl_fail:					"KhÃ´ng thá»ƒ sao chÃ©p URL bÃ i hÃ¡t vÃ o khay nhá»› táº¡m",
							toast_copyurl_success:				"URL bÃ i hÃ¡t Ä‘Ã£ Ä‘Æ°á»£c sao chÃ©p vÃ o khay nhá»› táº¡m"
						};
					case "zh-CN":	// Chinese (China)
						return {
							noaccount_header:					"ç¼ºäº†ç‚¹ä»€ä¹ˆ",
							noaccount_subheader:				"æ‚¨éœ€è¦è¿žæŽ¥ä¸€ä¸ª Spotify å¸æˆ·",
							noaccount_text:						"æ‚¨ç¼ºå°‘å…³è”çš„ Spotify å¸æˆ·ï¼Œå¦‚æžœæ²¡æœ‰å¸æˆ·ï¼Œå°†æ— æ³•ä½¿ç”¨ Spotify Controlsã€‚è¦å°† Spotify å¸æˆ·ä¸Žæ‚¨çš„ Discord å¸æˆ·å…³è”ï¼Œè¯·å•å‡»ä¸‹é¢çš„æŒ‰é’®ã€‚",
							restricted_device:					"åœ¨å—é™è®¾å¤‡ä¸Šæ’­æ”¾éŸ³ä¹æ—¶æ— æ³•æŽ§åˆ¶ Spotify",
							toast_copyurl_fail:					"æ­Œæ›²ç½‘å€æ— æ³•å¤åˆ¶åˆ°å‰ªè´´æ¿",
							toast_copyurl_success:				"æ­Œæ›²ç½‘å€å·²å¤åˆ¶åˆ°å‰ªè´´æ¿"
						};
					case "zh-TW":	// Chinese (Taiwan)
						return {
							noaccount_header:					"ç¼ºäº†é»žä»€éº¼",
							noaccount_subheader:				"æ‚¨éœ€è¦é€£æŽ¥ä¸€å€‹ Spotify å¸³æˆ¶",
							noaccount_text:						"æ‚¨ç¼ºå°‘é—œè¯çš„ Spotify å¸³æˆ¶ï¼Œå¦‚æžœæ²’æœ‰å¸³æˆ¶ï¼Œå°‡ç„¡æ³•ä½¿ç”¨ Spotify Controlsã€‚è¦å°‡ Spotify å¸³æˆ¶èˆ‡æ‚¨çš„ Discord å¸³æˆ¶é—œè¯ï¼Œè«‹å–®æ“Šä¸‹é¢çš„æŒ‰éˆ•ã€‚",
							restricted_device:					"åœ¨å—é™è¨­å‚™ä¸Šæ’­æ”¾éŸ³æ¨‚æ™‚ç„¡æ³•æŽ§åˆ¶ Spotify",
							toast_copyurl_fail:					"æ­Œæ›²ç¶²å€ç„¡æ³•è¤‡è£½åˆ°å‰ªè²¼æ¿",
							toast_copyurl_success:				"æ­Œæ›²ç¶²å€å·²å¾©è£½åˆ°å‰ªè²¼æ¿"
						};
					default:		// English
						return {
							noaccount_header:					"Something is missing",
							noaccount_subheader:				"You need to connect a Spotify Account",
							noaccount_text:						"You are missing a connected Spotify Account, without an Account you won't be able to use Spotify Controls. To connect a Spotify Account with your Discord Account click the button below.",
							restricted_device:					"Can not control Spotify while playing Music on restricted Device",
							toast_copyurl_fail:					"Song URL could not be copied to clipboard",
							toast_copyurl_success:				"Song URL was copied to clipboard"
						};
				}
			}
		};
	})(window.BDFDB_Global.PluginUtils.buildPlugin(config));
})();
{
	"blacklist": [],
	"categorydata": [],
	"settings": {
		"sortNative": true,
		"showText": true,
		"showVoice": true,
		"showAnnouncement": true,
		"showStore": true,
		"showVoiceUsers": true,
		"alwaysCollapse": false,
		"showForNormal": true
	}
}
{
	"amounts": {
		"tooltipDelay": 0,
		"tooltipWidth": 300
	},
	"colors": {
		"tooltipColor": ""
	},
	"dates": {
		"tooltipDates": {}
	},
	"items": {
		"icon": true,
		"owner": true,
		"creationDate": true,
		"joinDate": true,
		"members": true,
		"channels": true,
		"roles": true,
		"boosters": true,
		"region": true
	}
}
/**
 * @name ServerDetails
 * @author DevilBro
 * @authorId 278543574059057154
 * @version 1.0.5
 * @description Shows Server Details in the Server List Tooltip
 * @invite Jx3TjNS
 * @donate https://www.paypal.me/MircoWittrien
 * @patreon https://www.patreon.com/MircoWittrien
 * @website https://mwittrien.github.io/
 * @source https://github.com/mwittrien/BetterDiscordAddons/tree/master/Plugins/ServerDetails/
 * @updateUrl https://mwittrien.github.io/BetterDiscordAddons/Plugins/ServerDetails/ServerDetails.plugin.js
 */

module.exports = (_ => {
	const config = {
		"info": {
			"name": "ServerDetails",
			"author": "DevilBro",
			"version": "1.0.5",
			"description": "Shows Server Details in the Server List Tooltip"
		},
		"changeLog": {
			"improved": {
				"New Settings": "Changed the Settings Panel for the Plugin, some Settings got reset sowwy ~w~"
			}
		}
	};

	return !window.BDFDB_Global || (!window.BDFDB_Global.loaded && !window.BDFDB_Global.started) ? class {
		getName () {return config.info.name;}
		getAuthor () {return config.info.author;}
		getVersion () {return config.info.version;}
		getDescription () {return `The Library Plugin needed for ${config.info.name} is missing. Open the Plugin Settings to download it. \n\n${config.info.description}`;}
		
		downloadLibrary () {
			require("request").get("https://mwittrien.github.io/BetterDiscordAddons/Library/0BDFDB.plugin.js", (e, r, b) => {
				if (!e && b && r.statusCode == 200) require("fs").writeFile(require("path").join(BdApi.Plugins.folder, "0BDFDB.plugin.js"), b, _ => BdApi.showToast("Finished downloading BDFDB Library", {type: "success"}));
				else BdApi.alert("Error", "Could not download BDFDB Library Plugin. Try again later or download it manually from GitHub: https://mwittrien.github.io/downloader/?library");
			});
		}
		
		load () {
			if (!window.BDFDB_Global || !Array.isArray(window.BDFDB_Global.pluginQueue)) window.BDFDB_Global = Object.assign({}, window.BDFDB_Global, {pluginQueue: []});
			if (!window.BDFDB_Global.downloadModal) {
				window.BDFDB_Global.downloadModal = true;
				BdApi.showConfirmationModal("Library Missing", `The Library Plugin needed for ${config.info.name} is missing. Please click "Download Now" to install it.`, {
					confirmText: "Download Now",
					cancelText: "Cancel",
					onCancel: _ => {delete window.BDFDB_Global.downloadModal;},
					onConfirm: _ => {
						delete window.BDFDB_Global.downloadModal;
						this.downloadLibrary();
					}
				});
			}
			if (!window.BDFDB_Global.pluginQueue.includes(config.info.name)) window.BDFDB_Global.pluginQueue.push(config.info.name);
		}
		start () {this.load();}
		stop () {}
		getSettingsPanel () {
			let template = document.createElement("template");
			template.innerHTML = `<div style="color: var(--header-primary); font-size: 16px; font-weight: 300; white-space: pre; line-height: 22px;">The Library Plugin needed for ${config.info.name} is missing.\nPlease click <a style="font-weight: 500;">Download Now</a> to install it.</div>`;
			template.content.firstElementChild.querySelector("a").addEventListener("click", this.downloadLibrary);
			return template.content.firstElementChild;
		}
	} : (([Plugin, BDFDB]) => {
		var _this;
	
		const GuildDetailsComponent = class GuildDetails extends BdApi.React.Component {
			constructor(props) {
				super(props);
				this.state = {fetchedOwner: false, delayed: false, repositioned: false};
			}
			componentDidUpdate() {
				if (_this.settings.amounts.tooltipDelay && this.state.delayed && !this.state.repositioned) {
					this.state.repositioned = true;
					if (this.props.tooltipContainer && this.props.tooltipContainer.tooltip) this.props.tooltipContainer.tooltip.update();
				}
			}
			render() {
				if (_this.settings.amounts.tooltipDelay && !this.state.delayed) {
					BDFDB.TimeUtils.timeout(_ => {
						this.state.delayed = true;
						if (this.props.tooltipContainer && this.props.tooltipContainer.tooltip) BDFDB.DOMUtils.addClass(this.props.tooltipContainer.tooltip.firstElementChild, BDFDB.disCN._serverdetailstooltip);
						BDFDB.ReactUtils.forceUpdate(this);
					}, _this.settings.amounts.tooltipDelay * 1000);
					return null;
				}
				let owner = BDFDB.LibraryModules.UserStore.getUser(this.props.guild.ownerId);
				if (!owner && !this.state.fetchedOwner) {
					this.state.fetchedOwner = true;
					BDFDB.LibraryModules.UserFetchUtils.getUser(this.props.guild.ownerId).then(_ => BDFDB.ReactUtils.forceUpdate(this));
				}
				let src = this.props.guild.getIconURL(BDFDB.LibraryModules.IconUtils.hasAnimatedGuildIcon(this.props.guild) ? "gif" : "png");
				return BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Flex, {
					direction: BDFDB.LibraryComponents.Flex.Direction.VERTICAL,
					align: BDFDB.LibraryComponents.Flex.Align.CENTER,
					children: [
						_this.settings.items.icon && (src ? BDFDB.ReactUtils.createElement("img", {
							className: BDFDB.disCN._serverdetailsicon,
							src: src.replace(/\?size\=\d+$/, "?size=4096").replace(/[\?\&](height|width)=\d+/g, "")
						}) : BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.disCN._serverdetailsicon,
							children: this.props.guild.acronym
						})),
						_this.settings.items.owner && BDFDB.ReactUtils.createElement(GuildDetailsRowComponent, {
							prefix: BDFDB.LanguageUtils.LanguageStrings.GUILD_OWNER,
							string: `${owner ? owner.username : "Unknown"}#${owner ? owner.discriminator : "0000"}`
						}),
						_this.settings.items.creationDate && BDFDB.ReactUtils.createElement(GuildDetailsRowComponent, {
							prefix: _this.labels.creation_date,
							string: BDFDB.LibraryComponents.DateInput.format(_this.settings.dates.tooltipDates, BDFDB.LibraryModules.TimestampUtils.extractTimestamp(this.props.guild.id))
						}),
						_this.settings.items.joinDate && BDFDB.ReactUtils.createElement(GuildDetailsRowComponent, {
							prefix: _this.labels.join_date,
							string: BDFDB.LibraryComponents.DateInput.format(_this.settings.dates.tooltipDates, this.props.guild.joinedAt)
						}),
						_this.settings.items.members && BDFDB.ReactUtils.createElement(GuildDetailsRowComponent, {
							prefix: BDFDB.LanguageUtils.LanguageStrings.MEMBERS,
							string: BDFDB.LibraryModules.MemberCountUtils.getMemberCount(this.props.guild.id)
						}),
						_this.settings.items.boosters && BDFDB.ReactUtils.createElement(GuildDetailsRowComponent, {
							prefix: _this.labels.boosters,
							string: this.props.guild.premiumSubscriberCount
						}),
						_this.settings.items.channels && BDFDB.ReactUtils.createElement(GuildDetailsRowComponent, {
							prefix: BDFDB.LanguageUtils.LanguageStrings.CHANNELS,
							string: BDFDB.LibraryModules.GuildChannelStore.getChannels(this.props.guild.id).count
						}),
						_this.settings.items.roles && BDFDB.ReactUtils.createElement(GuildDetailsRowComponent, {
							prefix: BDFDB.LanguageUtils.LanguageStrings.ROLES,
							string: Object.keys(this.props.guild.roles).length
						}),
						_this.settings.items.region && BDFDB.ReactUtils.createElement(GuildDetailsRowComponent, {
							prefix: BDFDB.LanguageUtils.LanguageStrings.REGION,
							string: this.props.guild.region
						})
					].flat(10).filter(n => n)
				});
			}
		};
		
		const GuildDetailsRowComponent = class GuildDetailsRow extends BdApi.React.Component {
			render() {
				return (this.props.prefix.length + this.props.string.length) > Math.round(34 * (_this.settings.amounts.tooltipWidth/300)) ? [
					BDFDB.ReactUtils.createElement("div", {
						children: `${this.props.prefix}:`
					}),
					BDFDB.ReactUtils.createElement("div", {
						children: this.props.string
					})
				] : BDFDB.ReactUtils.createElement("div", {
					children: `${this.props.prefix}: ${this.props.string}`
				});
			}
		};
		
		return class ServerDetails extends Plugin {
			onLoad () {
				_this = this;
				
				this.defaults = {
					items: {
						icon:				{value: true, 	description: "GUILD_CREATE_UPLOAD_ICON_LABEL"},
						owner:				{value: true, 	description: "GUILD_OWNER"},
						creationDate:		{value: true, 	description: "creation_date"},
						joinDate:			{value: true, 	description: "join_date"},
						members:			{value: true, 	description: "MEMBERS"},
						channels:			{value: true, 	description: "CHANNELS"},
						roles:				{value: true, 	description: "ROLES"},
						boosters:			{value: true, 	description: "boosters"},
						region:				{value: true, 	description: "REGION"}
					},
					dates: {
						tooltipDates:		{value: {}, 	description: "Tooltip Dates"}
					},
					colors: {
						tooltipColor:		{value: "", 	description: "Tooltip Color"}
					},
					amounts: {
						tooltipDelay:		{value: 0,		min: 0,		max: 10,	digits: 1,	unit: "s",	description: "Tooltip Delay"},
						tooltipWidth:		{value: 300,	min: 200,	max: 600,	digits: 0,	unit: "px",	description: "Tooltip Width"}
					}
				};
			
				this.patchedModules = {
					after: {
						Guild: "render"
					}
				};
				
				this.patchPriority = 9;
				
				this.css = `
					${BDFDB.dotCNS._serverdetailstooltip + BDFDB.dotCN.tooltipcontent} {
						display: flex;
						flex-direction: column;
						justify-content: center;
						align-items: center;
					}
					${BDFDB.dotCNS._serverdetailstooltip + BDFDB.dotCN._serverdetailsicon} {
						display: flex;
						justify-content: center;
						align-items: center;
						margin-bottom: 5px;
						border-radius: 10px;
						overflow: hidden;
					}
					${BDFDB.dotCN._serverdetailstooltip} div${BDFDB.dotCN._serverdetailsicon} {
						background-color: var(--background-primary);
						color: var(--text-normal);
						font-size: 40px;
					}
				`;
			}
			
			onStart () {
				BDFDB.PatchUtils.patch(this, BDFDB.LibraryComponents.GuildComponents.Guild.prototype, "render", {after: e => {
					this.processGuild({instance: e.thisObject, returnvalue: e.returnValue, methodname: "render"});
				}});

				this.forceUpdateAll();
			}
			
			onStop () {
				this.forceUpdateAll();
				
				BDFDB.DOMUtils.removeLocalStyle(this.name + "TooltipWidth");
			}

			getSettingsPanel (collapseStates = {}) {
				let settingsPanel;
				return settingsPanel = BDFDB.PluginUtils.createSettingsPanel(this, {
					collapseStates: collapseStates,
					children: _ => {
						let settingsItems = [];
						
						settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.CollapseContainer, {
							title: "Tooltip Items",
							collapseStates: collapseStates,
							children: Object.keys(this.defaults.items).map(key => BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsSaveItem, {
								type: "Switch",
								plugin: this,
								keys: ["items", key],
								label: this.labels[this.defaults.items[key].description] || BDFDB.LanguageUtils.LanguageStrings[this.defaults.items[key].description],
								value: this.settings.items[key]
							}))
						}));
						
						settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.CollapseContainer, {
							title: "Tooltip Format",
							collapseStates: collapseStates,
							children: Object.keys(this.defaults.dates).map(key => BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.DateInput, Object.assign({}, this.settings.dates[key], {
								label: this.defaults.dates[key].description,
								onChange: valueObj => {
									this.SettingsUpdated = true;
									this.settings.dates[key] = valueObj;
									BDFDB.DataUtils.save(this.settings.dates, this, "dates");
								}
							}))).concat(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.FormComponents.FormDivider, {
								className: BDFDB.disCN.marginbottom8
							})).concat(Object.keys(this.defaults.amounts).map(key => BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsSaveItem, {
								type: "Slider",
								plugin: this,
								keys: ["amounts", key],
								label: this.defaults.amounts[key].description,
								basis: "70%",
								min: this.defaults.amounts[key].min,
								max: this.defaults.amounts[key].max,
								digits: this.defaults.amounts[key].digits,
								markerAmount: 11,
								onValueRender: value => value + this.defaults.amounts[key].unit,
								childProps: {type: "number"},
								value: this.settings.amounts[key]
							}))).concat(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.FormComponents.FormDivider, {
								className: BDFDB.disCN.marginbottom8
							})).concat(Object.keys(this.defaults.colors).map(key => BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsSaveItem, {
								type: "TextInput",
								plugin: this,
								keys: ["colors", key],
								basis: "70%",
								label: this.defaults.colors[key].description,
								value: this.settings.colors[key],
								childProps: {type: "color"},
								placeholder: this.settings.colors[key]
							})))
						}));
						
						return settingsItems;
					}
				});
			}

			onSettingsClosed () {
				if (this.SettingsUpdated) {
					delete this.SettingsUpdated;
					this.forceUpdateAll();
				}
			}
		
			forceUpdateAll () {				
				let iconSize = this.settings.amounts.tooltipWidth - 80;
				BDFDB.DOMUtils.appendLocalStyle(this.name + "TooltipWidth", `
					${BDFDB.dotCN._serverdetailstooltip} {
						min-width: ${this.settings.amounts.tooltipWidth}px !important;
						width: unset !important;
						max-width: unset !important;
					}
					${BDFDB.dotCNS._serverdetailstooltip + BDFDB.dotCN._serverdetailsicon} {
						width: ${iconSize > 0 ? iconSize : 30}px;
						height: ${iconSize > 0 ? iconSize : 30}px;
					}
				`);
				
				BDFDB.PatchUtils.forceAllUpdates(this);
			}

			processGuild (e) {
				if (BDFDB.GuildUtils.is(e.instance.props.guild)) {
					let tooltipContainer;
					let [children, index] = BDFDB.ReactUtils.findParent(e.returnvalue, {name: ["GuildTooltip", "BDFDB_TooltipContainer"]});
					if (index > -1) children[index] = BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TooltipContainer, Object.assign({}, children[index].props, {
						ref: instance => {if (instance) tooltipContainer = instance;},
						tooltipConfig:  Object.assign({
							backgroundColor: this.settings.colors.tooltipColor
						}, children[index].props.tooltipConfig, {
							className: !this.settings.amounts.tooltipDelay && BDFDB.disCN._serverdetailstooltip,
							type: "right",
							guild: e.instance.props.guild,
							list: true,
							offset: 12
						}),
						text: _ => BDFDB.ReactUtils.createElement(GuildDetailsComponent, {
							tooltipContainer: tooltipContainer,
							guild: e.instance.props.guild
						})
					}));
				}
			}

			setLabelsByLanguage () {
				switch (BDFDB.LanguageUtils.getLanguage().id) {
					case "bg":		// Bulgarian
						return {
							boosters:							"Ð‘ÑƒÑÑ‚ÐµÑ€Ð¸",
							creation_date:						"Ð”Ð°Ñ‚Ð° Ð½Ð° ÑÑŠÐ·Ð´Ð°Ð²Ð°Ð½Ðµ",
							join_date:							"Ð”Ð°Ñ‚Ð° Ð½Ð° Ð¿Ñ€Ð¸ÑÑŠÐµÐ´Ð¸Ð½ÑÐ²Ð°Ð½Ðµ"
						};
					case "da":		// Danish
						return {
							boosters:							"Boosters",
							creation_date:						"Oprettelsesdato",
							join_date:							"Deltag i dato"
						};
					case "de":		// German
						return {
							boosters:							"Booster",
							creation_date:						"Erstellungsdatum",
							join_date:							"Beitrittsdatum"
						};
					case "el":		// Greek
						return {
							boosters:							"Î•Î½Î¹ÏƒÏ‡Ï…Ï„Î­Ï‚",
							creation_date:						"Î—Î¼ÎµÏÎ¿Î¼Î·Î½Î¯Î± Î´Î·Î¼Î¹Î¿Ï…ÏÎ³Î¯Î±Ï‚",
							join_date:							"Î—Î¼ÎµÏÎ¿Î¼Î·Î½Î¯Î± Ï€ÏÎ¿ÏƒÏ‡ÏŽÏÎ·ÏƒÎ·Ï‚"
						};
					case "es":		// Spanish
						return {
							boosters:							"Impulsores",
							creation_date:						"Fecha de creaciÃ³n",
							join_date:							"Fecha de Ingreso"
						};
					case "fi":		// Finnish
						return {
							boosters:							"Tehostimet",
							creation_date:						"LuomispÃ¤ivÃ¤",
							join_date:							"LiittymispÃ¤ivÃ¤"
						};
					case "fr":		// French
						return {
							boosters:							"Boosters",
							creation_date:						"Date de crÃ©ation",
							join_date:							"Date d'inscription"
						};
					case "hr":		// Croatian
						return {
							boosters:							"PojaÄala",
							creation_date:						"Datum stvaranja",
							join_date:							"Datum pridruÅ¾ivanja"
						};
					case "hu":		// Hungarian
						return {
							boosters:							"EmlÃ©keztetÅ‘k",
							creation_date:						"LÃ©trehozÃ¡s dÃ¡tuma",
							join_date:							"CsatlakozÃ¡s dÃ¡tuma"
						};
					case "it":		// Italian
						return {
							boosters:							"Booster",
							creation_date:						"Data di creazione",
							join_date:							"Data di iscrizione"
						};
					case "ja":		// Japanese
						return {
							boosters:							"ãƒ–ãƒ¼ã‚¹ã‚¿ãƒ¼",
							creation_date:						"ä½œæˆæ—¥",
							join_date:							"å‚åŠ æ—¥"
						};
					case "ko":		// Korean
						return {
							boosters:							"ë¶€ìŠ¤í„°",
							creation_date:						"ì œìž‘ ì¼",
							join_date:							"ê°€ìž… ë‚ ì§œ"
						};
					case "lt":		// Lithuanian
						return {
							boosters:							"Stiprintuvai",
							creation_date:						"SukÅ«rimo data",
							join_date:							"Ä®stojimo data"
						};
					case "nl":		// Dutch
						return {
							boosters:							"Boosters",
							creation_date:						"Aanmaakdatum",
							join_date:							"Toetredingsdatum"
						};
					case "no":		// Norwegian
						return {
							boosters:							"Boosters",
							creation_date:						"Opprettelsesdato",
							join_date:							"Bli med pÃ¥ dato"
						};
					case "pl":		// Polish
						return {
							boosters:							"Dopalacze",
							creation_date:						"Data utworzenia",
							join_date:							"Data doÅ‚Ä…czenia"
						};
					case "pt-BR":	// Portuguese (Brazil)
						return {
							boosters:							"Boosters",
							creation_date:						"Data de criaÃ§Ã£o",
							join_date:							"Data de afiliaÃ§Ã£o"
						};
					case "ro":		// Romanian
						return {
							boosters:							"Amplificatoare",
							creation_date:						"Data crearii",
							join_date:							"Data Ã®nscrierii"
						};
					case "ru":		// Russian
						return {
							boosters:							"Ð‘ÑƒÑÑ‚ÐµÑ€Ñ‹",
							creation_date:						"Ð”Ð°Ñ‚Ð° ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ",
							join_date:							"Ð”Ð°Ñ‚Ðµ Ð²ÑÑ‚ÑƒÐ¿Ð»ÐµÐ½Ð¸Ñ"
						};
					case "sv":		// Swedish
						return {
							boosters:							"Boosters",
							creation_date:						"Skapelsedagen",
							join_date:							"GÃ¥ med datum"
						};
					case "th":		// Thai
						return {
							boosters:							"à¸šà¸¹à¸ªà¹€à¸•à¸­à¸£à¹Œ",
							creation_date:						"à¸§à¸±à¸™à¸—à¸µà¹ˆà¸ªà¸£à¹‰à¸²à¸‡",
							join_date:							"à¸§à¸±à¸™à¸—à¸µà¹ˆà¹€à¸‚à¹‰à¸²à¸£à¹ˆà¸§à¸¡"
						};
					case "tr":		// Turkish
						return {
							boosters:							"GÃ¼Ã§lendiriciler",
							creation_date:						"OluÅŸturulma tarihi",
							join_date:							"Ãœyelik Tarihi"
						};
					case "uk":		// Ukrainian
						return {
							boosters:							"ÐŸÑ–Ð´ÑÐ¸Ð»ÑŽÐ²Ð°Ñ‡Ñ–",
							creation_date:						"Ð”Ð°Ñ‚Ð° ÑÑ‚Ð²Ð¾Ñ€ÐµÐ½Ð½Ñ",
							join_date:							"Ð”Ð°Ñ‚Ð° Ð¿Ñ€Ð¸Ñ”Ð´Ð½Ð°Ð½Ð½Ñ"
						};
					case "vi":		// Vietnamese
						return {
							boosters:							"Bá»™ tÄƒng tá»‘c",
							creation_date:						"NgÃ y thÃ nh láº­p",
							join_date:							"NgÃ y tham gia"
						};
					case "zh-CN":	// Chinese (China)
						return {
							boosters:							"åŠ©æŽ¨å™¨",
							creation_date:						"åˆ›å»ºæ—¥æœŸ",
							join_date:							"å‚åŠ æ—¥æœŸ"
						};
					case "zh-TW":	// Chinese (Taiwan)
						return {
							boosters:							"åŠ©æŽ¨å™¨",
							creation_date:						"å‰µå»ºæ—¥æœŸ",
							join_date:							"åƒåŠ æ—¥æœŸ"
						};
					default:		// English
						return {
							boosters:							"Boosters",
							creation_date:						"Creation Date",
							join_date:							"Join Date"
						};
				}
			}
		};
	})(window.BDFDB_Global.PluginUtils.buildPlugin(config));
})();
{
	"settings": {
		"byNewlines": false
	}
}
/**!
 * @name SecretRingTone
 * @description Always plays the secret ring tone when someone calls you.
 * @version 1.0.0
 * @author Jaime Filho
 * @authorId 289112759948410881
 * @invite z6Yx9A8VDR
 * @website https://github.com/jaimeadf/BetterDiscordPlugins/tree/release/src/SecretRingTone
 * @source https://github.com/jaimeadf/BetterDiscordPlugins/tree/release/src/SecretRingTone
 * @updateUrl https://raw.githubusercontent.com/jaimeadf/BetterDiscordPlugins/release/dist/SecretRingTone/SecretRingTone.plugin.js
 */
/*@cc_on
@if (@_jscript)
    // Offer to self-install for clueless users that try to run this directly.
    var shell = WScript.CreateObject("WScript.Shell");
    var fs = new ActiveXObject("Scripting.FileSystemObject");
    var pathPlugins = shell.ExpandEnvironmentStrings("%APPDATA%\\BetterDiscord\\plugins");
    var pathSelf = WScript.ScriptFullName;
    // Put the user at ease by addressing them in the first person
    shell.Popup("It looks like you've mistakenly tried to run me directly. \n(Don't do that!)", 0, "I'm a plugin for BetterDiscord", 0x30);
    if (fs.GetParentFolderName(pathSelf) === fs.GetAbsolutePathName(pathPlugins)) {
        shell.Popup("I'm in the correct folder already.", 0, "I'm already installed", 0x40);
    } else if (!fs.FolderExists(pathPlugins)) {
        shell.Popup("I can't find the BetterDiscord plugins folder.\nAre you sure it's even installed?", 0, "Can't install myself", 0x10);
    } else if (shell.Popup("Should I copy myself to BetterDiscord's plugins folder for you?", 0, "Do you need some help?", 0x34) === 6) {
        fs.CopyFile(pathSelf, fs.BuildPath(pathPlugins, fs.GetFileName(pathSelf)), true);
        // Show the user where to put plugins in the future
        shell.Exec("explorer " + pathPlugins);
        shell.Popup("I'm installed!", 0, "Successfully installed", 0x40);
    }
    WScript.Quit();
@else@*/
const fs=require("fs"),path=require("path"),request=require("request"),electron=require("electron"),config={info:{name:"SecretRingTone",description:"Always plays the secret ring tone when someone calls you.",version:"1.0.0",authors:[{name:"Jaime Filho",discord_id:"289112759948410881"}],github:"https://github.com/jaimeadf/BetterDiscordPlugins/tree/release/src/SecretRingTone",github_raw:"https://raw.githubusercontent.com/jaimeadf/BetterDiscordPlugins/release/dist/SecretRingTone/SecretRingTone.plugin.js"}};function buildPlugin(){const[e,n]=global.ZeresPluginLibrary.buildPlugin(config);var i;return(()=>{"use strict";var r={n:e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return r.d(n,{a:n}),n},d:(e,n)=>{for(var i in n)r.o(n,i)&&!r.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:n[i]})},o:(e,n)=>Object.prototype.hasOwnProperty.call(e,n)},t={};r.d(t,{default:()=>SecretRingTone});const o=n,s=e;var a=r.n(s);const{WebAudioSound:l}=o.WebpackModules.getByProps("WebAudioSound");class SecretRingTone extends(a()){constructor(){super(),this.ringingSounds=[]}onStart(){o.Patcher.before(l.prototype,"_ensureAudio",(e=>{"call_ringing"===e.name&&(e.name="call_ringing_beat",this.ringingSounds.push(e))}))}onStop(){o.Patcher.unpatchAll();for(const e of this.ringingSounds)e.name="call_ringing";this.ringingSounds=[]}}i=t.default})(),i}module.exports=global.ZeresPluginLibrary?buildPlugin():class{constructor(){this._config=config}getName(){return config.info.name}getAuthor(){return config.info.authors.map((e=>e.name)).join(", ")}getDescription(){return config.info.description}getVersion(){return config.info.version}load(){global.BdApi.showConfirmationModal("Library plugin is needed",`The library plugin needed for ${config.info.name} is missing. Please click Download Now to install it.`,{confirmText:"Download",cancelText:"Cancel",onConfirm(){request.get("https://rauenzi.github.io/BDPluginLibrary/release/0PluginLibrary.plugin.js",((e,n,i)=>{if(e)return electron.shell.openExternal("https://betterdiscord.net/ghdl?url=https://raw.githubusercontent.com/rauenzi/BDPluginLibrary/master/release/0PluginLibrary.plugin.js");fs.writeFileSync(path.join(global.BdApi.Plugins.folder,"0PluginLibrary.plugin.js"),i)}))}})}start(){}stop(){}};
/*@end@*/
{
    "currentVersionInfo": {
        "version": "1.0.0",
        "hasShownChangelog": true
    }
}
/**
 * @name ReadAllNotificationsButton
 * @author DevilBro
 * @authorId 278543574059057154
 * @version 1.6.8
 * @description Adds a Clear Button to the Server List and the Mentions Popout
 * @invite Jx3TjNS
 * @donate https://www.paypal.me/MircoWittrien
 * @patreon https://www.patreon.com/MircoWittrien
 * @website https://mwittrien.github.io/
 * @source https://github.com/mwittrien/BetterDiscordAddons/tree/master/Plugins/ReadAllNotificationsButton/
 * @updateUrl https://mwittrien.github.io/BetterDiscordAddons/Plugins/ReadAllNotificationsButton/ReadAllNotificationsButton.plugin.js
 */

module.exports = (_ => {
	const config = {
		"info": {
			"name": "ReadAllNotificationsButton",
			"author": "DevilBro",
			"version": "1.6.8",
			"description": "Adds a Clear Button to the Server List and the Mentions Popout"
		}
	};

	return !window.BDFDB_Global || (!window.BDFDB_Global.loaded && !window.BDFDB_Global.started) ? class {
		getName () {return config.info.name;}
		getAuthor () {return config.info.author;}
		getVersion () {return config.info.version;}
		getDescription () {return `The Library Plugin needed for ${config.info.name} is missing. Open the Plugin Settings to download it. \n\n${config.info.description}`;}
		
		downloadLibrary () {
			require("request").get("https://mwittrien.github.io/BetterDiscordAddons/Library/0BDFDB.plugin.js", (e, r, b) => {
				if (!e && b && r.statusCode == 200) require("fs").writeFile(require("path").join(BdApi.Plugins.folder, "0BDFDB.plugin.js"), b, _ => BdApi.showToast("Finished downloading BDFDB Library", {type: "success"}));
				else BdApi.alert("Error", "Could not download BDFDB Library Plugin. Try again later or download it manually from GitHub: https://mwittrien.github.io/downloader/?library");
			});
		}
		
		load () {
			if (!window.BDFDB_Global || !Array.isArray(window.BDFDB_Global.pluginQueue)) window.BDFDB_Global = Object.assign({}, window.BDFDB_Global, {pluginQueue: []});
			if (!window.BDFDB_Global.downloadModal) {
				window.BDFDB_Global.downloadModal = true;
				BdApi.showConfirmationModal("Library Missing", `The Library Plugin needed for ${config.info.name} is missing. Please click "Download Now" to install it.`, {
					confirmText: "Download Now",
					cancelText: "Cancel",
					onCancel: _ => {delete window.BDFDB_Global.downloadModal;},
					onConfirm: _ => {
						delete window.BDFDB_Global.downloadModal;
						this.downloadLibrary();
					}
				});
			}
			if (!window.BDFDB_Global.pluginQueue.includes(config.info.name)) window.BDFDB_Global.pluginQueue.push(config.info.name);
		}
		start () {this.load();}
		stop () {}
		getSettingsPanel () {
			let template = document.createElement("template");
			template.innerHTML = `<div style="color: var(--header-primary); font-size: 16px; font-weight: 300; white-space: pre; line-height: 22px;">The Library Plugin needed for ${config.info.name} is missing.\nPlease click <a style="font-weight: 500;">Download Now</a> to install it.</div>`;
			template.content.firstElementChild.querySelector("a").addEventListener("click", this.downloadLibrary);
			return template.content.firstElementChild;
		}
	} : (([Plugin, BDFDB]) => {
		var _this;
		var blacklist, clearing;
		var settings = {};
		
		const ReadAllButtonComponent = class ReadAllButton extends BdApi.React.Component {
			clearClick() {
				if (settings.includeGuilds) this.clearGuilds(settings.includeMuted ? this.getGuilds() : this.getUnread());
				if (settings.includeDMs) BDFDB.DMUtils.markAsRead(this.getPingedDMs());
			}
			clearGuilds(guildIds) {
				BDFDB.GuildUtils.markAsRead(guildIds.filter(id => id && !blacklist.includes(id)));
			}
			getGuilds() {
				return BDFDB.LibraryModules.FolderStore.getFlattenedGuilds().map(g => g.id).filter(n => n);
			}
			getUnread() {
				return this.getGuilds().filter(id => BDFDB.LibraryModules.UnreadGuildUtils.hasUnread(id) || BDFDB.LibraryModules.UnreadGuildUtils.getMentionCount(id) > 0);
			}
			getPinged() {
				return this.getGuilds().filter(id => BDFDB.LibraryModules.UnreadGuildUtils.getMentionCount(id) > 0);
			}
			getMuted() {
				return this.getGuilds().filter(id => BDFDB.LibraryModules.MutedUtils.isGuildOrCategoryOrChannelMuted(id));
			}
			getPingedDMs() {
				return BDFDB.LibraryModules.ChannelStore.getSortedPrivateChannels().map(c => c.id).filter(id => id && BDFDB.LibraryModules.UnreadChannelUtils.getMentionCount(id) > 0);
			}
			render() {
				return BDFDB.ReactUtils.createElement("div", {
					className: BDFDB.disCNS.guildouter + BDFDB.disCN._readallnotificationsbuttonframe,
					children: BDFDB.ReactUtils.createElement("div", {
						className: BDFDB.disCNS.guildiconwrapper + BDFDB.disCN._readallnotificationsbuttoninner,
							children: BDFDB.ReactUtils.createElement("div", {
							className: BDFDB.disCNS.guildiconchildwrapper + BDFDB.disCN._readallnotificationsbuttonbutton,
							children: "read all",
							onClick: _ => {
								if (!settings.confirmClear) this.clearClick();
								else BDFDB.ModalUtils.confirm(_this, _this.labels.modal_confirmnotifications, _ => this.clearClick());
							},
							onContextMenu: event => {
								BDFDB.ContextMenuUtils.open(_this, event, BDFDB.ContextMenuUtils.createItem(BDFDB.LibraryComponents.MenuItems.MenuGroup, {
									children: [
										BDFDB.ContextMenuUtils.createItem(BDFDB.LibraryComponents.MenuItems.MenuItem, {
											label: _this.labels.context_unreadguilds,
											id: BDFDB.ContextMenuUtils.createItemId(_this.name, "mark-unread-read"),
											action: _ => this.clearGuilds(this.getUnread())
										}),
										BDFDB.ContextMenuUtils.createItem(BDFDB.LibraryComponents.MenuItems.MenuItem, {
											label: _this.labels.context_pingedguilds,
											id: BDFDB.ContextMenuUtils.createItemId(_this.name, "mark-pinged-read"),
											action: _ => this.clearGuilds(this.getPinged())
										}),
										BDFDB.ContextMenuUtils.createItem(BDFDB.LibraryComponents.MenuItems.MenuItem, {
											label: _this.labels.context_mutedguilds,
											id: BDFDB.ContextMenuUtils.createItemId(_this.name, "mark-muted-read"),
											action: _ => this.clearGuilds(this.getMuted())
										}),
										BDFDB.ContextMenuUtils.createItem(BDFDB.LibraryComponents.MenuItems.MenuItem, {
											label: _this.labels.context_guilds,
											id: BDFDB.ContextMenuUtils.createItemId(_this.name, "mark-all-read"),
											action: _ => this.clearGuilds(this.getGuilds())
										}),
										BDFDB.ContextMenuUtils.createItem(BDFDB.LibraryComponents.MenuItems.MenuItem, {
											label: _this.labels.context_dms,
											id: BDFDB.ContextMenuUtils.createItemId(_this.name, "mark-dms-read"),
											action: _ => BDFDB.DMUtils.markAsRead(this.getPingedDMs())
										})
									]
								}));
							}
						})
					})
				});
			}
		};
	
		return class ReadAllNotificationsButton extends Plugin {
			onLoad () {
				_this = this;
				
				this.defaults = {
					settings: {
						addClearButton:	{value: true, 	inner: false,	description: "Add a 'Clear Mentions' button to the recent mentions popout"},
						confirmClear:	{value: false,	inner: false, 	description: "Ask for your confirmation before clearing reads"},
						includeGuilds:	{value: true, 	inner: true,	description: "unread Servers"},
						includeMuted:	{value: false, 	inner: true,	description: "muted unread Servers"},
						includeDMs:		{value: false, 	inner: true,	description: "unread DMs"}
					}
				};
				
				this.patchedModules = {
					after: {
						Guilds: "render",
						RecentMentions: "default",
						RecentsHeader: "default"
					}
				};
				
				this.css = `
					${BDFDB.dotCN.messagespopouttabbar} {
						flex: 1 0 auto;
					}
					${BDFDB.dotCN.messagespopouttabbar} ~ * {
						margin-left: 10px;
					}
					${BDFDB.dotCN._readallnotificationsbuttonframe} {
						height: 24px;
						margin-bottom: 10px;
					}
					${BDFDB.dotCN._readallnotificationsbuttonframe}:active {
						transform: translateY(1px);
					}
					${BDFDB.dotCN._readallnotificationsbuttoninner} {
						height: 24px;
					}
					${BDFDB.dotCN._readallnotificationsbuttonbutton} {
						border-radius: 4px;
						height: 24px;
						font-size: 12px;
						line-height: 1.3;
						white-space: nowrap;
						cursor: pointer;
					}
				`;
			}
			
			onStart () {
				let loadedBlacklist = BDFDB.DataUtils.load(this, "blacklist");
				this.saveBlacklist(!BDFDB.ArrayUtils.is(loadedBlacklist) ? [] : loadedBlacklist);

				this.forceUpdateAll();
			}
			
			onStop () {
				this.forceUpdateAll();
			}

			getSettingsPanel (collapseStates = {}) {
				let settingsPanel, settingsItems = [];
				
				settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.CollapseContainer, {
					title: "Settings",
					collapseStates: collapseStates,
					children: Object.keys(settings).filter(key => !this.defaults.settings[key].inner).map(key => BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsSaveItem, {
						type: "Switch",
						plugin: this,
						keys: ["settings", key],
						label: this.defaults.settings[key].description,
						value: settings[key]
					})).concat(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsPanelList, {
						title: "When left clicking the 'read all' button mark following Elements as read:",
						first: false,
						last: true,
						children: Object.keys(settings).filter(key => this.defaults.settings[key].inner).map(key => BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsSaveItem, {
							type: "Switch",
							plugin: this,
							keys: ["settings", key],
							label: this.defaults.settings[key].description,
							value: settings[key]
						}))
					}))
				}));
				
				settingsItems.push(BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.CollapseContainer, {
					title: "Server Black List",
					collapseStates: collapseStates,
					children: [
						BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsGuildList, {
							className: BDFDB.disCN.marginbottom20,
							disabled: BDFDB.DataUtils.load(this, "blacklist"),
							onClick: disabledGuilds => {
								this.saveBlacklist(disabledGuilds);
							}
						}),
						BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsItem, {
							type: "Button",
							color: BDFDB.LibraryComponents.Button.Colors.GREEN,
							label: "Enable for all Servers",
							onClick: _ => {
								this.batchSetGuilds(settingsPanel, collapseStates, true);
							},
							children: BDFDB.LanguageUtils.LanguageStrings.ENABLE
						}),
						BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SettingsItem, {
							type: "Button",
							color: BDFDB.LibraryComponents.Button.Colors.PRIMARY,
							label: "Disable for all Servers",
							onClick: _ => {
								this.batchSetGuilds(settingsPanel, collapseStates, false);
							},
							children: BDFDB.LanguageUtils.LanguageStrings.DISABLE
						})
					]
				}));
				
				return settingsPanel = BDFDB.PluginUtils.createSettingsPanel(this, settingsItems);
			}

			onSettingsClosed () {
				if (this.SettingsUpdated) {
					delete this.SettingsUpdated;
					this.forceUpdateAll();
				}
			}
		
			forceUpdateAll () {
				settings = BDFDB.DataUtils.get(this, "settings");
				
				BDFDB.PatchUtils.forceAllUpdates(this);
			}
		
			processGuilds (e) {
				if (typeof e.returnvalue.props.children == "function") {
					let childrenRender = e.returnvalue.props.children;
					e.returnvalue.props.children = (...args) => {
						let children = childrenRender(...args);
						this.checkTree(children);
						return children;
					};
				}
				else this.checkTree(e.returnvalue);
			}
			
			checkTree (returnvalue) {
				let tree = BDFDB.ReactUtils.findChild(returnvalue, {filter: n => n && n.props && typeof n.props.children == "function"});
				if (tree) {
					let childrenRender = tree.props.children;
					tree.props.children = (...args) => {
						let children = childrenRender(...args);
						this.handleGuilds(children);
						return children;
					};
				}
				else this.handleGuilds(returnvalue);
			}
			
			handleGuilds (returnvalue) {
				let [children, index] = BDFDB.ReactUtils.findParent(returnvalue, {name: "ConnectedUnreadDMs"});
				if (index > -1) children.splice(index + 1, 0, BDFDB.ReactUtils.createElement(ReadAllButtonComponent, {}));
			}

			processRecentMentions (e) {
				if (e.instance.props.header && e.instance.props.header.props) e.instance.props.header.props.messages = e.returnvalue.props.messages;
			}

			processRecentsHeader (e) {
				if (settings.addClearButton && e.instance.props.tab == "Recent Mentions") e.returnvalue.props.children.push(BDFDB.ReactUtils.createElement("div", {
					children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.TooltipContainer, {
						text: `${BDFDB.LanguageUtils.LanguageStrings.CLOSE} (${BDFDB.LanguageUtils.LanguageStrings.FORM_LABEL_ALL})`,
						children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.Clickable, {
							className: BDFDB.disCNS.messagespopoutbutton + BDFDB.disCNS.messagespopoutbuttonsecondary + BDFDB.disCN.messagespopoutbuttonsize32,
							children: BDFDB.ReactUtils.createElement(BDFDB.LibraryComponents.SvgIcon, {
								nativeClass: true,
								name: BDFDB.LibraryComponents.SvgIcon.Names.CLOSE,
								width: 16,
								height: 16
							}),
							onClick: _ => {
								let clear = _ => {
									if (clearing) return BDFDB.NotificationUtils.toast(`${this.labels.toast_alreadyclearing} - ${BDFDB.LanguageUtils.LibraryStrings.please_wait}`, {type: "danger"});
									let messages = [].concat(e.instance.props.messages).filter(n => n);
									if (messages.length) {
										clearing = true;
										let toastInterval;
										let loadingString = `${this.labels.toast_clearing} - ${BDFDB.LanguageUtils.LibraryStrings.please_wait}`;
										let currentLoadingString = loadingString;
										let toast = BDFDB.NotificationUtils.toast(currentLoadingString, {
											timeout: 0,
											onClose: _ => {BDFDB.TimeUtils.clear(toastInterval);}
										});
										toastInterval = BDFDB.TimeUtils.interval(_ => {
											currentLoadingString = currentLoadingString.endsWith(".....") ? loadingString : currentLoadingString + ".";
											toast.update(currentLoadingString);
										}, 500);
										for (let i = 0; i < messages.length; i++) BDFDB.TimeUtils.timeout(_ => {
											BDFDB.LibraryModules.RecentMentionUtils.deleteRecentMention(messages[i].id);
											if (i == messages.length - 1) {
												clearing = false;
												toast.close();
												BDFDB.NotificationUtils.toast(this.labels.toastcleared, {type: "success"});
											}
										}, i * 1000);
									}
								};
								if (settings.confirmClear) BDFDB.ModalUtils.confirm(this, this.labels.modal_confirmmentions, clear);
								else clear();
							}
						})
					})
				}));
			}
			
			batchSetGuilds (settingsPanel, collapseStates, value) {
				if (!value) {
					for (let id of BDFDB.LibraryModules.FolderStore.getFlattenedGuildIds()) blacklist.push(id);
					this.saveBlacklist(BDFDB.ArrayUtils.removeCopies(blacklist));
				}
				else this.saveBlacklist([]);
				BDFDB.PluginUtils.refreshSettingsPanel(this, settingsPanel, collapseStates);
			}
			
			saveBlacklist (savedBlacklist) {
				blacklist = savedBlacklist;
				BDFDB.DataUtils.save(savedBlacklist, this, "blacklist");
			}

			setLabelsByLanguage () {
				switch (BDFDB.LanguageUtils.getLanguage().id) {
					case "bg":		// Bulgarian
						return {
							context_dms:						"Ð”Ð¸Ñ€ÐµÐºÑ‚Ð½Ð¾ ÑÑŠÐ¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ",
							context_guilds:						"Ð’ÑÐ¸Ñ‡ÐºÐ¸ ÑÑŠÑ€Ð²ÑŠÑ€Ð¸",
							context_mutedguilds:				"ÐŸÑ€Ð¸Ð³Ð»ÑƒÑˆÐµÐ½Ð¸ ÑÑŠÑ€Ð²ÑŠÑ€Ð¸",
							context_pingedguilds:				"Pinged ÑÑŠÑ€Ð²ÑŠÑ€Ð¸",
							context_unreadguilds:				"ÐÐµÐ¿Ñ€Ð¾Ñ‡ÐµÑ‚ÐµÐ½Ð¸ ÑÑŠÑ€Ð²ÑŠÑ€Ð¸",
							modal_confirmmentions:				"ÐÐ°Ð¸ÑÑ‚Ð¸Ð½Ð° Ð»Ð¸ Ð¸ÑÐºÐ°Ñ‚Ðµ Ð´Ð° Ð¸Ð·Ñ‚Ñ€Ð¸ÐµÑ‚Ðµ Ð²ÑÐ¸Ñ‡ÐºÐ¸ Ð½ÐµÐ¿Ñ€Ð¾Ñ‡ÐµÑ‚ÐµÐ½Ð¸ ÑÐ¿Ð¾Ð¼ÐµÐ½Ð°Ð²Ð°Ð½Ð¸Ñ?",
							modal_confirmnotifications:			"ÐÐ°Ð¸ÑÑ‚Ð¸Ð½Ð° Ð»Ð¸ Ð¸ÑÐºÐ°Ñ‚Ðµ Ð´Ð° Ð¸Ð·Ñ‚Ñ€Ð¸ÐµÑ‚Ðµ Ð²ÑÐ¸Ñ‡ÐºÐ¸ Ð½ÐµÐ¿Ñ€Ð¾Ñ‡ÐµÑ‚ÐµÐ½Ð¸ Ð¸Ð·Ð²ÐµÑÑ‚Ð¸Ñ?",
							toast_alreadyclearing:				"Ð˜Ð·Ñ‚Ñ€Ð¸Ð²Ð° Ð½ÑÐºÐ¾Ð¸ ÑÐ¿Ð¾Ð¼ÐµÐ½Ð°Ð²Ð°Ð½Ð¸Ñ Ð²ÐµÑ‡Ðµ",
							toast_cleared:						"Ð’ÑÐ¸Ñ‡ÐºÐ¸ Ð¿Ð¾ÑÐ»ÐµÐ´Ð½Ð¸ ÑÐ¿Ð¾Ð¼ÐµÐ½Ð°Ð²Ð°Ð½Ð¸Ñ Ð±ÑÑ…Ð° Ð¸Ð·Ñ‚Ñ€Ð¸Ñ‚Ð¸",
							toast_clearing:						"Ð˜Ð·Ñ‡Ð¸ÑÑ‚Ð²Ð° Ð²ÑÐ¸Ñ‡ÐºÐ¸ ÑÐºÐ¾Ñ€Ð¾ÑˆÐ½Ð¸ ÑÐ¿Ð¾Ð¼ÐµÐ½Ð°Ð²Ð°Ð½Ð¸Ñ"
						};
					case "da":		// Danish
						return {
							context_dms:						"Direkte beskeder",
							context_guilds:						"Alle servere",
							context_mutedguilds:				"DÃ¦mpede servere",
							context_pingedguilds:				"Pingede servere",
							context_unreadguilds:				"UlÃ¦ste servere",
							modal_confirmmentions:				"Er du sikker pÃ¥, at du vil slette alle ulÃ¦ste omtaler?",
							modal_confirmnotifications:			"Er du sikker pÃ¥, at du vil slette alle ulÃ¦ste meddelelser?",
							toast_alreadyclearing:				"Sletter allerede nogle omtaler",
							toast_cleared:						"Alle nylige omtaler er blevet slettet",
							toast_clearing:						"Rydder alle nylige omtaler"
						};
					case "de":		// German
						return {
							context_dms:						"Direktnachrichten",
							context_guilds:						"Alle Server",
							context_mutedguilds:				"Stummgeschaltete Server",
							context_pingedguilds:				"Gepingte Server",
							context_unreadguilds:				"Ungelesene Server",
							modal_confirmmentions:				"MÃ¶chten Sie wirklich alle ungelesenen ErwÃ¤hnungen lÃ¶schen?",
							modal_confirmnotifications:			"MÃ¶chten Sie wirklich alle ungelesenen Benachrichtigungen lÃ¶schen?",
							toast_alreadyclearing:				"LÃ¶scht bereits einige ErwÃ¤hnungen",
							toast_cleared:						"Alle kÃ¼rzlich ErwÃ¤hnungen wurden gelÃ¶scht",
							toast_clearing:						"LÃ¶scht alle letzten ErwÃ¤hnungen"
						};
					case "el":		// Greek
						return {
							context_dms:						"Î‘Î¼ÎµÏƒÎ± Î¼Î·Î½ÏÎ¼Î±Ï„Î±",
							context_guilds:						"ÎŒÎ»Î¿Î¹ Î¿Î¹ Î´Î¹Î±ÎºÎ¿Î¼Î¹ÏƒÏ„Î­Ï‚",
							context_mutedguilds:				"Î£Î¯Î³Î±ÏƒÎ· Î´Î¹Î±ÎºÎ¿Î¼Î¹ÏƒÏ„ÏŽÎ½",
							context_pingedguilds:				"Î”Î¹Î±ÎºÎ¿Î¼Î¹ÏƒÏ„Î­Ï‚ Ping",
							context_unreadguilds:				"ÎœÎ· Î±Î½Î±Î³Î½Ï‰ÏƒÎ¼Î­Î½Î¿Î¹ Î´Î¹Î±ÎºÎ¿Î¼Î¹ÏƒÏ„Î­Ï‚",
							modal_confirmmentions:				"Î•Î¯ÏƒÏ„Îµ Î²Î­Î²Î±Î¹Î¿Î¹ ÏŒÏ„Î¹ Î¸Î­Î»ÎµÏ„Îµ Î½Î± Î´Î¹Î±Î³ÏÎ¬ÏˆÎµÏ„Îµ ÏŒÎ»ÎµÏ‚ Ï„Î¹Ï‚ Î¼Î· Î±Î½Î±Î³Î½Ï‰ÏƒÎ¼Î­Î½ÎµÏ‚ Î±Î½Î±Ï†Î¿ÏÎ­Ï‚;",
							modal_confirmnotifications:			"Î•Î¯ÏƒÏ„Îµ Î²Î­Î²Î±Î¹Î¿Î¹ ÏŒÏ„Î¹ Î¸Î­Î»ÎµÏ„Îµ Î½Î± Î´Î¹Î±Î³ÏÎ¬ÏˆÎµÏ„Îµ ÏŒÎ»ÎµÏ‚ Ï„Î¹Ï‚ Î¼Î· Î±Î½Î±Î³Î½Ï‰ÏƒÎ¼Î­Î½ÎµÏ‚ ÎµÎ¹Î´Î¿Ï€Î¿Î¹Î®ÏƒÎµÎ¹Ï‚;",
							toast_alreadyclearing:				"Î”Î¹Î±Î³ÏÎ¬Ï†ÎµÎ¹ Î®Î´Î· ÎºÎ¬Ï€Î¿Î¹ÎµÏ‚ Î±Î½Î±Ï†Î¿ÏÎ­Ï‚",
							toast_cleared:						"ÎŒÎ»ÎµÏ‚ Î¿Î¹ Ï€ÏÏŒÏƒÏ†Î±Ï„ÎµÏ‚ Î±Î½Î±Ï†Î¿ÏÎ­Ï‚ Î­Ï‡Î¿Ï…Î½ Î´Î¹Î±Î³ÏÎ±Ï†ÎµÎ¯",
							toast_clearing:						"Î”Î¹Î±Î³ÏÎ¬Ï†ÎµÎ¹ ÏŒÎ»ÎµÏ‚ Ï„Î¹Ï‚ Ï€ÏÏŒÏƒÏ†Î±Ï„ÎµÏ‚ Î±Î½Î±Ï†Î¿ÏÎ­Ï‚"
						};
					case "es":		// Spanish
						return {
							context_dms:						"Mensajes directos",
							context_guilds:						"Todos los servidores",
							context_mutedguilds:				"Servidores silenciados",
							context_pingedguilds:				"Servidores con ping",
							context_unreadguilds:				"Servidores no leÃ­dos",
							modal_confirmmentions:				"Â¿EstÃ¡s seguro de que deseas eliminar todas las menciones no leÃ­das?",
							modal_confirmnotifications:			"Â¿EstÃ¡ seguro de que desea eliminar todas las notificaciones no leÃ­das?",
							toast_alreadyclearing:				"Elimina algunas menciones ya",
							toast_cleared:						"Se han eliminado todas las menciones recientes",
							toast_clearing:						"Borra todas las menciones recientes"
						};
					case "fi":		// Finnish
						return {
							context_dms:						"Suorat viestit",
							context_guilds:						"Kaikki palvelimet",
							context_mutedguilds:				"Mykistetyt palvelimet",
							context_pingedguilds:				"Pinged-palvelimet",
							context_unreadguilds:				"Lukemattomat palvelimet",
							modal_confirmmentions:				"Haluatko varmasti poistaa kaikki lukemattomat maininnat?",
							modal_confirmnotifications:			"Haluatko varmasti poistaa kaikki lukemattomat ilmoitukset?",
							toast_alreadyclearing:				"Poistaa jo joitain mainintoja",
							toast_cleared:						"Kaikki viimeisimmÃ¤t maininnat on poistettu",
							toast_clearing:						"TyhjentÃ¤Ã¤ kaikki viimeisimmÃ¤t maininnat"
						};
					case "fr":		// French
						return {
							context_dms:						"Messages directs",
							context_guilds:						"Tous les serveurs",
							context_mutedguilds:				"Serveurs muets",
							context_pingedguilds:				"Serveurs ping",
							context_unreadguilds:				"Serveurs non lus",
							modal_confirmmentions:				"Voulez-vous vraiment supprimer toutes les mentions non lues?",
							modal_confirmnotifications:			"Voulez-vous vraiment supprimer toutes les notifications non lues?",
							toast_alreadyclearing:				"Supprime dÃ©jÃ  certaines mentions",
							toast_cleared:						"Toutes les mentions rÃ©centes ont Ã©tÃ© supprimÃ©es",
							toast_clearing:						"Efface toutes les mentions rÃ©centes"
						};
					case "hr":		// Croatian
						return {
							context_dms:						"Direktna poruka",
							context_guilds:						"Svi posluÅ¾itelji",
							context_mutedguilds:				"PriguÅ¡eni posluÅ¾itelji",
							context_pingedguilds:				"Pingirani posluÅ¾itelji",
							context_unreadguilds:				"NeproÄitani posluÅ¾itelji",
							modal_confirmmentions:				"Jeste li sigurni da Å¾elite izbrisati sva neproÄitana spominjanja?",
							modal_confirmnotifications:			"Jeste li sigurni da Å¾elite izbrisati sve neproÄitane obavijesti?",
							toast_alreadyclearing:				"BriÅ¡e veÄ‡ spomenute",
							toast_cleared:						"Sva nedavna spominjanja su izbrisana",
							toast_clearing:						"BriÅ¡e sva nedavna spominjanja"
						};
					case "hu":		// Hungarian
						return {
							context_dms:						"KÃ¶zvetlen Ã¼zenet",
							context_guilds:						"Minden szerver",
							context_mutedguilds:				"NÃ©mÃ­tott szerverek",
							context_pingedguilds:				"Pingelt szerverek",
							context_unreadguilds:				"Olvasatlan szerverek",
							modal_confirmmentions:				"Biztosan tÃ¶rli az Ã¶sszes olvasatlan emlÃ­tÃ©st?",
							modal_confirmnotifications:			"Biztosan tÃ¶rli az Ã¶sszes olvasatlan Ã©rtesÃ­tÃ©st?",
							toast_alreadyclearing:				"NÃ©hÃ¡ny emlÃ­tÃ©st mÃ¡r tÃ¶rÃ¶l",
							toast_cleared:						"Az Ã¶sszes kÃ¶zelmÃºltbeli emlÃ­tÃ©st tÃ¶rÃ¶ltÃ©k",
							toast_clearing:						"TÃ¶rli az Ã¶sszes kÃ¶zelmÃºltbeli emlÃ­tÃ©st"
						};
					case "it":		// Italian
						return {
							context_dms:						"Messaggi diretti",
							context_guilds:						"Tutti i server",
							context_mutedguilds:				"Server disattivati",
							context_pingedguilds:				"Server sottoposti a ping",
							context_unreadguilds:				"Server non letti",
							modal_confirmmentions:				"Sei sicuro di voler eliminare tutte le menzioni non lette?",
							modal_confirmnotifications:			"Sei sicuro di voler eliminare tutte le notifiche non lette?",
							toast_alreadyclearing:				"Elimina giÃ  alcune menzioni",
							toast_cleared:						"Tutte le menzioni recenti sono state eliminate",
							toast_clearing:						"Cancella tutte le menzioni recenti"
						};
					case "ja":		// Japanese
						return {
							context_dms:						"ãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸",
							context_guilds:						"ã™ã¹ã¦ã®ã‚µãƒ¼ãƒãƒ¼",
							context_mutedguilds:				"ãƒŸãƒ¥ãƒ¼ãƒˆã•ã‚ŒãŸã‚µãƒ¼ãƒãƒ¼",
							context_pingedguilds:				"pingã•ã‚ŒãŸã‚µãƒ¼ãƒãƒ¼",
							context_unreadguilds:				"æœªèª­ã‚µãƒ¼ãƒãƒ¼",
							modal_confirmmentions:				"æœªèª­ã®ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã‚’ã™ã¹ã¦å‰Šé™¤ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ",
							modal_confirmnotifications:			"æœªèª­ã®é€šçŸ¥ã‚’ã™ã¹ã¦å‰Šé™¤ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ",
							toast_alreadyclearing:				"ã™ã§ã«ã„ãã¤ã‹ã®è¨€åŠã‚’å‰Šé™¤ã—ã¾ã™",
							toast_cleared:						"æœ€è¿‘ã®è¨€åŠã¯ã™ã¹ã¦å‰Šé™¤ã•ã‚Œã¾ã—ãŸ",
							toast_clearing:						"æœ€è¿‘ã®è¨€åŠã‚’ã™ã¹ã¦ã‚¯ãƒªã‚¢ã—ã¾ã™"
						};
					case "ko":		// Korean
						return {
							context_dms:						"ìª½ì§€",
							context_guilds:						"ëª¨ë“  ì„œë²„",
							context_mutedguilds:				"ìŒì†Œê±° ëœ ì„œë²„",
							context_pingedguilds:				"í•‘ëœ ì„œë²„",
							context_unreadguilds:				"ì½ì§€ ì•Šì€ ì„œë²„",
							modal_confirmmentions:				"ì½ì§€ ì•Šì€ ëª¨ë“  ë©˜ì…˜ì„ ì‚­ì œ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
							modal_confirmnotifications:			"ì½ì§€ ì•Šì€ ëª¨ë“  ì•Œë¦¼ì„ ì‚­ì œ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
							toast_alreadyclearing:				"ì´ë¯¸ ì¼ë¶€ ë©˜ì…˜ì„ ì‚­ì œí•©ë‹ˆë‹¤.",
							toast_cleared:						"ëª¨ë“  ìµœê·¼ ë©˜ì…˜ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.",
							toast_clearing:						"ìµœê·¼ ë©˜ì…˜ì„ ëª¨ë‘ ì§€ ì›ë‹ˆë‹¤."
						};
					case "lt":		// Lithuanian
						return {
							context_dms:						"Tiesioginiai praneÅ¡imai",
							context_guilds:						"Visi serveriai",
							context_mutedguilds:				"Nutildyti serveriai",
							context_pingedguilds:				"â€žPingedâ€œ serveriai",
							context_unreadguilds:				"Neskaityti serveriai",
							modal_confirmmentions:				"Ar tikrai norite iÅ¡trinti visus neperskaitytus paminÄ—jimus?",
							modal_confirmnotifications:			"Ar tikrai norite iÅ¡trinti visus neperskaitytus praneÅ¡imus?",
							toast_alreadyclearing:				"Kai kurie paminÄ—jimai jau iÅ¡trinami",
							toast_cleared:						"Visi naujausi paminÄ—jimai buvo iÅ¡trinti",
							toast_clearing:						"IÅ¡valo visus naujausius paminÄ—jimus"
						};
					case "nl":		// Dutch
						return {
							context_dms:						"Directe berichten",
							context_guilds:						"Alle servers",
							context_mutedguilds:				"Gedempte servers",
							context_pingedguilds:				"Gepingde servers",
							context_unreadguilds:				"Ongelezen servers",
							modal_confirmmentions:				"Weet u zeker dat u alle ongelezen vermeldingen wilt verwijderen?",
							modal_confirmnotifications:			"Weet u zeker dat u alle ongelezen meldingen wilt verwijderen?",
							toast_alreadyclearing:				"Verwijdert al enkele vermeldingen",
							toast_cleared:						"Alle recente vermeldingen zijn verwijderd",
							toast_clearing:						"Wist alle recente vermeldingen"
						};
					case "no":		// Norwegian
						return {
							context_dms:						"Direktemeldinger",
							context_guilds:						"Alle servere",
							context_mutedguilds:				"Dempede servere",
							context_pingedguilds:				"Pingede servere",
							context_unreadguilds:				"Uleste servere",
							modal_confirmmentions:				"Er du sikker pÃ¥ at du vil slette alle uleste omtaler?",
							modal_confirmnotifications:			"Er du sikker pÃ¥ at du vil slette alle uleste varsler?",
							toast_alreadyclearing:				"Sletter allerede noen omtaler",
							toast_cleared:						"Alle nylige omtaler er slettet",
							toast_clearing:						"Fjerner alle nylige omtaler"
						};
					case "pl":		// Polish
						return {
							context_dms:						"BezpoÅ›rednie wiadomoÅ›ci",
							context_guilds:						"Wszystkie serwery",
							context_mutedguilds:				"Wyciszone serwery",
							context_pingedguilds:				"Serwery pingowane",
							context_unreadguilds:				"Nieprzeczytane serwery",
							modal_confirmmentions:				"Czy na pewno chcesz usunÄ…Ä‡ wszystkie nieprzeczytane wzmianki?",
							modal_confirmnotifications:			"Czy na pewno chcesz usunÄ…Ä‡ wszystkie nieprzeczytane powiadomienia?",
							toast_alreadyclearing:				"Usuwa juÅ¼ niektÃ³re wzmianki",
							toast_cleared:						"Wszystkie ostatnie wzmianki zostaÅ‚y usuniÄ™te",
							toast_clearing:						"Usuwa wszystkie ostatnie wzmianki"
						};
					case "pt-BR":	// Portuguese (Brazil)
						return {
							context_dms:						"Mensagens diretas",
							context_guilds:						"Todos os servidores",
							context_mutedguilds:				"Servidores Silenciados",
							context_pingedguilds:				"Servidores com ping",
							context_unreadguilds:				"Servidores nÃ£o lidos",
							modal_confirmmentions:				"Tem certeza de que deseja excluir todas as menÃ§Ãµes nÃ£o lidas?",
							modal_confirmnotifications:			"Tem certeza de que deseja excluir todas as notificaÃ§Ãµes nÃ£o lidas?",
							toast_alreadyclearing:				"Exclui algumas menÃ§Ãµes jÃ¡",
							toast_cleared:						"Todas as menÃ§Ãµes recentes foram excluÃ­das",
							toast_clearing:						"Limpa todas as menÃ§Ãµes recentes"
						};
					case "ro":		// Romanian
						return {
							context_dms:						"Mesaje directe",
							context_guilds:						"Toate serverele",
							context_mutedguilds:				"Servere mutate",
							context_pingedguilds:				"Servere pinged",
							context_unreadguilds:				"Servere necitite",
							modal_confirmmentions:				"Sigur doriÈ›i sÄƒ È™tergeÈ›i toate menÈ›iunile necitite?",
							modal_confirmnotifications:			"Sigur doriÈ›i sÄƒ È™tergeÈ›i toate notificÄƒrile necitite?",
							toast_alreadyclearing:				"È˜terge deja cÃ¢teva menÈ›iuni",
							toast_cleared:						"Toate menÈ›iunile recente au fost È™terse",
							toast_clearing:						"È˜terge toate menÈ›iunile recente"
						};
					case "ru":		// Russian
						return {
							context_dms:						"ÐŸÑ€ÑÐ¼Ñ‹Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ",
							context_guilds:						"Ð’ÑÐµ ÑÐµÑ€Ð²ÐµÑ€Ñ‹",
							context_mutedguilds:				"ÐžÑ‚ÐºÐ»ÑŽÑ‡ÐµÐ½Ð½Ñ‹Ðµ ÑÐµÑ€Ð²ÐµÑ€Ñ‹",
							context_pingedguilds:				"ÐŸÑ€Ð¾Ð²ÐµÑ€ÐµÐ½Ð½Ñ‹Ðµ ÑÐµÑ€Ð²ÐµÑ€Ñ‹",
							context_unreadguilds:				"ÐÐµÐ¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ð½Ð½Ñ‹Ðµ ÑÐµÑ€Ð²ÐµÑ€Ñ‹",
							modal_confirmmentions:				"Ð’Ñ‹ ÑƒÐ²ÐµÑ€ÐµÐ½Ñ‹, Ñ‡Ñ‚Ð¾ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ ÑƒÐ´Ð°Ð»Ð¸Ñ‚ÑŒ Ð²ÑÐµ Ð½ÐµÐ¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ð½Ð½Ñ‹Ðµ ÑƒÐ¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ñ?",
							modal_confirmnotifications:			"Ð’Ñ‹ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ ÑƒÐ´Ð°Ð»Ð¸Ñ‚ÑŒ Ð²ÑÐµ Ð½ÐµÐ¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ð½Ð½Ñ‹Ðµ ÑƒÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ñ?",
							toast_alreadyclearing:				"Ð£Ð´Ð°Ð»ÑÐµÑ‚ ÑƒÐ¶Ðµ Ð½ÐµÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ðµ ÑƒÐ¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ñ",
							toast_cleared:						"Ð’ÑÐµ Ð½ÐµÐ´Ð°Ð²Ð½Ð¸Ðµ ÑƒÐ¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ñ Ð±Ñ‹Ð»Ð¸ ÑƒÐ´Ð°Ð»ÐµÐ½Ñ‹",
							toast_clearing:						"Ð£Ð´Ð°Ð»ÑÐµÑ‚ Ð²ÑÐµ Ð½ÐµÐ´Ð°Ð²Ð½Ð¸Ðµ ÑƒÐ¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ñ"
						};
					case "sv":		// Swedish
						return {
							context_dms:						"Direktmeddelanden",
							context_guilds:						"Alla servrar",
							context_mutedguilds:				"DÃ¤mpade servrar",
							context_pingedguilds:				"Pingade servrar",
							context_unreadguilds:				"OlÃ¤sta servrar",
							modal_confirmmentions:				"Ã„r du sÃ¤ker pÃ¥ att du vill ta bort alla olÃ¤sta omnÃ¤mnanden?",
							modal_confirmnotifications:			"Ã„r du sÃ¤ker pÃ¥ att du vill ta bort alla olÃ¤sta aviseringar?",
							toast_alreadyclearing:				"Raderar nÃ¥gra omnÃ¤mnanden redan",
							toast_cleared:						"Alla nya omnÃ¤mnanden har tagits bort",
							toast_clearing:						"Rensar alla senaste omnÃ¤mnanden"
						};
					case "th":		// Thai
						return {
							context_dms:						"à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¹‚à¸”à¸¢à¸•à¸£à¸‡",
							context_guilds:						"à¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¹€à¸§à¸­à¸£à¹Œà¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”",
							context_mutedguilds:				"à¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¹€à¸§à¸­à¸£à¹Œà¸—à¸µà¹ˆà¸›à¸´à¸”à¹€à¸ªà¸µà¸¢à¸‡",
							context_pingedguilds:				"à¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¹€à¸§à¸­à¸£à¹Œ Pinged",
							context_unreadguilds:				"à¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¹€à¸§à¸­à¸£à¹Œà¸—à¸µà¹ˆà¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¹„à¸”à¹‰à¸­à¹ˆà¸²à¸™",
							modal_confirmmentions:				"à¹à¸™à¹ˆà¹ƒà¸ˆà¹„à¸«à¸¡à¸§à¹ˆà¸²à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸¥à¸šà¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸—à¸µà¹ˆà¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¹„à¸”à¹‰à¸­à¹ˆà¸²à¸™à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”",
							modal_confirmnotifications:			"à¹à¸™à¹ˆà¹ƒà¸ˆà¹„à¸«à¸¡à¸§à¹ˆà¸²à¸•à¹‰à¸­à¸‡à¸à¸²à¸£à¸¥à¸šà¸à¸²à¸£à¹à¸ˆà¹‰à¸‡à¹€à¸•à¸·à¸­à¸™à¸—à¸µà¹ˆà¸¢à¸±à¸‡à¹„à¸¡à¹ˆà¹„à¸”à¹‰à¸­à¹ˆà¸²à¸™à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”",
							toast_alreadyclearing:				"à¸¥à¸šà¸à¸²à¸£à¸à¸¥à¹ˆà¸²à¸§à¸–à¸¶à¸‡à¸šà¸²à¸‡à¸ªà¹ˆà¸§à¸™à¹à¸¥à¹‰à¸§",
							toast_cleared:						"à¸¥à¸šà¸à¸²à¸£à¸à¸¥à¹ˆà¸²à¸§à¸–à¸¶à¸‡à¸¥à¹ˆà¸²à¸ªà¸¸à¸”à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”à¹à¸¥à¹‰à¸§",
							toast_clearing:						"à¸¥à¹‰à¸²à¸‡à¸à¸²à¸£à¸žà¸¹à¸”à¸–à¸¶à¸‡à¸¥à¹ˆà¸²à¸ªà¸¸à¸”à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”"
						};
					case "tr":		// Turkish
						return {
							context_dms:						"Direkt Mesajlar",
							context_guilds:						"TÃ¼m Sunucular",
							context_mutedguilds:				"Sessiz Sunucular",
							context_pingedguilds:				"Ping GÃ¶nderilen Sunucular",
							context_unreadguilds:				"OkunmamÄ±ÅŸ Sunucular",
							modal_confirmmentions:				"OkunmamÄ±ÅŸ tÃ¼m bahisleri silmek istediÄŸinizden emin misiniz?",
							modal_confirmnotifications:			"OkunmamÄ±ÅŸ tÃ¼m bildirimleri silmek istediÄŸinizden emin misiniz?",
							toast_alreadyclearing:				"Zaten bazÄ± bahsetmeleri siler",
							toast_cleared:						"Son bahsedenlerin tÃ¼mÃ¼ silindi",
							toast_clearing:						"TÃ¼m son bahsedilenleri temizler"
						};
					case "uk":		// Ukrainian
						return {
							context_dms:						"ÐŸÑ€ÑÐ¼Ñ– Ð¿Ð¾Ð²Ñ–Ð´Ð¾Ð¼Ð»ÐµÐ½Ð½Ñ",
							context_guilds:						"Ð£ÑÑ– ÑÐµÑ€Ð²ÐµÑ€Ð¸",
							context_mutedguilds:				"ÐŸÑ€Ð¸Ð³Ð»ÑƒÑˆÐµÐ½Ñ– ÑÐµÑ€Ð²ÐµÑ€Ð¸",
							context_pingedguilds:				"Pinged ÑÐµÑ€Ð²ÐµÑ€Ð¸",
							context_unreadguilds:				"ÐÐµÐ¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ð½Ñ– ÑÐµÑ€Ð²ÐµÑ€Ð¸",
							modal_confirmmentions:				"Ð’Ð¸ Ð²Ð¿ÐµÐ²Ð½ÐµÐ½Ñ–, Ñ‰Ð¾ Ñ…Ð¾Ñ‡ÐµÑ‚Ðµ Ð²Ð¸Ð´Ð°Ð»Ð¸Ñ‚Ð¸ Ð²ÑÑ– Ð½ÐµÐ¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ð½Ñ– Ð·Ð³Ð°Ð´ÐºÐ¸?",
							modal_confirmnotifications:			"Ð’Ð¸ Ð²Ð¿ÐµÐ²Ð½ÐµÐ½Ñ–, Ñ‰Ð¾ Ñ…Ð¾Ñ‡ÐµÑ‚Ðµ Ð²Ð¸Ð´Ð°Ð»Ð¸Ñ‚Ð¸ Ð²ÑÑ– Ð½ÐµÐ¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ð½Ñ– ÑÐ¿Ð¾Ð²Ñ–Ñ‰ÐµÐ½Ð½Ñ?",
							toast_alreadyclearing:				"Ð’Ð¸Ð´Ð°Ð»ÑÑ” Ð´ÐµÑÐºÑ– Ð·Ð³Ð°Ð´ÐºÐ¸ Ð²Ð¶Ðµ",
							toast_cleared:						"Ð£ÑÑ– Ð¾ÑÑ‚Ð°Ð½Ð½Ñ– Ð·Ð³Ð°Ð´ÑƒÐ²Ð°Ð½Ð½Ñ Ð±ÑƒÐ»Ð¸ Ð²Ð¸Ð´Ð°Ð»ÐµÐ½Ñ–",
							toast_clearing:						"ÐžÑ‡Ð¸Ñ‰Ð°Ñ” Ð²ÑÑ– Ð¾ÑÑ‚Ð°Ð½Ð½Ñ– Ð·Ð³Ð°Ð´ÑƒÐ²Ð°Ð½Ð½Ñ"
						};
					case "vi":		// Vietnamese
						return {
							context_dms:						"Tin nháº¯n trá»±c tiáº¿p",
							context_guilds:						"Táº¥t cáº£ mÃ¡y chá»§",
							context_mutedguilds:				"MÃ¡y chá»§ bá»‹ táº¯t tiáº¿ng",
							context_pingedguilds:				"MÃ¡y chá»§ Pinged",
							context_unreadguilds:				"MÃ¡y chá»§ chÆ°a Ä‘á»c",
							modal_confirmmentions:				"Báº¡n cÃ³ cháº¯c cháº¯n muá»‘n xÃ³a táº¥t cáº£ cÃ¡c Ä‘á» cáº­p chÆ°a Ä‘á»c khÃ´ng?",
							modal_confirmnotifications:			"Báº¡n cÃ³ cháº¯c cháº¯n muá»‘n xÃ³a táº¥t cáº£ cÃ¡c thÃ´ng bÃ¡o chÆ°a Ä‘á»c khÃ´ng?",
							toast_alreadyclearing:				"ÄÃ£ xÃ³a má»™t sá»‘ Ä‘á» cáº­p",
							toast_cleared:						"Táº¥t cáº£ cÃ¡c Ä‘á» cáº­p gáº§n Ä‘Ã¢y Ä‘Ã£ bá»‹ xÃ³a",
							toast_clearing:						"XÃ³a táº¥t cáº£ cÃ¡c Ä‘á» cáº­p gáº§n Ä‘Ã¢y"
						};
					case "zh-CN":	// Chinese (China)
						return {
							context_dms:						"ç›´æŽ¥è®¯æ¯",
							context_guilds:						"æ‰€æœ‰æœåŠ¡å™¨",
							context_mutedguilds:				"é™éŸ³æœåŠ¡å™¨",
							context_pingedguilds:				"ç»‘å®šæœåŠ¡å™¨",
							context_unreadguilds:				"æœªè¯»æœåŠ¡å™¨",
							modal_confirmmentions:				"æ‚¨ç¡®å®šè¦åˆ é™¤æ‰€æœ‰æœªè¯»çš„æåŠå—ï¼Ÿ",
							modal_confirmnotifications:			"æ‚¨ç¡®å®šè¦åˆ é™¤æ‰€æœ‰æœªè¯»çš„é€šçŸ¥å—ï¼Ÿ",
							toast_alreadyclearing:				"å·²åˆ é™¤ä¸€äº›æåŠ",
							toast_cleared:						"æœ€è¿‘æ‰€æœ‰æåŠçš„å†…å®¹å‡å·²åˆ é™¤",
							toast_clearing:						"æ¸…é™¤æ‰€æœ‰æœ€è¿‘æåŠçš„å†…å®¹"
						};
					case "zh-TW":	// Chinese (Taiwan)
						return {
							context_dms:						"ç›´æŽ¥è¨Šæ¯",
							context_guilds:						"æ‰€æœ‰æœå‹™å™¨",
							context_mutedguilds:				"éœéŸ³æœå‹™å™¨",
							context_pingedguilds:				"ç¶å®šæœå‹™å™¨",
							context_unreadguilds:				"æœªè®€æœå‹™å™¨",
							modal_confirmmentions:				"æ‚¨ç¢ºå®šè¦åˆªé™¤æ‰€æœ‰æœªè®€çš„æåŠå—Žï¼Ÿ",
							modal_confirmnotifications:			"æ‚¨ç¢ºå®šè¦åˆªé™¤æ‰€æœ‰æœªè®€çš„é€šçŸ¥å—Žï¼Ÿ",
							toast_alreadyclearing:				"å·²åˆªé™¤ä¸€äº›æåŠ",
							toast_cleared:						"æœ€è¿‘æ‰€æœ‰æåŠçš„å…§å®¹å‡å·²åˆªé™¤",
							toast_clearing:						"æ¸…é™¤æ‰€æœ‰æœ€è¿‘æåŠçš„å…§å®¹"
						};
					default:		// English
						return {
							context_dms:						"Direct Messages",
							context_guilds:						"All Servers",
							context_mutedguilds:				"Muted Servers",
							context_pingedguilds:				"Pinged Servers",
							context_unreadguilds:				"Unread Servers",
							modal_confirmmentions:				"Are you sure you want to delete all unread Mentions?",
							modal_confirmnotifications:			"Are you sure you want to delete all unread Notifications?",
							toast_alreadyclearing:				"Already clearing some Mentions",
							toast_cleared:						"All recent Mentions have been cleared",
							toast_clearing:						"Clearing all recent Mentions"
						};
				}
			}
		};
	})(window.BDFDB_Global.PluginUtils.buildPlugin(config));
})();
{
	"notifcations": {
		"messages": true,
		"voiceChat": true
	},
	"places": {
		"messages": true,
		"pins": true,
		"inbox": true,
		"replies": true,
		"mentions": true,
		"reactions": true,
		"autocompletes": true,
		"memberList": true,
		"voiceList": true,
		"voiceChat": true
	},
	"settings": {
		"disableNotifications": true,
		"disableVoiceNotifications": true,
		"removeMessages": true,
		"removePinnedMessages": true,
		"removeInbox": true,
		"removeReplies": true,
		"removeMentions": true,
		"removeReactions": true,
		"removeAutocomplete": true,
		"removeUsers": true,
		"removeVoiceUser": true,
		"removeVoiceChats": true
	}
}
